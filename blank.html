<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SlideMaker • Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --bg: #ffffff;
        --panel: #f9fafb;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --accent: #1a73e8;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: linear-gradient(145deg, #042c1a, #064a2c); color: #e8f5e9; }

      .layout { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
      .topbar { display:flex; align-items:center; gap:10px; padding: 8px 12px; background: rgba(255, 255, 255, 0.07); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,0.1); }
      .topbar .btn { border:1px solid var(--border); background:#fff; border-radius:8px; padding:8px 12px; font-weight:700; cursor:pointer; transition: opacity .2s; }
      .topbar .btn:hover { opacity: 0.9; }
      .topbar .btn.blue { background:#1a73e8; border-color:#1a73e8; color:#fff; }
      .topbar .btn.gray { background:#f3f4f6; }
      .topbar .btn.red { background:#fee2e2; border-color:#fecaca; color:#991b1b; }
      .topbar .btn.light { background:#f9fafb; }
      .topbar .btn.green { background:#10b981; border-color:#059669; color:#06221e; }
      .topbar .btn.emerald { background:#10b981; border-color:#059669; color:#fff; }

      .main { display:grid; grid-template-columns: 260px 1fr; gap: 12px; padding: 12px; min-height:0; }
      .sidebar { background: rgba(255, 255, 255, 0.07); backdrop-filter: blur(10px); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:10px; overflow:auto; }
      .slide-item { background: rgba(255, 255, 255, 0.1); border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:10px; margin-bottom:10px; cursor:pointer; transition: background .2s; color: #e8f5e9; }
      .slide-item:hover { background: rgba(255, 255, 255, 0.15); }
      .slide-item.active { outline:2px solid #2ecc71; background: rgba(46, 204, 113, 0.2); }

      .editor { display:grid; grid-template-rows: auto 1fr; background: rgba(255, 255, 255, 0.07); backdrop-filter: blur(10px); border-radius:12px; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4); }
      .toolbar { display:flex; align-items:center; gap:6px; padding:8px 12px; border-bottom:1px solid var(--border); background:#f0f3f5; flex-wrap:wrap; box-shadow:0 2px 6px rgba(0,0,0,0.05); }
      .tool { border:1px solid #d8e0e3; background:#fff; border-radius:6px; padding:6px 10px; font-weight:700; cursor:pointer; font-size:13px; transition:all .2s; }
      .tool:hover { background:#f7f8fa; }
      .tool.active { background:#2ecc71; border-color:#2ecc71; color:#fff; }
      .tool-select { border:1px solid #d8e0e3; background:#fff; border-radius:6px; padding:6px 8px; font-size:13px; cursor:pointer; }
      .tool-color { width:32px; height:28px; border:1px solid #d8e0e3; border-radius:6px; cursor:pointer; }
      .canvas-wrap { display:grid; place-items:center; padding:24px; overflow:auto; }
      .canvas { width:min(92vw, 960px); aspect-ratio:16/9; background:#fff; border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:24px; display:grid; grid-template-rows: auto 1fr; gap:10px; }
      
      /* Title box per Editor.json */
      .title-box {
        font-size: 28px;
        font-weight: bold;
        color: #000000;
        border: 1px dashed #ccc;
        margin-bottom: 10px;
        padding: 10px;
        min-height: 50px;
        outline: none;
      }
      .title-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .title-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }

      /* Text box per Editor.json */
      .text-box {
        font-size: 16px;
        border: 1px dashed #ccc;
        padding: 10px;
        min-height: 250px;
        outline: none;
        overflow-y: auto;
        color: #000000;
      }
      .text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .text-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }

      /* Save notification */
      .save-notification {
        position: fixed;
        top: 70px;
        right: 20px;
        background: #10b981;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity .3s, transform .3s;
        z-index: 1000;
        pointer-events: none;
      }
      .save-notification.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="topbar">
        <button class="btn blue" id="btnNew" data-action="new_slide">New Slide</button>
        <button class="btn gray" id="btnDup" data-action="duplicate_slide">Duplicate</button>
        <button class="btn red" id="btnDel" data-action="delete_slide">Delete</button>
        <button class="btn light" id="btnReset" data-action="reset_slides">Reset</button>
        <button class="btn green" id="btnSave" data-action="save_presentation">Save</button>
        <button class="btn green" id="btnSaveAs" data-action="save_as_file">Save As</button>
        <div style="flex:1"></div>
        <button class="btn emerald" id="btnHome" data-action="go_home">Return Home</button>
      </div>

      <div class="main">
        <aside class="sidebar" id="sidebar"></aside>
        <section class="editor">
          <div class="toolbar" id="toolbar">
            <button class="tool" data-action="bold" title="Bold">B</button>
            <button class="tool" data-action="italic" title="Italic">I</button>
            <button class="tool" data-action="underline" title="Underline">U</button>
            <button class="tool" data-action="strikeThrough" title="Strikethrough">S</button>
            <button class="tool" data-action="superscript" title="Superscript">x²</button>
            <button class="tool" data-action="subscript" title="Subscript">x₂</button>
            <input type="number" class="tool-select" id="fontSize" title="Font Size" min="8" max="72" step="2" value="16" style="width: 80px;">
            <input type="color" class="tool-color" id="fontColor" value="#000000" title="Font Color">
            <input type="color" class="tool-color" id="highlightColor" value="#ffff00" title="Highlight">
            <button class="tool" data-action="justifyLeft" title="Align Left">◀</button>
            <button class="tool" data-action="justifyCenter" title="Align Center">⬌</button>
            <button class="tool" data-action="justifyRight" title="Align Right">▶</button>
            <button class="tool" data-action="justifyFull" title="Justify">⬌⬌</button>
            <button class="tool" data-action="insertUnorderedList" title="Bullet List">• List</button>
            <button class="tool" data-action="insertOrderedList" title="Numbered List">1. List</button>
          </div>
          <div class="canvas-wrap">
            <div class="canvas" id="canvas">
              <div class="title-box" contenteditable="true" id="titleBox" data-placeholder="Click to add title"></div>
              <div class="text-box" contenteditable="true" id="textBox" data-placeholder="Click to add text"></div>
            </div>
          </div>
        </section>
      </div>
    </div>

    <div class="save-notification" id="saveNotification">Presentation saved!</div>

    <script>
      // Model per Editor.json: starting with one slide titled "Title"
      const slides = [{ title: 'Title', content: '' }];
      let active = 0;

      const sidebar = document.getElementById('sidebar');
      const titleBox = document.getElementById('titleBox');
      const textBox = document.getElementById('textBox');
      const saveNotification = document.getElementById('saveNotification');

      function renderSidebar() {
        sidebar.innerHTML = '';
        slides.forEach((s, i) => {
          const el = document.createElement('div');
          el.className = 'slide-item' + (i === active ? ' active' : '');
          el.textContent = s.title || `Slide ${i+1}`;
          el.addEventListener('click', () => {
            capture();
            active = i;
            load();
            renderSidebar();
          });
          sidebar.appendChild(el);
        });
      }

      function load() {
        const slide = slides[active];
        titleBox.textContent = slide.title || 'Title';
        textBox.textContent = slide.content || '';
        // Trigger placeholder display if empty
        if (!titleBox.textContent.trim()) titleBox.innerHTML = '';
        if (!textBox.textContent.trim()) textBox.innerHTML = '';
      }

      function capture() {
        slides[active].title = titleBox.textContent.trim() || 'Title';
        slides[active].content = textBox.textContent.trim() || '';
      }

      // Toolbar interactions per Editor.json
      function getActiveElement() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
        return document.activeElement === titleBox ? titleBox : textBox;
      }

      // Formatting tools
      document.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const action = btn.getAttribute('data-action');
          const activeEl = getActiveElement();
          
          // Focus on the active element if needed
          if (activeEl === titleBox || activeEl === textBox || titleBox.contains(activeEl) || textBox.contains(activeEl)) {
            if (titleBox.contains(activeEl) || activeEl === titleBox) {
              titleBox.focus();
            } else {
              textBox.focus();
            }
          }

          // Execute command
          if (action === 'bold') document.execCommand('bold', false);
          else if (action === 'italic') document.execCommand('italic', false);
          else if (action === 'underline') document.execCommand('underline', false);
          else if (action === 'strikeThrough') document.execCommand('strikeThrough', false);
          else if (action === 'superscript') document.execCommand('superscript', false);
          else if (action === 'subscript') document.execCommand('subscript', false);
          else if (action === 'justifyLeft') document.execCommand('justifyLeft', false);
          else if (action === 'justifyCenter') document.execCommand('justifyCenter', false);
          else if (action === 'justifyRight') document.execCommand('justifyRight', false);
          else if (action === 'justifyFull') document.execCommand('justifyFull', false);
          else if (action === 'insertUnorderedList') document.execCommand('insertUnorderedList', false);
          else if (action === 'insertOrderedList') document.execCommand('insertOrderedList', false);
        });
      });

      // Store separate font sizes for title and text
      let titleFontSize = 28;
      let textFontSize = 16;
      let currentActiveElement = textBox;

      // Initialize default font sizes
      titleBox.style.fontSize = titleFontSize + 'px';
      textBox.style.fontSize = textFontSize + 'px';

      // Function to get current font size from an element
      function getCurrentFontSize(element) {
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseFloat(computedStyle.fontSize);
        return Math.round(fontSize);
      }

      // Function to apply font size to an element
      function applyFontSize(element, size) {
        const selection = window.getSelection();
        
        // If there's selected text in the element, apply font size to selection
        if (selection.rangeCount > 0 && !selection.isCollapsed && 
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = size + 'px';
          
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
          } catch (e) {
            document.execCommand("fontSize", false, "7");
            setTimeout(() => {
              const fonts = element.getElementsByTagName("font");
              for (let i = fonts.length - 1; i >= 0; i--) {
                if (fonts[i].size === "7") {
                  const newSpan = document.createElement('span');
                  newSpan.style.fontSize = size + 'px';
                  newSpan.innerHTML = fonts[i].innerHTML;
                  fonts[i].parentNode.replaceChild(newSpan, fonts[i]);
                }
              }
            }, 10);
          }
        } else {
          // No selection - apply font size to the entire element
          element.style.fontSize = size + 'px';
          
          // Wrap existing text nodes in spans to preserve formatting
          const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
          const textNodes = [];
          let node;
          while (node = walker.nextNode()) {
            const parent = node.parentElement;
            if (!parent || !parent.style.fontSize) {
              textNodes.push(node);
            }
          }
          
          textNodes.forEach(textNode => {
            if (textNode.textContent.trim()) {
              const span = document.createElement('span');
              span.style.fontSize = size + 'px';
              span.textContent = textNode.textContent;
              textNode.parentNode.replaceChild(span, textNode);
            }
          });
        }
      }

      // Update font size input when focus changes
      function updateFontSizeInput() {
        const fontSizeInput = document.getElementById('fontSize');
        if (currentActiveElement === titleBox) {
          fontSizeInput.value = titleFontSize;
        } else {
          fontSizeInput.value = textFontSize;
        }
      }

      // Track focus changes
      titleBox.addEventListener('focus', () => {
        currentActiveElement = titleBox;
        updateFontSizeInput();
      });

      textBox.addEventListener('focus', () => {
        currentActiveElement = textBox;
        updateFontSizeInput();
      });

      // Also check on selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          if (titleBox.contains(anchorNode) || anchorNode === titleBox) {
            if (currentActiveElement !== titleBox) {
              currentActiveElement = titleBox;
              updateFontSizeInput();
            }
          } else if (textBox.contains(anchorNode) || anchorNode === textBox) {
            if (currentActiveElement !== textBox) {
              currentActiveElement = textBox;
              updateFontSizeInput();
            }
          }
        }
      });

      // Font size input change handler
      const fontSizeInput = document.getElementById('fontSize');
      fontSizeInput.addEventListener('change', (e) => {
        const size = parseInt(e.target.value);
        if (!isNaN(size) && size >= 8 && size <= 72) {
          if (currentActiveElement === titleBox) {
            titleFontSize = size;
            applyFontSize(titleBox, size);
          } else {
            textFontSize = size;
            applyFontSize(textBox, size);
          }
        }
      });
      
      // Validate input on blur
      fontSizeInput.addEventListener('blur', (e) => {
        const size = parseInt(e.target.value);
        if (isNaN(size) || size < 8) {
          e.target.value = currentActiveElement === titleBox ? titleFontSize : textFontSize;
        } else if (size > 72) {
          e.target.value = 72;
          if (currentActiveElement === titleBox) {
            titleFontSize = 72;
            applyFontSize(titleBox, 72);
          } else {
            textFontSize = 72;
            applyFontSize(textBox, 72);
          }
        }
      });

      // Initialize the input value
      updateFontSizeInput();

      // Font color picker
      document.getElementById('fontColor').addEventListener('change', (e) => {
        document.execCommand('foreColor', false, e.target.value);
      });

      // Highlight color picker
      document.getElementById('highlightColor').addEventListener('change', (e) => {
        document.execCommand('backColor', false, e.target.value);
      });

      // Save function per Editor.json and auth_system.json
      function savePresentation() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        
        if (!currentUser) {
          alert('Please log in to save presentations.');
          window.location.href = './templates.html';
          return;
        }

        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.textContent.trim() || "";
        
        // Save to user-specific key per auth_system.json
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        saved.push({
          title: title,
          date: new Date().toISOString().split("T")[0],
          content: content
        });
        
        localStorage.setItem(userKey, JSON.stringify(saved));
        
        // Show notification animation
        saveNotification.classList.add('show');
        setTimeout(() => {
          saveNotification.classList.remove('show');
        }, 2000);
      }

      // Save As function per Editor.json
      function saveAsFile() {
        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.innerHTML || "";

        const fileType = prompt("Enter file type: pdf or pptx").toLowerCase();

        if (fileType === "pdf") {
          const blob = new Blob([content], { type: "application/pdf" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${title}.pdf`;
          a.click();
          URL.revokeObjectURL(url);
        } else if (fileType === "pptx") {
          const blob = new Blob([content], { type: "application/vnd.openxmlformats-officedocument.presentationml.presentation" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${title}.pptx`;
          a.click();
          URL.revokeObjectURL(url);
        } else {
          alert("Invalid format. Use 'pdf' or 'pptx'.");
        }
      }

      // Topbar button actions per slides.json
      document.getElementById('btnNew').addEventListener('click', () => {
        capture();
        slides.push({ title: `Slide ${slides.length+1}`, content: '' });
        active = slides.length - 1;
        load();
        renderSidebar();
      });

      document.getElementById('btnDup').addEventListener('click', () => {
        capture();
        const s = slides[active];
        slides.splice(active + 1, 0, { title: s.title + ' copy', content: s.content });
        active += 1;
        load();
        renderSidebar();
      });

      document.getElementById('btnDel').addEventListener('click', () => {
        if (slides.length <= 1) return;
        slides.splice(active, 1);
        active = Math.max(0, active - 1);
        load();
        renderSidebar();
      });

      document.getElementById('btnReset').addEventListener('click', () => {
        if (confirm('Reset all slides? This cannot be undone.')) {
          slides.splice(0, slides.length, { title: 'Title', content: '' });
          active = 0;
          load();
          renderSidebar();
        }
      });

      document.getElementById('btnSave').addEventListener('click', savePresentation);
      document.getElementById('btnSaveAs').addEventListener('click', saveAsFile);

      document.getElementById('btnHome').addEventListener('click', () => {
        capture();
        window.location.href = './templates.html';
      });

      // Auto-save on input
      titleBox.addEventListener('input', () => {
        slides[active].title = titleBox.textContent.trim();
        renderSidebar();
      });
      textBox.addEventListener('input', () => {
        slides[active].content = textBox.textContent.trim();
      });

      // Check if loading a saved presentation from Recent section
      const loadPres = sessionStorage.getItem('loadPresentation');
      if (loadPres) {
        try {
          const pres = JSON.parse(loadPres);
          // Set the title and content from saved presentation
          slides[0].title = pres.title || 'Title';
          slides[0].content = pres.content || '';
          sessionStorage.removeItem('loadPresentation'); // Clear after loading
        } catch (e) {
          console.error('Error loading presentation:', e);
        }
      }

      // Init
      renderSidebar();
      load();
    </script>
  </body>
  </html>
