<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SlideMaker â€¢ Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;600&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Source+Sans+Pro:wght@400;600&family=Nunito:wght@400;600&family=Raleway:wght@400;600&family=Oswald:wght@400;600&family=Fira+Sans:wght@400;600&family=Fira+Code:wght@400;500&family=IBM+Plex+Mono:wght@400;600&family=Cabin:wght@400;600&family=Pacifico&family=Dancing+Script:wght@400;600&family=Great+Vibes&family=Bebas+Neue&family=Raleway+Dots&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="./Training/editor.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.10.1/dist/pptxgen.bundle.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
    <style>
      :root {
        --bg: #ffffff;
        --panel: #f9fafb;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --accent: #1a73e8;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: linear-gradient(145deg, #042c1a, #064a2c); color: #e8f5e9; }

      .layout { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
      .topbar { display:flex; align-items:center; gap:10px; padding: 8px 12px; background: rgba(255, 255, 255, 0.07); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,0.1); position: relative; z-index: 9000; }
      .topbar .btn { border:1px solid var(--border); background:#fff; border-radius:8px; padding:8px 12px; font-weight:700; cursor:pointer; transition: opacity .2s; }
      .topbar .btn:hover { opacity: 0.9; }
      .toolbar-btn { display: flex; align-items: center; justify-content: center; gap: 6px; min-width: 40px; padding: 8px 12px; }
      .toolbar-btn i { font-size: 16px; }
      .topbar .btn.blue { background:#1a73e8; border-color:#1a73e8; color:#fff; }
      .topbar .btn.gray { background:#f3f4f6; }
      .topbar .btn.red { background:#fee2e2; border-color:#fecaca; color:#991b1b; }
      .topbar .btn.light { background:#f9fafb; }
      .topbar .btn.green { background:#10b981; border-color:#059669; color:#06221e; }
      .topbar .btn.emerald { background:#10b981; border-color:#059669; color:#fff; }
      .save-as-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        z-index: 11000;
      }
      .save-as-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .save-as-toggle .caret {
        font-size: 11px;
        opacity: 0.75;
        margin-left: 2px;
      }
      .save-as-menu {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        padding: 8px 0;
        min-width: 200px;
        display: flex;
        flex-direction: column;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 12000;
      }
      .save-as-menu.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .save-as-option {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        font-weight: 600;
        text-align: left;
        padding: 10px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .save-as-option:hover {
        background: rgba(46, 213, 115, 0.2);
        color: #22c55e;
        transform: translateX(3px);
      }
      .save-as-option .option-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        font-size: 16px;
      }

      .main { display:grid; grid-template-columns: 260px 1fr; gap: 12px; padding: 12px; min-height:0; }
      .sidebar { 
        background: rgba(0, 40, 20, 0.85); 
        backdrop-filter: blur(8px); 
        border-right: 1px solid rgba(255, 255, 255, 0.05); 
        border-radius:12px; 
        padding:10px; 
        padding-bottom: 60px; 
        overflow-y: auto; 
        overflow-x: visible; 
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .slide-item { 
        position: relative; 
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.3s ease;
      }
      .slide-item.dragging {
        opacity: 0.6;
        transform: scale(0.98);
      }
      .slide-preview { 
        background: rgba(255, 255, 255, 0.05); 
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px; 
        padding: 10px 14px; 
        cursor:pointer; 
        transition: all 0.3s ease; 
        color: #e8f5e9; 
        width: 100%;
      }
      .slide-preview:hover { background: rgba(255, 255, 255, 0.1); }
      .slide-preview.active { outline:2px solid #2ecc71; background: rgba(46, 204, 113, 0.2); }
      .slide-preview.drop-target {
        border-color: rgba(46, 213, 115, 0.65);
        background: rgba(46, 213, 115, 0.15);
      }
      .slide-preview.drop-target-before {
        box-shadow: inset 0 3px 0 rgba(46, 213, 115, 0.85);
      }
      .slide-preview.drop-target-after {
        box-shadow: inset 0 -3px 0 rgba(46, 213, 115, 0.85);
      }
      .transition-control-button {
        background: rgba(20, 60, 45, 0.9);
        border: 1px solid rgba(46, 213, 115, 0.35);
        color: #bbf7d0;
        font-size: 14px;
        border-radius: 8px;
        padding: 6px 8px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 40px;
        justify-content: center;
      }
      .transition-control-button .transition-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-icon i {
        font-size: 12px;
      }
      .transition-control-button .transition-icon svg {
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-caret {
        font-size: 10px;
        opacity: 0.75;
        margin-left: 0;
      }
      .transition-control-button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #22c55e;
        transform: translateY(-1px);
      }
      .transition-control-button.disabled,
      .transition-control-button:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none;
      }
      .transition-control-button.disabled:hover,
      .transition-control-button:disabled:hover {
        background: rgba(20, 60, 45, 0.9);
        color: #bbf7d0;
      }
      .transition-select {
        min-width: 150px;
      }
      .transition-select option {
        color: #111827;
      }
      .slide-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 140px;
        padding: 6px 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        z-index: 5000;
      }
      .slide-context-menu.show {
        display: flex;
      }
      .slide-context-menu button {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        text-align: left;
        padding: 10px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .slide-context-menu button:hover {
        background: rgba(46, 213, 115, 0.2);
        transform: translateX(2px);
      }
      .slide-context-menu button.active {
        background: rgba(46, 213, 115, 0.25);
        color: #22c55e;
      }
      .image-context-menu,
      .slide-canvas-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 180px;
        padding: 8px 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        z-index: 6000;
        opacity: 0;
        transform: translateY(-6px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }
      .image-context-menu.show,
      .slide-canvas-context-menu.show {
        display: flex;
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .image-context-menu button,
      .slide-canvas-context-menu button {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        text-align: left;
        padding: 10px 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .image-context-menu button:hover:not([disabled]),
      .slide-canvas-context-menu button:hover:not([disabled]) {
        background: rgba(46, 213, 115, 0.2);
        color: #22c55e;
        transform: translateX(2px);
      }
      .image-context-menu button[disabled],
      .slide-canvas-context-menu button[disabled] {
        opacity: 0.55;
        cursor: default;
        transform: none;
      }
      .image-context-menu .menu-icon,
      .slide-canvas-context-menu .menu-icon {
        width: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        opacity: 0.8;
      }
      .slide-action-bar { 
        margin-top: 6px;
        display: flex;
        justify-content: center;
        gap: 8px;
        background: rgba(10, 60, 40, 0.9);
        border-radius: 8px;
        padding: 6px 0;
        height: 0;
        overflow: hidden;
        opacity: 0;
        transform: scaleY(0);
        transform-origin: top;
        transition: all 0.3s ease-in-out;
        width: 100%;
      }
      .slide-item:hover .slide-action-bar {
        height: auto;
        opacity: 1;
        transform: scaleY(1);
        margin-bottom: 10px;
      }
      .slide-action-bar button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-size: 17px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 36px;
      }
      .slide-action-bar button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #2ed573;
        transform: scale(1.1);
      }
      .slide-action-bar button i {
        font-size: 16px;
      }
      .slide-preview-title {
        display: block;
        font-weight: 600;
        font-size: 14px;
        letter-spacing: 0.3px;
      }
      .slide-preview-title.editing {
        background: rgba(46, 213, 115, 0.16);
        outline: 2px solid rgba(46, 213, 115, 0.7);
        border-radius: 6px;
        padding: 2px 6px;
        color: #e8f5e9;
      }

      /* Dark metallic gradient background */
      body.dark-theme {
        background: linear-gradient(135deg, #0b0b0b 0%, #0d0d0d 40%, #000000 100%) !important;
        background-attachment: fixed;
        background-repeat: no-repeat;
        background-size: cover;
        color: #eaeaea;
        position: relative;
      }

      body.dark-theme::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.05), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }

      body.dark-theme > * {
        position: relative;
        z-index: 1;
      }

      /* Light mode background with frosted glass effect */
      body.light-mode {
        background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,240,240,0.8)) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #1a1a1a;
        transition: all 0.3s ease-in-out;
        position: relative;
      }

      body.light-mode > * {
        position: relative;
        z-index: 1;
      }

      /* Card or container glass effect in light mode */
      body.light-mode .editor {
        background: rgba(255, 255, 255, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
      }

      body.light-mode .sidebar {
        background: rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-right: 1px solid rgba(0, 0, 0, 0.1);
      }

      body.light-mode .topbar {
        background: rgba(255, 255, 255, 0.4);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }

      /* Navigation and text colors in light mode */
      body.light-mode .tool,
      body.light-mode .tool-select,
      body.light-mode .slide-preview {
        color: #1a1a1a !important;
      }

      body.light-mode .slide-preview {
        background: rgba(255, 255, 255, 0.4);
        border-color: rgba(0, 0, 0, 0.15);
      }

      body.light-mode .tool-select::placeholder {
        color: #666 !important;
      }

      body.light-mode .title-box,
      body.light-mode .text-box {
        color: #000000 !important;
      }

      body.light-mode .topbar {
        color: #1a1a1a !important;
      }

      .editor { display:grid; grid-template-rows: auto 1fr; background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border-radius:12px; box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); }
      .toolbar { 
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        background: rgba(5, 60, 35, 0.95);
        padding: 10px 20px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        flex-wrap: wrap;
      }
      .tool { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-weight: 600;
        font-size: 15px;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .tool.present-button {
        margin-left: 12px;
        padding: 8px 16px;
        gap: 0;
        font-size: 15px;
        border: 2px solid rgba(255, 255, 255, 0.65);
        background: transparent;
        color: #f8fafc;
        min-width: 52px;
      }
      .tool.present-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.85);
        transform: translateY(-1px);
      }
      .tool.present-button svg {
        width: 18px;
        height: 18px;
        display: block;
      }
      .tool:hover { 
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .tool.active { 
        background: #1c7c54;
        color: #fff;
        border-color: #2ed573;
      }
      .tool i {
        font-size: 14px;
      }
      .tool svg {
        width: 18px;
        height: 18px;
      }
      .font-picker-button {
        position: relative;
        min-width: 140px;
        padding: 8px 16px;
        justify-content: center;
      }
      .font-picker-label {
        font-size: 15px;
        font-weight: 600;
        line-height: 1.2;
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .color-controls {
        display: flex;
        gap: 8px;
      }
      .color-tool-button {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
        padding: 8px 12px;
      }
      .color-tool-button .color-bar {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 26px;
        height: 4px;
        border-radius: 999px;
        background: currentColor;
        border: 1px solid rgba(255, 255, 255, 0.3);
        pointer-events: none;
      }
      .font-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 220px;
        gap: 4px;
      }
      .font-dropdown.show {
        display: flex;
      }
      .font-option {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        text-align: left;
        transition: all 0.2s ease;
        font-size: 15px;
      }
      .font-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .font-option.active {
        background: #1c7c54;
        border-color: #2ed573;
        color: #fff;
      }
      .shape-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .image-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .video-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .table-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .shape-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 240px;
        gap: 6px;
      }
      .shape-dropdown.show {
        display: flex;
      }
      .table-insert-panel {
        position: fixed;
        display: flex;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 12px;
        gap: 10px;
        z-index: 4100;
        width: 220px;
        color: #e8f5e9;
        transition: opacity 0.2s ease, transform 0.2s ease;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px) scale(0.96);
        pointer-events: none;
      }
      .table-insert-panel.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .table-insert-panel h4 {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 0.3px;
        color: #a7f3d0;
      }
      .table-insert-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      .table-insert-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .table-insert-field label {
        font-size: 13px;
        font-weight: 600;
        color: rgba(232, 245, 233, 0.75);
      }
      .table-insert-field input {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 6px 8px;
        color: #e8f5e9;
        font-size: 14px;
        font-weight: 600;
      }
      .table-insert-field input:focus {
        outline: none;
        border-color: rgba(46, 213, 115, 0.6);
        box-shadow: 0 0 0 2px rgba(46, 213, 115, 0.25);
      }
      .table-insert-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .table-insert-actions button {
        background: rgba(46, 213, 115, 0.25);
        border: 1px solid rgba(46, 213, 115, 0.5);
        color: #bbf7d0;
        font-weight: 600;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }
      .table-insert-actions button:hover {
        background: rgba(46, 213, 115, 0.35);
        transform: translateY(-1px);
      }
      .table-element {
        position: absolute;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.55);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
        cursor: move;
        color: #0f172a;
      }
      .table-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.3);
      }
      .table-element table {
        width: 100%;
        height: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }
      .table-element td,
      .table-element th {
        border: 1px solid rgba(15, 118, 110, 0.25);
        padding: 8px;
        min-width: 40px;
        min-height: 28px;
        background: rgba(236, 253, 245, 0.75);
        color: #0f172a;
      }
      .table-element .table-cell-selected {
        position: relative;
      }
      .table-element .table-cell-selected::after {
        content: "";
        position: absolute;
        inset: -2px;
        border-radius: 6px;
        border: 2px solid rgba(46, 213, 115, 0.7);
        background: rgba(134, 239, 172, 0.2);
        pointer-events: none;
        box-shadow: 0 0 0 1px rgba(12, 83, 60, 0.15);
      }
      .table-element td:focus,
      .table-element th:focus {
        outline: none;
        background: rgba(134, 239, 172, 0.35);
      }
      .table-element td,
      .table-element th {
        position: relative;
      }
      .table-element .table-resize-handle {
        position: absolute;
        background: rgba(46, 213, 115, 0.6);
        border-radius: 4px;
        z-index: 6;
        opacity: 0;
        transition: opacity 0.18s ease, transform 0.18s ease;
      }
      .table-element .table-resize-handle::after {
        content: '';
        position: absolute;
        inset: 0;
        background: rgba(46, 213, 115, 0.75);
        border-radius: inherit;
      }
      .table-element .table-resize-handle.table-resize-col {
        width: 6px;
        top: 0;
        bottom: 0;
        cursor: col-resize;
        transform: translateX(-3px);
      }
      .table-element .table-resize-handle.table-resize-row {
        height: 6px;
        left: 0;
        right: 0;
        cursor: row-resize;
        transform: translateY(-3px);
      }
      .table-element.selected .table-resize-handle,
      .table-element .table-resize-handle.active,
      .table-element:hover .table-resize-handle {
        opacity: 1;
      }
      .shape-option {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .shape-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .shape-option svg {
        width: 36px;
        height: 36px;
      }
      .shape-option-preview {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .shape-option-label {
        font-size: 15px;
        font-weight: 600;
      }
      .shape-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        color: #e8f5e9;
        user-select: none;
        transform-origin: center center;
      }
      .shape-element svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .image-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        cursor: move;
        transform-origin: center center;
        border: 2px solid transparent;
        border-radius: 8px;
        transition: border-color 0.15s ease;
      }
      .image-element img {
        width: 100%;
        height: 100%;
        object-fit: fill;
        border-radius: inherit;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.3);
        pointer-events: none;
      }
      .image-element:hover,
      .image-element.resizing,
      .image-element.selected {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .image-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .video-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        cursor: move;
        transform-origin: center center;
        border: 2px solid transparent;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.45);
        transition: border-color 0.15s ease;
      }
      .video-element video {
        width: 100%;
        height: 100%;
        border-radius: inherit;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.3);
        background: #000;
        position: relative;
        z-index: 1;
      }
      .video-element.selected video,
      .video-element.resizing video {
        pointer-events: none;
      }
      .video-element:hover,
      .video-element.resizing,
      .video-element.selected {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .video-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .text-box,
      .title-box,
      .additional-text-box {
        transform-origin: center center;
      }
      .shape-element.selected {
        outline: 2px solid #1a73e8;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .shape-element .resize-edge,
      .image-element .resize-edge,
      .text-box .resize-edge,
      .title-box .resize-edge,
      .additional-text-box .resize-edge {
        position: absolute;
        border-radius: 50%;
        border: 2px solid rgba(14, 165, 233, 0.9);
        background: rgba(230, 249, 255, 0.98);
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
        opacity: 0;
        transform: translate(-50%, -50%);
        transition: opacity 0.15s ease;
      }
      .shape-element.selected .resize-edge,
      .image-element.selected .resize-edge,
      .video-element.selected .resize-edge,
      .text-box.selected .resize-edge,
      .title-box.selected .resize-edge,
      .additional-text-box.selected .resize-edge {
        opacity: 1;
      }
      .image-element:hover .resize-edge,
      .image-element.resizing .resize-edge {
        opacity: 1;
      }
      .video-element:hover .resize-edge,
      .video-element.resizing .resize-edge {
        opacity: 1;
      }
      .shape-element .resize-edge.side,
      .image-element .resize-edge.side,
      .video-element .resize-edge.side,
      .text-box .resize-edge.side,
      .title-box .resize-edge.side,
      .additional-text-box .resize-edge.side {
        width: 14px;
        height: 14px;
        background: rgba(219, 246, 255, 0.9);
      }
      .shape-element .resize-edge.corner,
      .image-element .resize-edge.corner,
      .video-element .resize-edge.corner,
      .text-box .resize-edge.corner,
      .title-box .resize-edge.corner,
      .additional-text-box .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-element .resize-edge.top,
      .image-element .resize-edge.top,
      .video-element .resize-edge.top,
      .text-box .resize-edge.top,
      .title-box .resize-edge.top,
      .additional-text-box .resize-edge.top {
        top: -12px;
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.bottom,
      .image-element .resize-edge.bottom,
      .video-element .resize-edge.bottom,
      .text-box .resize-edge.bottom,
      .title-box .resize-edge.bottom,
      .additional-text-box .resize-edge.bottom {
        top: calc(100% + 12px);
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.left,
      .image-element .resize-edge.left,
      .video-element .resize-edge.left,
      .text-box .resize-edge.left,
      .title-box .resize-edge.left,
      .additional-text-box .resize-edge.left {
        left: -12px;
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.right,
      .image-element .resize-edge.right,
      .video-element .resize-edge.right,
      .text-box .resize-edge.right,
      .title-box .resize-edge.right,
      .additional-text-box .resize-edge.right {
        left: calc(100% + 12px);
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.top-left,
      .image-element .resize-edge.top-left,
      .video-element .resize-edge.top-left,
      .text-box .resize-edge.top-left,
      .title-box .resize-edge.top-left,
      .additional-text-box .resize-edge.top-left {
        top: -16px;
        left: -16px;
        cursor: nwse-resize;
      }
      .shape-element .resize-edge.top-right,
      .image-element .resize-edge.top-right,
      .video-element .resize-edge.top-right,
      .text-box .resize-edge.top-right,
      .title-box .resize-edge.top-right,
      .additional-text-box .resize-edge.top-right {
        top: -16px;
        left: calc(100% + 16px);
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-left,
      .image-element .resize-edge.bottom-left,
      .video-element .resize-edge.bottom-left,
      .text-box .resize-edge.bottom-left,
      .title-box .resize-edge.bottom-left,
      .additional-text-box .resize-edge.bottom-left {
        top: calc(100% + 16px);
        left: -16px;
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-right,
      .image-element .resize-edge.bottom-right,
      .video-element .resize-edge.bottom-right,
      .text-box .resize-edge.bottom-right,
      .title-box .resize-edge.bottom-right,
      .additional-text-box .resize-edge.bottom-right {
        top: calc(100% + 18px);
        left: calc(100% + 18px);
        cursor: nwse-resize;
        background: linear-gradient(135deg, rgba(59,130,246,0.95), rgba(129,230,217,0.95));
        border-color: rgba(56, 189, 248, 0.85);
      }
      .video-element .resize-edge.bottom-right {
        top: calc(100% + 14px);
        left: calc(100% + 14px);
      }
      .image-element .resize-edge {
        background: rgba(219, 246, 255, 0.95);
        border-color: rgba(59, 130, 246, 0.75);
      }
      .image-element .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .video-element .resize-edge {
        background: rgba(219, 246, 255, 0.95);
        border-color: rgba(59, 130, 246, 0.75);
        z-index: 2;
      }
      .video-element .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-color-picker {
        position: fixed;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(4, 44, 28, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 6px;
        gap: 8px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        transform: translateY(8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 4100;
      }
      .shape-color-picker.visible {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .shape-rotation-handle {
        position: fixed;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: rgba(4, 44, 28, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transform: translateY(8px) scale(0.95);
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-rotation-handle.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0) scale(1);
      }
      .shape-rotation-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 2px solid rgba(59, 130, 246, 0.4);
        background: rgba(14, 116, 144, 0.2);
        color: #bae6fd;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }
      .shape-rotation-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.25);
      }
      .shape-rotation-button:active {
        cursor: grabbing;
        background: rgba(59, 130, 246, 0.35);
      }
      .shape-rotation-button i {
        pointer-events: none;
        font-size: 14px;
      }
      .shape-rotation-angle {
        font-size: 13px;
        font-weight: 600;
        color: #c4e3ff;
        letter-spacing: 0.4px;
        pointer-events: none;
      }
      .shape-size-badge {
        position: fixed;
        padding: 6px 12px;
        background: rgba(4, 44, 28, 0.95);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        color: #d1fae5;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.4px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.28);
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-size-badge.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .image-crop-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.75);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 14000;
        backdrop-filter: blur(6px);
      }
      .image-crop-overlay.visible {
        display: flex;
      }
      .image-crop-dialog {
        width: min(90vw, 720px);
        background: rgba(0, 40, 20, 0.92);
        border: 1px solid rgba(46, 213, 115, 0.45);
        border-radius: 18px;
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.6);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        color: #ecfdf5;
      }
      .image-crop-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        font-weight: 700;
        background: rgba(4, 44, 28, 0.65);
        letter-spacing: 0.3px;
      }
      .image-crop-content {
        position: relative;
        padding: 20px;
        background: rgba(2, 32, 20, 0.65);
      }
      .image-crop-content img {
        max-width: 100%;
        max-height: 60vh;
        display: block;
        margin: 0 auto;
      }
      .image-crop-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        padding: 16px 20px;
        background: rgba(4, 44, 28, 0.65);
      }
      .image-crop-actions button {
        border: none;
        border-radius: 999px;
        padding: 10px 20px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, background 0.15s ease;
      }
      #imageCropCancel {
        background: rgba(255, 255, 255, 0.08);
        color: #ecfdf5;
        border: 1px solid rgba(255, 255, 255, 0.18);
      }
      #imageCropCancel:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-1px);
      }
      #imageCropApply {
        background: rgba(46, 213, 115, 0.2);
        color: #bbf7d0;
        border: 1px solid rgba(46, 213, 115, 0.45);
      }
      #imageCropApply:hover {
        background: rgba(46, 213, 115, 0.35);
        transform: translateY(-1px);
      }
      .image-crop-close {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 20px;
        cursor: pointer;
        transition: transform 0.15s ease, color 0.15s ease;
      }
      .image-crop-close:hover {
        transform: scale(1.1);
        color: #22c55e;
      }
      @keyframes imageInsertFade {
        from {
          opacity: 0;
          transform: scale(0.94);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      .image-element.image-insert-animation {
        animation: imageInsertFade 0.28s ease-out;
      }
      .shape-color-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.12);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #0f172a;
        font-size: 16px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      .shape-color-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      }
      .shape-color-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      .tool-select { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        font-weight: 600;
      }
      .tool-select::placeholder {
        color: rgba(232, 245, 233, 0.6);
      }
      .tool-select:hover {
        background: rgba(255, 255, 255, 0.25);
      }
      .tool-color { 
        width: 40px; 
        height: 36px; 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px; 
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .tool-color:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .color-picker-button {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(50%);
        white-space: nowrap;
        border: 0;
      }
      .canvas-wrap { display:grid; place-items:center; padding:24px; overflow:auto; }
      .canvas { width:min(92vw, 960px); aspect-ratio:16/9; background:#ffffff; border-radius:10px; box-shadow: 0 0 25px rgba(0, 0, 0, 0.25); padding:24px; position: relative; background-size: cover; background-position: center; background-repeat: no-repeat; transition: background 0.6s ease-in-out; }
      @keyframes slideFade {
        from { opacity: 0; transform: scale(0.98); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes slideSlide {
        from { opacity: 0; transform: translateX(35px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes slideZoom {
        from { opacity: 0; transform: scale(0.9); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes slideFlip {
        from { opacity: 0; transform: rotateX(45deg); transform-origin: center; }
        to { opacity: 1; transform: rotateX(0deg); transform-origin: center; }
      }
      @keyframes slideRotate {
        from { opacity: 0; transform: rotate(-12deg) scale(0.9); }
        to { opacity: 1; transform: rotate(0deg) scale(1); }
      }
      @keyframes slidePush {
        from { opacity: 0; transform: translateX(80px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes slideWipe {
        from { opacity: 0; clip-path: inset(0 100% 0 0); }
        to { opacity: 1; clip-path: inset(0 0 0 0); }
      }
      @keyframes slideSpin {
        from { opacity: 0; transform: rotateZ(-360deg) scale(0.8); }
        to { opacity: 1; transform: rotateZ(0deg) scale(1); }
      }
      @keyframes slideDissolve {
        0% { opacity: 0; filter: blur(18px); }
        50% { opacity: 0.5; filter: blur(8px); }
        100% { opacity: 1; filter: blur(0); }
      }
      @keyframes slideCube {
        from { opacity: 0; transform: perspective(1000px) rotateY(-65deg) translateX(-60px); transform-origin: left center; }
        to { opacity: 1; transform: perspective(1000px) rotateY(0deg) translateX(0); transform-origin: left center; }
      }
      @keyframes slideBounce {
        0% { opacity: 0; transform: translateY(60px) scale(0.95); }
        60% { opacity: 1; transform: translateY(-12px) scale(1.01); }
        85% { transform: translateY(6px) scale(0.995); }
        100% { transform: translateY(0) scale(1); }
      }
      @keyframes slideSwirl {
        from { opacity: 0; transform: rotate(18deg) scale(0.85); filter: saturate(0.6); }
        to { opacity: 1; transform: rotate(0deg) scale(1); filter: saturate(1); }
      }
      .presentation-stage .presentation-slide.transition-effect-fade { animation: slideFade 0.45s ease; }
      .presentation-stage .presentation-slide.transition-effect-slide { animation: slideSlide 0.5s ease; }
      .presentation-stage .presentation-slide.transition-effect-zoom { animation: slideZoom 0.5s ease; }
      .presentation-stage .presentation-slide.transition-effect-flip { animation: slideFlip 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-rotate { animation: slideRotate 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-push { animation: slidePush 0.55s ease; }
      .presentation-stage .presentation-slide.transition-effect-wipe { animation: slideWipe 0.55s ease; }
      .presentation-stage .presentation-slide.transition-effect-spin { animation: slideSpin 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-dissolve { animation: slideDissolve 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-cube { animation: slideCube 0.65s ease; }
      .presentation-stage .presentation-slide.transition-effect-bounce { animation: slideBounce 0.65s ease; }
      .presentation-stage .presentation-slide.transition-effect-swirl { animation: slideSwirl 0.65s ease; }
      
      .presentation-overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: #000;
        z-index: 9999;
        color: #f9fafb;
      }
      .presentation-overlay.visible {
        display: block;
      }
      .presentation-stage {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #111;
      }
      .presentation-stage .presentation-slide {
        width: 100%;
        height: 100%;
        position: absolute;
        inset: 0;
        background: #fff;
        overflow: hidden;
      }
      .presentation-stage .title-box,
      .presentation-stage .text-box,
      .presentation-stage .additional-text-box {
        border: none !important;
        box-shadow: none !important;
        outline: none !important;
        cursor: default !important;
        user-select: none;
      }
      .presentation-stage .title-box::before,
      .presentation-stage .text-box::before,
      .presentation-stage .additional-text-box::before {
        display: none !important;
        content: none !important;
      }
      .presentation-stage .shape-element {
        outline: none !important;
        box-shadow: none !important;
        cursor: default !important;
      }
      .presentation-stage .resize-edge {
        display: none !important;
      }
      .presentation-overlay .presentation-meta {
        position: absolute;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 16px;
        font-size: 14px;
        letter-spacing: 0.4px;
        background: rgba(15, 23, 42, 0.5);
        padding: 10px 18px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay .presentation-meta span {
        display: flex;
        align-items: center;
        gap: 8px;
        text-transform: uppercase;
        font-weight: 600;
      }
      .presentation-overlay .presentation-counter {
        position: absolute;
        bottom: 32px;
        right: 40px;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.6px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay.show-controls .presentation-meta,
      .presentation-overlay.show-controls .presentation-counter {
        opacity: 1;
        pointer-events: auto;
      }
      body.presenting {
        overflow: hidden;
      }
      body.presenting .layout {
        visibility: hidden;
      }
      body.presenting .presentation-overlay {
        visibility: visible;
      }

      /* Template Background Styles */
      .canvas.marketing-template {
        background-image: url('./CURSOR-Project/Background/B1.avif');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.marketing-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.business-template {
        background-image: url('./CURSOR-Project/Background/business-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.business-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.education-template {
        background-image: url('./CURSOR-Project/Background/education-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.education-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.project-template {
        background-image: url('./CURSOR-Project/Background/project-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.project-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      /* Ensure content is above overlay */
      .canvas .title-box,
      .canvas .text-box {
        position: relative;
        z-index: 1;
      }
      
      /* Title box per Editor.json */
      .title-box {
        font-size: 28px;
        font-weight: bold;
        color: #000000;
        border: 1px dashed transparent;
        padding: 10px;
        min-height: 50px;
        min-width: 200px;
        outline: none;
        position: absolute;
        top: 24px;
        left: 24px;
        width: calc(100% - 48px);
        outline: none;
      }
      .title-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .title-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      .title-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .title-box.resizing {
        user-select: none;
      }
      
      /* Resize edges for title box */
      .title-box .resize-edge {
        position: absolute;
        background: transparent;
        z-index: 10;
      }
      .title-box .resize-edge.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.left { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.right { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.corner { width: 15px; height: 15px; }
      .title-box .resize-edge.top-left { top: -5px; left: -5px; cursor: nw-resize; }
      .title-box .resize-edge.top-right { top: -5px; right: -5px; cursor: ne-resize; }
      .title-box .resize-edge.bottom-left { bottom: -5px; left: -5px; cursor: sw-resize; }
      .title-box .resize-edge.bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }

      /* Text box per Editor.json */
      .text-box {
        font-size: 16px;
        border: 1px dashed transparent;
        padding: 10px;
        min-height: 250px;
        min-width: 200px;
        outline: none;
        overflow: visible;
        color: #000000;
        position: absolute;
        top: 100px;
        left: 24px;
        width: calc(100% - 48px);
        bottom: 24px;
        outline: none;
      }
      .text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .additional-text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .text-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      
      /* Selected state for text boxes and title box */
      .text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .additional-text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .title-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      
      .text-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .text-box.resizing {
        user-select: none;
      }
      

      /* Save notification */
      .save-notification {
        position: fixed;
        top: 70px;
        right: 20px;
        background: #10b981;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity .3s, transform .3s;
        z-index: 1000;
        pointer-events: none;
      }
      .save-notification.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="topbar">
        <button class="btn blue toolbar-btn" id="btnBack" data-action="back" title="Back (Cmd+Z / Ctrl+Z)">
          <i class="fas fa-arrow-left"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnForward" data-action="forward" title="Forward (Cmd+Shift+Z / Ctrl+Shift+Z)">
          <i class="fas fa-arrow-right"></i>
        </button>
        <button class="btn red toolbar-btn" id="btnDel" data-action="delete_slide" title="Delete Slide">
          <i class="fas fa-trash"></i>
        </button>
        <button class="btn light toolbar-btn" id="btnReset" data-action="reset_slides" title="Reset Slides">
          <i class="fas fa-rotate-right"></i>
        </button>
        <button class="btn green toolbar-btn" id="btnSave" title="Save Presentation">
          <i class="fas fa-save"></i>
        </button>
        <div class="save-as-wrapper">
          <button class="btn green toolbar-btn save-as-toggle" id="btnSaveAs" title="Save As">
            <i class="fas fa-folder-open"></i>
            <span class="caret"><i class="fas fa-caret-down"></i></span>
          </button>
          <div class="save-as-menu" id="saveAsMenu" role="menu" aria-label="Export presentation">
            <button type="button" class="save-as-option" data-format="pdf" role="menuitem">
              <span class="option-icon"><i class="fas fa-file-pdf"></i></span>
              <span>Export as PDF</span>
            </button>
            <button type="button" class="save-as-option" data-format="pptx" role="menuitem">
              <span class="option-icon"><i class="fas fa-file-powerpoint"></i></span>
              <span>Export as PPTX</span>
            </button>
          </div>
        </div>
        <div style="flex:1"></div>
        <button class="btn emerald toolbar-btn" id="btnHome" data-action="go_home" title="Return Home">
          <i class="fas fa-home"></i>
        </button>
      </div>

      <div class="main">
        <aside class="sidebar" id="sidebar"></aside>
        <section class="editor">
          <div class="toolbar" id="toolbar">
            <button class="tool" data-action="bold" title="Bold"><i class="fas fa-bold"></i></button>
            <button class="tool" data-action="italic" title="Italic"><i class="fas fa-italic"></i></button>
            <button class="tool" data-action="underline" title="Underline"><i class="fas fa-underline"></i></button>
            <button class="tool" data-action="strikeThrough" title="Strikethrough"><i class="fas fa-strikethrough"></i></button>
            <button class="tool" data-action="subscript" title="Subscript"><i class="fas fa-subscript"></i></button>
            <button class="tool" data-action="superscript" title="Superscript"><i class="fas fa-superscript"></i></button>
            <input type="number" class="tool-select" id="fontSize" title="Font Size" min="8" max="72" step="2" value="16" style="width: 80px; color: #e8f5e9;">
            <button type="button" class="tool font-picker-button" id="fontPickerButton" title="Font Family" aria-haspopup="true" aria-expanded="false">
              <span class="font-picker-label" id="fontPickerLabel">Aa</span>
            </button>
            <div id="colorControlsRoot" class="color-controls"></div>
            <button type="button" class="tool shape-picker-button" id="shapePickerButton" title="Insert Shape" aria-haspopup="true" aria-expanded="false">
              <i class="fas fa-shapes"></i>
            </button>
            <button type="button" class="tool image-picker-button" id="imagePickerButton" title="Insert Image">
              <i class="fas fa-image"></i>
            </button>
            <button type="button" class="tool video-picker-button" id="videoPickerButton" title="Insert Video">
              <i class="fas fa-film"></i>
            </button>
            <button type="button" class="tool table-picker-button" id="tablePickerButton" title="Insert Table" aria-haspopup="true" aria-expanded="false">
              <i class="fas fa-table"></i>
            </button>
            <button class="tool" data-action="justifyLeft" title="Align Left"><i class="fas fa-align-left"></i></button>
            <button class="tool" data-action="justifyCenter" title="Align Center"><i class="fas fa-align-center"></i></button>
            <button class="tool" data-action="justifyRight" title="Align Right"><i class="fas fa-align-right"></i></button>
            <button class="tool" data-action="justifyFull" title="Justify"><i class="fas fa-align-justify"></i></button>
            <button class="tool" data-action="insertUnorderedList" title="Bullet List"><i class="fas fa-list-ul"></i></button>
            <button class="tool" data-action="insertOrderedList" title="Numbered List"><i class="fas fa-list-ol"></i></button>
            <button class="tool" data-action="addTextBox" title="Add Text Box"><i class="fas fa-text-width"></i> Text Box</button>
            <button class="tool present-button" data-action="present" title="Present Slideshow" aria-label="Present">
              <svg class="present-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 4l12 8-12 8z" fill="currentColor"></path>
              </svg>
            </button>
          </div>
          <div class="canvas-wrap">
            <div class="canvas" id="canvas">
              <div class="title-box" contenteditable="true" id="titleBox" data-placeholder="Click to add title"></div>
              <div class="text-box" contenteditable="true" id="textBox" data-placeholder="Click to add text"></div>
            </div>
          </div>
        </section>
      </div>
    </div>

    <div class="save-notification" id="saveNotification">Presentation saved!</div>

    <script type="module">
      import React, { useEffect, useRef, useState } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { PaintBucket } from 'https://esm.sh/lucide-react@0.312.0?deps=react@18.2.0';

      const { createElement, Fragment } = React;

      const TextIcon = (props) => createElement(
        'svg',
        Object.assign({
          width: 18,
          height: 18,
          viewBox: '0 0 24 24',
          fill: 'none',
          stroke: 'currentColor',
          strokeWidth: 2,
          strokeLinecap: 'round',
          strokeLinejoin: 'round'
        }, props),
        createElement('path', { d: 'M5 20h14' }),
        createElement('path', { d: 'M12 4l5 12' }),
        createElement('path', { d: 'M12 4L7 16' }),
        createElement('line', { x1: 10.5, y1: 12, x2: 13.5, y2: 12 })
      );

      const DEFAULT_TEXT_COLOR = '#000000';
      const DEFAULT_BG_COLOR = '#ffff00';

      const ColorControls = ({ textColorHandler, bgColorHandler }) => {
        const [textColor, setTextColor] = useState(DEFAULT_TEXT_COLOR);
        const [bgColor, setBgColor] = useState(DEFAULT_BG_COLOR);
        const textInputRef = useRef(null);
        const bgInputRef = useRef(null);

        useEffect(() => {
          if (textInputRef.current) {
            setTextColor(textInputRef.current.value || DEFAULT_TEXT_COLOR);
          }
          if (bgInputRef.current) {
            setBgColor(bgInputRef.current.value || DEFAULT_BG_COLOR);
          }
        }, []);

        const handleTextColorChange = (event) => {
          const color = event.target.value;
          setTextColor(color);
          if (typeof textColorHandler === 'function') {
            textColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-text-color', { detail: { color } }));
          }
        };

        const handleBgColorChange = (event) => {
          const color = event.target.value;
          setBgColor(color);
          if (typeof bgColorHandler === 'function') {
            bgColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-bg-color', { detail: { color } }));
          }
        };

        const triggerTextPicker = () => {
          if (textInputRef.current) {
            textInputRef.current.click();
          }
        };

        const triggerBgPicker = () => {
          if (bgInputRef.current) {
            bgInputRef.current.click();
          }
        };

        return createElement(
          Fragment,
          null,
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerTextPicker,
              title: 'Font Color',
              'aria-label': 'Font Color'
            },
            createElement(TextIcon, { className: 'color-tool-icon' }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: textColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'fontColor',
            ref: textInputRef,
            defaultValue: DEFAULT_TEXT_COLOR,
            className: 'visually-hidden',
            onChange: handleTextColorChange
          }),
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerBgPicker,
              title: 'Text Box Background Color',
              'aria-label': 'Text Box Background Color'
            },
            createElement(PaintBucket, { size: 18 }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: bgColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'highlightColor',
            ref: bgInputRef,
            defaultValue: DEFAULT_BG_COLOR,
            className: 'visually-hidden',
            onChange: handleBgColorChange
          })
        );
      };

      const rootElement = document.getElementById('colorControlsRoot');
      if (rootElement) {
        const handlers = window.slideEditorColorHandlers || {};
        createRoot(rootElement).render(createElement(ColorControls, {
          textColorHandler: handlers.onTextColor,
          bgColorHandler: handlers.onBackgroundColor
        }));
      }
    </script>

    <script>
      // Route Protection - Check authentication on page load
      (function() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        // If not authenticated and not a guest, redirect to welcome page
        if (!currentUser && !isGuest) {
          window.location.href = './index.html';
          return;
        }
      })();
      
      const DEFAULT_FONT_STACK = 'Inter, system-ui, -apple-system, "Segoe UI", sans-serif';

      // Model per Editor.json: starting with one slide titled "Title"
      const slides = [{ 
        title: '', 
        content: '',
        titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
        textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
        titleFontFamily: DEFAULT_FONT_STACK,
        textFontFamily: DEFAULT_FONT_STACK,
        shapes: [],
        additionalTextBoxes: [],
      tables: [],
      images: [],
      videos: [],
        transition: 'none',
        background: { image: '', size: '', position: '', repeat: '' }
      }];
      let active = 0;
      let slideDragSourceIndex = null;

      const sidebar = document.getElementById('sidebar');
      const titleBox = document.getElementById('titleBox');
      const textBox = document.getElementById('textBox');
      const saveNotification = document.getElementById('saveNotification');
      const saveAsButton = document.getElementById('btnSaveAs');
      const saveAsMenu = document.getElementById('saveAsMenu');
      const canvas = document.getElementById('canvas');
      const fontPickerButton = document.getElementById('fontPickerButton');
      const fontPickerLabel = document.getElementById('fontPickerLabel');
      const shapePickerButton = document.getElementById('shapePickerButton');
      const imagePickerButton = document.getElementById('imagePickerButton');
      const videoPickerButton = document.getElementById('videoPickerButton');
      const tablePickerButton = document.getElementById('tablePickerButton');
      const DEFAULT_FONT_FAMILY = window.getComputedStyle(textBox).fontFamily || DEFAULT_FONT_STACK;
      titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
      textBox.dataset.rotation = textBox.dataset.rotation || '0';
      titleBox.style.transform = `rotate(${parseFloat(titleBox.dataset.rotation || '0')}deg)`;
      textBox.style.transform = `rotate(${parseFloat(textBox.dataset.rotation || '0')}deg)`;
      titleBox.dataset.minWidth = titleBox.dataset.minWidth || '200';
      titleBox.dataset.minHeight = titleBox.dataset.minHeight || '50';
      textBox.dataset.minWidth = textBox.dataset.minWidth || '200';
      textBox.dataset.minHeight = textBox.dataset.minHeight || '50';
      titleBox.style.display = 'none';
      textBox.style.display = 'none';
      let isExportingPresentation = false;
      const CANVAS_INTERACTIVE_SELECTOR = '.text-box, #titleBox, #textBox, .additional-text-box, .shape-element, .image-element, .video-element, .table-element, .table-resize-handle, .resize-edge, .shape-rotation-handle';

      if (canvas) {
        canvas.addEventListener('dblclick', (event) => {
          if (isPresenting) return;
          const interactiveTarget = event.target.closest(CANVAS_INTERACTIVE_SELECTOR);
          if (interactiveTarget && interactiveTarget !== canvas) {
            return;
          }
          const rect = canvas.getBoundingClientRect();
          const canvasX = event.clientX - rect.left;
          const canvasY = event.clientY - rect.top;
          lastCanvasInsertPosition = {
            x: canvasX,
            y: canvasY
          };
          const newTextBox = addTextBoxAtCanvasPosition(canvasX, canvasY);
          if (newTextBox) {
            event.preventDefault();
            event.stopPropagation();
          }
        });
        canvas.addEventListener('click', (event) => {
          const rect = canvas.getBoundingClientRect();
          lastCanvasInsertPosition = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
          };
        });
        canvas.addEventListener('contextmenu', (event) => {
          const objectTarget = event.target.closest('.image-element, .video-element, .shape-element, .table-element, .additional-text-box, #titleBox, #textBox');
          if (objectTarget) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          const rect = canvas.getBoundingClientRect();
          lastCanvasInsertPosition = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
          };
          showSlideCanvasContextMenu(event, active);
        });
      }
      if (titleBox) {
        titleBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(titleBox);
          showElementContextMenu(event, titleBox);
        });
      }
      if (textBox) {
        textBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(textBox);
          showElementContextMenu(event, textBox);
        });
      }

      function showNotification(message) {
        if (!saveNotification) return;
        saveNotification.textContent = message;
        saveNotification.classList.add('show');
        setTimeout(() => {
          saveNotification.classList.remove('show');
        }, 2200);
      }

      const FONT_OPTIONS = [
        { name: 'Inter', stack: DEFAULT_FONT_STACK },
        { name: 'System UI', stack: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif' },
        { name: 'Roboto', stack: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Open Sans', stack: '"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Lato', stack: 'Lato, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Montserrat', stack: 'Montserrat, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Poppins', stack: 'Poppins, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Source Sans Pro', stack: '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Nunito', stack: 'Nunito, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway', stack: 'Raleway, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Oswald', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Cabin', stack: 'Cabin, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Fira Sans', stack: '"Fira Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Arial', stack: 'Arial, Helvetica, sans-serif' },
        { name: 'Verdana', stack: 'Verdana, Geneva, sans-serif' },
        { name: 'Tahoma', stack: 'Tahoma, Geneva, sans-serif' },
        { name: 'Trebuchet MS', stack: '"Trebuchet MS", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Helvetica Neue', stack: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Times New Roman', stack: '"Times New Roman", Times, serif' },
        { name: 'Georgia', stack: 'Georgia, serif' },
        { name: 'Garamond', stack: 'Garamond, Baskerville, "Times New Roman", serif' },
        { name: 'Merriweather', stack: 'Merriweather, Georgia, serif' },
        { name: 'Playfair Display', stack: '"Playfair Display", Georgia, serif' },
        { name: 'Cambria', stack: 'Cambria, Georgia, serif' },
        { name: 'Palatino', stack: '"Palatino Linotype", "Book Antiqua", Palatino, serif' },
        { name: 'Courier New', stack: '"Courier New", Courier, monospace' },
        { name: 'IBM Plex Mono', stack: '"IBM Plex Mono", "Courier New", Courier, monospace' },
        { name: 'Consolas', stack: 'Consolas, "Liberation Mono", Courier, monospace' },
        { name: 'Fira Code', stack: '"Fira Code", "Fira Mono", "DejaVu Sans Mono", monospace' },
        { name: 'Lucida Console', stack: '"Lucida Console", Monaco, monospace' },
        { name: 'Brush Script', stack: '"Brush Script MT", cursive' },
        { name: 'Pacifico', stack: 'Pacifico, "Brush Script MT", cursive' },
        { name: 'Dancing Script', stack: '"Dancing Script", "Brush Script MT", cursive' },
        { name: 'Great Vibes', stack: '"Great Vibes", "Brush Script MT", cursive' },
        { name: 'Oswald Condensed', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Bebas Neue', stack: '"Bebas Neue", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway Dots', stack: '"Raleway Dots", "Helvetica Neue", Helvetica, Arial, sans-serif' }
      ];

      const fontDropdown = document.createElement('div');
      fontDropdown.id = 'fontDropdown';
      fontDropdown.className = 'font-dropdown';
      document.body.appendChild(fontDropdown);
      const imageFileInput = document.createElement('input');
      imageFileInput.type = 'file';
      imageFileInput.accept = 'image/*';
      imageFileInput.id = 'imageFileInput';
      imageFileInput.className = 'visually-hidden';
      document.body.appendChild(imageFileInput);
      const videoFileInput = document.createElement('input');
      videoFileInput.type = 'file';
      videoFileInput.accept = 'video/*';
      videoFileInput.id = 'videoFileInput';
      videoFileInput.className = 'visually-hidden';
      document.body.appendChild(videoFileInput);

      const fontOptionButtons = new Map();
      const fontStackToName = new Map();
      const fontNameToStack = new Map();

      const shapeDropdown = document.createElement('div');
      shapeDropdown.id = 'shapeDropdown';
      shapeDropdown.className = 'shape-dropdown';
      document.body.appendChild(shapeDropdown);
      const shapeOptionButtons = new Map();

      const tableInsertPanel = document.createElement('div');
      tableInsertPanel.id = 'tableInsertPanel';
      tableInsertPanel.className = 'table-insert-panel';
      tableInsertPanel.innerHTML = `
        <h4>Insert Table</h4>
        <div class="table-insert-grid">
          <div class="table-insert-field">
            <label for="tableRowsInput">Rows</label>
            <input type="number" id="tableRowsInput" min="1" max="12" value="3">
          </div>
          <div class="table-insert-field">
            <label for="tableColsInput">Columns</label>
            <input type="number" id="tableColsInput" min="1" max="12" value="3">
          </div>
        </div>
        <div class="table-insert-actions">
          <button type="button" id="tableInsertConfirm">Insert</button>
        </div>
      `;
      document.body.appendChild(tableInsertPanel);
      const tableRowsInput = tableInsertPanel.querySelector('#tableRowsInput');
      const tableColsInput = tableInsertPanel.querySelector('#tableColsInput');
      const tableInsertConfirm = tableInsertPanel.querySelector('#tableInsertConfirm');

      const COLOR_CANVAS = document.createElement('canvas');
      COLOR_CANVAS.width = COLOR_CANVAS.height = 1;
      const COLOR_CTX = COLOR_CANVAS.getContext('2d');
      function normalizeColorHex(color) {
        if (!color) return '#ffffff';
        try {
          COLOR_CTX.fillStyle = '#000000';
          COLOR_CTX.fillStyle = color;
          return COLOR_CTX.fillStyle;
        } catch (err) {
          return '#ffffff';
        }
      }

      const SHAPE_OPTIONS = [
        {
          id: 'rectangle',
          name: 'Rectangle',
          viewBox: '0 0 100 70',
          svg: '<rect x="6" y="10" width="88" height="50" rx="10" ry="10"></rect>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#9ae6b4'
        },
        {
          id: 'square',
          name: 'Square',
          viewBox: '0 0 100 100',
          svg: '<rect x="12" y="12" width="76" height="76" rx="12" ry="12"></rect>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#a5b4fc'
        },
        {
          id: 'circle',
          name: 'Circle',
          viewBox: '0 0 100 100',
          svg: '<circle cx="50" cy="50" r="38"></circle>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#fbb6ce'
        },
        {
          id: 'triangle',
          name: 'Triangle',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 12 L90 78 H10 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#f6ad55'
        },
        {
          id: 'star',
          name: 'Star',
          viewBox: '0 0 100 100',
          svg: '<path d="M50 6 L61 36 H92 L66 54 L76 84 L50 66 L24 84 L34 54 L8 36 H39 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 160,
          minWidth: 80,
          minHeight: 80,
          defaultColor: '#fcd34d'
        },
        {
          id: 'arrow-right',
          name: 'Arrow',
          viewBox: '0 0 120 70',
          svg: '<path d="M16 28 H70 V14 L104 35 L70 56 V42 H16 Z"></path>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#4ade80'
        },
        {
          id: 'line',
          name: 'Line',
          viewBox: '0 0 100 40',
          svg: '<line x1="8" y1="32" x2="92" y2="8" stroke-linecap="round" fill="none"></line>',
          defaultWidth: 220,
          defaultHeight: 60,
          minWidth: 80,
          minHeight: 30,
          defaultColor: '#63b3ed',
          strokeWidth: 8
        },
        {
          id: 'pentagon',
          name: 'Pentagon',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 8 L90 36 L74 80 H26 L10 36 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 70,
          defaultColor: '#f472b6'
        }
      ];

      const SHAPE_OPTION_MAP = new Map(SHAPE_OPTIONS.map(shape => [shape.id, shape]));

      function normalizeFontStack(value) {
        if (!value) return '';
        return value.replace(/"/g, "'").split(',').map(part => part.replace(/['"]/g, '').trim().toLowerCase()).join(',');
      }

      FONT_OPTIONS.forEach(font => {
        const normalized = normalizeFontStack(font.stack);
        fontStackToName.set(normalized, font.name);
        fontNameToStack.set(font.name.toLowerCase(), font.stack);
      });

      function renderFontOptions() {
        fontDropdown.innerHTML = '';
        fontOptionButtons.clear();
        FONT_OPTIONS.forEach(font => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'font-option';
          option.textContent = font.name;
          option.style.fontFamily = font.stack;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            applyFontFamilyToCurrent(font.stack);
            hideFontDropdown();
          });
          fontDropdown.appendChild(option);
          fontOptionButtons.set(normalizeFontStack(font.stack), option);
        });
      }

      function renderShapeOptions() {
        shapeDropdown.innerHTML = '';
        shapeOptionButtons.clear();
        SHAPE_OPTIONS.forEach(shape => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'shape-option';
          option.innerHTML = `
            <div class="shape-option-preview">${renderShapeSvg(shape)}</div>
            <span class="shape-option-label">${shape.name}</span>
          `;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            insertShape(shape.id);
            hideShapeDropdown();
          });
          shapeDropdown.appendChild(option);
          shapeOptionButtons.set(shape.id, option);
        });
      }

      renderShapeOptions();

      renderFontOptions();

      const shapeColorPicker = document.createElement('div');
      shapeColorPicker.id = 'shapeColorPicker';
      shapeColorPicker.className = 'shape-color-picker';
      shapeColorPicker.innerHTML = `
        <button type="button" id="shapeColorButton" class="shape-color-button" title="Shape Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="shapeColorInput" class="shape-color-input" value="#e8f5e9" aria-label="Shape Fill Color Picker">
      `;
      document.body.appendChild(shapeColorPicker);
      const shapeColorButton = document.getElementById('shapeColorButton');
      const shapeColorInput = document.getElementById('shapeColorInput');
      const shapeSizeBadge = document.createElement('div');
      shapeSizeBadge.id = 'shapeSizeBadge';
      shapeSizeBadge.className = 'shape-size-badge';
      document.body.appendChild(shapeSizeBadge);

      const tableColumnColorPicker = document.createElement('div');
      tableColumnColorPicker.id = 'tableColumnColorPicker';
      tableColumnColorPicker.className = 'shape-color-picker table-column-color-picker';
      tableColumnColorPicker.innerHTML = `
        <button type="button" id="tableColumnColorButton" class="shape-color-button" title="Column Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="tableColumnColorInput" class="shape-color-input" value="#ecfdf5" aria-label="Column Fill Color Picker">
      `;
      document.body.appendChild(tableColumnColorPicker);
      const tableColumnColorButton = tableColumnColorPicker.querySelector('#tableColumnColorButton');
      const tableColumnColorInput = tableColumnColorPicker.querySelector('#tableColumnColorInput');

      const slideContextMenu = document.createElement('div');
      slideContextMenu.id = 'slideContextMenu';
      slideContextMenu.className = 'slide-context-menu';
      slideContextMenu.innerHTML = `
        <button type="button" data-action="rename-slide">
          <i class="fas fa-pen"></i>
          <span>Rename</span>
        </button>
      `;
      document.body.appendChild(slideContextMenu);
      const slideContextRenameBtn = slideContextMenu.querySelector('[data-action="rename-slide"]');

      const slideTransitionMenu = document.createElement('div');
      slideTransitionMenu.id = 'slideTransitionMenu';
      slideTransitionMenu.className = 'slide-context-menu';
      slideTransitionMenu.innerHTML = '';
      document.body.appendChild(slideTransitionMenu);
      const elementContextMenu = document.createElement('div');
      elementContextMenu.id = 'elementContextMenu';
      elementContextMenu.className = 'image-context-menu';
      elementContextMenu.innerHTML = `
        <button type="button" data-action="copy">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
        </button>
        <button type="button" data-action="cut">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
        </button>
        <button type="button" data-action="paste">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
        </button>
        <button type="button" data-action="delete">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete</span>
        </button>
        <button type="button" data-action="crop">
          <span class="menu-icon"><i class="fas fa-crop"></i></span>
          <span>Crop Image</span>
        </button>
        <button type="button" data-action="background">
          <span class="menu-icon"><i class="fas fa-image"></i></span>
          <span>Set Image as Background</span>
        </button>
      `;
      document.body.appendChild(elementContextMenu);
      const elementContextButtons = {
        copy: elementContextMenu.querySelector('[data-action="copy"]'),
        cut: elementContextMenu.querySelector('[data-action="cut"]'),
        paste: elementContextMenu.querySelector('[data-action="paste"]'),
        delete: elementContextMenu.querySelector('[data-action="delete"]'),
        crop: elementContextMenu.querySelector('[data-action="crop"]'),
        background: elementContextMenu.querySelector('[data-action="background"]')
      };
      const slideCanvasContextMenu = document.createElement('div');
      slideCanvasContextMenu.id = 'slideCanvasContextMenu';
      slideCanvasContextMenu.className = 'slide-canvas-context-menu';
      slideCanvasContextMenu.innerHTML = `
        <button type="button" data-action="copy-slide">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
        </button>
        <button type="button" data-action="cut-slide">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
        </button>
        <button type="button" data-action="paste-slide">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
        </button>
        <button type="button" data-action="new-slide">
          <span class="menu-icon"><i class="fas fa-plus"></i></span>
          <span>New Slide</span>
        </button>
        <button type="button" data-action="duplicate-slide">
          <span class="menu-icon"><i class="fas fa-clone"></i></span>
          <span>Duplicate Slide</span>
        </button>
        <button type="button" data-action="delete-slide">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete Slide</span>
        </button>
      `;
      document.body.appendChild(slideCanvasContextMenu);
      const slideCanvasMenuButtons = {
        copy: slideCanvasContextMenu.querySelector('[data-action="copy-slide"]'),
        cut: slideCanvasContextMenu.querySelector('[data-action="cut-slide"]'),
        paste: slideCanvasContextMenu.querySelector('[data-action="paste-slide"]'),
        newSlide: slideCanvasContextMenu.querySelector('[data-action="new-slide"]'),
        duplicate: slideCanvasContextMenu.querySelector('[data-action="duplicate-slide"]'),
        delete: slideCanvasContextMenu.querySelector('[data-action="delete-slide"]')
      };
      const imageCropOverlay = document.createElement('div');
      imageCropOverlay.id = 'imageCropOverlay';
      imageCropOverlay.className = 'image-crop-overlay';
      imageCropOverlay.innerHTML = `
        <div class="image-crop-dialog" role="dialog" aria-modal="true" aria-labelledby="imageCropTitle">
          <div class="image-crop-header">
            <span id="imageCropTitle">Crop Image</span>
            <button type="button" id="imageCropClose" class="image-crop-close" aria-label="Close crop dialog">&times;</button>
          </div>
          <div class="image-crop-content">
            <img id="imageCropperImage" alt="Image crop preview">
          </div>
          <div class="image-crop-actions">
            <button type="button" id="imageCropCancel">Cancel</button>
            <button type="button" id="imageCropApply">Apply Crop</button>
          </div>
        </div>
      `;
      document.body.appendChild(imageCropOverlay);
      const imageCropperImage = imageCropOverlay.querySelector('#imageCropperImage');
      const imageCropCancel = imageCropOverlay.querySelector('#imageCropCancel');
      const imageCropApply = imageCropOverlay.querySelector('#imageCropApply');
      const imageCropClose = imageCropOverlay.querySelector('#imageCropClose');
      let elementContextTarget = null;
      let editorClipboard = {
        type: null,
        mode: 'copy',
        data: null,
        offset: 0
      };
      let imageCropperInstance = null;
      let imageCropTargetElement = null;
      let slideCanvasContextTargetIndex = null;
      function setEditorClipboard(type, data, mode = 'copy') {
        editorClipboard = {
          type,
          data,
          mode,
          offset: 0
        };
        updateSlideCanvasMenuState();
        updateElementContextMenuState();
      }
      function hideElementContextMenu() {
        if (!elementContextMenu) return;
        elementContextMenu.classList.remove('show');
        elementContextMenu.style.top = '-9999px';
        elementContextMenu.style.left = '-9999px';
        elementContextTarget = null;
      }
      function updateElementContextMenuState() {
        if (!elementContextMenu) return;
        if (elementContextButtons.paste) {
          const hasElementsClipboard = editorClipboard.type === 'elements'
            && editorClipboard.data
            && Array.isArray(editorClipboard.data.items)
            && editorClipboard.data.items.length > 0;
          elementContextButtons.paste.disabled = !hasElementsClipboard;
        }
      }
      function getElementPosition(element) {
        const styleLeft = parseFloat(element.style.left);
        const styleTop = parseFloat(element.style.top);
        if (Number.isFinite(styleLeft) && Number.isFinite(styleTop)) {
          return { left: styleLeft, top: styleTop };
        }
        const rect = element.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        return {
          left: rect.left - canvasRect.left,
          top: rect.top - canvasRect.top
        };
      }
      function serializeImageElement(element) {
        if (!element) return null;
        const img = element.querySelector('img');
        if (!img) return null;
        const { left, top } = getElementPosition(element);
        return {
          src: img.getAttribute('src'),
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '80'),
          minHeight: parseFloat(element.dataset.minHeight || '60'),
          aspectRatio: parseFloat(element.dataset.aspectRatio || (element.offsetWidth / Math.max(element.offsetHeight, 0.01))),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeVideoElement(element) {
        if (!element) return null;
        const video = element.querySelector('video');
        if (!video) return null;
        const { left, top } = getElementPosition(element);
        return {
          src: video.getAttribute('src'),
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '160'),
          minHeight: parseFloat(element.dataset.minHeight || '90'),
          aspectRatio: parseFloat(element.dataset.aspectRatio || (element.offsetWidth / Math.max(element.offsetHeight, 0.01))),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeShapeElement(element) {
        if (!element) return null;
        const { left, top } = getElementPosition(element);
        return {
          shapeId: element.dataset.shape,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          color: normalizeColorHex(element.dataset.color || element.style.color || '#e8f5e9'),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          minWidth: element.dataset.minWidth ? parseFloat(element.dataset.minWidth) : undefined,
          minHeight: element.dataset.minHeight ? parseFloat(element.dataset.minHeight) : undefined,
          rotation: parseFloat(element.dataset.rotation || '0') || 0
        };
      }
      function serializeTableElement(element) {
        if (!element) return null;
        const table = element.querySelector('table');
        const rows = table ? table.rows.length : parseInt(element.dataset.rows || '1', 10) || 1;
        const cols = table && table.rows[0] ? table.rows[0].cells.length : parseInt(element.dataset.cols || '1', 10) || 1;
        const clone = element.cloneNode(true);
        clone.querySelectorAll('.table-resize-handle').forEach((handle) => handle.remove());
        clone.querySelectorAll('.table-cell-selected').forEach(cell => cell.classList.remove('table-cell-selected'));
        const sanitizedHtml = clone.innerHTML;
        const { left, top } = getElementPosition(element);
        return {
          rows,
          cols,
          html: sanitizedHtml,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          minWidth: parseFloat(element.dataset.minWidth || '240'),
          minHeight: parseFloat(element.dataset.minHeight || '160'),
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeTextBoxElement(element) {
        if (!element) return null;
        const { left, top } = getElementPosition(element);
        const computed = window.getComputedStyle(element);
        const minWidthValue = parseFloat(element.dataset.minWidth || element.style.minWidth || 200);
        const minHeightValue = parseFloat(element.dataset.minHeight || element.style.minHeight || 50);
        return {
          html: element.innerHTML,
          top,
          left,
          width: element.offsetWidth,
          height: element.offsetHeight,
          fontSize: element.style.fontSize || computed.fontSize,
          fontFamily: computed.fontFamily,
          display: element.style.display || '',
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: minWidthValue,
          minHeight: minHeightValue,
          backgroundColor: element.style.backgroundColor || '',
          color: element.style.color || '',
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          isTitle: element === titleBox,
          isBody: element === textBox
        };
      }
      function applyTextBoxData(element, data) {
        if (!element || !data) return;
        if (Number.isFinite(data.left)) {
          element.style.left = `${data.left}px`;
        }
        if (Number.isFinite(data.top)) {
          element.style.top = `${data.top}px`;
        }
        if (Number.isFinite(data.width)) {
          element.style.width = `${data.width}px`;
        }
        if (Number.isFinite(data.height)) {
          element.style.height = `${data.height}px`;
        }
        if (Number.isFinite(data.minWidth)) {
          element.dataset.minWidth = String(data.minWidth);
          element.style.minWidth = `${data.minWidth}px`;
        }
        if (Number.isFinite(data.minHeight)) {
          element.dataset.minHeight = String(data.minHeight);
          element.style.minHeight = `${data.minHeight}px`;
        }
        element.style.fontSize = data.fontSize || element.style.fontSize || '16px';
        element.style.fontFamily = data.fontFamily || element.style.fontFamily || DEFAULT_FONT_FAMILY;
        elementFontSizes.set(element, parseFloat(element.style.fontSize) || 16);
        elementFontFamilies.set(element, element.style.fontFamily || DEFAULT_FONT_FAMILY);
        element.style.backgroundColor = data.backgroundColor || '';
        element.style.color = data.color || '';
        element.style.display = data.display || '';
        const rotation = Number.isFinite(data.rotation) ? data.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = data.html || '';
        if (Number.isFinite(data.zIndex)) {
          element.style.zIndex = String(data.zIndex);
        }
        createResizeEdges(element);
      }
      function serializeElement(element) {
        if (!element) return null;
        if (element.classList.contains('image-element')) {
          const data = serializeImageElement(element);
          return data ? { type: 'image', data } : null;
        }
        if (element.classList.contains('video-element')) {
          const data = serializeVideoElement(element);
          return data ? { type: 'video', data } : null;
        }
        if (element.classList.contains('shape-element')) {
          const data = serializeShapeElement(element);
          return data ? { type: 'shape', data } : null;
        }
        if (element.classList.contains('table-element')) {
          const data = serializeTableElement(element);
          return data ? { type: 'table', data } : null;
        }
        if (element.classList.contains('additional-text-box') || element === titleBox || element === textBox) {
          const data = serializeTextBoxElement(element);
          return data ? { type: 'textbox', data } : null;
        }
        return null;
      }
      function showElementContextMenu(event, element) {
        if (!elementContextMenu || !element) return;
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        elementContextTarget = element;
        elementContextMenu.classList.add('show');
        elementContextMenu.style.top = '0px';
        elementContextMenu.style.left = '0px';
        const menuRect = elementContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        elementContextMenu.style.top = `${Math.max(padding, top)}px`;
        elementContextMenu.style.left = `${Math.max(padding, left)}px`;
        const isImage = element.classList.contains('image-element');
        if (elementContextButtons.crop) {
          elementContextButtons.crop.style.display = isImage ? 'flex' : 'none';
        }
        if (elementContextButtons.background) {
          elementContextButtons.background.style.display = isImage ? 'flex' : 'none';
        }
        updateElementContextMenuState();
      }
      function getSelectedElementContext() {
        if (selectedImage) return { type: 'image', element: selectedImage };
        if (selectedVideo) return { type: 'video', element: selectedVideo };
        if (selectedShape) return { type: 'shape', element: selectedShape };
        if (selectedTable) return { type: 'table', element: selectedTable };
        if (selectedTextBox) return { type: 'textbox', element: selectedTextBox };
        return null;
      }
      function removeElementElement(element) {
        if (!element) return false;
        if (element.classList.contains('image-element')) {
          deleteImage(element);
          return true;
        }
        if (element.classList.contains('video-element')) {
          deleteVideo(element);
          return true;
        }
        if (element.classList.contains('shape-element')) {
          deleteShape(element);
          return true;
        }
        if (element.classList.contains('table-element')) {
          deleteTable(element);
          return true;
        }
        if (element.classList.contains('additional-text-box') || element === titleBox || element === textBox) {
          deleteTextBox(element);
          return true;
        }
        return false;
      }
      function copySelectedElements(targetElement = null) {
        const context = targetElement
          ? { element: targetElement }
          : getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('No object selected');
          return false;
        }
        const serialized = serializeElement(context.element);
        if (!serialized) {
          showNotification('Cannot copy this object');
          return false;
        }
        setEditorClipboard('elements', { items: [serialized] }, 'copy');
        showNotification('Copied object');
        return true;
      }
      function cutSelectedElements(targetElement = null) {
        const context = targetElement
          ? { element: targetElement }
          : getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('No object selected');
          return false;
        }
        const serialized = serializeElement(context.element);
        if (!serialized) {
          showNotification('Cannot cut this object');
          return false;
        }
        setEditorClipboard('elements', { items: [serialized] }, 'cut');
        if (removeElementElement(context.element)) {
          showNotification('Cut object');
          return true;
        }
        return false;
      }
      function instantiateClipboardElement(item, offsetMultiplier = 1, referenceElement = null) {
        if (!item || !item.type || !item.data) return null;
        const offsetAmount = 24 * offsetMultiplier;
        let baseLeft = item.data.left;
        let baseTop = item.data.top;
        if (referenceElement) {
          const refPos = getElementPosition(referenceElement);
          baseLeft = refPos.left;
          baseTop = refPos.top;
        } else if (editorClipboard.mode === 'copy' && lastCanvasInsertPosition && Number.isFinite(item.data.width) && Number.isFinite(item.data.height)) {
          baseLeft = lastCanvasInsertPosition.x - item.data.width / 2;
          baseTop = lastCanvasInsertPosition.y - item.data.height / 2;
        }
        if (!Number.isFinite(baseLeft)) {
          baseLeft = 0;
        }
        if (!Number.isFinite(baseTop)) {
          baseTop = 0;
        }
        switch (item.type) {
          case 'image': {
            const element = createImageElement({
              src: item.data.src,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount,
              width: item.data.width,
              height: item.data.height,
              rotation: item.data.rotation,
              minWidth: item.data.minWidth,
              minHeight: item.data.minHeight,
              aspectRatio: item.data.aspectRatio,
              zIndex: item.data.zIndex,
              animate: false,
              select: true
            });
            return element;
          }
          case 'video': {
            const element = createVideoElement({
              src: item.data.src,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount,
              width: item.data.width,
              height: item.data.height,
              rotation: item.data.rotation,
              minWidth: item.data.minWidth,
              minHeight: item.data.minHeight,
              aspectRatio: item.data.aspectRatio,
              zIndex: item.data.zIndex,
              animate: false,
              select: true
            });
            return element;
          }
          case 'shape': {
            const element = instantiateShape({
              ...item.data,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            });
            if (element) {
              selectShape(element);
            }
            return element;
          }
          case 'table': {
            const element = instantiateTable({
              ...item.data,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            });
            if (element) {
              selectTableElement(element);
            }
            return element;
          }
          case 'textbox': {
            const isTitle = !!item.data.isTitle;
            const isBody = !!item.data.isBody;
            const restoringMain = editorClipboard.mode === 'cut';
            if (isTitle && titleBox && restoringMain) {
              applyTextBoxData(titleBox, item.data);
              selectTextBox(titleBox);
              return titleBox;
            }
            if (isBody && textBox && restoringMain) {
              applyTextBoxData(textBox, item.data);
              selectTextBox(textBox);
              return textBox;
            }
            const element = createAdditionalTextBox({
              ...item.data,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            });
            if (element) {
              selectTextBox(element);
            }
            return element;
          }
          default:
            return null;
        }
      }
      function pasteElementsFromClipboard(options = {}) {
        if (!editorClipboard || editorClipboard.type !== 'elements' || !editorClipboard.data || !Array.isArray(editorClipboard.data.items)) {
          showNotification('Clipboard is empty');
          return false;
        }
        const items = editorClipboard.data.items;
        if (!items.length) {
          showNotification('Clipboard is empty');
          return false;
        }
        const baseOffset = (editorClipboard.offset || 0) + 1;
        editorClipboard.offset = baseOffset;
        const createdElements = [];
        const referenceElement = options.referenceElement || elementContextTarget || null;
        items.forEach((item, index) => {
          const element = instantiateClipboardElement(item, baseOffset + index - 1, referenceElement);
          if (element) {
            createdElements.push(element);
          }
        });
        if (!createdElements.length) {
          showNotification('Nothing to paste');
          return false;
        }
        const lastElement = createdElements[createdElements.length - 1];
        if (lastElement) {
          if (lastElement.classList.contains('image-element')) {
            selectImage(lastElement);
          } else if (lastElement.classList.contains('video-element')) {
            selectVideo(lastElement);
          } else if (lastElement.classList.contains('shape-element')) {
            selectShape(lastElement);
          } else if (lastElement.classList.contains('table-element')) {
            selectTableElement(lastElement);
          } else if (lastElement.classList.contains('additional-text-box')) {
            selectTextBox(lastElement);
          }
        }
        capture();
        saveEditorState('paste_elements');
        editorClipboard.mode = 'copy';
        showNotification('Pasted object');
        updateElementContextMenuState();
        updateSlideCanvasMenuState();
        return true;
      }
      function openImageCropper(element) {
        if (!element) return;
        if (typeof window.Cropper !== 'function') {
          alert('Image crop tools are still loading. Please try again in a moment.');
          return;
        }
        const img = element.querySelector('img');
        if (!img) return;
        imageCropTargetElement = element;
        imageCropOverlay.classList.add('visible');
        if (imageCropperInstance) {
          imageCropperInstance.destroy();
          imageCropperInstance = null;
        }
        const source = img.getAttribute('src');
        imageCropperImage.onload = () => {
          if (imageCropperInstance) {
            imageCropperInstance.destroy();
          }
          imageCropperInstance = new window.Cropper(imageCropperImage, {
            viewMode: 1,
            autoCropArea: 1,
            responsive: true,
            background: false,
            movable: true,
            zoomable: true,
            scalable: false,
            modal: true
          });
        };
        if (imageCropperImage.getAttribute('src') === source) {
          imageCropperImage.onload();
        } else {
          imageCropperImage.setAttribute('src', source || '');
        }
      }
      function closeImageCropper() {
        if (imageCropperInstance) {
          imageCropperInstance.destroy();
          imageCropperInstance = null;
        }
        imageCropOverlay.classList.remove('visible');
        imageCropperImage.removeAttribute('src');
        imageCropperImage.onload = null;
        imageCropTargetElement = null;
      }
      function applyImageCrop() {
        if (!imageCropperInstance || !imageCropTargetElement) return;
        const croppedCanvas = imageCropperInstance.getCroppedCanvas();
        if (!croppedCanvas) return;
        const dataUrl = croppedCanvas.toDataURL('image/png');
        const img = imageCropTargetElement.querySelector('img');
        if (!img) return;
        img.src = dataUrl;
        const newAspect = croppedCanvas.width / Math.max(croppedCanvas.height, 0.01);
        const minWidth = parseFloat(imageCropTargetElement.dataset.minWidth || '80');
        imageCropTargetElement.dataset.aspectRatio = String(newAspect);
        imageCropTargetElement.dataset.minHeight = String(Math.max(60, minWidth / Math.max(newAspect, 0.01)));
        capture();
        saveEditorState('crop_image');
        showNotification('Cropped image');
        closeImageCropper();
      }
      function setImageAsBackground(element) {
        if (!element) return;
        const img = element.querySelector('img');
        if (!img) return;
        const src = img.getAttribute('src');
        if (!src) return;
        const backgroundConfig = {
          image: `url(${src})`,
          size: 'cover',
          position: 'center center',
          repeat: 'no-repeat'
        };
        canvas.style.backgroundImage = backgroundConfig.image;
        canvas.style.backgroundSize = backgroundConfig.size;
        canvas.style.backgroundPosition = backgroundConfig.position;
        canvas.style.backgroundRepeat = backgroundConfig.repeat;
        deleteImage(element, { skipCapture: true, skipHistory: true });
        if (slides[active]) {
          slides[active].background = { ...backgroundConfig };
        }
        capture();
        saveEditorState('set_image_background');
        showNotification('Set image as background');
      }
      function hideSlideCanvasContextMenu() {
        if (!slideCanvasContextMenu) return;
        slideCanvasContextMenu.classList.remove('show');
        slideCanvasContextMenu.style.top = '-9999px';
        slideCanvasContextMenu.style.left = '-9999px';
        slideCanvasContextTargetIndex = null;
      }
      function updateSlideCanvasMenuState() {
        if (!slideCanvasContextMenu) return;
        let hasClipboard = false;
        if (editorClipboard) {
          if (editorClipboard.type === 'slide') {
            hasClipboard = !!(editorClipboard.data && editorClipboard.data.slide);
          } else if (editorClipboard.type === 'elements') {
            hasClipboard = !!(editorClipboard.data && Array.isArray(editorClipboard.data.items) && editorClipboard.data.items.length > 0);
          }
        }
        if (slideCanvasMenuButtons.paste) {
          slideCanvasMenuButtons.paste.disabled = !hasClipboard;
        }
        const singleSlide = slides.length <= 1;
        if (slideCanvasMenuButtons.cut) {
          slideCanvasMenuButtons.cut.disabled = singleSlide;
        }
        if (slideCanvasMenuButtons.delete) {
          slideCanvasMenuButtons.delete.disabled = singleSlide;
        }
      }
      function showSlideCanvasContextMenu(event, index) {
        if (!slideCanvasContextMenu) return;
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        slideCanvasContextTargetIndex = index;
        slideCanvasContextMenu.classList.add('show');
        slideCanvasContextMenu.style.top = '0px';
        slideCanvasContextMenu.style.left = '0px';
        const menuRect = slideCanvasContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        slideCanvasContextMenu.style.top = `${Math.max(padding, top)}px`;
        slideCanvasContextMenu.style.left = `${Math.max(padding, left)}px`;
        updateSlideCanvasMenuState();
      }
      function copySlideAt(index) {
        if (!Number.isInteger(index) || index < 0 || index >= slides.length) return false;
        capture();
        setEditorClipboard('slide', {
          slide: JSON.parse(JSON.stringify(slides[index]))
        }, 'copy');
        return true;
      }
      function deleteSlide(index, options = {}) {
        if (!Number.isInteger(index) || index < 0 || index >= slides.length) return false;
        if (slides.length <= 1) {
          showNotification('Cannot delete the only slide');
          return false;
        }
        const { skipHistory = false } = options;
        capture();
        slides.splice(index, 1);
        if (active > index) {
          active -= 1;
        } else if (active >= slides.length) {
          active = slides.length - 1;
        }
        load();
        renderSidebar();
        if (!skipHistory) {
          saveEditorState('delete_slide');
        }
        updateSlideCanvasMenuState();
        return true;
      }
      function cutSlideAt(index) {
        if (slides.length <= 1) {
          showNotification('Cannot cut the only slide');
          return false;
        }
        if (!copySlideAt(index)) return false;
      editorClipboard.mode = 'cut';
        return deleteSlide(index);
      }
      function pasteSlideAfter(index) {
        if (!editorClipboard || editorClipboard.type !== 'slide' || !editorClipboard.data || !editorClipboard.data.slide) {
          showNotification('Clipboard is empty');
          return false;
        }
        const insertIndex = Math.min(slides.length, Math.max(0, index) + 1);
        capture();
        const newSlide = JSON.parse(JSON.stringify(editorClipboard.data.slide));
        slides.splice(insertIndex, 0, newSlide);
        active = insertIndex;
        load();
        renderSidebar();
        saveEditorState('paste_slide');
        editorClipboard.mode = 'copy';
        updateSlideCanvasMenuState();
        updateElementContextMenuState();
        showNotification('Pasted slide');
        return true;
      }
      if (elementContextButtons.copy) {
        elementContextButtons.copy.addEventListener('click', () => {
          copySelectedElements(elementContextTarget);
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.cut) {
        elementContextButtons.cut.addEventListener('click', () => {
          cutSelectedElements(elementContextTarget);
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.paste) {
        elementContextButtons.paste.addEventListener('click', () => {
          pasteElementsFromClipboard({ referenceElement: elementContextTarget });
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.delete) {
        elementContextButtons.delete.addEventListener('click', () => {
          const target = elementContextTarget || (getSelectedElementContext()?.element ?? null);
          if (target && removeElementElement(target)) {
            showNotification('Deleted object');
          } else {
            showNotification('No object selected');
          }
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.crop) {
        elementContextButtons.crop.addEventListener('click', () => {
          if (elementContextTarget && elementContextTarget.classList.contains('image-element')) {
            hideElementContextMenu();
            openImageCropper(elementContextTarget);
          }
        });
      }
      if (elementContextButtons.background) {
        elementContextButtons.background.addEventListener('click', () => {
          if (elementContextTarget && elementContextTarget.classList.contains('image-element')) {
            hideElementContextMenu();
            setImageAsBackground(elementContextTarget);
          }
        });
      }
      if (slideCanvasMenuButtons.copy) {
        slideCanvasMenuButtons.copy.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (copySlideAt(index)) {
            showNotification('Copied slide');
          }
        });
      }
      if (slideCanvasMenuButtons.cut) {
        slideCanvasMenuButtons.cut.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (cutSlideAt(index)) {
            showNotification('Cut slide');
          }
        });
      }
      if (slideCanvasMenuButtons.paste) {
        slideCanvasMenuButtons.paste.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (editorClipboard.type === 'slide') {
            pasteSlideAfter(index);
          } else if (editorClipboard.type === 'elements') {
            pasteElementsFromClipboard({ referenceElement: null });
          } else {
            showNotification('Clipboard is empty');
          }
        });
      }
      if (slideCanvasMenuButtons.newSlide) {
        slideCanvasMenuButtons.newSlide.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          createNewSlide(index);
        });
      }
      if (slideCanvasMenuButtons.duplicate) {
        slideCanvasMenuButtons.duplicate.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          duplicateCurrentSlide(index);
        });
      }
      if (slideCanvasMenuButtons.delete) {
        slideCanvasMenuButtons.delete.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (deleteSlide(index)) {
            showNotification('Deleted slide');
          }
        });
      }
      if (elementContextMenu) {
        elementContextMenu.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });
        elementContextMenu.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }
      if (slideCanvasContextMenu) {
        slideCanvasContextMenu.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });
        slideCanvasContextMenu.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }
      document.addEventListener('click', (event) => {
        if (elementContextMenu && elementContextMenu.classList.contains('show') && !elementContextMenu.contains(event.target)) {
          hideElementContextMenu();
        }
        if (slideCanvasContextMenu && slideCanvasContextMenu.classList.contains('show') && !slideCanvasContextMenu.contains(event.target)) {
          hideSlideCanvasContextMenu();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (imageCropOverlay.classList.contains('visible')) {
            closeImageCropper();
          } else {
            hideElementContextMenu();
            hideSlideCanvasContextMenu();
          }
        }
      });
      window.addEventListener('resize', () => {
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
      });
      window.addEventListener('scroll', (event) => {
        if (elementContextMenu && elementContextMenu.classList.contains('show') && !elementContextMenu.contains(event.target)) {
          hideElementContextMenu();
        }
        if (slideCanvasContextMenu && slideCanvasContextMenu.classList.contains('show') && !slideCanvasContextMenu.contains(event.target)) {
          hideSlideCanvasContextMenu();
        }
      }, true);
      if (imageCropOverlay) {
        imageCropOverlay.addEventListener('click', (event) => {
          if (event.target === imageCropOverlay) {
            closeImageCropper();
          }
        });
        imageCropOverlay.addEventListener('contextmenu', (event) => event.preventDefault());
      }
      if (imageCropCancel) {
        imageCropCancel.addEventListener('click', () => closeImageCropper());
      }
      if (imageCropClose) {
        imageCropClose.addEventListener('click', () => closeImageCropper());
      }
      if (imageCropApply) {
        imageCropApply.addEventListener('click', () => applyImageCrop());
      }

      const presentationOverlay = document.createElement('div');
      presentationOverlay.id = 'presentationOverlay';
      presentationOverlay.className = 'presentation-overlay';
      presentationOverlay.setAttribute('tabindex', '-1');
      presentationOverlay.innerHTML = `
        <div class="presentation-stage" tabindex="-1"></div>
        <div class="presentation-meta">
          <span><i class="fas fa-arrow-left"></i> Prev</span>
          <span>Esc to Exit</span>
          <span>Next <i class="fas fa-arrow-right"></i></span>
        </div>
        <div class="presentation-counter"></div>
      `;
      document.body.appendChild(presentationOverlay);
      const presentationStage = presentationOverlay.querySelector('.presentation-stage');
      const presentationCounterEl = presentationOverlay.querySelector('.presentation-counter');
      let isPresenting = false;
      let presentationIndex = 0;
      let presentationReturnIndex = 0;
      let presentationControlsTimeout = null;
      const PRESENTATION_CONTROLS_AUTOHIDE_DELAY = 4000;
      let presentationControlsLocked = false;
      let slideContextMenuTarget = null;
      let slideContextMenuTitle = null;
      let slideContextMenuIndex = null;
      const TRANSITION_OPTIONS = Object.freeze([
        { value: 'none', label: 'No Transition' },
        { value: 'fade', label: 'Fade' },
        { value: 'slide', label: 'Slide' },
        { value: 'zoom', label: 'Zoom' },
        { value: 'flip', label: 'Flip' },
        { value: 'rotate', label: 'Rotate' },
        { value: 'push', label: 'Push' },
        { value: 'wipe', label: 'Wipe' },
        { value: 'spin', label: 'Spin' },
        { value: 'dissolve', label: 'Dissolve' },
        { value: 'cube', label: 'Cube' },
        { value: 'bounce', label: 'Bounce' },
        { value: 'swirl', label: 'Swirl' }
      ]);
      const DEFAULT_TRANSITION = 'none';
      const TRANSITION_CLASS_NAMES = TRANSITION_OPTIONS
        .filter(opt => opt.value !== 'none')
        .map(opt => `transition-effect-${opt.value}`);
      let slideTransitionMenuIndex = null;
      let slideTransitionMenuAnchor = null;

      function renderSlideTransitionMenuOptions() {
        if (!slideTransitionMenu) return;
        slideTransitionMenu.innerHTML = '';
        TRANSITION_OPTIONS.forEach(opt => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.transition = opt.value;
          btn.innerHTML = `${getTransitionIconHtml(opt.value)}<span>${opt.label}</span>`;
          slideTransitionMenu.appendChild(btn);
        });
      }
      renderSlideTransitionMenuOptions();

      function showSaveAsMenu() {
        if (!saveAsMenu) return;
        saveAsMenu.classList.add('show');
      }

      function hideSaveAsMenu() {
        if (!saveAsMenu) return;
        saveAsMenu.classList.remove('show');
      }

      function toggleSaveAsMenu() {
        if (!saveAsMenu) return;
        if (saveAsMenu.classList.contains('show')) {
          hideSaveAsMenu();
        } else {
          showSaveAsMenu();
        }
      }

      if (saveAsButton && saveAsMenu) {
        saveAsButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleSaveAsMenu();
        });
        document.addEventListener('click', (event) => {
          if (!saveAsMenu.contains(event.target) && !saveAsButton.contains(event.target)) {
            hideSaveAsMenu();
          }
        });
        window.addEventListener('resize', hideSaveAsMenu);
        window.addEventListener('scroll', hideSaveAsMenu, true);
        saveAsMenu.querySelectorAll('.save-as-option').forEach((option) => {
          option.addEventListener('click', async (event) => {
            event.preventDefault();
            event.stopPropagation();
            const { format } = option.dataset;
            hideSaveAsMenu();
            await handleSaveAsExport(format);
          });
        });
      }

      function prepareCanvasForPresentation(clone) {
        clone.removeAttribute('id');
        clone.classList.add('presentation-slide');
        clone.style.width = '100%';
        clone.style.height = '100%';
        clone.style.pointerEvents = 'none';
        clone.querySelectorAll('[id]').forEach(el => {
          if (el.id) {
            el.removeAttribute('id');
          }
        });
        clone.querySelectorAll('[contenteditable]').forEach(el => {
          el.removeAttribute('contenteditable');
          el.classList.remove('selected');
          el.removeAttribute('spellcheck');
        });
        clone.querySelectorAll('.resize-edge').forEach(el => el.remove());
        clone.querySelectorAll('[data-placeholder]').forEach(el => el.removeAttribute('data-placeholder'));
        clone.querySelectorAll('.shape-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.video-element').forEach(el => {
          el.classList.remove('selected');
          const video = el.querySelector('video');
          if (video) {
            video.controls = true;
          }
        });
        clone.querySelectorAll('.image-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.table-resize-handle').forEach(el => el.remove());
        clone.querySelectorAll('.table-cell-selected').forEach(el => el.classList.remove('table-cell-selected'));
        clone.querySelectorAll('.table-element').forEach(el => {
          el.style.border = '1px solid rgba(148, 232, 203, 0.35)';
          el.style.boxShadow = 'none';
        });
        clone.querySelectorAll('.table-element').forEach(el => {
          el.classList.remove('selected');
          el.style.border = '1px solid rgba(148, 232, 203, 0.35)';
          el.style.boxShadow = 'none';
        });
        clone.querySelectorAll('.title-box, .text-box, .additional-text-box').forEach(el => {
          el.style.border = 'none';
          el.style.boxShadow = 'none';
          el.style.backgroundColor = el.style.backgroundColor || 'transparent';
        });
      }

      function cloneCanvasForPresentation(index) {
        const originalActive = presentationReturnIndex;
        active = index;
        load();
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        applySlideTransitionClass(clone, (slides[index] && slides[index].transition) || DEFAULT_TRANSITION);
        active = originalActive;
        load();
        return clone;
      }

      function waitForNextFrame() {
        return new Promise((resolve) => requestAnimationFrame(() => resolve()));
      }

      function getCanvasBackgroundColor() {
        const computed = window.getComputedStyle(canvas);
        return computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)'
          ? computed.backgroundColor
          : '#ffffff';
      }

      async function renderSlideToImage() {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Export library html2canvas is not available.');
        }
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        clone.style.width = `${canvas.offsetWidth}px`;
        clone.style.height = `${canvas.offsetHeight}px`;
        clone.style.pointerEvents = 'none';
        clone.style.transform = 'none';
        const wrapper = document.createElement('div');
        wrapper.className = 'export-slide-wrapper';
        wrapper.style.position = 'fixed';
        wrapper.style.top = '-12000px';
        wrapper.style.left = '-12000px';
        wrapper.style.width = `${canvas.offsetWidth}px`;
        wrapper.style.height = `${canvas.offsetHeight}px`;
        wrapper.style.pointerEvents = 'none';
        wrapper.style.opacity = '0';
        wrapper.style.background = getCanvasBackgroundColor();
        wrapper.appendChild(clone);
        document.body.appendChild(wrapper);
        try {
          const exportCanvas = await window.html2canvas(clone, {
            backgroundColor: wrapper.style.background || '#ffffff',
            scale: 2,
            useCORS: true,
            logging: false
          });
          return {
            dataUrl: exportCanvas.toDataURL('image/png'),
            width: exportCanvas.width,
            height: exportCanvas.height
          };
        } finally {
          document.body.removeChild(wrapper);
        }
      }

      async function captureSlidesAsImages() {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Export libraries are still loading.');
        }
        const originalActiveIndex = active;
        capture();
        const slideImages = [];
        try {
          for (let index = 0; index < slides.length; index += 1) {
            active = index;
            load();
            await waitForNextFrame();
            const image = await renderSlideToImage();
            slideImages.push(image);
          }
        } finally {
          active = originalActiveIndex;
          load();
        }
        return slideImages;
      }

      function getExportFileName(extension) {
        const currentSlide = slides[active] || slides[0] || {};
        const rawTitle = (currentSlide.title || '').trim();
        const sanitizedTitle = rawTitle
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_');
        const base = sanitizedTitle || 'Presentation';
        const dateStamp = new Date().toISOString().slice(0, 10);
        return `${base}_${dateStamp}.${extension}`;
      }

      async function exportSlidesToPdf(slideImages) {
        const jspdfNamespace = window.jspdf;
        if (!jspdfNamespace || typeof jspdfNamespace.jsPDF !== 'function') {
          throw new Error('PDF export library is not available.');
        }
        if (!slideImages.length) {
          throw new Error('No slides available to export.');
        }
        const { jsPDF } = jspdfNamespace;
        const pxToPt = 72 / 96;
        const firstSlide = slideImages[0];
        const firstOrientation = firstSlide.width >= firstSlide.height ? 'landscape' : 'portrait';
        const doc = new jsPDF({
          orientation: firstOrientation,
          unit: 'pt',
          format: [firstSlide.width * pxToPt, firstSlide.height * pxToPt]
        });
        doc.addImage(
          firstSlide.dataUrl,
          'PNG',
          0,
          0,
          firstSlide.width * pxToPt,
          firstSlide.height * pxToPt,
          undefined,
          'FAST'
        );
        for (let i = 1; i < slideImages.length; i += 1) {
          const slide = slideImages[i];
          const orientation = slide.width >= slide.height ? 'landscape' : 'portrait';
          doc.addPage([slide.width * pxToPt, slide.height * pxToPt], orientation);
          doc.addImage(
            slide.dataUrl,
            'PNG',
            0,
            0,
            slide.width * pxToPt,
            slide.height * pxToPt,
            undefined,
            'FAST'
          );
        }
        doc.save(getExportFileName('pdf'));
      }

      async function exportSlidesToPptx(slideImages) {
        if (typeof window.PptxGenJS !== 'function') {
          throw new Error('PPTX export library is not available.');
        }
        if (!slideImages.length) {
          throw new Error('No slides available to export.');
        }
        const pptx = new window.PptxGenJS();
        pptx.layout = 'LAYOUT_16x9';
        slideImages.forEach((slide) => {
          const slideDeck = pptx.addSlide();
          slideDeck.background = { color: 'FFFFFF' };
          slideDeck.addImage({
            data: slide.dataUrl,
            x: 0,
            y: 0,
            w: pptx.width,
            h: pptx.height
          });
        });
        await pptx.writeFile({ fileName: getExportFileName('pptx') });
      }

      async function handleSaveAsExport(format) {
        if (!format || isExportingPresentation) return;
        if (format !== 'pdf' && format !== 'pptx') return;
        if (typeof window.html2canvas !== 'function') {
          alert('Export tools are still loading. Please try again in a moment.');
          return;
        }
        if (format === 'pdf' && (!window.jspdf || typeof window.jspdf.jsPDF !== 'function')) {
          alert('PDF export tools are still loading. Please try again in a moment.');
          return;
        }
        if (format === 'pptx' && typeof window.PptxGenJS !== 'function') {
          alert('PPTX export tools are still loading. Please try again in a moment.');
          return;
        }
        isExportingPresentation = true;
        const previousCursor = document.body.style.cursor;
        document.body.style.cursor = 'wait';
        try {
          const slideImages = await captureSlidesAsImages();
          if (format === 'pdf') {
            await exportSlidesToPdf(slideImages);
            showNotification('Exported presentation as PDF');
          } else {
            await exportSlidesToPptx(slideImages);
            showNotification('Exported presentation as PPTX');
          }
        } catch (error) {
          console.error('Export failed:', error);
          alert('Unable to export the presentation. Please try again.');
        } finally {
          document.body.style.cursor = previousCursor || '';
          isExportingPresentation = false;
        }
      }

      function updatePresentationCounter() {
        if (presentationCounterEl) {
          presentationCounterEl.textContent = `${presentationIndex + 1} / ${slides.length}`;
        }
      }

      function showPresentationSlide(index) {
        if (index < 0 || index >= slides.length) return;
        presentationIndex = index;
        const clone = cloneCanvasForPresentation(index);
        if (presentationStage) {
          presentationStage.innerHTML = '';
          presentationStage.appendChild(clone);
          clone.querySelectorAll('video').forEach((videoEl) => {
            videoEl.controls = true;
            videoEl.addEventListener('click', (event) => {
              event.stopPropagation();
              if (videoEl.paused) {
                videoEl.play().catch(() => {});
              } else {
                videoEl.pause();
              }
            });
          });
          applySlideTransitionClass(clone, (slides[index] && slides[index].transition) || DEFAULT_TRANSITION);
        }
        updatePresentationCounter();
      }

      function hidePresentationControls(lock = false) {
        if (!isPresenting) return;
        presentationOverlay.classList.remove('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (lock) {
          presentationControlsLocked = true;
        }
      }

      function showPresentationControls(autoHide = true) {
        if (!isPresenting || presentationControlsLocked) return;
        presentationOverlay.classList.add('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
        }
        if (autoHide) {
          presentationControlsTimeout = setTimeout(() => {
            presentationControlsTimeout = null;
            hidePresentationControls(true);
          }, PRESENTATION_CONTROLS_AUTOHIDE_DELAY);
        } else {
          presentationControlsTimeout = null;
        }
      }

      function startPresentation() {
        if (isPresenting) return;
        capture();
        presentationReturnIndex = active;
        isPresenting = true;
        presentationOverlay.classList.add('visible');
        showPresentationSlide(active);
        document.body.classList.add('presenting');
        presentationControlsLocked = false;
        showPresentationControls(true);
        requestAnimationFrame(() => {
          try {
            presentationOverlay.focus({ preventScroll: true });
          } catch (err) {
            presentationOverlay.focus();
          }
          if (presentationOverlay.requestFullscreen) {
            presentationOverlay.requestFullscreen().catch(() => {});
          }
        });
      }

      function exitPresentation(fromFullscreenChange = false) {
        if (!isPresenting) return;
        isPresenting = false;
        presentationOverlay.classList.remove('visible');
        presentationOverlay.classList.remove('show-controls');
        document.body.classList.remove('presenting');
        presentationControlsLocked = false;
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (presentationStage) {
          presentationStage.innerHTML = '';
        }
        active = presentationReturnIndex;
        load();
        renderSidebar();
        if (!fromFullscreenChange && document.fullscreenElement && document.exitFullscreen) {
          document.exitFullscreen().catch(() => {});
        }
      }

      function goToNextSlide() {
        if (presentationIndex < slides.length - 1) {
          showPresentationSlide(presentationIndex + 1);
        }
      }

      function goToPreviousSlide() {
        if (presentationIndex > 0) {
          showPresentationSlide(presentationIndex - 1);
        }
      }

      presentationOverlay.addEventListener('click', (event) => {
        if (!isPresenting) return;
        if (event.target.closest('.presentation-meta') || event.target.closest('.presentation-counter')) return;
        const stageRect = presentationStage ? presentationStage.getBoundingClientRect() : presentationOverlay.getBoundingClientRect();
        if (!stageRect || stageRect.width === 0) return;
        if (event.clientX > stageRect.left + stageRect.width / 2) {
          goToNextSlide();
        } else {
          goToPreviousSlide();
        }
      });

      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && isPresenting) {
          exitPresentation(true);
        }
      });


      shapeColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      shapeColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        shapeColorInput.click();
      });

      function updateShapeColorButtonAppearance(color) {
        shapeColorButton.style.background = color;
        const shadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
        shapeColorButton.style.boxShadow = shadow;
        const hex = color.replace('#', '');
        const bigint = parseInt(hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        shapeColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
      }

      const SHAPE_PICKER_MARGIN = 12;

      function positionShapeColorPicker(element) {
        if (!element || !shapeColorPicker.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const pickerRect = shapeColorPicker.getBoundingClientRect();
        let top = rect.top - pickerRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - pickerRect.width / 2;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }

        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }

        shapeColorPicker.style.top = `${top}px`;
        shapeColorPicker.style.left = `${left}px`;
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
      }

      function showShapeColorPicker(element) {
        if (!element) return;
        const color = normalizeColorHex(element.dataset.color || window.getComputedStyle(element).color || '#e8f5e9');
        shapeColorInput.value = color;
        updateShapeColorButtonAppearance(color);
        shapeColorPicker.classList.add('visible');
        positionShapeColorPicker(element);
        showRotationHandle(element);
      }

      function hideShapeColorPicker() {
        shapeColorPicker.classList.remove('visible');
        hideRotationHandle();
      }

      shapeColorInput.addEventListener('change', (event) => {
        if (!selectedShape) return;
        const color = normalizeColorHex(event.target.value);
        selectedShape.dataset.color = color;
        selectedShape.style.color = color;
        updateShapeColorButtonAppearance(color);
        positionShapeColorPicker(selectedShape);
        if (rotationTarget === selectedShape) {
          positionRotationHandle(selectedShape);
        }
        capture();
        saveEditorState('change_shape_color');
      });

      const shapeRotationHandle = document.createElement('div');
      shapeRotationHandle.id = 'shapeRotationHandle';
      shapeRotationHandle.className = 'shape-rotation-handle';
      shapeRotationHandle.innerHTML = `
        <button type="button" class="shape-rotation-button" title="Rotate Shape">
          <i class="fas fa-sync-alt"></i>
        </button>
        <span class="shape-rotation-angle">0Â°</span>
      `;
      document.body.appendChild(shapeRotationHandle);
      const shapeRotationButton = shapeRotationHandle.querySelector('.shape-rotation-button');
      const shapeRotationAngle = shapeRotationHandle.querySelector('.shape-rotation-angle');

      tableColumnColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      tableColumnColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        tableColumnColorInput.click();
      });

      function handleTableColumnColorInputEvent(event, final = false) {
        if (!tableColumnColorTarget || tableColumnColorIndex == null) return;
        const color = normalizeColorHex(event.target.value);
        updateTableColumnColorButtonAppearance(color);
        applyColorToTableColumn(tableColumnColorTarget, tableColumnColorIndex, color, final);
        positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
      }

      tableColumnColorInput.addEventListener('input', (event) => {
        handleTableColumnColorInputEvent(event, false);
      });

      tableColumnColorInput.addEventListener('change', (event) => {
        handleTableColumnColorInputEvent(event, true);
      });

      tableColumnColorPicker.addEventListener('mouseenter', () => {
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
          tableColumnHideTimeout = null;
        }
      });

      tableColumnColorPicker.addEventListener('mouseleave', () => {
        hideTableColumnColorPicker();
      });

      let rotationTarget = null;
      let isRotatingTarget = false;
      let rotationStartAngle = 0;
      let rotationInitial = 0;
      let rotationCenter = { x: 0, y: 0 };
      let activeResizeShape = null;
      let shapeResizeAnimating = false;

      function updateRotationAngleLabel(element, angleOverride) {
        if (!element || !shapeRotationAngle) return;
        const angle = angleOverride !== undefined ? angleOverride : (parseFloat(element.dataset.rotation || '0') || 0);
        shapeRotationAngle.textContent = `${Math.round(angle)}Â°`;
      }

      function positionRotationHandle(element) {
        if (!element || !shapeRotationHandle.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const handleRect = shapeRotationHandle.getBoundingClientRect();
        const colorRect = shapeColorPicker.getBoundingClientRect();
        const horizontalOffset = shapeColorPicker.classList.contains('visible')
          ? (colorRect.width / 2 + 28)
          : 70;
        let top = rect.top - handleRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 + horizontalOffset;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + handleRect.width > window.innerWidth - 16) {
          left = window.innerWidth - handleRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + handleRect.height > window.innerHeight - 16) {
          top = window.innerHeight - handleRect.height - 16;
        }

        shapeRotationHandle.style.top = `${top}px`;
        shapeRotationHandle.style.left = `${left}px`;
      }

      function showRotationHandle(element) {
        if (!element) return;
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        const currentRotation = parseFloat(element.dataset.rotation || '0') || 0;
        element.style.transform = `rotate(${currentRotation}deg)`;
        rotationTarget = element;
        updateRotationAngleLabel(element);
        positionRotationHandle(element);
        shapeRotationHandle.classList.add('visible');
      }

      function hideRotationHandle() {
        shapeRotationHandle.classList.remove('visible');
        endRotation(false);
        rotationTarget = null;
      }

      function endRotation(save = true) {
        if (!isRotatingTarget) return;
        isRotatingTarget = false;
        shapeRotationButton.classList.remove('active');
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleRotationMove);
        document.removeEventListener('mouseup', handleRotationUp);
        if (save && rotationTarget) {
          updateRotationAngleLabel(rotationTarget);
          positionRotationHandle(rotationTarget);
          capture();
          saveEditorState('rotate_shape');
        }
      }

      function handleRotationMove(event) {
        if (!isRotatingTarget || !rotationTarget) return;
        const current = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        let delta = (current - rotationStartAngle) * (180 / Math.PI);
        let newRotation = rotationInitial + delta;
        newRotation = ((newRotation % 360) + 360) % 360;
        rotationTarget.dataset.rotation = String(newRotation);
        rotationTarget.style.transform = `rotate(${newRotation}deg)`;
        updateRotationAngleLabel(rotationTarget, newRotation);
        if (rotationTarget.classList.contains('shape-element')) {
          positionShapeColorPicker(rotationTarget);
        }
        positionRotationHandle(rotationTarget);
      }

      function handleRotationUp() {
        endRotation(true);
      }

      shapeRotationButton.addEventListener('mousedown', (event) => {
        if (!rotationTarget) return;
        event.preventDefault();
        event.stopPropagation();
        const rect = rotationTarget.getBoundingClientRect();
        rotationCenter = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        rotationStartAngle = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        rotationInitial = parseFloat(rotationTarget.dataset.rotation || '0') || 0;
        isRotatingTarget = true;
        shapeRotationButton.classList.add('active');
        document.body.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleRotationMove);
        document.addEventListener('mouseup', handleRotationUp);
      });

      shapeRotationHandle.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      function updateShapeSizeBadge(element, width, height) {
        if (!element) return;
        shapeSizeBadge.textContent = `${Math.round(width)} Ã— ${Math.round(height)} px`;
        const rect = element.getBoundingClientRect();
        const badgeRect = shapeSizeBadge.getBoundingClientRect();
        let top = rect.top - badgeRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - badgeRect.width / 2;
        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + badgeRect.width > window.innerWidth - 16) {
          left = window.innerWidth - badgeRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        shapeSizeBadge.style.top = `${top}px`;
        shapeSizeBadge.style.left = `${left}px`;
      }

      function showShapeSizeBadge() {
        if (!shapeSizeBadge.classList.contains('visible')) {
          shapeSizeBadge.classList.add('visible');
        }
      }

      function hideShapeSizeBadge() {
        shapeSizeBadge.classList.remove('visible');
      }

      let isFontDropdownVisible = false;

      function setActiveFontOption(fontFamily) {
        const normalized = normalizeFontStack(fontFamily);
        fontOptionButtons.forEach((button, key) => {
          const isActive = key === normalized;
          button.classList.toggle('active', isActive);
          if (isActive) {
            button.scrollIntoView({ block: 'nearest' });
          }
        });
      }

      function extractPrimaryFontName(fontFamily) {
        if (!fontFamily) return 'Inter';
        const primary = fontFamily.split(',')[0].replace(/['"]/g, '').trim();
        if (!primary) return 'Inter';
        return primary;
      }

      function positionFontDropdown() {
        if (!fontPickerButton) return;
        const rect = fontPickerButton.getBoundingClientRect();
        fontDropdown.style.top = '0px';
        fontDropdown.style.left = '0px';
        fontDropdown.classList.add('show');
        const dropdownRect = fontDropdown.getBoundingClientRect();
        let top = rect.bottom + 8;
        let left = rect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = rect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(rect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        fontDropdown.style.top = `${Math.max(16, top)}px`;
        fontDropdown.style.left = `${left}px`;
      }

      function showFontDropdown() {
        if (!fontPickerButton) return;
        const currentFont = getCurrentFontFamily(currentActiveElement);
        setActiveFontOption(currentFont);
        fontDropdown.classList.add('show');
        positionFontDropdown();
        isFontDropdownVisible = true;
        fontPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideFontDropdown() {
        fontDropdown.classList.remove('show');
        isFontDropdownVisible = false;
        if (fontPickerButton) {
          fontPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleFontDropdown() {
        if (isFontDropdownVisible) {
          hideFontDropdown();
        } else {
          showFontDropdown();
        }
      }

      if (fontPickerButton) {
        fontPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleFontDropdown();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target) || (fontPickerButton && fontPickerButton.contains(event.target))) {
          return;
        }
        hideFontDropdown();
      });

      window.addEventListener('resize', () => {
        if (isFontDropdownVisible) {
          positionFontDropdown();
        }
      });

      window.addEventListener('scroll', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target)) {
          return;
        }
        hideFontDropdown();
      }, true);

      let isShapeDropdownVisible = false;
      let selectedShape = null;
      let selectedImage = null;
      let selectedVideo = null;
      let selectedTable = null;
      let lastCanvasInsertPosition = null;
      const TABLE_MIN_COLUMN_WIDTH = 48;
      const tableResizeObservers = new WeakMap();
      const tableMutationObservers = new WeakMap();
      const tableColumnHoverHandlers = new WeakMap();
      let activeTableResize = null;
      let isTablePanelVisible = false;
      let tableColumnColorTarget = null;
      let tableColumnColorIndex = null;
      let tableColumnHideTimeout = null;

      function positionShapeDropdown() {
        if (!shapePickerButton) return;
        shapeDropdown.style.top = '0px';
        shapeDropdown.style.left = '0px';
        shapeDropdown.classList.add('show');
        const buttonRect = shapePickerButton.getBoundingClientRect();
        const dropdownRect = shapeDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        shapeDropdown.style.top = `${Math.max(16, top)}px`;
        shapeDropdown.style.left = `${left}px`;
      }

      function showShapeDropdown() {
        if (!shapePickerButton) return;
        positionShapeDropdown();
        isShapeDropdownVisible = true;
        shapeDropdown.classList.add('show');
        shapePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideShapeDropdown() {
        shapeDropdown.classList.remove('show');
        isShapeDropdownVisible = false;
        if (shapePickerButton) {
          shapePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleShapeDropdown() {
        if (isShapeDropdownVisible) {
          hideShapeDropdown();
        } else {
          showShapeDropdown();
        }
      }

      if (shapePickerButton) {
        shapePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleShapeDropdown();
        });
      }

      if (imagePickerButton && imageFileInput) {
        imagePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          imageFileInput.value = '';
          imageFileInput.click();
        });
        imageFileInput.addEventListener('change', (event) => {
          const { files } = event.target;
          if (!files || !files.length) return;
          const file = files[0];
          if (!file.type || !file.type.startsWith('image/')) {
            alert('Please select a valid image file.');
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            insertImageFromDataUrl(reader.result);
          };
          reader.onerror = () => {
            alert('Unable to read the selected image.');
          };
          reader.readAsDataURL(file);
        });
      }

      if (videoPickerButton && videoFileInput) {
        videoPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          videoFileInput.value = '';
          videoFileInput.click();
        });
        videoFileInput.addEventListener('change', (event) => {
          const { files } = event.target;
          if (!files || !files.length) return;
          const file = files[0];
          if (!file.type || !file.type.startsWith('video/')) {
            alert('Please select a valid video file.');
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            insertVideoFromDataUrl(reader.result);
          };
          reader.onerror = () => {
            alert('Unable to read the selected video.');
          };
          reader.readAsDataURL(file);
        });
      }

      function positionTableInsertPanel() {
        if (!tablePickerButton) return;
        tableInsertPanel.style.top = '0px';
        tableInsertPanel.style.left = '0px';
        tableInsertPanel.classList.add('show');
        const buttonRect = tablePickerButton.getBoundingClientRect();
        const panelRect = tableInsertPanel.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + panelRect.height > window.innerHeight - 16) {
          top = buttonRect.top - panelRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - panelRect.height - 16);
        }
        if (left + panelRect.width > window.innerWidth - 16) {
          left = window.innerWidth - panelRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        tableInsertPanel.style.top = `${Math.max(16, top)}px`;
        tableInsertPanel.style.left = `${left}px`;
      }

      function showTableInsertPanel() {
        if (!tablePickerButton) return;
        positionTableInsertPanel();
        isTablePanelVisible = true;
        tablePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideTableInsertPanel() {
        tableInsertPanel.classList.remove('show');
        isTablePanelVisible = false;
        if (tablePickerButton) {
          tablePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleTableInsertPanel() {
        if (isTablePanelVisible) {
          hideTableInsertPanel();
        } else {
          showTableInsertPanel();
        }
      }

      if (tablePickerButton) {
        tablePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleTableInsertPanel();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isShapeDropdownVisible) return;
        if (shapeDropdown.contains(event.target) || (shapePickerButton && shapePickerButton.contains(event.target))) {
          return;
        }
        hideShapeDropdown();
      });

      document.addEventListener('click', (event) => {
        if (!isTablePanelVisible) return;
        if (tableInsertPanel.contains(event.target) || (tablePickerButton && tablePickerButton.contains(event.target))) {
          return;
        }
        hideTableInsertPanel();
      });

      window.addEventListener('resize', () => {
        if (isShapeDropdownVisible) {
          positionShapeDropdown();
        }
        if (isTablePanelVisible) {
          positionTableInsertPanel();
        }
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget) {
          positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        }
      });

      window.addEventListener('scroll', (event) => {
        if (isShapeDropdownVisible && !shapeDropdown.contains(event.target)) {
          hideShapeDropdown();
        }
        if (isTablePanelVisible && !tableInsertPanel.contains(event.target)) {
          hideTableInsertPanel();
        }
      }, true);

      window.addEventListener('scroll', () => {
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
        if (isTablePanelVisible) {
          positionTableInsertPanel();
        }
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget) {
          positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        }
      }, true);

      function clearShapeSelection() {
        if (selectedShape) {
          selectedShape.classList.remove('selected');
          selectedShape = null;
        }
        hideShapeColorPicker();
        hideShapeSizeBadge();
        hideRotationHandle();
        activeResizeShape = null;
      }

      function clearImageSelection() {
        if (selectedImage) {
          selectedImage.classList.remove('selected');
          if (rotationTarget === selectedImage) {
            hideRotationHandle();
          }
          selectedImage = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
      }

      function clearVideoSelection() {
        if (selectedVideo) {
          selectedVideo.classList.remove('selected');
          if (rotationTarget === selectedVideo) {
            hideRotationHandle();
          }
          selectedVideo = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
      }

      function clearSelectedTableElement() {
        if (selectedTable) {
          clearTableSelection(selectedTable);
          selectedTable.classList.remove('selected');
          selectedTable = null;
        }
        if (rotationTarget && rotationTarget.classList && rotationTarget.classList.contains('table-element')) {
          hideRotationHandle();
        }
        hideTableColumnColorPicker(true);
        clearVideoSelection();
      }

      function selectShape(element) {
        if (!element || !element.classList.contains('shape-element')) return;
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        if (selectedShape && selectedShape !== element) {
          selectedShape.classList.remove('selected');
        }
        selectedShape = element;
        element.classList.add('selected');
        showShapeColorPicker(element);

        setTimeout(() => {
          document.addEventListener('click', function shapeDeselectHandler(e) {
            if (!element.contains(e.target)) {
              if (selectedShape === element) {
                clearShapeSelection();
              }
              document.removeEventListener('click', shapeDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteShape(element) {
        if (!element) return;
        if (selectedShape === element) {
          selectedShape = null;
          hideShapeColorPicker();
          hideRotationHandle();
        }
        element.remove();
        capture();
        saveEditorState('delete_shape');
        updateElementContextMenuState();
      }

      function selectImage(element) {
        if (!element || !element.classList.contains('image-element')) return;
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearShapeSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        if (selectedImage && selectedImage !== element) {
          selectedImage.classList.remove('selected');
        }
        selectedImage = element;
        element.classList.add('selected');
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        setTimeout(() => {
          document.addEventListener('click', function imageDeselectHandler(event) {
            if (!element.contains(event.target)) {
              if (selectedImage === element) {
                clearImageSelection();
              }
              document.removeEventListener('click', imageDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteImage(element, options = {}) {
        if (!element) return;
        const { skipCapture = false, skipHistory = false } = options;
        if (selectedImage === element) {
          selectedImage = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        element.remove();
        if (!skipCapture) {
          capture();
        }
        if (!skipHistory) {
          saveEditorState('delete_image');
        }
        updateElementContextMenuState();
      }

      function selectVideo(element) {
        if (!element || !element.classList.contains('video-element')) return;
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearShapeSelection();
        clearImageSelection();
        clearSelectedTableElement();
        if (selectedVideo && selectedVideo !== element) {
          selectedVideo.classList.remove('selected');
        }
        selectedVideo = element;
        element.classList.add('selected');
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        setTimeout(() => {
          document.addEventListener('click', function videoDeselectHandler(event) {
            if (!element.contains(event.target)) {
              if (selectedVideo === element) {
                clearVideoSelection();
              }
              document.removeEventListener('click', videoDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteVideo(element) {
        if (!element) return;
        if (selectedVideo === element) {
          selectedVideo = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        const video = element.querySelector('video');
        if (video) {
          video.pause();
        }
        element.remove();
        capture();
        saveEditorState('delete_video');
        updateElementContextMenuState();
      }

      function selectTableElement(element) {
        if (!element || !element.classList.contains('table-element')) return;
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearShapeSelection();
        clearImageSelection();
        if (selectedTable && selectedTable !== element) {
          clearTableSelection(selectedTable);
          selectedTable.classList.remove('selected');
          if (rotationTarget === selectedTable) {
            hideRotationHandle();
          }
        }
        selectedTable = element;
        element.classList.add('selected');
        showRotationHandle(element);
        setTimeout(() => {
          document.addEventListener('click', function tableDeselectHandler(event) {
            if (!element.contains(event.target) && event.target !== element) {
              if (selectedTable === element) {
                element.classList.remove('selected');
                selectedTable = null;
                if (rotationTarget === element) {
                  hideRotationHandle();
                }
              }
              document.removeEventListener('click', tableDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteTable(element) {
        if (!element) return;
        if (selectedTable === element) {
          selectedTable = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
        }
        if (tableColumnColorTarget === element) {
          hideTableColumnColorPicker(true);
        }
        clearTableSelection(element);
        teardownTableResizing(element);
        element.remove();
        capture();
        saveEditorState('delete_table');
        updateElementContextMenuState();
      }

      function renderShapeSvg(shape) {
        const strokeWidth = typeof shape.strokeWidth === 'number' ? shape.strokeWidth : 0;
        return `
          <svg class="shape-svg" viewBox="${shape.viewBox}" preserveAspectRatio="none">
            <g class="shape-geometry" fill="currentColor" stroke="currentColor"
               stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round">
              ${shape.svg}
            </g>
          </svg>
        `;
      }

      function createShapeElement(shape, options = {}) {
        if (!shape) return null;
        const element = document.createElement('div');
        element.className = 'shape-element';
        element.dataset.shape = shape.id;
        const minWidth = options.minWidth || shape.minWidth || 60;
        const minHeight = options.minHeight || shape.minHeight || 60;
        element.dataset.minWidth = String(minWidth);
        element.dataset.minHeight = String(minHeight);
        const color = normalizeColorHex(options.color || shape.defaultColor || '#e8f5e9');
        element.dataset.color = color;
        element.style.color = color;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? options.zIndex : 2;

        const parsedWidth = Number(options.width);
        const parsedHeight = Number(options.height);
        const width = Number.isFinite(parsedWidth) && parsedWidth > 0 ? parsedWidth : (shape.defaultWidth || 160);
        const height = Number.isFinite(parsedHeight) && parsedHeight > 0 ? parsedHeight : (shape.defaultHeight || 140);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        const innerWidth = canvas.clientWidth;
        const innerHeight = canvas.clientHeight;
        const defaultLeft = (innerWidth - width) / 2;
        const defaultTop = (innerHeight - height) / 2;
        const parsedLeft = Number(options.left);
        const parsedTop = Number(options.top);
        const left = Number.isFinite(parsedLeft) ? parsedLeft : defaultLeft;
        const top = Number.isFinite(parsedTop) ? parsedTop : defaultTop;

        const clampedLeft = Math.max(24, Math.min(left, innerWidth - width - 24));
        const clampedTop = Math.max(24, Math.min(top, innerHeight - height - 24));

        element.style.left = `${clampedLeft}px`;
        element.style.top = `${clampedTop}px`;
        const rotation = Number.isFinite(Number(options.rotation)) ? Number(options.rotation) : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = renderShapeSvg(shape);
        const svg = element.querySelector('.shape-svg');
        if (svg) {
          svg.style.width = '100%';
          svg.style.height = '100%';
        }

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectShape(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectShape(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectShape(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectShape(element);
        }

        return element;
      }

      function instantiateShape(shapeData) {
        if (!shapeData) return;
        const shape = SHAPE_OPTION_MAP.get(shapeData.shapeId) || SHAPE_OPTIONS[0];
        if (!shape) return;
        const element = createShapeElement(shape, {
          left: shapeData.left,
          top: shapeData.top,
          width: shapeData.width,
          height: shapeData.height,
          color: shapeData.color,
          zIndex: shapeData.zIndex,
          minWidth: shapeData.minWidth,
          minHeight: shapeData.minHeight,
          rotation: shapeData.rotation
        });
        if (element && shapeData.color) {
          const normalizedColor = normalizeColorHex(shapeData.color);
          element.dataset.color = normalizedColor;
          element.style.color = normalizedColor;
        }
        return element;
      }

      function insertShape(shapeId) {
        const shape = SHAPE_OPTION_MAP.get(shapeId);
        if (!shape) return;
        const element = createShapeElement(shape, { select: true });
        if (element) {
          capture();
          saveEditorState('add_shape');
        }
      }

      function createImageElement(options = {}) {
        if (!options || !options.src) return null;
        const element = document.createElement('div');
        const shouldAnimate = options.animate !== false;
        element.className = shouldAnimate ? 'image-element image-insert-animation' : 'image-element';
        const img = document.createElement('img');
        img.src = options.src;
        img.alt = options.alt || 'Slide image';
        img.draggable = false;
        element.appendChild(img);
        const aspectRatio = Number.isFinite(options.aspectRatio)
          ? options.aspectRatio
          : (() => {
              const width = Number(options.width);
              const height = Number(options.height);
              if (Number.isFinite(width) && Number.isFinite(height) && height !== 0) {
                return width / height;
              }
              return 1;
            })();
        const minWidthValue = Number.isFinite(options.minWidth) ? options.minWidth : 80;
        const minHeightValue = Number.isFinite(options.minHeight) ? options.minHeight : Math.max(60, minWidthValue / Math.max(aspectRatio, 0.01));
        element.dataset.aspectRatio = String(aspectRatio || 1);
        element.dataset.minWidth = String(minWidthValue);
        element.dataset.minHeight = String(minHeightValue);
        const rotation = Number.isFinite(options.rotation) ? options.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '4';

        const canvasRect = canvas.getBoundingClientRect();
        let width = Number(options.width);
        let height = Number(options.height);
        if (!Number.isFinite(width) || width <= 0) {
          if (Number.isFinite(height) && height > 0) {
            width = height * (aspectRatio || 1);
          } else {
            width = Math.min(canvasRect.width - 96, Math.max(240, minWidthValue));
          }
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = width / Math.max(aspectRatio || 1, 0.01);
        }
        width = Math.max(minWidthValue, width);
        height = Math.max(minHeightValue, height);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        let left = Number(options.left);
        let top = Number(options.top);
        if (!Number.isFinite(left)) {
          if (lastCanvasInsertPosition) {
            left = lastCanvasInsertPosition.x - width / 2;
          } else {
            left = (canvasRect.width - width) / 2;
          }
        }
        if (!Number.isFinite(top)) {
          if (lastCanvasInsertPosition) {
            top = lastCanvasInsertPosition.y - height / 2;
          } else {
            top = (canvasRect.height - height) / 2;
          }
        }
        const maxLeft = canvasRect.width - width - 24;
        const maxTop = canvasRect.height - height - 24;
        left = Math.max(24, Math.min(left, maxLeft));
        top = Math.max(24, Math.min(top, maxTop));
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectImage(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectImage(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectImage(element);
          showElementContextMenu(event, element);
        });

        if (shouldAnimate) {
          setTimeout(() => {
            element.classList.remove('image-insert-animation');
          }, 320);
        }

        if (options.select) {
          selectImage(element);
        }

        return element;
      }

      function instantiateImage(imageData) {
        if (!imageData || !imageData.src) return;
        createImageElement({
          src: imageData.src,
          left: imageData.left,
          top: imageData.top,
          width: imageData.width,
          height: imageData.height,
          rotation: imageData.rotation,
          minWidth: imageData.minWidth,
          minHeight: imageData.minHeight,
          aspectRatio: imageData.aspectRatio,
          zIndex: imageData.zIndex,
          animate: false
        });
      }

      function insertImageFromDataUrl(dataUrl) {
        if (!dataUrl) return;
        const tempImage = new Image();
        tempImage.onload = () => {
          const intrinsicWidth = tempImage.naturalWidth || tempImage.width || 1;
          const intrinsicHeight = tempImage.naturalHeight || tempImage.height || 1;
          const aspectRatio = intrinsicWidth / intrinsicHeight;
          const canvasRect = canvas.getBoundingClientRect();
          const maxWidth = canvasRect.width - 96;
          const maxHeight = canvasRect.height - 96;
          const scale = Math.min(1, maxWidth / intrinsicWidth, maxHeight / intrinsicHeight);
          const width = Math.max(160, intrinsicWidth * scale);
          const height = width / aspectRatio;
          const element = createImageElement({
            src: dataUrl,
            width,
            height,
            aspectRatio,
            minWidth: 80,
            minHeight: 80 / Math.max(aspectRatio, 0.01),
            select: true
          });
          if (element) {
            capture();
            saveEditorState('add_image');
          }
        };
        tempImage.onerror = () => {
          alert('Unable to load the selected image. Please try a different file.');
        };
        tempImage.src = dataUrl;
      }

      function createVideoElement(options = {}) {
        if (!options || !options.src) return null;
        const element = document.createElement('div');
        const shouldAnimate = options.animate !== false;
        element.className = shouldAnimate ? 'video-element image-insert-animation' : 'video-element';
        const video = document.createElement('video');
        video.src = options.src;
        video.setAttribute('src', options.src);
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.preload = 'metadata';
        video.controls = true;
        video.draggable = false;
        element.appendChild(video);

        const aspectRatio = Number.isFinite(options.aspectRatio)
          ? options.aspectRatio
          : (() => {
              const width = Number(options.width);
              const height = Number(options.height);
              if (Number.isFinite(width) && Number.isFinite(height) && height !== 0) {
                return width / height;
              }
              return 16 / 9;
            })();
        const minWidthValue = Number.isFinite(options.minWidth) ? options.minWidth : 160;
        const minHeightValue = Number.isFinite(options.minHeight) ? options.minHeight : Math.max(90, minWidthValue / Math.max(aspectRatio, 0.01));
        element.dataset.aspectRatio = String(aspectRatio || 1);
        element.dataset.minWidth = String(minWidthValue);
        element.dataset.minHeight = String(minHeightValue);
        const rotation = Number.isFinite(options.rotation) ? options.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '5';

        const canvasRect = canvas.getBoundingClientRect();
        let width = Number(options.width);
        let height = Number(options.height);
        if (!Number.isFinite(width) || width <= 0) {
          if (Number.isFinite(height) && height > 0) {
            width = height * (aspectRatio || 1);
          } else {
            width = Math.min(canvasRect.width - 120, Math.max(320, minWidthValue));
          }
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = width / Math.max(aspectRatio || 1, 0.01);
        }
        width = Math.max(minWidthValue, width);
        height = Math.max(minHeightValue, height);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        let left = Number(options.left);
        let top = Number(options.top);
        if (!Number.isFinite(left)) {
          if (lastCanvasInsertPosition) {
            left = lastCanvasInsertPosition.x - width / 2;
          } else {
            left = (canvasRect.width - width) / 2;
          }
        }
        if (!Number.isFinite(top)) {
          if (lastCanvasInsertPosition) {
            top = lastCanvasInsertPosition.y - height / 2;
          } else {
            top = (canvasRect.height - height) / 2;
          }
        }
        const maxLeft = canvasRect.width - width - 24;
        const maxTop = canvasRect.height - height - 24;
        left = Math.max(24, Math.min(left, maxLeft));
        top = Math.max(24, Math.min(top, maxTop));
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          if (event.target === video) return;
          event.stopPropagation();
          selectVideo(element);
        });

        element.addEventListener('click', (event) => {
          if (event.target === video) return;
          event.stopPropagation();
          selectVideo(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectVideo(element);
          showElementContextMenu(event, element);
        });

        video.addEventListener('mousedown', (event) => {
          if (event.button !== 0) return;
          selectVideo(element);
        });
        video.addEventListener('click', (event) => {
          if (event.button !== 0) return;
          selectVideo(element);
        });
        video.addEventListener('dragstart', (event) => {
          event.preventDefault();
        });

        if (shouldAnimate) {
          setTimeout(() => {
            element.classList.remove('image-insert-animation');
          }, 320);
        }

        if (options.select) {
          selectVideo(element);
        }

        return element;
      }

      function instantiateVideo(videoData) {
        if (!videoData || !videoData.src) return;
        createVideoElement({
          src: videoData.src,
          left: videoData.left,
          top: videoData.top,
          width: videoData.width,
          height: videoData.height,
          rotation: videoData.rotation,
          minWidth: videoData.minWidth,
          minHeight: videoData.minHeight,
          aspectRatio: videoData.aspectRatio,
          zIndex: videoData.zIndex,
          animate: false
        });
      }

      function insertVideoFromDataUrl(dataUrl) {
        if (!dataUrl) return;
        const tempVideo = document.createElement('video');
        tempVideo.preload = 'metadata';
        tempVideo.src = dataUrl;
        tempVideo.addEventListener('loadedmetadata', () => {
          const intrinsicWidth = tempVideo.videoWidth || 640;
          const intrinsicHeight = tempVideo.videoHeight || 360;
          const aspectRatio = intrinsicWidth / Math.max(intrinsicHeight, 0.01);
          const canvasRect = canvas.getBoundingClientRect();
          const maxWidth = canvasRect.width - 96;
          const maxHeight = canvasRect.height - 96;
          const scale = Math.min(1, maxWidth / intrinsicWidth, maxHeight / intrinsicHeight);
          const width = Math.max(240, intrinsicWidth * scale);
          const height = width / aspectRatio;
          const element = createVideoElement({
            src: dataUrl,
            width,
            height,
            aspectRatio,
            minWidth: 200,
            minHeight: 120,
            select: true
          });
          if (element) {
            capture();
            saveEditorState('add_video');
          }
        }, { once: true });
        tempVideo.addEventListener('error', () => {
          alert('Unable to load the selected video. Please try a different file.');
        }, { once: true });
      }

      function instantiateTable(tableData) {
        if (!tableData) return;
        const element = createTableElement(
          tableData.rows || 1,
          tableData.cols || 1,
          {
            width: tableData.width,
            height: tableData.height,
            left: tableData.left,
            top: tableData.top,
            html: tableData.html,
            rotation: tableData.rotation,
            minWidth: tableData.minWidth,
            minHeight: tableData.minHeight,
            zIndex: tableData.zIndex
          }
        );
        if (element) {
          element.dataset.rows = String(tableData.rows || 1);
          element.dataset.cols = String(tableData.cols || 1);
          element.dataset.minWidth = String(tableData.minWidth || 240);
          element.dataset.minHeight = String(tableData.minHeight || 160);
          element.dataset.rotation = String(Number.isFinite(tableData.rotation) ? tableData.rotation : 0);
          element.style.transform = `rotate(${parseFloat(element.dataset.rotation || '0')}deg)`;
        }
        return element;
      }

      function buildTableMarkup(rows, cols) {
        const safeRows = Math.max(1, Math.min(20, rows));
        const safeCols = Math.max(1, Math.min(20, cols));
        let html = '<table>';
        html += '<colgroup>';
        const defaultWidthPercent = 100 / safeCols;
        for (let c = 0; c < safeCols; c += 1) {
          html += `<col style="width:${defaultWidthPercent}%">`;
        }
        html += '</colgroup><tbody>';
        for (let r = 0; r < safeRows; r += 1) {
          html += '<tr>';
          for (let c = 0; c < safeCols; c += 1) {
            html += '<td contenteditable="true"></td>';
          }
          html += '</tr>';
        }
        html += '</tbody></table>';
        return html;
      }

      function setupTableCell(cell, container) {
        if (!cell) return;
        cell.contentEditable = 'true';
        cell.spellcheck = true;
        setupFontSizeTracking(cell);
        setupFontFamilyTracking(cell);
        cell.addEventListener('focus', () => {
          currentActiveElement = cell;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
          if (container) {
            selectTableElement(container);
          }
        });
        cell.addEventListener('click', (event) => {
          event.stopPropagation();
          if (container) {
            selectTableElement(container);
          }
        });
      }

      function initializeTableElement(element) {
        if (!element) return;
        const cells = element.querySelectorAll('td, th');
        cells.forEach((cell) => {
          setupTableCell(cell, element);
        });
      }

      function ensureTableColGroup(table) {
        if (!table) return [];
        const firstRow = table.rows[0];
        const columnCount = firstRow ? firstRow.cells.length : 0;
        if (!columnCount) return [];
        let colgroup = table.querySelector('colgroup');
        if (!colgroup) {
          colgroup = document.createElement('colgroup');
          table.insertBefore(colgroup, table.firstChild);
        }
        const currentCols = Array.from(colgroup.children);
        if (currentCols.length !== columnCount) {
          while (colgroup.firstChild) {
            colgroup.removeChild(colgroup.firstChild);
          }
          for (let index = 0; index < columnCount; index += 1) {
            const col = document.createElement('col');
            colgroup.appendChild(col);
          }
        }
        return Array.from(colgroup.children);
      }

      function teardownTableResizing(container) {
        if (!container) return;
        container.querySelectorAll('.table-resize-handle').forEach((handle) => handle.remove());
        const resizeObserver = tableResizeObservers.get(container);
        if (resizeObserver) {
          resizeObserver.disconnect();
          tableResizeObservers.delete(container);
        }
        const mutationObserver = tableMutationObservers.get(container);
        if (mutationObserver) {
          mutationObserver.disconnect();
          tableMutationObservers.delete(container);
        }
        unbindTableColumnHover(container);
      }

      function scheduleTableResizeUpdate(container) {
        if (!container) return;
        if (container.__tableResizePending) return;
        container.__tableResizePending = true;
        requestAnimationFrame(() => {
          container.__tableResizePending = false;
          setupTableResizing(container);
        });
      }

      function positionTableResizeHandles(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table) return;
        const handles = container.querySelectorAll('.table-resize-handle.table-resize-col');
        if (!handles.length) return;
        const containerRect = container.getBoundingClientRect();
        const tableRect = table.getBoundingClientRect();
        const rows = table.rows;
        if (!rows.length) return;
        const referenceRow = rows[0];
        const cells = referenceRow.cells;
        if (!cells.length) return;
        handles.forEach((handle) => {
          const columnIndex = parseInt(handle.dataset.col, 10);
          const cell = cells[columnIndex];
          if (!cell) return;
          const cellRect = cell.getBoundingClientRect();
          const boundaryLeft = cellRect.right - containerRect.left;
          handle.style.left = `${boundaryLeft}px`;
          handle.style.top = `${tableRect.top - containerRect.top}px`;
          handle.style.height = `${tableRect.height}px`;
        });
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget === container) {
          positionTableColumnColorPicker(container, tableColumnColorIndex);
        }
      }

      function updateAllTableResizeHandles() {
        document.querySelectorAll('.table-element').forEach((tableEl) => {
          positionTableResizeHandles(tableEl);
        });
      }

      function setupTableResizing(container) {
        if (!container) return;
        teardownTableResizing(container);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        const columnCount = rows[0].cells.length;
        if (!columnCount || columnCount < 2) return;
        ensureTableColGroup(table);
        for (let index = 0; index < columnCount - 1; index += 1) {
          const handle = document.createElement('div');
          handle.className = 'table-resize-handle table-resize-col';
          handle.dataset.col = String(index);
          handle.addEventListener('mousedown', (event) => {
            startTableColumnResize(event, container, index);
          });
          container.appendChild(handle);
        }
        positionTableResizeHandles(container);
        const resizeObserver = new ResizeObserver(() => {
          positionTableResizeHandles(container);
        });
        resizeObserver.observe(container);
        tableResizeObservers.set(container, resizeObserver);
        const mutationObserver = new MutationObserver(() => {
          scheduleTableResizeUpdate(container);
        });
        mutationObserver.observe(table, { childList: true, subtree: true });
        tableMutationObservers.set(container, mutationObserver);
        bindTableColumnHover(container);
        ensureTableSelectionHandlers(container);
      }

      function startTableColumnResize(event, container, columnIndex) {
        event.preventDefault();
        event.stopPropagation();
        hideTableColumnColorPicker(true);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        ensureTableColGroup(table);
        const colgroup = table.querySelector('colgroup');
        if (!colgroup) return;
        const columns = Array.from(colgroup.children);
        if (columns.length <= columnIndex + 1) return;
        const firstRow = rows[0];
        const widths = Array.from(firstRow.cells).map((cell, idx) => {
          const rect = cell.getBoundingClientRect();
          const width = rect.width;
          columns[idx].style.width = `${width}px`;
          return width;
        });
        activeTableResize = {
          container,
          table,
          columns,
          columnIndex,
          nextIndex: columnIndex + 1,
          initialWidths: widths,
          startX: event.clientX
        };
        container.classList.add('table-resizing');
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', handleTableResizeMove);
        document.addEventListener('mouseup', handleTableResizeEnd, { once: true });
      }

      function handleTableResizeMove(event) {
        if (!activeTableResize) return;
        const {
          container,
          columns,
          columnIndex,
          nextIndex,
          initialWidths,
          startX
        } = activeTableResize;
        const delta = event.clientX - startX;
        const currentWidth = initialWidths[columnIndex];
        const neighborWidth = initialWidths[nextIndex];
        const minDelta = TABLE_MIN_COLUMN_WIDTH - currentWidth;
        const maxDelta = neighborWidth - TABLE_MIN_COLUMN_WIDTH;
        const clampedDelta = Math.max(minDelta, Math.min(delta, maxDelta));
        const newWidth = currentWidth + clampedDelta;
        const newNeighborWidth = neighborWidth - clampedDelta;
        columns[columnIndex].style.width = `${newWidth}px`;
        columns[nextIndex].style.width = `${newNeighborWidth}px`;
        positionTableResizeHandles(container);
      }

      function handleTableResizeEnd() {
        if (!activeTableResize) return;
        document.removeEventListener('mousemove', handleTableResizeMove);
        document.body.style.cursor = '';
        const { container } = activeTableResize;
        container.classList.remove('table-resizing');
        positionTableResizeHandles(container);
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget === container) {
          positionTableColumnColorPicker(container, tableColumnColorIndex);
        }
        activeTableResize = null;
        capture();
        saveEditorState('resize_table_column');
      }

      function updateTableColumnColorButtonAppearance(color) {
        tableColumnColorButton.style.background = color;
        const hex = color.replace('#', '');
        const safeHex = hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex;
        const bigint = parseInt(safeHex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        tableColumnColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
        tableColumnColorButton.style.boxShadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
      }

      function hideTableColumnColorPicker(immediate = false) {
        if (!tableColumnColorPicker.classList.contains('visible')) return;
        const performHide = () => {
          tableColumnColorPicker.classList.remove('visible');
          tableColumnColorTarget = null;
          tableColumnColorIndex = null;
        };
        if (immediate) {
          performHide();
          return;
        }
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
        }
        tableColumnHideTimeout = setTimeout(performHide, 120);
      }

      function showTableColumnColorPicker(container, columnIndex, cell) {
        if (!container || !container.contains(cell)) return;
        tableColumnColorTarget = container;
        tableColumnColorIndex = columnIndex;
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
          tableColumnHideTimeout = null;
        }
        const computed = window.getComputedStyle(cell);
        let color = normalizeColorHex(computed.backgroundColor || cell.style.backgroundColor || '#ecfdf5');
        if (!color || color === '#000000' && computed.backgroundColor === 'rgba(0, 0, 0, 0)') {
          color = '#ecfdf5';
        }
        tableColumnColorInput.value = color;
        updateTableColumnColorButtonAppearance(color);
        tableColumnColorPicker.classList.add('visible');
        positionTableColumnColorPicker(container, columnIndex);
      }

      function positionTableColumnColorPicker(container, columnIndex) {
        if (!tableColumnColorPicker.classList.contains('visible')) return;
        if (!container || columnIndex == null) return;
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        const referenceRow = rows[0];
        const cell = referenceRow.cells[columnIndex];
        if (!cell) return;
        const cellRect = cell.getBoundingClientRect();
        const pickerRect = tableColumnColorPicker.getBoundingClientRect();
        let top = cellRect.top - pickerRect.height - 12;
        let left = cellRect.left + (cellRect.width / 2) - (pickerRect.width / 2);
        if (top < 16) {
          top = cellRect.bottom + 12;
        }
        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }
        tableColumnColorPicker.style.top = `${top}px`;
        tableColumnColorPicker.style.left = `${left}px`;
      }

      function applyColorToTableColumn(container, columnIndex, color, final = true) {
        const table = container.querySelector('table');
        if (!table) return;
        const selectedCells = getTableSelectedCells(container);
        if (selectedCells.length) {
          selectedCells.forEach((cell) => {
            cell.style.backgroundColor = color;
          });
          if (final) {
            capture();
            saveEditorState('color_table_cells');
          }
          return;
        }
        Array.from(table.rows).forEach((row) => {
          const cell = row.cells[columnIndex];
          if (cell) {
            cell.style.backgroundColor = color;
          }
        });
        if (final) {
          capture();
          saveEditorState('color_table_column');
        }
      }

      function bindTableColumnHover(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table || tableColumnHoverHandlers.has(table)) return;
        const moveHandler = (event) => {
          if (activeTableResize) return;
          const cell = event.target.closest('td, th');
          if (!cell || !container.contains(cell)) {
            hideTableColumnColorPicker(true);
            return;
          }
          const columnIndex = cell.cellIndex;
          if (columnIndex === -1) {
            hideTableColumnColorPicker(true);
            return;
          }
          showTableColumnColorPicker(container, columnIndex, cell);
        };
        const leaveHandler = () => {
          hideTableColumnColorPicker();
        };
        table.addEventListener('mousemove', moveHandler);
        table.addEventListener('mouseleave', leaveHandler);
        tableColumnHoverHandlers.set(table, { moveHandler, leaveHandler });
      }

      function unbindTableColumnHover(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table) return;
        const handlers = tableColumnHoverHandlers.get(table);
        if (!handlers) return;
        table.removeEventListener('mousemove', handlers.moveHandler);
        table.removeEventListener('mouseleave', handlers.leaveHandler);
        tableColumnHoverHandlers.delete(table);
      }

      function getCellCoordinates(cell) {
        if (!cell) return null;
        const row = cell.parentElement;
        if (!row) return null;
        const section = row.parentElement;
        if (!section) return null;
        const rowIndex = Array.prototype.indexOf.call(section.children, row);
        const colIndex = cell.cellIndex;
        return { row: rowIndex, col: colIndex };
      }

      function getTableSelectedCells(container) {
        if (!container || !container.__selectedCellsSet) return [];
        return Array.from(container.__selectedCellsSet);
      }

      function setTableSelection(container, cells) {
        if (!container) return;
        const previous = getTableSelectedCells(container);
        previous.forEach((cell) => cell.classList.remove('table-cell-selected'));
        if (!cells || !cells.length) {
          container.__selectedCellsSet = null;
          return;
        }
        const set = new Set();
        cells.forEach((cell) => {
          if (!cell) return;
          cell.classList.add('table-cell-selected');
          set.add(cell);
        });
        container.__selectedCellsSet = set;
      }

      function clearTableSelection(container) {
        setTableSelection(container, null);
      }

      function isEditingTableCell() {
        const active = document.activeElement;
        if (active && active.isContentEditable && active.closest && active.closest('.table-element')) {
          return true;
        }
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          const anchorElement = anchorNode && (anchorNode.nodeType === Node.ELEMENT_NODE ? anchorNode : anchorNode.parentElement);
          if (anchorElement && anchorElement.closest && anchorElement.closest('.table-element') && anchorElement.closest('[contenteditable="true"]')) {
            return true;
          }
        }
        return false;
      }

      function updateTableSelectionRange(container, startCoords, endCoords) {
        if (!container || !startCoords || !endCoords) return;
        const table = container.querySelector('table');
        if (!table) return;
        const minRow = Math.min(startCoords.row, endCoords.row);
        const maxRow = Math.max(startCoords.row, endCoords.row);
        const minCol = Math.min(startCoords.col, endCoords.col);
        const maxCol = Math.max(startCoords.col, endCoords.col);
        const selectedCells = [];
        Array.from(table.rows).forEach((row, rowIndex) => {
          if (rowIndex < minRow || rowIndex > maxRow) return;
          Array.from(row.cells).forEach((cell, colIndex) => {
            if (colIndex >= minCol && colIndex <= maxCol) {
              selectedCells.push(cell);
            }
          });
        });
        setTableSelection(container, selectedCells);
        if (selectedCells.length) {
          selectTableElement(container);
        }
      }

      function ensureTableSelectionHandlers(container) {
        if (!container || container.__tableSelectionBound) return;
        const table = container.querySelector('table');
        if (!table) return;
        table.addEventListener('mousedown', handleTableCellMouseDown);
        container.__tableSelectionBound = true;
      }

      const tableSelectionState = {
        isMouseDown: false,
        table: null,
        anchorCoords: null,
        startCell: null,
        startX: 0,
        startY: 0,
        hasDragged: false
      };

      function handleTableCellMouseDown(event) {
        if (event.button !== 0) return;
        const cell = event.target.closest('td, th');
        if (!cell) return;
        const container = cell.closest('.table-element');
        if (!container) return;
        tableSelectionState.isMouseDown = true;
        tableSelectionState.table = container;
        tableSelectionState.startCell = cell;
        tableSelectionState.anchorCoords = getCellCoordinates(cell);
        tableSelectionState.startX = event.clientX;
        tableSelectionState.startY = event.clientY;
        tableSelectionState.hasDragged = false;
      }

      function handleTableMouseMove(event) {
        if (!tableSelectionState.isMouseDown) return;
        const { table, startX, startY } = tableSelectionState;
        if (!table) return;
        const deltaX = Math.abs(event.clientX - startX);
        const deltaY = Math.abs(event.clientY - startY);
        const threshold = 6;
        if (!tableSelectionState.hasDragged && (deltaX > threshold || deltaY > threshold)) {
          tableSelectionState.hasDragged = true;
        }
        const hoveredElement = document.elementFromPoint(event.clientX, event.clientY);
        const cell = hoveredElement ? hoveredElement.closest('td, th') : null;
        if (!cell || !table.contains(cell)) {
          return;
        }
        const coords = getCellCoordinates(cell);
        if (!coords) return;
        if (tableSelectionState.hasDragged) {
          updateTableSelectionRange(table, tableSelectionState.anchorCoords, coords);
          const selection = window.getSelection();
          if (selection) {
            selection.removeAllRanges();
          }
        }
      }

      function handleTableMouseUp(event) {
        if (!tableSelectionState.isMouseDown) return;
        const { table, startCell, anchorCoords, hasDragged } = tableSelectionState;
        tableSelectionState.isMouseDown = false;
        tableSelectionState.table = null;
        tableSelectionState.startCell = null;
        tableSelectionState.anchorCoords = null;
        tableSelectionState.hasDragged = false;
        if (!table || !startCell) return;
        let cell = event.target.closest ? event.target.closest('td, th') : null;
        if (!cell || !table.contains(cell)) {
          cell = startCell;
        }
        const coords = getCellCoordinates(cell) || anchorCoords;
        if (!coords) return;
        if (!hasDragged) {
          updateTableSelectionRange(table, anchorCoords, coords);
        }
      }

      document.addEventListener('mousemove', handleTableMouseMove);
      document.addEventListener('mouseup', handleTableMouseUp);

      document.addEventListener('mousedown', (event) => {
        const target = event.target;
        if (!target.closest('.table-element') && !target.closest('#tableColumnColorPicker')) {
          document.querySelectorAll('.table-element').forEach((tableEl) => {
            clearTableSelection(tableEl);
          });
          clearSelectedTableElement();
          hideTableColumnColorPicker(true);
        }
        if (!target.closest('.image-element') && !target.closest('#shapeRotationHandle')) {
          clearImageSelection();
        }
        if (!target.closest('.video-element') && !target.closest('#shapeRotationHandle')) {
          clearVideoSelection();
        }
      });

      function createTableElement(rows, cols, options = {}) {
        const element = document.createElement('div');
        element.className = 'table-element';
        element.dataset.rows = String(rows);
        element.dataset.cols = String(cols);
        element.dataset.minWidth = String(options.minWidth || 240);
        element.dataset.minHeight = String(options.minHeight || 160);
        element.dataset.rotation = String(Number.isFinite(options.rotation) ? options.rotation : 0);
        element.style.transform = `rotate(${parseFloat(element.dataset.rotation || '0')}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '3';

        const defaultWidth = options.width || 360;
        const defaultHeight = options.height || 240;
        element.style.width = `${defaultWidth}px`;
        element.style.height = `${defaultHeight}px`;
        element.innerHTML = options.html || buildTableMarkup(rows, cols);

        canvas.appendChild(element);
        initializeTableElement(element);
        ensureTableSelectionHandlers(element);
        setupTableResizing(element);
        clearTableSelection(element);
        const internalTable = element.querySelector('table');
        if (internalTable) {
          const tableRows = internalTable.rows.length || rows;
          const tableCols = internalTable.rows[0] ? internalTable.rows[0].cells.length : cols;
          element.dataset.rows = String(tableRows);
          element.dataset.cols = String(tableCols);
        }

        const canvasRect = canvas.getBoundingClientRect();
        const initialLeft = options.left !== undefined ? options.left : ((canvasRect.width - defaultWidth) / 2);
        const initialTop = options.top !== undefined ? options.top : ((canvasRect.height - defaultHeight) / 2);
        const clampedLeft = Math.max(24, Math.min(initialLeft, canvasRect.width - defaultWidth - 24));
        const clampedTop = Math.max(24, Math.min(initialTop, canvasRect.height - defaultHeight - 24));
        element.style.left = `${clampedLeft}px`;
        element.style.top = `${clampedTop}px`;

        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          if (event.target.closest('td') || event.target.closest('th')) {
            return;
          }
          event.stopPropagation();
          selectTableElement(element);
        });

        element.addEventListener('click', (event) => {
          if (event.target.closest('td') || event.target.closest('th')) {
            return;
          }
          event.stopPropagation();
          selectTableElement(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTableElement(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectTableElement(element);
        }

        return element;
      }

      function insertTable(rows, cols) {
        const safeRows = Math.max(1, Math.min(12, parseInt(rows, 10) || 1));
        const safeCols = Math.max(1, Math.min(12, parseInt(cols, 10) || 1));
        const canvasRect = canvas.getBoundingClientRect();
        const defaultWidth = Math.min(canvasRect.width - 48, safeCols * 120);
        const defaultHeight = Math.min(canvasRect.height - 48, safeRows * 80);

        let left = (canvasRect.width - defaultWidth) / 2;
        let top = (canvasRect.height - defaultHeight) / 2;
        if (lastCanvasInsertPosition) {
          left = Math.max(24, Math.min(lastCanvasInsertPosition.x - defaultWidth / 2, canvasRect.width - defaultWidth - 24));
          top = Math.max(24, Math.min(lastCanvasInsertPosition.y - defaultHeight / 2, canvasRect.height - defaultHeight - 24));
        }

        const tableElement = createTableElement(safeRows, safeCols, {
          width: defaultWidth,
          height: defaultHeight,
          left,
          top,
          select: true
        });
        if (tableElement) {
          selectTableElement(tableElement);
          capture();
          saveEditorState('add_table');
        }
      }

      function handleTableInsert() {
        if (!tableRowsInput || !tableColsInput) return;
        insertTable(tableRowsInput.value, tableColsInput.value);
        hideTableInsertPanel();
      }

      if (tableInsertConfirm) {
        tableInsertConfirm.addEventListener('click', (event) => {
          event.preventDefault();
          handleTableInsert();
        });
      }

      [tableRowsInput, tableColsInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleTableInsert();
          }
        });
      });
      function collectAdditionalTextBoxesData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
          const rect = box.getBoundingClientRect();
          const computed = window.getComputedStyle(box);
          return {
            html: box.innerHTML,
            top: parseFloat(box.style.top) || rect.top - canvasRect.top,
            left: parseFloat(box.style.left) || rect.left - canvasRect.left,
            width: box.offsetWidth,
            height: box.offsetHeight,
            fontSize: box.style.fontSize || computed.fontSize,
            fontFamily: computed.fontFamily,
            display: box.style.display || '',
            rotation: parseFloat(box.dataset.rotation || '0') || 0,
            minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
            minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50),
            backgroundColor: box.style.backgroundColor || '',
            color: box.style.color || '',
            zIndex: box.style.zIndex ? parseInt(box.style.zIndex, 10) : undefined
          };
        });
      }

      function collectTablesData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.table-element')).map(element => {
          const table = element.querySelector('table');
          const rowCount = table ? table.rows.length : parseInt(element.dataset.rows || '1', 10) || 1;
          const colCount = table && table.rows[0] ? table.rows[0].cells.length : parseInt(element.dataset.cols || '1', 10) || 1;
          const rect = element.getBoundingClientRect();
          const leftStyle = parseFloat(element.style.left);
          const topStyle = parseFloat(element.style.top);
          const clone = element.cloneNode(true);
          clone.querySelectorAll('.table-resize-handle').forEach(handle => handle.remove());
          clone.querySelectorAll('.table-cell-selected').forEach(cell => cell.classList.remove('table-cell-selected'));
          const sanitizedHtml = clone.innerHTML;
          return {
            rows: rowCount,
            cols: colCount,
            html: sanitizedHtml,
            left: Number.isFinite(leftStyle) ? leftStyle : rect.left - canvasRect.left,
            top: Number.isFinite(topStyle) ? topStyle : rect.top - canvasRect.top,
            width: element.offsetWidth,
            height: element.offsetHeight,
            minWidth: parseFloat(element.dataset.minWidth || '240'),
            minHeight: parseFloat(element.dataset.minHeight || '160'),
            rotation: parseFloat(element.dataset.rotation || '0') || 0,
            zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
          };
        });
      }

      function createAdditionalTextBox(baseOptions = {}) {
        const newTextBox = document.createElement('div');
        newTextBox.className = 'text-box additional-text-box';
        newTextBox.contentEditable = true;
        newTextBox.dataset.placeholder = 'Click to add text';
        newTextBox.style.position = 'absolute';
        newTextBox.style.top = (baseOptions.top !== undefined ? baseOptions.top : (canvas.clientHeight / 2 - 100)) + 'px';
        newTextBox.style.left = (baseOptions.left !== undefined ? baseOptions.left : (canvas.clientWidth / 2 - 150)) + 'px';
        newTextBox.style.width = (baseOptions.width !== undefined ? baseOptions.width : 150) + 'px';
        newTextBox.style.height = (baseOptions.height !== undefined ? baseOptions.height : 40) + 'px';
        const minWidthValue = baseOptions.minWidth !== undefined ? baseOptions.minWidth : 80;
        const minHeightValue = baseOptions.minHeight !== undefined ? baseOptions.minHeight : 30;
        newTextBox.style.minWidth = minWidthValue + 'px';
        newTextBox.style.minHeight = minHeightValue + 'px';
        newTextBox.dataset.minWidth = String(minWidthValue);
        newTextBox.dataset.minHeight = String(minHeightValue);
        newTextBox.style.border = baseOptions.border || '1px dashed transparent';
        newTextBox.style.padding = '10px';
        newTextBox.style.outline = 'none';
        newTextBox.style.overflow = 'visible';
        newTextBox.style.display = 'flex';
        newTextBox.style.alignItems = 'center';
        newTextBox.style.justifyContent = 'flex-start';
        newTextBox.style.textAlign = 'left';
        newTextBox.style.color = baseOptions.color || '#000000';
        const backgroundColor = baseOptions.backgroundColor ?? 'transparent';
        newTextBox.style.backgroundColor = backgroundColor;
        newTextBox.style.fontSize = baseOptions.fontSize || '16px';
        newTextBox.style.fontFamily = baseOptions.fontFamily || DEFAULT_FONT_FAMILY;
        if (baseOptions.display !== undefined) {
          newTextBox.style.display = baseOptions.display;
        }
        const rotation = Number.isFinite(baseOptions.rotation) ? baseOptions.rotation : 0;
        newTextBox.dataset.rotation = String(rotation);
        newTextBox.style.transform = `rotate(${rotation}deg)`;
        if (baseOptions.zIndex !== undefined) {
          newTextBox.style.zIndex = String(baseOptions.zIndex);
        }
        if (baseOptions.html) {
          newTextBox.innerHTML = baseOptions.html;
        }
        const placeholder = newTextBox.dataset.placeholder;
        newTextBox.addEventListener('focus', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        newTextBox.addEventListener('blur', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        canvas.appendChild(newTextBox);
        createResizeEdges(newTextBox);
        makeDraggable(newTextBox);
        makeResizable(newTextBox);
        setupFontSizeTracking(newTextBox);
        setupFontFamilyTracking(newTextBox);
        elementFontSizes.set(newTextBox, parseFloat(newTextBox.style.fontSize) || 16);
        elementFontFamilies.set(newTextBox, newTextBox.style.fontFamily || DEFAULT_FONT_FAMILY);
        newTextBox.addEventListener('click', (e) => {
          if (e.target === newTextBox || !newTextBox.textContent.trim()) {
            selectTextBox(newTextBox);
          }
        });
        newTextBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(newTextBox);
          showElementContextMenu(event, newTextBox);
        });
        return newTextBox;
      }

      function instantiateAdditionalTextBox(boxData) {
        if (!boxData) return;
        createAdditionalTextBox(boxData);
      }

      function collectShapesData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.shape-element')).map(el => {
          const rect = el.getBoundingClientRect();
          const leftStyle = parseFloat(el.style.left);
          const topStyle = parseFloat(el.style.top);
          return {
            shapeId: el.dataset.shape,
            left: Number.isFinite(leftStyle) ? leftStyle : rect.left - canvasRect.left,
            top: Number.isFinite(topStyle) ? topStyle : rect.top - canvasRect.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            color: normalizeColorHex(el.dataset.color || el.style.color || '#e8f5e9'),
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined,
            minWidth: el.dataset.minWidth ? parseFloat(el.dataset.minWidth) : undefined,
            minHeight: el.dataset.minHeight ? parseFloat(el.dataset.minHeight) : undefined,
            rotation: parseFloat(el.dataset.rotation || '0') || 0
          };
        });
      }

      function collectImagesData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.image-element')).map(el => {
          const rect = el.getBoundingClientRect();
          const leftStyle = parseFloat(el.style.left);
          const topStyle = parseFloat(el.style.top);
          const img = el.querySelector('img');
          const src = img ? img.getAttribute('src') : '';
          if (!src) return null;
          const rotation = parseFloat(el.dataset.rotation || '0') || 0;
          const minWidthValue = parseFloat(el.dataset.minWidth || '80');
          const minHeightValue = parseFloat(el.dataset.minHeight || '60');
          const aspectRatioValue = parseFloat(el.dataset.aspectRatio || (el.offsetWidth / Math.max(el.offsetHeight, 0.01)));
          return {
            src,
            left: Number.isFinite(leftStyle) ? leftStyle : rect.left - canvasRect.left,
            top: Number.isFinite(topStyle) ? topStyle : rect.top - canvasRect.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation,
            minWidth: minWidthValue,
            minHeight: minHeightValue,
            aspectRatio: aspectRatioValue,
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        }).filter(Boolean);
      }

      function collectVideosData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.video-element')).map(el => {
          const rect = el.getBoundingClientRect();
          const leftStyle = parseFloat(el.style.left);
          const topStyle = parseFloat(el.style.top);
          const video = el.querySelector('video');
          const src = video ? video.getAttribute('src') : '';
          if (!src) return null;
          const rotation = parseFloat(el.dataset.rotation || '0') || 0;
          const minWidthValue = parseFloat(el.dataset.minWidth || '160');
          const minHeightValue = parseFloat(el.dataset.minHeight || '90');
          const aspectRatioValue = parseFloat(el.dataset.aspectRatio || (el.offsetWidth / Math.max(el.offsetHeight, 0.01)));
          return {
            src,
            left: Number.isFinite(leftStyle) ? leftStyle : rect.left - canvasRect.left,
            top: Number.isFinite(topStyle) ? topStyle : rect.top - canvasRect.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation,
            minWidth: minWidthValue,
            minHeight: minHeightValue,
            aspectRatio: aspectRatioValue,
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        }).filter(Boolean);
      }
      
      // Template Background Detection and Application
      (function() {
        // Get template from query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const templateParam = urlParams.get('template');
        
        // Also check sessionStorage for backward compatibility
        const templateFromStorage = sessionStorage.getItem('selectedTemplate');
        const templateName = templateParam || templateFromStorage;
        
        if (templateName) {
          // Map template names to CSS classes
          const templateMap = {
            'marketing': 'marketing-template',
            'business': 'business-template',
            'education': 'education-template',
            'project': 'project-template',
            'business-pro': 'business-template',
            'creative-bold': 'marketing-template',
            'corporate-clean': 'business-template'
          };
          
          const templateClass = templateMap[templateName.toLowerCase()];
          
          if (templateClass) {
            // Remove any existing template classes
            canvas.classList.remove('marketing-template', 'business-template', 'education-template', 'project-template');
            
            // Add the new template class
            canvas.classList.add(templateClass);
          }
        }
      })();
      
      // Track selected text box for keyboard deletion
      let selectedTextBox = null;
      
      // Undo/Redo history stack
      let actionHistory = [];
      let redoStack = [];
      const MAX_HISTORY = 50; // Limit history size
      
      // Save current editor state to history
      function saveEditorState(action) {
        const state = {
          action: action,
          timestamp: Date.now(),
          slides: JSON.parse(JSON.stringify(slides)), // Deep copy
          active: active,
          canvasState: {
            titleBoxVisible: titleBox.style.display !== 'none',
            textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
              const rect = box.getBoundingClientRect();
              const canvasRect = canvas.getBoundingClientRect();
              return {
                element: box,
                html: box.innerHTML,
                style: {
                  top: rect.top - canvasRect.top,
                  left: rect.left - canvasRect.left,
                  width: box.offsetWidth,
                  height: box.offsetHeight,
                  fontSize: box.style.fontSize,
                  fontFamily: window.getComputedStyle(box).fontFamily,
                display: box.style.display,
                rotation: parseFloat(box.dataset.rotation || '0') || 0
                }
              };
            }),
            shapes: collectShapesData(),
            tables: collectTablesData(),
            images: collectImagesData(),
            videos: collectVideosData()
          }
        };
        
        actionHistory.push(state);
        
        // Limit history size
        if (actionHistory.length > MAX_HISTORY) {
          actionHistory.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update undo button state
        updateUndoButton();
      }
      
      // Restore editor state from history
      function restoreEditorState(state) {
        // Restore slides data
        slides.length = 0;
        slides.push(...JSON.parse(JSON.stringify(state.slides)));
        active = state.active;
        
        // Restore title and text box visibility
        if (state.canvasState) {
          titleBox.style.display = state.canvasState.titleBoxVisible ? '' : 'none';
          textBox.style.display = state.canvasState.textBoxVisible ? '' : 'none';
        }
        
        // Restore slide content
        load();
        renderSidebar();
        
        // Restore additional text boxes
        if (state.canvasState && state.canvasState.additionalTextBoxes) {
          // Remove existing additional text boxes
          document.querySelectorAll('.additional-text-box').forEach(box => {
            if (!state.canvasState.additionalTextBoxes.some(saved => saved.element === box)) {
              box.remove();
            }
          });
          
          // Restore saved additional text boxes
          state.canvasState.additionalTextBoxes.forEach(savedBox => {
            let existingBox = null;
            if (savedBox.element && document.contains(savedBox.element)) {
              existingBox = savedBox.element;
            } else {
              // Create new box if it doesn't exist
              existingBox = document.createElement('div');
              existingBox.className = 'text-box additional-text-box';
              existingBox.contentEditable = true;
              existingBox.dataset.placeholder = 'Click to add text';
              canvas.appendChild(existingBox);
              
              // Setup the new box
              createResizeEdges(existingBox);
              makeDraggable(existingBox);
              makeResizable(existingBox);
              setupFontSizeTracking(existingBox);
              setupFontFamilyTracking(existingBox);
              elementFontSizes.set(existingBox, parseFloat(savedBox.style.fontSize) || 16);
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily || DEFAULT_FONT_FAMILY);
              
              // Add selection handler
              existingBox.addEventListener('click', (e) => {
                if (e.target === existingBox || !existingBox.textContent.trim()) {
                  selectTextBox(existingBox);
                }
              });
            }
            
            // Restore content and style
            existingBox.innerHTML = savedBox.html;
            existingBox.style.top = savedBox.style.top + 'px';
            existingBox.style.left = savedBox.style.left + 'px';
            existingBox.style.width = savedBox.style.width + 'px';
            existingBox.style.height = savedBox.style.height + 'px';
            existingBox.style.fontSize = savedBox.style.fontSize;
            if (savedBox.style.fontFamily) {
              existingBox.style.fontFamily = savedBox.style.fontFamily;
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily);
            }
            existingBox.style.display = savedBox.style.display || '';
            const savedRotation = Number.isFinite(savedBox.style.rotation) ? savedBox.style.rotation : 0;
            existingBox.dataset.rotation = String(savedRotation);
            existingBox.style.transform = `rotate(${savedRotation}deg)`;
            const savedMinWidth = Number.isFinite(savedBox.style.minWidth) ? savedBox.style.minWidth : 200;
            const savedMinHeight = Number.isFinite(savedBox.style.minHeight) ? savedBox.style.minHeight : 50;
            existingBox.dataset.minWidth = String(savedMinWidth);
            existingBox.dataset.minHeight = String(savedMinHeight);
          });
        }

        if (state.canvasState && state.canvasState.shapes) {
          document.querySelectorAll('.shape-element').forEach(shapeEl => shapeEl.remove());
          state.canvasState.shapes.forEach(shapeData => instantiateShape(shapeData));
        }
        if (state.canvasState && state.canvasState.tables) {
          document.querySelectorAll('.table-element').forEach(tableEl => tableEl.remove());
          state.canvasState.tables.forEach(tableData => instantiateTable(tableData));
        }
        document.querySelectorAll('.image-element').forEach(imageEl => imageEl.remove());
        if (state.canvasState && state.canvasState.images) {
          state.canvasState.images.forEach(imageData => instantiateImage(imageData));
        }
        document.querySelectorAll('.video-element').forEach(videoEl => {
          const vid = videoEl.querySelector('video');
          if (vid) vid.pause();
          videoEl.remove();
        });
        if (state.canvasState && state.canvasState.videos) {
          state.canvasState.videos.forEach(videoData => instantiateVideo(videoData));
        }
        
        updateUndoButton();
        updateSlideCanvasMenuState();
      }
      
      // Undo last action
      function undoLastAction() {
        if (actionHistory.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const rect = box.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: rect.top - canvasRect.top,
                    left: rect.left - canvasRect.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                  display: box.style.display,
                  rotation: parseFloat(box.dataset.rotation || '0') || 0,
                  minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                  minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData(),
              tables: collectTablesData(),
              images: collectImagesData(),
              videos: collectVideosData()
            }
          };
          
          // Save current state to redo stack
          redoStack.push(currentState);
          
          // Get previous state from history
          const previousState = actionHistory.pop();
          restoreEditorState(previousState);
        }
      }
      
      // Update undo/redo button states
      function updateUndoButton() {
        const backBtn = document.getElementById('btnBack');
        const forwardBtn = document.getElementById('btnForward');
        if (backBtn) {
          backBtn.disabled = actionHistory.length === 0;
          backBtn.style.opacity = actionHistory.length === 0 ? '0.5' : '1';
        }
        if (forwardBtn) {
          forwardBtn.disabled = redoStack.length === 0;
          forwardBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
        }
      }
      
      // Initialize with initial state
      saveEditorState('initial');

      function clearSlideDragIndicators() {
        sidebar.querySelectorAll('.slide-preview.drop-target, .slide-preview.drop-target-before, .slide-preview.drop-target-after').forEach(preview => {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        });
      }

      function handleSlideDragStart(event) {
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        slideDragSourceIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(slideDragSourceIndex)) {
          slideDragSourceIndex = null;
          return;
        }
        item.classList.add('dragging');
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(slideDragSourceIndex));
        }
      }

      function handleSlideDragOver(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const preview = item.querySelector('.slide-preview');
        if (!preview) return;
        clearSlideDragIndicators();
        preview.classList.add('drop-target');
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        if (isAfter) {
          preview.classList.add('drop-target-after');
          preview.classList.remove('drop-target-before');
        } else {
          preview.classList.add('drop-target-before');
          preview.classList.remove('drop-target-after');
        }
        item.dataset.dropPosition = isAfter ? 'after' : 'before';
      }

      function handleSlideDragLeave(event) {
        const item = event.currentTarget;
        if (!item) return;
        const preview = item.querySelector('.slide-preview');
        if (preview) {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        }
        delete item.dataset.dropPosition;
      }

      function finalizeSlideReorder(fromIndex, insertIndex) {
        if (fromIndex === null || insertIndex === null) return;
        if (fromIndex < 0 || fromIndex >= slides.length) return;
        if (insertIndex < 0) insertIndex = 0;
        if (insertIndex > slides.length) insertIndex = slides.length;
        if (insertIndex === fromIndex || insertIndex === fromIndex + 1) return;

        capture();

        const [movedSlide] = slides.splice(fromIndex, 1);
        let adjustedInsertIndex = insertIndex;
        if (insertIndex > fromIndex) {
          adjustedInsertIndex = insertIndex - 1;
        }
        if (adjustedInsertIndex < 0) adjustedInsertIndex = 0;
        slides.splice(adjustedInsertIndex, 0, movedSlide);

        let newActive = active;
        if (fromIndex === active) {
          newActive = adjustedInsertIndex;
        } else {
          if (fromIndex < active) {
            newActive -= 1;
          }
          if (adjustedInsertIndex <= newActive) {
            newActive += 1;
          }
        }
        active = Math.max(0, Math.min(slides.length - 1, newActive));
        load();
        renderSidebar();
        saveEditorState('reorder_slides');
      }

      function handleSlideDrop(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const targetIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(targetIndex)) return;
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        const insertIndex = targetIndex + (isAfter ? 1 : 0);
        clearSlideDragIndicators();
        delete item.dataset.dropPosition;
        finalizeSlideReorder(slideDragSourceIndex, insertIndex);
      }

      function handleSlideDragEnd(event) {
        const item = event.currentTarget;
        if (item) {
          item.classList.remove('dragging');
          delete item.dataset.dropPosition;
        }
        clearSlideDragIndicators();
        slideDragSourceIndex = null;
      }

      function selectEditableText(element) {
        const range = document.createRange();
        range.selectNodeContents(element);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function refreshSidebarSoon() {
        requestAnimationFrame(() => renderSidebar());
      }

      function moveSlideByOffset(index, offset) {
        if (!Number.isInteger(index) || !Number.isInteger(offset)) return;
        const targetIndex = index + offset;
        if (targetIndex < 0 || targetIndex >= slides.length) return;
        finalizeSlideReorder(index, targetIndex + (offset > 0 ? 1 : 0));
      }

      function applySlideTransitionClass(element, transition) {
        if (!element) return;
        const normalized = typeof transition === 'string' ? transition : DEFAULT_TRANSITION;
        TRANSITION_CLASS_NAMES.forEach(cls => element.classList.remove(cls));
        void element.offsetWidth;
        if (!isPresenting) return;
        if (normalized && normalized !== 'none') {
          element.classList.add(`transition-effect-${normalized}`);
        }
      }

      function getTransitionLabel(type) {
        const option = TRANSITION_OPTIONS.find(opt => opt.value === type) || TRANSITION_OPTIONS[0];
        return option.label;
      }

      function getTransitionIconHtml(type) {
        const normalized = (type || DEFAULT_TRANSITION);
        switch (normalized) {
          case 'fade':
            return '<i class="fas fa-water"></i>';
          case 'slide':
            return '<i class="fas fa-arrow-right"></i>';
          case 'zoom':
            return '<i class="fas fa-search-plus"></i>';
          case 'flip':
            return '<i class="fas fa-sync-alt"></i>';
          case 'rotate':
            return '<i class="fas fa-sync"></i>';
          case 'push':
            return '<i class="fas fa-long-arrow-alt-right"></i>';
          case 'wipe':
            return '<i class="fas fa-align-left"></i>';
          case 'spin':
            return '<i class="fas fa-circle-notch"></i>';
          case 'dissolve':
            return '<i class="fas fa-braille"></i>';
          case 'cube':
            return '<i class="fas fa-dice-d6"></i>';
          case 'bounce':
            return '<i class="fas fa-arrow-down"></i>';
          case 'swirl':
            return '<i class="fas fa-asterisk"></i>';
          case 'none':
          default:
            return `
              <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="15" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.8"/>
                <rect x="11" y="9" width="10" height="8" rx="1.6" ry="1.6" fill="none" stroke="currentColor" stroke-width="1.6"/>
                <path d="M3 8h15M3 11h7M3 14h7" stroke="currentColor" stroke-width="1.2" />
              </svg>
            `;
        }
      }

      function updateTransitionButtonAppearance(button, slideIndex) {
        if (!button) return;
        const slide = slides[slideIndex];
        const transitionValue = slide ? (slide.transition || DEFAULT_TRANSITION) : DEFAULT_TRANSITION;
        const iconHtml = getTransitionIconHtml(transitionValue);
        button.innerHTML = `<span class="transition-icon">${iconHtml}</span><span class="transition-caret"><i class="fas fa-caret-down"></i></span>`;
        const targetSlideNumber = slideIndex === slides.length - 1 ? 'End' : `Slide ${slideIndex + 2}`;
        const label = getTransitionLabel(transitionValue);
        button.title = `Transition (${label}) â†’ ${targetSlideNumber}`;
        button.setAttribute('aria-label', button.title);
      }

      function hideSlideContextMenu() {
        if (!slideContextMenu || !slideContextMenu.classList.contains('show')) {
          slideContextMenuTarget = null;
          slideContextMenuTitle = null;
          slideContextMenuIndex = null;
          return;
        }
        slideContextMenu.classList.remove('show');
        slideContextMenu.style.top = '';
        slideContextMenu.style.left = '';
        slideContextMenuTarget = null;
        slideContextMenuTitle = null;
        slideContextMenuIndex = null;
      }

      function showSlideContextMenu(event, index, titleElement, slideItem) {
        if (!slideContextMenu || !titleElement || !slideItem) return;
        event.preventDefault();
        hideSlideCanvasContextMenu();
        slideContextMenuIndex = index;
        slideContextMenuTitle = titleElement;
        slideContextMenuTarget = slideItem;

        slideContextMenu.classList.add('show');
        const menuRect = slideContextMenu.getBoundingClientRect();
        const padding = 8;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        top = Math.max(padding, top);
        left = Math.max(padding, left);
        slideContextMenu.style.top = `${top}px`;
        slideContextMenu.style.left = `${left}px`;
      }

      function hideSlideTransitionMenu() {
        if (!slideTransitionMenu || !slideTransitionMenu.classList.contains('show')) {
          slideTransitionMenuIndex = null;
          slideTransitionMenuAnchor = null;
          return;
        }
        slideTransitionMenu.classList.remove('show');
        slideTransitionMenu.style.top = '';
        slideTransitionMenu.style.left = '';
        slideTransitionMenuIndex = null;
        slideTransitionMenuAnchor = null;
      }

      function showSlideTransitionMenu(event, index, anchorElement) {
        if (!slideTransitionMenu || !anchorElement) return;
        event.preventDefault();
        event.stopPropagation();
        hideSlideCanvasContextMenu();
        slideTransitionMenuIndex = index;
        slideTransitionMenuAnchor = anchorElement;
        slideTransitionMenu.classList.add('show');
        const buttons = slideTransitionMenu.querySelectorAll('button');
        const currentTransition = (slides[index] && slides[index].transition) || DEFAULT_TRANSITION;
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.transition === currentTransition);
        });
        const menuRect = slideTransitionMenu.getBoundingClientRect();
        const anchorRect = anchorElement.getBoundingClientRect();
        const padding = 8;
        let top = anchorRect.top + window.scrollY - menuRect.height - 6;
        let left = anchorRect.left + window.scrollX - menuRect.width / 2 + anchorRect.width / 2;
        if (top < padding) {
          top = anchorRect.bottom + window.scrollY + 6;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        if (left < padding) {
          left = padding;
        }
        slideTransitionMenu.style.top = `${top}px`;
        slideTransitionMenu.style.left = `${left}px`;
      }

      if (slideContextRenameBtn) {
        slideContextRenameBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const titleElement = slideContextMenuTitle;
          const slideIndex = slideContextMenuIndex;
          const slideItem = slideContextMenuTarget;
          hideSlideContextMenu();
          if (titleElement && slideItem && Number.isInteger(slideIndex)) {
            startSlideTitleEditing(titleElement, slideIndex, slideItem);
          }
        });
      }

      if (slideTransitionMenu) {
        slideTransitionMenu.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (slideTransitionMenuIndex === null) {
              hideSlideTransitionMenu();
              return;
            }
            const value = btn.dataset.transition || DEFAULT_TRANSITION;
            const slide = slides[slideTransitionMenuIndex];
            hideSlideTransitionMenu();
            if (!slide) return;
            slide.transition = value;
            capture();
            slide.transition = value;
            if (slideTransitionMenuIndex === active) {
              applySlideTransitionClass(canvas, value);
            }
            if (slideTransitionMenuAnchor) {
              updateTransitionButtonAppearance(slideTransitionMenuAnchor, slideTransitionMenuIndex);
            }
            saveEditorState('change_transition');
            refreshSidebarSoon();
          });
        });
      }

      document.addEventListener('click', (event) => {
        if (slideContextMenu && slideContextMenu.classList.contains('show') && !slideContextMenu.contains(event.target)) {
          hideSlideContextMenu();
        }
        if (slideTransitionMenu && slideTransitionMenu.classList.contains('show') && !slideTransitionMenu.contains(event.target)) {
          hideSlideTransitionMenu();
        }
      });

      window.addEventListener('resize', hideSlideContextMenu);
      window.addEventListener('scroll', hideSlideContextMenu, true);
      window.addEventListener('resize', hideSlideTransitionMenu);
      window.addEventListener('scroll', hideSlideTransitionMenu, true);

      function startSlideTitleEditing(titleElement, slideIndex, slideItem) {
        if (!titleElement) return;
        const originalTitle = titleElement.textContent.trim();
        titleElement.contentEditable = 'true';
        titleElement.classList.add('editing');
        titleElement.focus({ preventScroll: true });
        selectEditableText(titleElement);
        if (slideItem) {
          slideItem.setAttribute('draggable', 'false');
        }

        function cleanup() {
          titleElement.contentEditable = 'false';
          titleElement.classList.remove('editing');
          if (slideItem) {
            slideItem.setAttribute('draggable', 'true');
          }
          titleElement.removeEventListener('blur', handleBlur);
          titleElement.removeEventListener('keydown', handleKeyDown);
        }

        function applyTitleChange(shouldPersist) {
          const trimmed = titleElement.textContent.trim();
          const fallback = originalTitle || slides[slideIndex].title || `Slide ${slideIndex + 1}`;
          const finalTitle = shouldPersist ? (trimmed || fallback) : fallback;
          cleanup();
          titleElement.textContent = finalTitle;
          if (shouldPersist && finalTitle !== originalTitle) {
            slides[slideIndex].title = finalTitle;
            if (slideIndex === active && titleBox.style.display !== 'none') {
              titleBox.textContent = finalTitle;
            }
            capture();
            saveEditorState('rename_slide');
          }
          refreshSidebarSoon();
        }

        function handleBlur() {
          applyTitleChange(true);
        }

        function handleKeyDown(event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            applyTitleChange(true);
          } else if (event.key === 'Escape') {
            event.preventDefault();
            titleElement.textContent = originalTitle;
            applyTitleChange(false);
          }
        }

        titleElement.addEventListener('blur', handleBlur);
        titleElement.addEventListener('keydown', handleKeyDown);
      }

      function renderSidebar() {
        hideSlideContextMenu();
        hideSlideTransitionMenu();
        hideSlideTransitionMenu();
        sidebar.innerHTML = '';
        slides.forEach((s, i) => {
          // Create slide-item container
          const slideItem = document.createElement('div');
          slideItem.className = 'slide-item';
          slideItem.dataset.index = String(i);
          slideItem.setAttribute('draggable', 'true');
          
        // Create slide preview
        const el = document.createElement('div');
        el.className = 'slide-preview' + (i === active ? ' active' : '');
        el.setAttribute('draggable', 'false');

        const titleSpan = document.createElement('span');
        titleSpan.className = 'slide-preview-title';
        titleSpan.textContent = s.title || `Slide ${i + 1}`;
        el.appendChild(titleSpan);

        el.addEventListener('click', () => {
          capture();
          active = i;
          load();
          renderSidebar();
        });

        titleSpan.addEventListener('click', (event) => {
          if (titleSpan.isContentEditable) {
            event.stopPropagation();
          }
        });

        titleSpan.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          startSlideTitleEditing(titleSpan, i, slideItem);
        });

        titleSpan.addEventListener('dragstart', (event) => {
          if (titleSpan.isContentEditable) {
            event.preventDefault();
          }
        });
          
          // Create slide action bar container
          const slideActionBar = document.createElement('div');
          slideActionBar.className = 'slide-action-bar';
          
          // New Slide button with icon
          const newSlideBtn = document.createElement('button');
          newSlideBtn.className = 'new-slide';
          newSlideBtn.title = 'New Slide';
          newSlideBtn.innerHTML = '<i class="fas fa-plus"></i>';
          newSlideBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            createNewSlide(i);
          });
          
          // Duplicate button with icon
          const duplicateBtn = document.createElement('button');
          duplicateBtn.className = 'duplicate-slide';
          duplicateBtn.title = 'Duplicate';
          duplicateBtn.innerHTML = '<i class="fas fa-copy"></i>';
          duplicateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            duplicateCurrentSlide(i);
          });

          const moveUpBtn = document.createElement('button');
          moveUpBtn.className = 'move-slide-up';
          moveUpBtn.title = 'Move Up';
          moveUpBtn.innerHTML = '<i class="fas fa-arrow-up"></i>';
          moveUpBtn.disabled = i === 0;
          moveUpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            moveSlideByOffset(i, -1);
          });

          const moveDownBtn = document.createElement('button');
          moveDownBtn.className = 'move-slide-down';
          moveDownBtn.title = 'Move Down';
          moveDownBtn.innerHTML = '<i class="fas fa-arrow-down"></i>';
          moveDownBtn.disabled = i === slides.length - 1;
          moveDownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            moveSlideByOffset(i, 1);
          });
          
          slideActionBar.appendChild(newSlideBtn);
          slideActionBar.appendChild(duplicateBtn);
          slideActionBar.appendChild(moveUpBtn);
        const transitionButton = document.createElement('button');
        transitionButton.type = 'button';
        transitionButton.className = 'transition-control-button';
        transitionButton.setAttribute('data-slide-index', String(i));
        updateTransitionButtonAppearance(transitionButton, i);
        transitionButton.addEventListener('click', (event) => {
          hideSlideContextMenu();
          event.preventDefault();
          event.stopPropagation();
          showSlideTransitionMenu(event, i, transitionButton);
        });
        
        slideActionBar.appendChild(moveDownBtn);
        slideActionBar.appendChild(transitionButton);
        
        slideItem.appendChild(el);
        slideItem.appendChild(slideActionBar);

        slideItem.addEventListener('dragstart', handleSlideDragStart);
        slideItem.addEventListener('dragenter', (event) => {
          if (slideDragSourceIndex !== null) {
            event.preventDefault();
          }
        });
        slideItem.addEventListener('dragover', handleSlideDragOver);
        slideItem.addEventListener('dragleave', handleSlideDragLeave);
        slideItem.addEventListener('drop', handleSlideDrop);
        slideItem.addEventListener('dragend', handleSlideDragEnd);
        slideItem.addEventListener('contextmenu', (event) => {
          hideSlideTransitionMenu();
          showSlideContextMenu(event, i, titleSpan, slideItem);
        });
          
          sidebar.appendChild(slideItem);

        });
      }

      function createResizeEdges(element) {
        // Remove existing edges
        element.querySelectorAll('.resize-edge').forEach(el => el.remove());
        
        const isShapeLike = element.classList && (
          element.classList.contains('shape-element') ||
          element.classList.contains('text-box') ||
          element.classList.contains('title-box') ||
          element.classList.contains('additional-text-box') ||
          element.classList.contains('table-element')
        );
        const isImageElement = element.classList && element.classList.contains('image-element');
        const isVideoElement = element.classList && element.classList.contains('video-element');
        let edges;
        if (isImageElement) {
          edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        } else if (isVideoElement) {
          edges = ['bottom-right'];
        } else if (isShapeLike) {
          edges = ['top', 'bottom', 'left', 'right', 'bottom-right'];
        } else {
          edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        }
        edges.forEach(edge => {
          const edgeEl = document.createElement('div');
          edgeEl.className = `resize-edge ${edge}`;
          edgeEl.dataset.edge = edge;
          if (isImageElement) {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          } else if (isVideoElement) {
            edgeEl.classList.add('corner');
          } else if (isShapeLike) {
            edgeEl.classList.add(edge === 'bottom-right' ? 'corner' : 'side');
          } else {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          }
          element.appendChild(edgeEl);
        });
      }

      function load() {
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        closeImageCropper();
        const slide = slides[active];
        const backgroundConfig = slide && slide.background ? slide.background : { image: '', size: '', position: '', repeat: '' };
        canvas.style.backgroundImage = backgroundConfig.image || '';
        canvas.style.backgroundSize = backgroundConfig.size || '';
        canvas.style.backgroundPosition = backgroundConfig.position || '';
        canvas.style.backgroundRepeat = backgroundConfig.repeat || '';
        const titleFont = slide.titleFontFamily || DEFAULT_FONT_FAMILY;
        const textFont = slide.textFontFamily || DEFAULT_FONT_FAMILY;
        elementFontFamilies.set(titleBox, titleFont);
        elementFontFamilies.set(textBox, textFont);
        titleBox.style.fontFamily = titleFont;
        textBox.style.fontFamily = textFont;

        const titleBoxData = slide.titleBox || {};
        const textBoxData = slide.textBox || {};
        const showTitleBox = titleBoxData.visible !== undefined ? titleBoxData.visible : true;
        if (showTitleBox) {
          titleBox.style.display = '';
          titleBox.textContent = slide.title || '';
          if (slide.titleBox) {
            titleBox.style.top = slide.titleBox.top + 'px';
            titleBox.style.left = slide.titleBox.left + 'px';
            if (slide.titleBox.width) {
              titleBox.style.width = slide.titleBox.width + 'px';
              titleBox.style.right = 'auto';
            }
            if (slide.titleBox.height) {
              titleBox.style.height = slide.titleBox.height + 'px';
            }
            const titleRotation = Number.isFinite(slide.titleBox.rotation) ? slide.titleBox.rotation : 0;
            titleBox.dataset.rotation = String(titleRotation);
            titleBox.style.transform = `rotate(${titleRotation}deg)`;
          }
        } else {
          titleBox.style.display = 'none';
          titleBox.textContent = '';
        }

        const showTextBox = textBoxData.visible !== undefined ? textBoxData.visible : true;
        if (showTextBox) {
          textBox.style.display = '';
          textBox.textContent = slide.content || '';
          if (slide.textBox) {
            textBox.style.top = slide.textBox.top + 'px';
            textBox.style.left = slide.textBox.left + 'px';
            if (slide.textBox.width) {
              textBox.style.width = slide.textBox.width + 'px';
              textBox.style.right = 'auto';
            }
            if (slide.textBox.height) {
              textBox.style.height = slide.textBox.height + 'px';
              textBox.style.bottom = 'auto';
            }
            const textRotation = Number.isFinite(slide.textBox.rotation) ? slide.textBox.rotation : 0;
            textBox.dataset.rotation = String(textRotation);
            textBox.style.transform = `rotate(${textRotation}deg)`;
          }
        } else {
          textBox.style.display = 'none';
          textBox.textContent = '';
        }

        if (!slide.titleBox) {
          titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
        }
        if (!slide.textBox) {
          textBox.dataset.rotation = textBox.dataset.rotation || '0';
        }

        // Create resize edges
        createResizeEdges(titleBox);
        createResizeEdges(textBox);

        document.querySelectorAll('.additional-text-box').forEach(el => el.remove());
        if (!Array.isArray(slide.additionalTextBoxes)) {
          slide.additionalTextBoxes = [];
        }
        slide.additionalTextBoxes.forEach(textBoxData => instantiateAdditionalTextBox(textBoxData));

        document.querySelectorAll('.shape-element').forEach(el => el.remove());
        document.querySelectorAll('.table-element').forEach(el => el.remove());
        document.querySelectorAll('.image-element').forEach(el => el.remove());
        document.querySelectorAll('.video-element').forEach(el => {
          const video = el.querySelector('video');
          if (video) {
            video.pause();
          }
          el.remove();
        });
        selectedShape = null;
        selectedImage = null;
        selectedVideo = null;
        selectedTable = null;
        hideShapeColorPicker();
        hideRotationHandle();
        if (!Array.isArray(slide.shapes)) {
          slide.shapes = [];
        }
        slide.shapes.forEach(shapeData => instantiateShape(shapeData));
        if (!Array.isArray(slide.tables)) {
          slide.tables = [];
        }
        slide.tables.forEach(tableData => instantiateTable(tableData));
        if (!Array.isArray(slide.images)) {
          slide.images = [];
        }
        slide.images.forEach(imageData => instantiateImage(imageData));

        updateFontPickerSelectedFont();
        const transitionValue = slide.transition || DEFAULT_TRANSITION;
        slide.transition = transitionValue;
        if (!isPresenting) {
          TRANSITION_CLASS_NAMES.forEach(cls => canvas.classList.remove(cls));
        }
      }

      function capture() {
        const slide = slides[active];
        if (!slide) return;
        const titleVisible = titleBox.style.display !== 'none';
        const textVisible = textBox.style.display !== 'none';
        if (titleVisible) {
          slide.title = titleBox.textContent.trim();
        }
        if (textVisible) {
          slide.content = textBox.textContent.trim();
        }
        
        // Save positions and sizes
        const titleRect = titleBox.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        slide.titleBox = {
          top: titleRect.top - canvasRect.top,
          left: titleRect.left - canvasRect.left,
          width: titleBox.offsetWidth,
          height: titleBox.offsetHeight,
          visible: titleVisible,
          rotation: parseFloat(titleBox.dataset.rotation || '0') || 0
        };
        
        const textRect = textBox.getBoundingClientRect();
        slide.textBox = {
          top: textRect.top - canvasRect.top,
          left: textRect.left - canvasRect.left,
          width: textBox.offsetWidth,
          height: textBox.offsetHeight,
          visible: textVisible,
          rotation: parseFloat(textBox.dataset.rotation || '0') || 0
        };

        slide.titleFontFamily = getCurrentFontFamily(titleBox);
        slide.textFontFamily = getCurrentFontFamily(textBox);
        slide.additionalTextBoxes = collectAdditionalTextBoxesData();
        slide.shapes = collectShapesData();
        slide.tables = collectTablesData();
        slide.images = collectImagesData();
        slide.videos = collectVideosData();
      }

      // Drag functionality - only when clicking on empty space
      function makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;
        let dragThreshold = 5;
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        
        element.addEventListener('mousedown', (e) => {
          if (element.classList.contains('table-element') && (e.target.closest('td') || e.target.closest('th'))) {
            return;
          }
          // Don't drag if clicking on resize edge
          if (e.target.classList && e.target.classList.contains('resize-edge')) {
            return;
          }
          
          // Don't drag if clicking on text content
          if (e.target !== element && e.target.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          
          // Only drag if clicking on empty space or border area
          const selection = window.getSelection();
          if (selection.toString().length > 0) {
            return;
          }
          
          // Check if element is empty or clicking on border
          const isEmpty = !element.textContent.trim() || element.textContent.trim() === element.dataset.placeholder;
          const isBorderClick = e.target === element || (e.target === element && element.contains(e.target));
          
          if (!isEmpty && !isBorderClick) {
            return; // Allow text editing
          }
          
          const rect = element.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          startX = e.clientX;
          startY = e.clientY;
          initialLeft = rect.left - canvasRect.left;
          initialTop = rect.top - canvasRect.top;
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
        });
        
        document.addEventListener('mousemove', (e) => {
          if (startX === undefined || startY === undefined) return;
          
          const deltaX = Math.abs(e.clientX - startX);
          const deltaY = Math.abs(e.clientY - startY);
          
          if (!isDragging && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            isDragging = true;
            element.classList.add('dragging');
            if (hadEditableAttr || wasContentEditable) {
              element.setAttribute('contenteditable', 'false');
            }
          }
          
          if (!isDragging) return;
          
          const canvasRect = canvas.getBoundingClientRect();
          const moveX = e.clientX - startX;
          const moveY = e.clientY - startY;
          
          let newLeft = initialLeft + moveX;
          let newTop = initialTop + moveY;
          
          const maxLeft = canvasRect.width - element.offsetWidth - 48;
          const maxTop = canvasRect.height - element.offsetHeight - 48;
          
          newLeft = Math.max(24, Math.min(newLeft, maxLeft));
          newTop = Math.max(24, Math.min(newTop, maxTop));
          
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          capture();
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
              element.setAttribute('contenteditable', 'true');
            }
            capture();
            // Save state for undo after dragging
            saveEditorState('move_element');
          }
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        });
      }
      
      // Resize functionality using edges
      function makeResizable(element) {
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        let resizeEdge = '';
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        let minWidth = 200;
        let minHeight = 50;
        let aspectRatio = 1;
        
        element.addEventListener('mousedown', (e) => {
          if (!e.target.classList.contains('resize-edge')) return;
          
          resizeEdge = e.target.dataset.edge;
          isResizing = true;
          element.classList.add('resizing');
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
          if (hadEditableAttr || wasContentEditable) {
            element.setAttribute('contenteditable', 'false');
          }
          
          const rect = element.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          startX = e.clientX;
          startY = e.clientY;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
          startLeft = rect.left - canvasRect.left;
          startTop = rect.top - canvasRect.top;
          minWidth = parseFloat(element.dataset.minWidth) || 200;
          minHeight = parseFloat(element.dataset.minHeight) || 50;
          aspectRatio = startWidth / startHeight || 1;
        const isShape = element.classList.contains('shape-element');
        const isImage = element.classList.contains('image-element');
        const isVideo = element.classList.contains('video-element');
        const isTable = element.classList.contains('table-element');
        const isTextBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        if (isImage && selectedImage !== element) {
          selectImage(element);
        }
        if (isVideo && selectedVideo !== element) {
          selectVideo(element);
        }
        if (isShape || isTextBox || isTable || isImage || isVideo) {
          activeResizeShape = element;
          updateShapeSizeBadge(element, startWidth, startHeight);
          showShapeSizeBadge();
        }
          
          e.preventDefault();
          e.stopPropagation();
        });
        
        document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const canvasRect = canvas.getBoundingClientRect();
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        const isShape = element.classList.contains('shape-element');
        const isImage = element.classList.contains('image-element');
        const isVideo = element.classList.contains('video-element');
        const isTable = element.classList.contains('table-element');
        const isShapeLike = isShape || isTable || isImage || isVideo || element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        
        if (isImage || isVideo) {
          const bounds = {
            left: 24,
            top: 24,
            right: canvasRect.width - 24,
            bottom: canvasRect.height - 24
          };
          const isCornerHandle = ['top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeEdge);
          const storedAspect = parseFloat(element.dataset.aspectRatio || '0');
          const aspect = storedAspect > 0 ? storedAspect : (startWidth / Math.max(startHeight, 0.01));
          
          if (resizeEdge.includes('right')) {
            const maxWidth = bounds.right - startLeft;
            newWidth = Math.max(minWidth, Math.min(startWidth + deltaX, maxWidth));
          }
          if (resizeEdge.includes('left')) {
            const proposedLeft = startLeft + deltaX;
            const maxLeft = startLeft + startWidth - minWidth;
            newLeft = Math.max(bounds.left, Math.min(proposedLeft, maxLeft));
            newWidth = Math.max(minWidth, startWidth + (startLeft - newLeft));
          }
          if (resizeEdge.includes('bottom')) {
            const maxHeight = bounds.bottom - startTop;
            newHeight = Math.max(minHeight, Math.min(startHeight + deltaY, maxHeight));
          }
          if (resizeEdge.includes('top')) {
            const proposedTop = startTop + deltaY;
            const maxTop = startTop + startHeight - minHeight;
            newTop = Math.max(bounds.top, Math.min(proposedTop, maxTop));
            newHeight = Math.max(minHeight, startHeight + (startTop - newTop));
          }
          
          if (!resizeEdge.includes('left') && !resizeEdge.includes('right')) {
            newLeft = startLeft;
          }
          if (!resizeEdge.includes('top') && !resizeEdge.includes('bottom')) {
            newTop = startTop;
          }
          
          if (!isCornerHandle) {
            if (resizeEdge === 'left' || resizeEdge === 'right') {
              newHeight = startHeight;
              newTop = startTop;
            }
            if (resizeEdge === 'top' || resizeEdge === 'bottom') {
              newWidth = startWidth;
              newLeft = startLeft;
            }
          } else {
            const clampedAspect = Math.max(aspect, 0.01);
            const widthDelta = Math.abs(newWidth - startWidth);
            const heightDelta = Math.abs(newHeight - startHeight);
            if (widthDelta >= heightDelta) {
              newHeight = newWidth / clampedAspect;
              if (resizeEdge.includes('top')) {
                newTop = startTop + (startHeight - newHeight);
              }
            } else {
              newWidth = newHeight * clampedAspect;
              if (resizeEdge.includes('left')) {
                newLeft = startLeft + (startWidth - newWidth);
              }
            }
            
            if (newLeft < bounds.left) {
              const overflow = bounds.left - newLeft;
              newLeft = bounds.left;
              newWidth = Math.max(minWidth, newWidth - overflow);
            }
            if (newTop < bounds.top) {
              const overflow = bounds.top - newTop;
              newTop = bounds.top;
              newHeight = Math.max(minHeight, newHeight - overflow);
            }
            if (newLeft + newWidth > bounds.right) {
              const overflow = (newLeft + newWidth) - bounds.right;
              if (resizeEdge.includes('left')) {
                newLeft = Math.max(bounds.left, newLeft - overflow);
              } else {
                newWidth = Math.max(minWidth, newWidth - overflow);
              }
            }
            if (newTop + newHeight > bounds.bottom) {
              const overflow = (newTop + newHeight) - bounds.bottom;
              if (resizeEdge.includes('top')) {
                newTop = Math.max(bounds.top, newTop - overflow);
              } else {
                newHeight = Math.max(minHeight, newHeight - overflow);
              }
            }
          }
          
          newWidth = Math.max(minWidth, Math.min(newWidth, bounds.right - newLeft));
          newHeight = Math.max(minHeight, Math.min(newHeight, bounds.bottom - newTop));
          
          element.style.width = `${newWidth}px`;
          element.style.height = `${newHeight}px`;
          element.style.left = `${newLeft}px`;
          element.style.top = `${newTop}px`;
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          element.dataset.aspectRatio = String(newWidth / Math.max(newHeight, 0.01));
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else if (isShapeLike) {
          const minScale = Math.max(minWidth / startWidth, minHeight / startHeight);
          const bounds = {
            left: 24,
            top: 24,
            right: canvasRect.width - 24,
            bottom: canvasRect.height - 24
          };
          
          if (resizeEdge === 'bottom-right') {
            const centerX = startLeft + startWidth / 2;
            const centerY = startTop + startHeight / 2;
            let widthCandidate = Math.max(minWidth, startWidth + deltaX);
            let heightCandidate = Math.max(minHeight, startHeight + deltaY);
            let scale = Math.max(widthCandidate / startWidth, heightCandidate / startHeight);
            scale = Math.max(scale, minScale);
            newWidth = startWidth * scale;
            newHeight = startHeight * scale;
            newLeft = centerX - newWidth / 2;
            newTop = centerY - newHeight / 2;
          } else if (resizeEdge === 'left') {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(bounds.left, startLeft + deltaX);
            if (newLeft === bounds.left) {
              newWidth = startLeft + startWidth - bounds.left;
            }
          } else if (resizeEdge === 'right') {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, bounds.right - startLeft);
          } else if (resizeEdge === 'top') {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(bounds.top, startTop + deltaY);
            if (newTop === bounds.top) {
              newHeight = startTop + startHeight - bounds.top;
            }
          } else if (resizeEdge === 'bottom') {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, bounds.bottom - startTop);
          }
          
          newWidth = Math.max(newWidth, minWidth);
          newHeight = Math.max(newHeight, minHeight);
          if (resizeEdge === 'bottom-right') {
            if (newLeft < bounds.left) newLeft = bounds.left;
            if (newTop < bounds.top) newTop = bounds.top;
            if (newLeft + newWidth > bounds.right) newLeft = bounds.right - newWidth;
            if (newTop + newHeight > bounds.bottom) newTop = bounds.bottom - newHeight;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else {
          if (resizeEdge.includes('right')) {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, canvasRect.width - newLeft - 48);
          }
          if (resizeEdge.includes('left')) {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(24, startLeft + deltaX);
            if (newLeft === 24) newWidth = startLeft + startWidth - 24;
          }
          if (resizeEdge.includes('bottom')) {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, canvasRect.height - newTop - 48);
          }
          if (resizeEdge.includes('top')) {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(24, startTop + deltaY);
            if (newTop === 24) newHeight = startTop + startHeight - 24;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
        }
          
        capture();
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        });
        
        document.addEventListener('mouseup', () => {
          if (isResizing) {
            isResizing = false;
            element.classList.remove('resizing');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
              element.setAttribute('contenteditable', 'true');
            }
            resizeEdge = '';
            capture();
            // Save state for undo after resizing
            saveEditorState('resize_element');
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        if (shapeSizeBadge.classList.contains('visible')) {
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        });
      }
      
      // Make boxes draggable and resizable
      makeDraggable(titleBox);
      makeDraggable(textBox);
      makeResizable(titleBox);
      makeResizable(textBox);
      
      // Initialize resize edges
      createResizeEdges(titleBox);
      createResizeEdges(textBox);
      
      // Add selection handlers for title and text boxes
      titleBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === titleBox || !titleBox.textContent.trim()) {
          selectTextBox(titleBox);
        }
      });
      
      textBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === textBox || !textBox.textContent.trim()) {
          selectTextBox(textBox);
        }
      });

      // Toolbar interactions per Editor.json
      function getActiveElement() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
        return document.activeElement === titleBox ? titleBox : textBox;
      }

      function addTextBoxAtCanvasPosition(canvasX, canvasY) {
        if (!canvas) return null;
        const canvasRect = canvas.getBoundingClientRect();
        const defaultWidth = 150;
        const defaultHeight = 40;
        const margin = 24;
        const clampPosition = (value, elementSize, canvasSize) => {
          const maxWithMargin = canvasSize - elementSize - margin;
          if (maxWithMargin <= margin) {
            return Math.max(0, Math.min(value, canvasSize - elementSize));
          }
          return Math.max(margin, Math.min(value, maxWithMargin));
        };
        let left = canvasX - defaultWidth / 2;
        let top = canvasY - defaultHeight / 2;
        left = clampPosition(left, defaultWidth, canvasRect.width);
        top = clampPosition(top, defaultHeight, canvasRect.height);
        const newTextBox = createAdditionalTextBox({
          top,
          left,
          width: defaultWidth,
          height: defaultHeight,
          fontSize: '16px',
          fontFamily: DEFAULT_FONT_FAMILY,
          color: '#000000'
        });
        if (!newTextBox) return null;
        lastCanvasInsertPosition = {
          x: left + defaultWidth / 2,
          y: top + defaultHeight / 2
        };
        selectTextBox(newTextBox);
        requestAnimationFrame(() => {
          if (!document.contains(newTextBox)) {
            return;
          }
          try {
            newTextBox.focus({ preventScroll: true });
          } catch (error) {
            newTextBox.focus();
          }
          const selection = window.getSelection();
          if (!selection) return;
          const range = document.createRange();
          range.selectNodeContents(newTextBox);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        });
        capture();
        saveEditorState('add_textbox');
        return newTextBox;
      }

      // Add Text Box functionality
      function addTextBox() {
        if (!canvas) return;
        const canvasRect = canvas.getBoundingClientRect();
        addTextBoxAtCanvasPosition(canvasRect.width / 2, canvasRect.height / 2);
      }
      
      // Function to select/deselect text boxes
      function selectTextBox(element) {
        // Can select any text box or title box
        if (!element || (!element.classList.contains('text-box') && element.id !== 'titleBox')) {
          return;
        }
        clearShapeSelection();
        clearImageSelection();
        clearVideoSelection();
        
        // Deselect all other boxes
        document.querySelectorAll('.text-box.selected, .title-box.selected').forEach(box => {
          box.classList.remove('selected');
        });
        
        // Select this box
        element.classList.add('selected');
        createResizeEdges(element);
        selectedTextBox = element;
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        
        // Deselect when clicking elsewhere
        setTimeout(() => {
          document.addEventListener('click', function deselectHandler(e) {
            if (!element.contains(e.target) && e.target !== element) {
              element.classList.remove('selected');
              selectedTextBox = null;
              if (rotationTarget === element) {
                hideRotationHandle();
              }
              document.removeEventListener('click', deselectHandler);
            }
          }, { once: true });
        }, 150);
      }
      
      // Function to delete text box
      function deleteTextBox(element) {
        if (!element) return;
        
        // Handle title box deletion - hide it instead of removing
        if (element.id === 'titleBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          capture();
          updateElementContextMenuState();
          return;
        }
        
        // Handle main text box deletion - hide it instead of removing
        if (element.id === 'textBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = titleBox;
            updateFontSizeInput();
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          capture();
          updateElementContextMenuState();
          return;
        }
        
        // Handle additional text boxes - remove completely
        if (element.classList.contains('additional-text-box')) {
          // Remove from font size tracking
          elementFontSizes.delete(element);
          // Remove selection
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          // Remove from DOM
          element.remove();
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = textBox;
            updateFontSizeInput();
          }
          capture();
          updateElementContextMenuState();
        }
      }
      
      // Global keyboard listener for Delete/Backspace and Undo
      document.addEventListener('keydown', (e) => {
        if (!isPresenting && slideTransitionMenu && slideTransitionMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideTransitionMenu();
          return;
        }
        if (!isPresenting && slideContextMenu && slideContextMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideContextMenu();
          return;
        }
        if (!isPresenting && saveAsMenu && saveAsMenu.classList.contains('show') && e.key === 'Escape') {
          hideSaveAsMenu();
          return;
        }
        if (isPresenting) {
          if (e.key === 'Escape') {
            e.preventDefault();
            exitPresentation();
            return;
          }
          if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') {
            e.preventDefault();
            goToNextSlide();
            return;
          }
          if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            e.preventDefault();
            goToPreviousSlide();
            return;
          }
          return;
        }
        const selection = window.getSelection();
        const editingTableCell = isEditingTableCell();

        // Undo keyboard shortcut (Cmd+Z on Mac, Ctrl+Z on Windows)
        if (!editingTableCell && (e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undoLastAction();
          return;
        }
        
        // Redo keyboard shortcut (Cmd+Shift+Z on Mac, Ctrl+Shift+Z on Windows)
        if (!editingTableCell && (e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          redoLastAction();
          return;
        }
        
        // Only handle Delete/Backspace if a text box is selected
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
          // Check if user is typing (cursor is inside the text box)
          const isTyping = selection.rangeCount > 0 && 
                          selection.getRangeAt(0).startOffset !== selection.getRangeAt(0).endOffset;
          
          // Only delete if not typing (no text selection) or if box is empty
          const isEmpty = !selectedTextBox.textContent.trim();
          const hasTextSelection = selection.toString().length > 0;
          
          if (!hasTextSelection || isEmpty) {
            e.preventDefault();
            e.stopPropagation();
            deleteTextBox(selectedTextBox);
            saveEditorState('delete_textbox');
          }
        }

        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedShape) {
          e.preventDefault();
          e.stopPropagation();
          deleteShape(selectedShape);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedImage) {
          e.preventDefault();
          e.stopPropagation();
          deleteImage(selectedImage);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedVideo) {
          e.preventDefault();
          e.stopPropagation();
          deleteVideo(selectedVideo);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedTable) {
          e.preventDefault();
          e.stopPropagation();
          deleteTable(selectedTable);
        }
      });
      
      // Back (Undo) button click handler
      document.getElementById('btnBack').addEventListener('click', () => {
        undoLastAction();
      });
      
      // Forward (Redo) button click handler
      document.getElementById('btnForward').addEventListener('click', () => {
        redoLastAction();
      });
      
      // Redo functionality
      function redoLastAction() {
        if (redoStack.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const rect = box.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: rect.top - canvasRect.top,
                    left: rect.left - canvasRect.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                    display: box.style.display,
                    rotation: parseFloat(box.dataset.rotation || '0') || 0,
                    minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                    minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData(),
              tables: collectTablesData(),
              images: collectImagesData(),
              videos: collectVideosData()
            }
          };
          
          // Save current state to undo stack
          actionHistory.push(currentState);
          
          // Get next state from redo stack
          const nextState = redoStack.pop();
          restoreEditorState(nextState);
        }
      }
      
      // Formatting tools
      document.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const action = btn.getAttribute('data-action');
          
          // Handle addTextBox action
          if (action === 'addTextBox') {
            addTextBox();
            return;
          }
          if (action === 'present') {
            startPresentation();
            return;
          }
          
          const activeEl = getActiveElement();
          
          // Focus on the active element if needed
          if (activeEl === titleBox || activeEl === textBox || titleBox.contains(activeEl) || textBox.contains(activeEl)) {
            if (titleBox.contains(activeEl) || activeEl === titleBox) {
              titleBox.focus();
            } else {
              textBox.focus();
            }
          }

          // Execute command
          if (action === 'bold') document.execCommand('bold', false);
          else if (action === 'italic') document.execCommand('italic', false);
          else if (action === 'underline') document.execCommand('underline', false);
          else if (action === 'strikeThrough') document.execCommand('strikeThrough', false);
          else if (action === 'superscript') document.execCommand('superscript', false);
          else if (action === 'subscript') document.execCommand('subscript', false);
          else if (action === 'justifyLeft') document.execCommand('justifyLeft', false);
          else if (action === 'justifyCenter') document.execCommand('justifyCenter', false);
          else if (action === 'justifyRight') document.execCommand('justifyRight', false);
          else if (action === 'justifyFull') document.execCommand('justifyFull', false);
          else if (action === 'insertUnorderedList') document.execCommand('insertUnorderedList', false);
          else if (action === 'insertOrderedList') document.execCommand('insertOrderedList', false);
        });
      });

      // Store font sizes for elements
      let titleFontSize = 28;
      let textFontSize = 16;
      let elementFontSizes = new Map(); // Store font sizes for dynamically created elements
      let elementFontFamilies = new Map();
      let currentActiveElement = textBox;

      // Initialize default font sizes
      titleBox.style.fontSize = titleFontSize + 'px';
      textBox.style.fontSize = textFontSize + 'px';
      elementFontSizes.set(titleBox, titleFontSize);
      elementFontSizes.set(textBox, textFontSize);
      titleBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      textBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      elementFontFamilies.set(titleBox, DEFAULT_FONT_FAMILY);
      elementFontFamilies.set(textBox, DEFAULT_FONT_FAMILY);

      // Function to get current font size from an element
      function getCurrentFontSize(element) {
        if (elementFontSizes.has(element)) {
          return elementFontSizes.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseFloat(computedStyle.fontSize);
        return Math.round(fontSize);
      }

      function getCurrentFontFamily(element) {
        if (!element) return DEFAULT_FONT_FAMILY;
        if (elementFontFamilies.has(element)) {
          return elementFontFamilies.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        return computedStyle.fontFamily || DEFAULT_FONT_FAMILY;
      }

      // Function to apply font size to an element
      function applyFontSize(element, size) {
        const selection = window.getSelection();
        
        // If there's selected text in the element, apply font size to selection
        if (selection.rangeCount > 0 && !selection.isCollapsed && 
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = size + 'px';
          
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
          } catch (e) {
            document.execCommand("fontSize", false, "7");
            setTimeout(() => {
              const fonts = element.getElementsByTagName("font");
              for (let i = fonts.length - 1; i >= 0; i--) {
                if (fonts[i].size === "7") {
                  const newSpan = document.createElement('span');
                  newSpan.style.fontSize = size + 'px';
                  newSpan.innerHTML = fonts[i].innerHTML;
                  fonts[i].parentNode.replaceChild(newSpan, fonts[i]);
                }
              }
            }, 10);
          }
        } else {
          // No selection - apply font size to the entire element
          element.style.fontSize = size + 'px';
          
          // Wrap existing text nodes in spans to preserve formatting
          const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
          const textNodes = [];
          let node;
          while (node = walker.nextNode()) {
            const parent = node.parentElement;
            if (!parent || !parent.style.fontSize) {
              textNodes.push(node);
            }
          }
          
          textNodes.forEach(textNode => {
            if (textNode.textContent.trim()) {
              const span = document.createElement('span');
              span.style.fontSize = size + 'px';
              span.textContent = textNode.textContent;
              textNode.parentNode.replaceChild(span, textNode);
            }
          });
        }
        
        // Store the font size for this element
        elementFontSizes.set(element, size);
      }

      function applyFontFamily(element, family) {
        const selection = window.getSelection();
        const normalizedFamily = family || DEFAULT_FONT_FAMILY;

        if (selection.rangeCount > 0 && !selection.isCollapsed &&
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          document.execCommand('fontName', false, normalizedFamily);
        } else {
          element.style.fontFamily = normalizedFamily;
        }

        elementFontFamilies.set(element, normalizedFamily);
      }

      // Update font size input when focus changes
      function updateFontSizeInput() {
        const fontSizeInput = document.getElementById('fontSize');
        if (currentActiveElement) {
          const currentSize = getCurrentFontSize(currentActiveElement);
          fontSizeInput.value = currentSize;
        }
      }

      function updateFontPickerSelectedFont() {
        if (!fontPickerButton || !fontPickerLabel) return;
        const fontFamily = getCurrentFontFamily(currentActiveElement);
        const normalized = normalizeFontStack(fontFamily);
        const name = fontStackToName.get(normalized) || extractPrimaryFontName(fontFamily);
        fontPickerButton.style.fontFamily = fontFamily;
        fontPickerLabel.style.fontFamily = fontFamily;
        fontPickerLabel.textContent = name;
        fontPickerButton.setAttribute('title', `Font Family: ${name}`);
        fontPickerButton.setAttribute('aria-label', `Font Family: ${name}`);
        setActiveFontOption(fontFamily);
      }

      // Track focus changes for any contenteditable element
      function setupFontSizeTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
        });
        
        // Initialize font size if not set
        if (!elementFontSizes.has(element)) {
          const currentSize = parseFloat(window.getComputedStyle(element).fontSize) || 16;
          elementFontSizes.set(element, Math.round(currentSize));
        }
      }

      function setupFontFamilyTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          if (!elementFontFamilies.has(element)) {
            elementFontFamilies.set(element, getCurrentFontFamily(element));
          }
          updateFontPickerSelectedFont();
        });

        if (!elementFontFamilies.has(element)) {
          elementFontFamilies.set(element, getCurrentFontFamily(element));
        }
      }

      function applyFontFamilyToCurrent(fontFamily) {
        if (!currentActiveElement) {
          currentActiveElement = textBox;
        }
        applyFontFamily(currentActiveElement, fontFamily);
        updateFontPickerSelectedFont();
        capture();
        saveEditorState('change_font_family');
      }

      // Track focus changes for existing elements
      setupFontSizeTracking(titleBox);
      setupFontSizeTracking(textBox);
      setupFontFamilyTracking(titleBox);
      setupFontFamilyTracking(textBox);

      // Also check on selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          
          // Find which contenteditable element contains the selection
          let activeEl = null;
          if (titleBox.contains(anchorNode) || anchorNode === titleBox) {
            activeEl = titleBox;
          } else if (textBox.contains(anchorNode) || anchorNode === textBox) {
            activeEl = textBox;
          } else {
            // Check additional text boxes
            const allTextBoxes = document.querySelectorAll('.additional-text-box, .text-box');
            allTextBoxes.forEach(box => {
              if (box.contains(anchorNode) || anchorNode === box) {
                activeEl = box;
              }
            });
          }
          
          if (activeEl && currentActiveElement !== activeEl) {
            currentActiveElement = activeEl;
            updateFontSizeInput();
            updateFontPickerSelectedFont();
          }
        }
      });

      // Font size input change handler
      const fontSizeInput = document.getElementById('fontSize');
      fontSizeInput.addEventListener('change', (e) => {
        const size = parseInt(e.target.value);
        if (!isNaN(size) && size >= 8 && size <= 72 && currentActiveElement) {
          applyFontSize(currentActiveElement, size);
          
          // Update stored sizes for title and main text box
          if (currentActiveElement === titleBox) {
            titleFontSize = size;
          } else if (currentActiveElement === textBox) {
            textFontSize = size;
          }
        }
      });
      
      // Validate input on blur
      fontSizeInput.addEventListener('blur', (e) => {
        if (!currentActiveElement) return;
        
        const size = parseInt(e.target.value);
        const currentSize = getCurrentFontSize(currentActiveElement);
        
        if (isNaN(size) || size < 8) {
          e.target.value = currentSize;
        } else if (size > 72) {
          e.target.value = 72;
          applyFontSize(currentActiveElement, 72);
          
          // Update stored sizes
          if (currentActiveElement === titleBox) {
            titleFontSize = 72;
          } else if (currentActiveElement === textBox) {
            textFontSize = 72;
          }
        }
      });

      // Initialize the input value
      updateFontSizeInput();
      updateFontPickerSelectedFont();

      function attachColorInputHandlers() {
        const fontColorInput = document.getElementById('fontColor');
        const highlightColorInput = document.getElementById('highlightColor');

        if (!fontColorInput || !highlightColorInput) {
          requestAnimationFrame(attachColorInputHandlers);
          return;
        }

        if (!fontColorInput.dataset.bound) {
          fontColorInput.addEventListener('change', (e) => {
            document.execCommand('foreColor', false, e.target.value);
          });
          fontColorInput.dataset.bound = 'true';
        }

        if (!highlightColorInput.dataset.bound) {
          highlightColorInput.addEventListener('change', (e) => {
            document.execCommand('backColor', false, e.target.value);
          });
          highlightColorInput.dataset.bound = 'true';
        }
      }
      attachColorInputHandlers();

      document.addEventListener('apply-text-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#000000';
        document.execCommand('foreColor', false, color);
      });

      document.addEventListener('apply-bg-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#ffff00';
        const targetTable = selectedTable && getTableSelectedCells(selectedTable).length
          ? selectedTable
          : null;
        if (targetTable) {
          const cells = getTableSelectedCells(targetTable);
          if (cells.length) {
            const normalized = normalizeColorHex(color);
            cells.forEach((cell) => {
              cell.style.backgroundColor = normalized;
            });
            capture();
            saveEditorState('color_table_cells');
            return;
          }
        }
        document.execCommand('backColor', false, color);
      });

      // Save function per Editor.json and auth_system.json
      function savePresentation() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        if (!currentUser) {
          if (isGuest) {
            alert('Please sign in to save presentations. Guests can only view and edit.');
            return;
          }
          alert('Please log in to save presentations.');
          window.location.href = './templates.html';
          return;
        }

        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.textContent.trim() || "";
        
        // Save to user-specific key per auth_system.json
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        saved.push({
          title: title,
          date: new Date().toISOString().split("T")[0],
          content: content
        });
        
        localStorage.setItem(userKey, JSON.stringify(saved));
        
        // Show notification animation
        showNotification('Presentation saved!');
      }

      // Topbar button actions per slides.json
      document.getElementById('btnDel').addEventListener('click', () => {
        deleteSlide(active);
      });

      document.getElementById('btnReset').addEventListener('click', () => {
        if (confirm('Reset all slides? This cannot be undone.')) {
          saveEditorState('reset_slides');
          slides.splice(0, slides.length, { 
            title: '', 
            content: '',
            titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
            textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
            titleFontFamily: DEFAULT_FONT_STACK,
            textFontFamily: DEFAULT_FONT_STACK,
            shapes: [],
            additionalTextBoxes: [],
          tables: [],
          images: [],
          videos: [],
        transition: DEFAULT_TRANSITION,
        background: { image: '', size: '', position: '', repeat: '' }
          });
          active = 0;
          load();
          renderSidebar();
          updateSlideCanvasMenuState();
        }
      });

      document.getElementById('btnSave').addEventListener('click', savePresentation);

      document.getElementById('btnHome').addEventListener('click', () => {
        capture();
        window.location.href = './templates.html';
      });

      // Hover button functions per Editor.json slidePreview
      function createNewSlide(index) {
        capture();
        saveEditorState('create_slide');
        slides.splice(index + 1, 0, { 
          title: '', 
          content: '',
          titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
          textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
          titleFontFamily: DEFAULT_FONT_STACK,
          textFontFamily: DEFAULT_FONT_STACK,
          shapes: [],
          additionalTextBoxes: [],
          tables: [],
          images: [],
          videos: [],
        transition: DEFAULT_TRANSITION,
        background: { image: '', size: '', position: '', repeat: '' }
        });
        active = index + 1;
        load();
        renderSidebar();
        updateSlideCanvasMenuState();
      }

      function duplicateCurrentSlide(index) {
        capture();
        saveEditorState('duplicate_slide');
        const s = slides[index];
        slides.splice(index + 1, 0, { 
          title: s.title ? `${s.title} copy` : '',
          content: s.content,
          titleBox: s.titleBox ? {...s.titleBox} : { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
          textBox: s.textBox ? {...s.textBox} : { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
          titleFontFamily: s.titleFontFamily || DEFAULT_FONT_STACK,
          textFontFamily: s.textFontFamily || DEFAULT_FONT_STACK,
          shapes: s.shapes ? JSON.parse(JSON.stringify(s.shapes)) : [],
          additionalTextBoxes: s.additionalTextBoxes ? JSON.parse(JSON.stringify(s.additionalTextBoxes)) : [],
        tables: s.tables ? JSON.parse(JSON.stringify(s.tables)) : [],
        images: s.images ? JSON.parse(JSON.stringify(s.images)) : [],
        videos: s.videos ? JSON.parse(JSON.stringify(s.videos)) : [],
        transition: s.transition || DEFAULT_TRANSITION,
        background: s.background ? { ...s.background } : { image: '', size: '', position: '', repeat: '' }
        });
        active = index + 1;
        load();
        renderSidebar();
        updateSlideCanvasMenuState();
      }

      // Auto-save on input with debounce for undo
      let textEditTimeout;
      function saveTextEditState() {
        clearTimeout(textEditTimeout);
        textEditTimeout = setTimeout(() => {
          saveEditorState('edit_text');
        }, 1000); // Save state 1 second after typing stops
      }
      
      titleBox.addEventListener('input', () => {
        if (titleBox.style.display === 'none') return;
        slides[active].title = titleBox.textContent.trim();
        renderSidebar();
        saveTextEditState();
      });
      textBox.addEventListener('input', () => {
        if (textBox.style.display === 'none') return;
        slides[active].content = textBox.textContent.trim();
        saveTextEditState();
      });
      
      // Also track input on additional text boxes
      document.addEventListener('input', (e) => {
        if (e.target.classList && e.target.classList.contains('additional-text-box')) {
          saveTextEditState();
        }
      });

      // Check if loading a saved presentation from Recent section
      const loadPres = sessionStorage.getItem('loadPresentation');
      if (loadPres) {
        try {
          const pres = JSON.parse(loadPres);
          // Set the title and content from saved presentation
          slides[0].title = pres.title || slides[0].title || '';
          slides[0].content = pres.content || '';
          sessionStorage.removeItem('loadPresentation'); // Clear after loading
        } catch (e) {
          console.error('Error loading presentation:', e);
        }
      }

      // Load and apply saved background color from settings
      const savedBg = localStorage.getItem('siteBackgroundColor');
      if (savedBg) {
        if (savedBg === '#000000') {
          document.body.classList.add('dark-theme');
          document.body.style.background = '';
          document.body.style.color = '';
        } else if (savedBg === '#ffffff') {
          document.body.classList.add('light-mode');
          document.body.style.background = '';
          document.body.style.color = '';
        } else {
          document.body.style.background = savedBg;
        }
      }

      // Listen for background color updates from settings page
      window.addEventListener('message', (e) => {
        if (e.data.type === 'updateBackground') {
          const color = e.data.color;
          document.body.classList.remove('dark-theme', 'light-mode');
          
          if (color === '#000000') {
            document.body.classList.add('dark-theme');
            document.body.style.background = '';
            document.body.style.color = '';
          } else if (color === '#ffffff') {
            document.body.classList.add('light-mode');
            document.body.style.background = '';
            document.body.style.color = '';
          } else {
            document.body.style.background = color;
            if (color !== '#0b3d2e') {
              document.body.style.color = '#e8f5e9';
            }
          }
        }
      });

      // Init
      renderSidebar();
      load();
      updateSlideCanvasMenuState();
      updateElementContextMenuState();

    </script>
  </body>
  </html>
