<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SlideMaker â€¢ Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
      :root {
        --bg: #ffffff;
        --panel: #f9fafb;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --accent: #1a73e8;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: linear-gradient(145deg, #042c1a, #064a2c); color: #e8f5e9; }

      .layout { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
      .topbar { display:flex; align-items:center; gap:10px; padding: 8px 12px; background: rgba(255, 255, 255, 0.07); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,0.1); }
      .topbar .btn { border:1px solid var(--border); background:#fff; border-radius:8px; padding:8px 12px; font-weight:700; cursor:pointer; transition: opacity .2s; }
      .topbar .btn:hover { opacity: 0.9; }
      .toolbar-btn { display: flex; align-items: center; justify-content: center; gap: 6px; min-width: 40px; padding: 8px 12px; }
      .toolbar-btn i { font-size: 16px; }
      .topbar .btn.blue { background:#1a73e8; border-color:#1a73e8; color:#fff; }
      .topbar .btn.gray { background:#f3f4f6; }
      .topbar .btn.red { background:#fee2e2; border-color:#fecaca; color:#991b1b; }
      .topbar .btn.light { background:#f9fafb; }
      .topbar .btn.green { background:#10b981; border-color:#059669; color:#06221e; }
      .topbar .btn.emerald { background:#10b981; border-color:#059669; color:#fff; }

      .main { display:grid; grid-template-columns: 260px 1fr; gap: 12px; padding: 12px; min-height:0; }
      .sidebar { 
        background: rgba(0, 40, 20, 0.85); 
        backdrop-filter: blur(8px); 
        border-right: 1px solid rgba(255, 255, 255, 0.05); 
        border-radius:12px; 
        padding:10px; 
        padding-bottom: 60px; 
        overflow-y: auto; 
        overflow-x: visible; 
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .slide-item { 
        position: relative; 
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.3s ease;
      }
      .slide-preview { 
        background: rgba(255, 255, 255, 0.05); 
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px; 
        padding: 10px 14px; 
        cursor:pointer; 
        transition: all 0.3s ease; 
        color: #e8f5e9; 
        width: 100%;
      }
      .slide-preview:hover { background: rgba(255, 255, 255, 0.1); }
      .slide-preview.active { outline:2px solid #2ecc71; background: rgba(46, 204, 113, 0.2); }
      .slide-action-bar { 
        margin-top: 6px;
        display: flex;
        justify-content: center;
        gap: 10px;
        background: rgba(10, 60, 40, 0.9);
        border-radius: 8px;
        padding: 6px 0;
        height: 0;
        overflow: hidden;
        opacity: 0;
        transform: scaleY(0);
        transform-origin: top;
        transition: all 0.3s ease-in-out;
        width: 100%;
      }
      .slide-item:hover .slide-action-bar {
        height: auto;
        opacity: 1;
        transform: scaleY(1);
        margin-bottom: 10px;
      }
      .slide-action-bar button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-size: 18px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
      }
      .slide-action-bar button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #2ed573;
        transform: scale(1.1);
      }
      .slide-action-bar button i {
        font-size: 16px;
      }

      /* Dark metallic gradient background */
      body.dark-theme {
        background: linear-gradient(135deg, #0b0b0b 0%, #0d0d0d 40%, #000000 100%) !important;
        background-attachment: fixed;
        background-repeat: no-repeat;
        background-size: cover;
        color: #eaeaea;
        position: relative;
      }

      body.dark-theme::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.05), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }

      body.dark-theme > * {
        position: relative;
        z-index: 1;
      }

      /* Light mode background with frosted glass effect */
      body.light-mode {
        background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,240,240,0.8)) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #1a1a1a;
        transition: all 0.3s ease-in-out;
        position: relative;
      }

      body.light-mode > * {
        position: relative;
        z-index: 1;
      }

      /* Card or container glass effect in light mode */
      body.light-mode .editor {
        background: rgba(255, 255, 255, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
      }

      body.light-mode .sidebar {
        background: rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-right: 1px solid rgba(0, 0, 0, 0.1);
      }

      body.light-mode .topbar {
        background: rgba(255, 255, 255, 0.4);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }

      /* Navigation and text colors in light mode */
      body.light-mode .tool,
      body.light-mode .tool-select,
      body.light-mode .slide-preview {
        color: #1a1a1a !important;
      }

      body.light-mode .slide-preview {
        background: rgba(255, 255, 255, 0.4);
        border-color: rgba(0, 0, 0, 0.15);
      }

      body.light-mode .tool-select::placeholder {
        color: #666 !important;
      }

      body.light-mode .title-box,
      body.light-mode .text-box {
        color: #000000 !important;
      }

      body.light-mode .topbar {
        color: #1a1a1a !important;
      }

      .editor { display:grid; grid-template-rows: auto 1fr; background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border-radius:12px; box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); }
      .toolbar { 
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        background: rgba(5, 60, 35, 0.95);
        padding: 10px 20px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        flex-wrap: wrap;
      }
      .tool { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-weight: 600;
        font-size: 15px;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .tool:hover { 
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .tool.active { 
        background: #1c7c54;
        color: #fff;
        border-color: #2ed573;
      }
      .tool i {
        font-size: 14px;
      }
      .tool-select { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        font-weight: 600;
      }
      .tool-select::placeholder {
        color: rgba(232, 245, 233, 0.6);
      }
      .tool-select:hover {
        background: rgba(255, 255, 255, 0.25);
      }
      .tool-color { 
        width: 40px; 
        height: 36px; 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px; 
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .tool-color:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .canvas-wrap { display:grid; place-items:center; padding:24px; overflow:auto; }
      .canvas { width:min(92vw, 960px); aspect-ratio:16/9; background:#ffffff; border-radius:10px; box-shadow: 0 0 25px rgba(0, 0, 0, 0.25); padding:24px; position: relative; background-size: cover; background-position: center; background-repeat: no-repeat; transition: background 0.6s ease-in-out; }
      
      /* Template Background Styles */
      .canvas.marketing-template {
        background-image: url('./CURSOR-Project/Background/B1.avif');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.marketing-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.business-template {
        background-image: url('./CURSOR-Project/Background/business-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.business-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.education-template {
        background-image: url('./CURSOR-Project/Background/education-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.education-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.project-template {
        background-image: url('./CURSOR-Project/Background/project-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.project-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      /* Ensure content is above overlay */
      .canvas .title-box,
      .canvas .text-box {
        position: relative;
        z-index: 1;
      }
      
      /* Title box per Editor.json */
      .title-box {
        font-size: 28px;
        font-weight: bold;
        color: #000000;
        border: 1px dashed #ccc;
        padding: 10px;
        min-height: 50px;
        min-width: 200px;
        outline: none;
        position: absolute;
        top: 24px;
        left: 24px;
        width: calc(100% - 48px);
        outline: none;
      }
      .title-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .title-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      .title-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .title-box.resizing {
        user-select: none;
      }
      
      /* Resize edges for title box */
      .title-box .resize-edge {
        position: absolute;
        background: transparent;
        z-index: 10;
      }
      .title-box .resize-edge.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.left { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.right { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.corner { width: 15px; height: 15px; }
      .title-box .resize-edge.top-left { top: -5px; left: -5px; cursor: nw-resize; }
      .title-box .resize-edge.top-right { top: -5px; right: -5px; cursor: ne-resize; }
      .title-box .resize-edge.bottom-left { bottom: -5px; left: -5px; cursor: sw-resize; }
      .title-box .resize-edge.bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }

      /* Text box per Editor.json */
      .text-box {
        font-size: 16px;
        border: 1px dashed #ccc;
        padding: 10px;
        min-height: 250px;
        min-width: 200px;
        outline: none;
        overflow-y: auto;
        color: #000000;
        position: absolute;
        top: 100px;
        left: 24px;
        width: calc(100% - 48px);
        bottom: 24px;
        outline: none;
      }
      .text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .additional-text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .text-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      
      /* Selected state for text boxes and title box */
      .text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .additional-text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .title-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      
      .text-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .text-box.resizing {
        user-select: none;
      }
      
      /* Resize edges for text box */
      .text-box .resize-edge {
        position: absolute;
        background: transparent;
        z-index: 10;
        transition: background 0.2s;
      }
      .text-box:hover .resize-edge {
        background: rgba(26, 115, 232, 0.1);
      }
      .text-box .resize-edge:hover {
        background: rgba(26, 115, 232, 0.3);
      }
      .text-box .resize-edge.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .text-box .resize-edge.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .text-box .resize-edge.left { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .text-box .resize-edge.right { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .text-box .resize-edge.corner { width: 15px; height: 15px; }
      .text-box .resize-edge.top-left { top: -5px; left: -5px; cursor: nw-resize; }
      .text-box .resize-edge.top-right { top: -5px; right: -5px; cursor: ne-resize; }
      .text-box .resize-edge.bottom-left { bottom: -5px; left: -5px; cursor: sw-resize; }
      .text-box .resize-edge.bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }

      /* Save notification */
      .save-notification {
        position: fixed;
        top: 70px;
        right: 20px;
        background: #10b981;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity .3s, transform .3s;
        z-index: 1000;
        pointer-events: none;
      }
      .save-notification.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="topbar">
        <button class="btn blue toolbar-btn" id="btnBack" data-action="back" title="Back (Cmd+Z / Ctrl+Z)">
          <i class="fas fa-arrow-left"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnForward" data-action="forward" title="Forward (Cmd+Shift+Z / Ctrl+Shift+Z)">
          <i class="fas fa-arrow-right"></i>
        </button>
        <button class="btn red toolbar-btn" id="btnDel" data-action="delete_slide" title="Delete Slide">
          <i class="fas fa-trash"></i>
        </button>
        <button class="btn light toolbar-btn" id="btnReset" data-action="reset_slides" title="Reset Slides">
          <i class="fas fa-rotate-right"></i>
        </button>
        <button class="btn green toolbar-btn" id="btnSave" data-action="save_presentation" title="Save Presentation">
          <i class="fas fa-save"></i>
        </button>
        <button class="btn green toolbar-btn" id="btnSaveAs" data-action="save_as_file" title="Save As">
          <i class="fas fa-folder-open"></i>
        </button>
        <div style="flex:1"></div>
        <button class="btn emerald toolbar-btn" id="btnHome" data-action="go_home" title="Return Home">
          <i class="fas fa-home"></i>
        </button>
      </div>

      <div class="main">
        <aside class="sidebar" id="sidebar"></aside>
        <section class="editor">
          <div class="toolbar" id="toolbar">
            <button class="tool" data-action="bold" title="Bold"><i class="fas fa-bold"></i></button>
            <button class="tool" data-action="italic" title="Italic"><i class="fas fa-italic"></i></button>
            <button class="tool" data-action="underline" title="Underline"><i class="fas fa-underline"></i></button>
            <button class="tool" data-action="strikeThrough" title="Strikethrough"><i class="fas fa-strikethrough"></i></button>
            <button class="tool" data-action="subscript" title="Subscript"><i class="fas fa-subscript"></i></button>
            <button class="tool" data-action="superscript" title="Superscript"><i class="fas fa-superscript"></i></button>
            <input type="number" class="tool-select" id="fontSize" title="Font Size" min="8" max="72" step="2" value="16" style="width: 80px; color: #e8f5e9;">
            <input type="color" class="tool-color" id="fontColor" value="#000000" title="Font Color">
            <input type="color" class="tool-color" id="highlightColor" value="#ffff00" title="Highlight">
            <button class="tool" data-action="highlight" title="Highlight"><i class="fas fa-highlighter"></i></button>
            <button class="tool" data-action="justifyLeft" title="Align Left"><i class="fas fa-align-left"></i></button>
            <button class="tool" data-action="justifyCenter" title="Align Center"><i class="fas fa-align-center"></i></button>
            <button class="tool" data-action="justifyRight" title="Align Right"><i class="fas fa-align-right"></i></button>
            <button class="tool" data-action="justifyFull" title="Justify"><i class="fas fa-align-justify"></i></button>
            <button class="tool" data-action="insertUnorderedList" title="Bullet List"><i class="fas fa-list-ul"></i></button>
            <button class="tool" data-action="insertOrderedList" title="Numbered List"><i class="fas fa-list-ol"></i></button>
            <button class="tool" data-action="addTextBox" title="Add Text Box"><i class="fas fa-text-width"></i> Text Box</button>
          </div>
          <div class="canvas-wrap">
            <div class="canvas" id="canvas">
              <div class="title-box" contenteditable="true" id="titleBox" data-placeholder="Click to add title"></div>
              <div class="text-box" contenteditable="true" id="textBox" data-placeholder="Click to add text"></div>
            </div>
          </div>
        </section>
      </div>
    </div>

    <div class="save-notification" id="saveNotification">Presentation saved!</div>

    <script>
      // Route Protection - Check authentication on page load
      (function() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        // If not authenticated and not a guest, redirect to welcome page
        if (!currentUser && !isGuest) {
          window.location.href = './index.html';
          return;
        }
      })();
      
      // Model per Editor.json: starting with one slide titled "Title"
      const slides = [{ 
        title: 'Title', 
        content: '',
        titleBox: { top: 24, left: 24, right: 24, width: null, height: null },
        textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null }
      }];
      let active = 0;

      const sidebar = document.getElementById('sidebar');
      const titleBox = document.getElementById('titleBox');
      const textBox = document.getElementById('textBox');
      const saveNotification = document.getElementById('saveNotification');
      const canvas = document.getElementById('canvas');
      
      // Template Background Detection and Application
      (function() {
        // Get template from query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const templateParam = urlParams.get('template');
        
        // Also check sessionStorage for backward compatibility
        const templateFromStorage = sessionStorage.getItem('selectedTemplate');
        const templateName = templateParam || templateFromStorage;
        
        if (templateName) {
          // Map template names to CSS classes
          const templateMap = {
            'marketing': 'marketing-template',
            'business': 'business-template',
            'education': 'education-template',
            'project': 'project-template',
            'business-pro': 'business-template',
            'creative-bold': 'marketing-template',
            'corporate-clean': 'business-template'
          };
          
          const templateClass = templateMap[templateName.toLowerCase()];
          
          if (templateClass) {
            // Remove any existing template classes
            canvas.classList.remove('marketing-template', 'business-template', 'education-template', 'project-template');
            
            // Add the new template class
            canvas.classList.add(templateClass);
          }
        }
      })();
      
      // Track selected text box for keyboard deletion
      let selectedTextBox = null;
      
      // Undo/Redo history stack
      let actionHistory = [];
      let redoStack = [];
      const MAX_HISTORY = 50; // Limit history size
      
      // Save current editor state to history
      function saveEditorState(action) {
        const state = {
          action: action,
          timestamp: Date.now(),
          slides: JSON.parse(JSON.stringify(slides)), // Deep copy
          active: active,
          canvasState: {
            titleBoxVisible: titleBox.style.display !== 'none',
            textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
              const rect = box.getBoundingClientRect();
              const canvasRect = canvas.getBoundingClientRect();
              return {
                element: box,
                html: box.innerHTML,
                style: {
                  top: rect.top - canvasRect.top,
                  left: rect.left - canvasRect.left,
                  width: box.offsetWidth,
                  height: box.offsetHeight,
                  fontSize: box.style.fontSize,
                  display: box.style.display
                }
              };
            })
          }
        };
        
        actionHistory.push(state);
        
        // Limit history size
        if (actionHistory.length > MAX_HISTORY) {
          actionHistory.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update undo button state
        updateUndoButton();
      }
      
      // Restore editor state from history
      function restoreEditorState(state) {
        // Restore slides data
        slides.length = 0;
        slides.push(...JSON.parse(JSON.stringify(state.slides)));
        active = state.active;
        
        // Restore title and text box visibility
        if (state.canvasState) {
          titleBox.style.display = state.canvasState.titleBoxVisible ? '' : 'none';
          textBox.style.display = state.canvasState.textBoxVisible ? '' : 'none';
        }
        
        // Restore slide content
        load();
        renderSidebar();
        
        // Restore additional text boxes
        if (state.canvasState && state.canvasState.additionalTextBoxes) {
          // Remove existing additional text boxes
          document.querySelectorAll('.additional-text-box').forEach(box => {
            if (!state.canvasState.additionalTextBoxes.some(saved => saved.element === box)) {
              box.remove();
            }
          });
          
          // Restore saved additional text boxes
          state.canvasState.additionalTextBoxes.forEach(savedBox => {
            let existingBox = null;
            if (savedBox.element && document.contains(savedBox.element)) {
              existingBox = savedBox.element;
            } else {
              // Create new box if it doesn't exist
              existingBox = document.createElement('div');
              existingBox.className = 'text-box additional-text-box';
              existingBox.contentEditable = true;
              existingBox.dataset.placeholder = 'Click to add text';
              canvas.appendChild(existingBox);
              
              // Setup the new box
              createResizeEdges(existingBox);
              makeDraggable(existingBox);
              makeResizable(existingBox);
              setupFontSizeTracking(existingBox);
              elementFontSizes.set(existingBox, parseFloat(savedBox.style.fontSize) || 16);
              
              // Add selection handler
              existingBox.addEventListener('click', (e) => {
                if (e.target === existingBox || !existingBox.textContent.trim()) {
                  selectTextBox(existingBox);
                }
              });
            }
            
            // Restore content and style
            existingBox.innerHTML = savedBox.html;
            existingBox.style.top = savedBox.style.top + 'px';
            existingBox.style.left = savedBox.style.left + 'px';
            existingBox.style.width = savedBox.style.width + 'px';
            existingBox.style.height = savedBox.style.height + 'px';
            existingBox.style.fontSize = savedBox.style.fontSize;
            existingBox.style.display = savedBox.style.display || '';
          });
        }
        
        updateUndoButton();
      }
      
      // Undo last action
      function undoLastAction() {
        if (actionHistory.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const rect = box.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: rect.top - canvasRect.top,
                    left: rect.left - canvasRect.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    display: box.style.display
                  }
                };
              })
            }
          };
          
          // Save current state to redo stack
          redoStack.push(currentState);
          
          // Get previous state from history
          const previousState = actionHistory.pop();
          restoreEditorState(previousState);
        }
      }
      
      // Update undo/redo button states
      function updateUndoButton() {
        const backBtn = document.getElementById('btnBack');
        const forwardBtn = document.getElementById('btnForward');
        if (backBtn) {
          backBtn.disabled = actionHistory.length === 0;
          backBtn.style.opacity = actionHistory.length === 0 ? '0.5' : '1';
        }
        if (forwardBtn) {
          forwardBtn.disabled = redoStack.length === 0;
          forwardBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
        }
      }
      
      // Initialize with initial state
      saveEditorState('initial');

      function renderSidebar() {
        sidebar.innerHTML = '';
        slides.forEach((s, i) => {
          // Create slide-item container
          const slideItem = document.createElement('div');
          slideItem.className = 'slide-item';
          
          // Create slide preview
          const el = document.createElement('div');
          el.className = 'slide-preview' + (i === active ? ' active' : '');
          el.textContent = s.title || `Slide ${i+1}`;
          el.addEventListener('click', () => {
            capture();
            active = i;
            load();
            renderSidebar();
          });
          
          // Create slide action bar container
          const slideActionBar = document.createElement('div');
          slideActionBar.className = 'slide-action-bar';
          
          // New Slide button with icon
          const newSlideBtn = document.createElement('button');
          newSlideBtn.className = 'new-slide';
          newSlideBtn.title = 'New Slide';
          newSlideBtn.innerHTML = '<i class="fas fa-plus"></i>';
          newSlideBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            createNewSlide(i);
          });
          
          // Duplicate button with icon
          const duplicateBtn = document.createElement('button');
          duplicateBtn.className = 'duplicate-slide';
          duplicateBtn.title = 'Duplicate';
          duplicateBtn.innerHTML = '<i class="fas fa-copy"></i>';
          duplicateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            duplicateCurrentSlide(i);
          });
          
          slideActionBar.appendChild(newSlideBtn);
          slideActionBar.appendChild(duplicateBtn);
          
          slideItem.appendChild(el);
          slideItem.appendChild(slideActionBar);
          
          sidebar.appendChild(slideItem);
        });
      }

      function createResizeEdges(element) {
        // Remove existing edges
        element.querySelectorAll('.resize-edge').forEach(el => el.remove());
        
        const edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        edges.forEach(edge => {
          const edgeEl = document.createElement('div');
          edgeEl.className = `resize-edge ${edge}`;
          edgeEl.dataset.edge = edge;
          element.appendChild(edgeEl);
        });
      }

      function load() {
        const slide = slides[active];
        titleBox.textContent = slide.title || 'Title';
        textBox.textContent = slide.content || '';
        // Trigger placeholder display if empty
        if (!titleBox.textContent.trim()) titleBox.innerHTML = '';
        if (!textBox.textContent.trim()) textBox.innerHTML = '';
        
        // Restore positions and sizes
        if (slide.titleBox) {
          titleBox.style.top = slide.titleBox.top + 'px';
          titleBox.style.left = slide.titleBox.left + 'px';
          if (slide.titleBox.width) {
            titleBox.style.width = slide.titleBox.width + 'px';
            titleBox.style.right = 'auto';
          }
          if (slide.titleBox.height) {
            titleBox.style.height = slide.titleBox.height + 'px';
          }
        }
        if (slide.textBox) {
          textBox.style.top = slide.textBox.top + 'px';
          textBox.style.left = slide.textBox.left + 'px';
          if (slide.textBox.width) {
            textBox.style.width = slide.textBox.width + 'px';
            textBox.style.right = 'auto';
          }
          if (slide.textBox.height) {
            textBox.style.height = slide.textBox.height + 'px';
            textBox.style.bottom = 'auto';
          }
        }
        
        // Create resize edges
        createResizeEdges(titleBox);
        createResizeEdges(textBox);
      }

      function capture() {
        slides[active].title = titleBox.textContent.trim() || 'Title';
        slides[active].content = textBox.textContent.trim() || '';
        
        // Save positions and sizes
        const titleRect = titleBox.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        slides[active].titleBox = {
          top: titleRect.top - canvasRect.top,
          left: titleRect.left - canvasRect.left,
          width: titleBox.offsetWidth,
          height: titleBox.offsetHeight,
          visible: titleBox.style.display !== 'none'
        };
        
        const textRect = textBox.getBoundingClientRect();
        slides[active].textBox = {
          top: textRect.top - canvasRect.top,
          left: textRect.left - canvasRect.left,
          width: textBox.offsetWidth,
          height: textBox.offsetHeight,
          visible: textBox.style.display !== 'none'
        };
      }

      // Drag functionality - only when clicking on empty space
      function makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;
        let dragThreshold = 5;
        
        element.addEventListener('mousedown', (e) => {
          // Don't drag if clicking on resize edge
          if (e.target.classList && e.target.classList.contains('resize-edge')) {
            return;
          }
          
          // Don't drag if clicking on text content
          if (e.target !== element && e.target.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          
          // Only drag if clicking on empty space or border area
          const selection = window.getSelection();
          if (selection.toString().length > 0) {
            return;
          }
          
          // Check if element is empty or clicking on border
          const isEmpty = !element.textContent.trim() || element.textContent.trim() === element.dataset.placeholder;
          const isBorderClick = e.target === element || (e.target === element && element.contains(e.target));
          
          if (!isEmpty && !isBorderClick) {
            return; // Allow text editing
          }
          
          const rect = element.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          startX = e.clientX;
          startY = e.clientY;
          initialLeft = rect.left - canvasRect.left;
          initialTop = rect.top - canvasRect.top;
        });
        
        document.addEventListener('mousemove', (e) => {
          if (startX === undefined || startY === undefined) return;
          
          const deltaX = Math.abs(e.clientX - startX);
          const deltaY = Math.abs(e.clientY - startY);
          
          if (!isDragging && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            isDragging = true;
            element.classList.add('dragging');
            element.setAttribute('contenteditable', 'false');
          }
          
          if (!isDragging) return;
          
          const canvasRect = canvas.getBoundingClientRect();
          const moveX = e.clientX - startX;
          const moveY = e.clientY - startY;
          
          let newLeft = initialLeft + moveX;
          let newTop = initialTop + moveY;
          
          const maxLeft = canvasRect.width - element.offsetWidth - 48;
          const maxTop = canvasRect.height - element.offsetHeight - 48;
          
          newLeft = Math.max(24, Math.min(newLeft, maxLeft));
          newTop = Math.max(24, Math.min(newTop, maxTop));
          
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          capture();
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            element.setAttribute('contenteditable', 'true');
            capture();
            // Save state for undo after dragging
            saveEditorState('move_element');
          }
          startX = undefined;
          startY = undefined;
        });
      }
      
      // Resize functionality using edges
      function makeResizable(element) {
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        let resizeEdge = '';
        
        element.addEventListener('mousedown', (e) => {
          if (!e.target.classList.contains('resize-edge')) return;
          
          resizeEdge = e.target.dataset.edge;
          isResizing = true;
          element.classList.add('resizing');
          element.setAttribute('contenteditable', 'false');
          
          const rect = element.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          startX = e.clientX;
          startY = e.clientY;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
          startLeft = rect.left - canvasRect.left;
          startTop = rect.top - canvasRect.top;
          
          e.preventDefault();
          e.stopPropagation();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isResizing) return;
          
          const canvasRect = canvas.getBoundingClientRect();
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          let newWidth = startWidth;
          let newHeight = startHeight;
          let newLeft = startLeft;
          let newTop = startTop;
          
          if (resizeEdge.includes('right')) {
            newWidth = Math.max(200, startWidth + deltaX);
            newWidth = Math.min(newWidth, canvasRect.width - newLeft - 48);
          }
          if (resizeEdge.includes('left')) {
            newWidth = Math.max(200, startWidth - deltaX);
            newLeft = Math.max(24, startLeft + deltaX);
            if (newLeft === 24) newWidth = startLeft + startWidth - 24;
          }
          if (resizeEdge.includes('bottom')) {
            newHeight = Math.max(50, startHeight + deltaY);
            newHeight = Math.min(newHeight, canvasRect.height - newTop - 48);
          }
          if (resizeEdge.includes('top')) {
            newHeight = Math.max(50, startHeight - deltaY);
            newTop = Math.max(24, startTop + deltaY);
            if (newTop === 24) newHeight = startTop + startHeight - 24;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          
          capture();
        });
        
        document.addEventListener('mouseup', () => {
          if (isResizing) {
            isResizing = false;
            element.classList.remove('resizing');
            element.setAttribute('contenteditable', 'true');
            resizeEdge = '';
            capture();
            // Save state for undo after resizing
            saveEditorState('resize_element');
          }
        });
      }
      
      // Make boxes draggable and resizable
      makeDraggable(titleBox);
      makeDraggable(textBox);
      makeResizable(titleBox);
      makeResizable(textBox);
      
      // Initialize resize edges
      createResizeEdges(titleBox);
      createResizeEdges(textBox);
      
      // Add selection handlers for title and text boxes
      titleBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === titleBox || !titleBox.textContent.trim()) {
          selectTextBox(titleBox);
        }
      });
      
      textBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === textBox || !textBox.textContent.trim()) {
          selectTextBox(textBox);
        }
      });

      // Toolbar interactions per Editor.json
      function getActiveElement() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
        return document.activeElement === titleBox ? titleBox : textBox;
      }

      // Add Text Box functionality
      function addTextBox() {
        const canvasRect = canvas.getBoundingClientRect();
        const centerX = canvasRect.width / 2 - 150; // Center of canvas
        const centerY = canvasRect.height / 2 - 100;
        
        const newTextBox = document.createElement('div');
        newTextBox.className = 'text-box additional-text-box';
        newTextBox.contentEditable = true;
        newTextBox.dataset.placeholder = 'Click to add text';
        newTextBox.style.position = 'absolute';
        newTextBox.style.top = centerY + 'px';
        newTextBox.style.left = centerX + 'px';
        newTextBox.style.width = '300px';
        newTextBox.style.height = '200px';
        newTextBox.style.minWidth = '200px';
        newTextBox.style.minHeight = '50px';
        newTextBox.style.border = '1px dashed #ccc';
        newTextBox.style.padding = '10px';
        newTextBox.style.outline = 'none';
        newTextBox.style.overflowY = 'auto';
        newTextBox.style.color = '#000000';
        newTextBox.style.fontSize = '16px';
        newTextBox.style.background = '#fff';
        
        // Add placeholder functionality
        const placeholder = newTextBox.dataset.placeholder;
        newTextBox.addEventListener('focus', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        
        newTextBox.addEventListener('blur', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        
        // Add placeholder CSS
        if (!newTextBox.textContent.trim()) {
          newTextBox.setAttribute('data-placeholder', placeholder);
        }
        
        // Add resize edges
        createResizeEdges(newTextBox);
        
        // Make draggable and resizable
        makeDraggable(newTextBox);
        makeResizable(newTextBox);
        
        // Setup font size tracking for the new text box
        setupFontSizeTracking(newTextBox);
        
        // Initialize font size
        elementFontSizes.set(newTextBox, 16);
        
        // Select text box when clicking on border
        newTextBox.addEventListener('click', (e) => {
          // Select if clicking on border or empty space
          if (e.target === newTextBox || !newTextBox.textContent.trim()) {
            selectTextBox(newTextBox);
          }
        });
        
        // Add to canvas
        canvas.appendChild(newTextBox);
        
        // Focus the new text box
        setTimeout(() => {
          newTextBox.focus();
        }, 100);
        
        // Save to slide data
        capture();
        
        // Save state for undo
        saveEditorState('add_textbox');
      }
      
      // Function to select/deselect text boxes
      function selectTextBox(element) {
        // Can select any text box or title box
        if (!element || (!element.classList.contains('text-box') && element.id !== 'titleBox')) {
          return;
        }
        
        // Deselect all other boxes
        document.querySelectorAll('.text-box.selected, .title-box.selected').forEach(box => {
          box.classList.remove('selected');
        });
        
        // Select this box
        element.classList.add('selected');
        selectedTextBox = element;
        
        // Deselect when clicking elsewhere
        setTimeout(() => {
          document.addEventListener('click', function deselectHandler(e) {
            if (!element.contains(e.target) && e.target !== element) {
              element.classList.remove('selected');
              selectedTextBox = null;
              document.removeEventListener('click', deselectHandler);
            }
          }, { once: true });
        }, 0);
      }
      
      // Function to delete text box
      function deleteTextBox(element) {
        if (!element) return;
        
        // Handle title box deletion - hide it instead of removing
        if (element.id === 'titleBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          capture();
          return;
        }
        
        // Handle main text box deletion - hide it instead of removing
        if (element.id === 'textBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = titleBox;
            updateFontSizeInput();
          }
          capture();
          return;
        }
        
        // Handle additional text boxes - remove completely
        if (element.classList.contains('additional-text-box')) {
          // Remove from font size tracking
          elementFontSizes.delete(element);
          // Remove selection
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          // Remove from DOM
          element.remove();
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = textBox;
            updateFontSizeInput();
          }
          capture();
        }
      }
      
      // Global keyboard listener for Delete/Backspace and Undo
      document.addEventListener('keydown', (e) => {
        // Undo keyboard shortcut (Cmd+Z on Mac, Ctrl+Z on Windows)
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undoLastAction();
          return;
        }
        
        // Redo keyboard shortcut (Cmd+Shift+Z on Mac, Ctrl+Shift+Z on Windows)
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          redoLastAction();
          return;
        }
        
        // Only handle Delete/Backspace if a text box is selected
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
          // Check if user is typing (cursor is inside the text box)
          const selection = window.getSelection();
          const isTyping = selection.rangeCount > 0 && 
                          selection.getRangeAt(0).startOffset !== selection.getRangeAt(0).endOffset;
          
          // Only delete if not typing (no text selection) or if box is empty
          const isEmpty = !selectedTextBox.textContent.trim();
          const hasTextSelection = selection.toString().length > 0;
          
          if (!hasTextSelection || isEmpty) {
            e.preventDefault();
            e.stopPropagation();
            deleteTextBox(selectedTextBox);
            saveEditorState('delete_textbox');
          }
        }
      });
      
      // Back (Undo) button click handler
      document.getElementById('btnBack').addEventListener('click', () => {
        undoLastAction();
      });
      
      // Forward (Redo) button click handler
      document.getElementById('btnForward').addEventListener('click', () => {
        redoLastAction();
      });
      
      // Redo functionality
      function redoLastAction() {
        if (redoStack.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const rect = box.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: rect.top - canvasRect.top,
                    left: rect.left - canvasRect.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    display: box.style.display
                  }
                };
              })
            }
          };
          
          // Save current state to undo stack
          actionHistory.push(currentState);
          
          // Get next state from redo stack
          const nextState = redoStack.pop();
          restoreEditorState(nextState);
        }
      }
      
      // Formatting tools
      document.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const action = btn.getAttribute('data-action');
          
          // Handle addTextBox action
          if (action === 'addTextBox') {
            addTextBox();
            return;
          }
          
          const activeEl = getActiveElement();
          
          // Focus on the active element if needed
          if (activeEl === titleBox || activeEl === textBox || titleBox.contains(activeEl) || textBox.contains(activeEl)) {
            if (titleBox.contains(activeEl) || activeEl === titleBox) {
              titleBox.focus();
            } else {
              textBox.focus();
            }
          }

          // Execute command
          if (action === 'bold') document.execCommand('bold', false);
          else if (action === 'italic') document.execCommand('italic', false);
          else if (action === 'underline') document.execCommand('underline', false);
          else if (action === 'strikeThrough') document.execCommand('strikeThrough', false);
          else if (action === 'superscript') document.execCommand('superscript', false);
          else if (action === 'subscript') document.execCommand('subscript', false);
          else if (action === 'justifyLeft') document.execCommand('justifyLeft', false);
          else if (action === 'justifyCenter') document.execCommand('justifyCenter', false);
          else if (action === 'justifyRight') document.execCommand('justifyRight', false);
          else if (action === 'justifyFull') document.execCommand('justifyFull', false);
          else if (action === 'insertUnorderedList') document.execCommand('insertUnorderedList', false);
          else if (action === 'insertOrderedList') document.execCommand('insertOrderedList', false);
        });
      });

      // Store font sizes for elements
      let titleFontSize = 28;
      let textFontSize = 16;
      let elementFontSizes = new Map(); // Store font sizes for dynamically created elements
      let currentActiveElement = textBox;

      // Initialize default font sizes
      titleBox.style.fontSize = titleFontSize + 'px';
      textBox.style.fontSize = textFontSize + 'px';
      elementFontSizes.set(titleBox, titleFontSize);
      elementFontSizes.set(textBox, textFontSize);

      // Function to get current font size from an element
      function getCurrentFontSize(element) {
        if (elementFontSizes.has(element)) {
          return elementFontSizes.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseFloat(computedStyle.fontSize);
        return Math.round(fontSize);
      }

      // Function to apply font size to an element
      function applyFontSize(element, size) {
        const selection = window.getSelection();
        
        // If there's selected text in the element, apply font size to selection
        if (selection.rangeCount > 0 && !selection.isCollapsed && 
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = size + 'px';
          
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
          } catch (e) {
            document.execCommand("fontSize", false, "7");
            setTimeout(() => {
              const fonts = element.getElementsByTagName("font");
              for (let i = fonts.length - 1; i >= 0; i--) {
                if (fonts[i].size === "7") {
                  const newSpan = document.createElement('span');
                  newSpan.style.fontSize = size + 'px';
                  newSpan.innerHTML = fonts[i].innerHTML;
                  fonts[i].parentNode.replaceChild(newSpan, fonts[i]);
                }
              }
            }, 10);
          }
        } else {
          // No selection - apply font size to the entire element
          element.style.fontSize = size + 'px';
          
          // Wrap existing text nodes in spans to preserve formatting
          const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
          const textNodes = [];
          let node;
          while (node = walker.nextNode()) {
            const parent = node.parentElement;
            if (!parent || !parent.style.fontSize) {
              textNodes.push(node);
            }
          }
          
          textNodes.forEach(textNode => {
            if (textNode.textContent.trim()) {
              const span = document.createElement('span');
              span.style.fontSize = size + 'px';
              span.textContent = textNode.textContent;
              textNode.parentNode.replaceChild(span, textNode);
            }
          });
        }
        
        // Store the font size for this element
        elementFontSizes.set(element, size);
      }

      // Update font size input when focus changes
      function updateFontSizeInput() {
        const fontSizeInput = document.getElementById('fontSize');
        if (currentActiveElement) {
          const currentSize = getCurrentFontSize(currentActiveElement);
          fontSizeInput.value = currentSize;
        }
      }

      // Track focus changes for any contenteditable element
      function setupFontSizeTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          updateFontSizeInput();
        });
        
        // Initialize font size if not set
        if (!elementFontSizes.has(element)) {
          const currentSize = parseFloat(window.getComputedStyle(element).fontSize) || 16;
          elementFontSizes.set(element, Math.round(currentSize));
        }
      }

      // Track focus changes for existing elements
      setupFontSizeTracking(titleBox);
      setupFontSizeTracking(textBox);

      // Also check on selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          
          // Find which contenteditable element contains the selection
          let activeEl = null;
          if (titleBox.contains(anchorNode) || anchorNode === titleBox) {
            activeEl = titleBox;
          } else if (textBox.contains(anchorNode) || anchorNode === textBox) {
            activeEl = textBox;
          } else {
            // Check additional text boxes
            const allTextBoxes = document.querySelectorAll('.additional-text-box, .text-box');
            allTextBoxes.forEach(box => {
              if (box.contains(anchorNode) || anchorNode === box) {
                activeEl = box;
              }
            });
          }
          
          if (activeEl && currentActiveElement !== activeEl) {
            currentActiveElement = activeEl;
            updateFontSizeInput();
          }
        }
      });

      // Font size input change handler
      const fontSizeInput = document.getElementById('fontSize');
      fontSizeInput.addEventListener('change', (e) => {
        const size = parseInt(e.target.value);
        if (!isNaN(size) && size >= 8 && size <= 72 && currentActiveElement) {
          applyFontSize(currentActiveElement, size);
          
          // Update stored sizes for title and main text box
          if (currentActiveElement === titleBox) {
            titleFontSize = size;
          } else if (currentActiveElement === textBox) {
            textFontSize = size;
          }
        }
      });
      
      // Validate input on blur
      fontSizeInput.addEventListener('blur', (e) => {
        if (!currentActiveElement) return;
        
        const size = parseInt(e.target.value);
        const currentSize = getCurrentFontSize(currentActiveElement);
        
        if (isNaN(size) || size < 8) {
          e.target.value = currentSize;
        } else if (size > 72) {
          e.target.value = 72;
          applyFontSize(currentActiveElement, 72);
          
          // Update stored sizes
          if (currentActiveElement === titleBox) {
            titleFontSize = 72;
          } else if (currentActiveElement === textBox) {
            textFontSize = 72;
          }
        }
      });

      // Initialize the input value
      updateFontSizeInput();

      // Font color picker
      document.getElementById('fontColor').addEventListener('change', (e) => {
        document.execCommand('foreColor', false, e.target.value);
      });

      // Highlight color picker
      document.getElementById('highlightColor').addEventListener('change', (e) => {
        document.execCommand('backColor', false, e.target.value);
      });

      // Save function per Editor.json and auth_system.json
      function savePresentation() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        if (!currentUser) {
          if (isGuest) {
            alert('Please sign in to save presentations. Guests can only view and edit.');
            return;
          }
          alert('Please log in to save presentations.');
          window.location.href = './templates.html';
          return;
        }

        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.textContent.trim() || "";
        
        // Save to user-specific key per auth_system.json
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        saved.push({
          title: title,
          date: new Date().toISOString().split("T")[0],
          content: content
        });
        
        localStorage.setItem(userKey, JSON.stringify(saved));
        
        // Show notification animation
        saveNotification.classList.add('show');
        setTimeout(() => {
          saveNotification.classList.remove('show');
        }, 2000);
      }

      // Save As function per Editor.json
      function saveAsFile() {
        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.innerHTML || "";

        const fileType = prompt("Enter file type: pdf or pptx").toLowerCase();

        if (fileType === "pdf") {
          const blob = new Blob([content], { type: "application/pdf" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${title}.pdf`;
          a.click();
          URL.revokeObjectURL(url);
        } else if (fileType === "pptx") {
          const blob = new Blob([content], { type: "application/vnd.openxmlformats-officedocument.presentationml.presentation" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${title}.pptx`;
          a.click();
          URL.revokeObjectURL(url);
        } else {
          alert("Invalid format. Use 'pdf' or 'pptx'.");
        }
      }

      // Topbar button actions per slides.json
      document.getElementById('btnDel').addEventListener('click', () => {
        if (slides.length <= 1) return;
        saveEditorState('delete_slide');
        slides.splice(active, 1);
        active = Math.max(0, active - 1);
        load();
        renderSidebar();
      });

      document.getElementById('btnReset').addEventListener('click', () => {
        if (confirm('Reset all slides? This cannot be undone.')) {
          saveEditorState('reset_slides');
          slides.splice(0, slides.length, { 
            title: 'Title', 
            content: '',
            titleBox: { top: 24, left: 24, right: 24, width: null, height: null },
            textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null }
          });
          active = 0;
          load();
          renderSidebar();
        }
      });

      document.getElementById('btnSave').addEventListener('click', savePresentation);
      document.getElementById('btnSaveAs').addEventListener('click', saveAsFile);

      document.getElementById('btnHome').addEventListener('click', () => {
        capture();
        window.location.href = './templates.html';
      });

      // Hover button functions per Editor.json slidePreview
      function createNewSlide(index) {
        capture();
        saveEditorState('create_slide');
        slides.splice(index + 1, 0, { 
          title: `Slide ${slides.length+1}`, 
          content: '',
          titleBox: { top: 24, left: 24, right: 24, width: null, height: null },
          textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null }
        });
        active = index + 1;
        load();
        renderSidebar();
      }

      function duplicateCurrentSlide(index) {
        capture();
        saveEditorState('duplicate_slide');
        const s = slides[index];
        slides.splice(index + 1, 0, { 
          title: s.title + ' copy', 
          content: s.content,
          titleBox: s.titleBox ? {...s.titleBox} : { top: 24, left: 24, right: 24, width: null, height: null },
          textBox: s.textBox ? {...s.textBox} : { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null }
        });
        active = index + 1;
        load();
        renderSidebar();
      }

      // Auto-save on input with debounce for undo
      let textEditTimeout;
      function saveTextEditState() {
        clearTimeout(textEditTimeout);
        textEditTimeout = setTimeout(() => {
          saveEditorState('edit_text');
        }, 1000); // Save state 1 second after typing stops
      }
      
      titleBox.addEventListener('input', () => {
        slides[active].title = titleBox.textContent.trim();
        renderSidebar();
        saveTextEditState();
      });
      textBox.addEventListener('input', () => {
        slides[active].content = textBox.textContent.trim();
        saveTextEditState();
      });
      
      // Also track input on additional text boxes
      document.addEventListener('input', (e) => {
        if (e.target.classList && e.target.classList.contains('additional-text-box')) {
          saveTextEditState();
        }
      });

      // Check if loading a saved presentation from Recent section
      const loadPres = sessionStorage.getItem('loadPresentation');
      if (loadPres) {
        try {
          const pres = JSON.parse(loadPres);
          // Set the title and content from saved presentation
          slides[0].title = pres.title || 'Title';
          slides[0].content = pres.content || '';
          sessionStorage.removeItem('loadPresentation'); // Clear after loading
        } catch (e) {
          console.error('Error loading presentation:', e);
        }
      }

      // Load and apply saved background color from settings
      const savedBg = localStorage.getItem('siteBackgroundColor');
      if (savedBg) {
        if (savedBg === '#000000') {
          document.body.classList.add('dark-theme');
          document.body.style.background = '';
          document.body.style.color = '';
        } else if (savedBg === '#ffffff') {
          document.body.classList.add('light-mode');
          document.body.style.background = '';
          document.body.style.color = '';
        } else {
          document.body.style.background = savedBg;
        }
      }

      // Listen for background color updates from settings page
      window.addEventListener('message', (e) => {
        if (e.data.type === 'updateBackground') {
          const color = e.data.color;
          document.body.classList.remove('dark-theme', 'light-mode');
          
          if (color === '#000000') {
            document.body.classList.add('dark-theme');
            document.body.style.background = '';
            document.body.style.color = '';
          } else if (color === '#ffffff') {
            document.body.classList.add('light-mode');
            document.body.style.background = '';
            document.body.style.color = '';
          } else {
            document.body.style.background = color;
            if (color !== '#0b3d2e') {
              document.body.style.color = '#e8f5e9';
            }
          }
        }
      });

      // Init
      renderSidebar();
      load();
    </script>
  </body>
  </html>
