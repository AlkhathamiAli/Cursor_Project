<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SlideMaker â€¢ Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;600&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Source+Sans+Pro:wght@400;600&family=Nunito:wght@400;600&family=Raleway:wght@400;600&family=Oswald:wght@400;600&family=Fira+Sans:wght@400;600&family=Fira+Code:wght@400;500&family=IBM+Plex+Mono:wght@400;600&family=Cabin:wght@400;600&family=Pacifico&family=Dancing+Script:wght@400;600&family=Great+Vibes&family=Bebas+Neue&family=Raleway+Dots&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="./Training/editor.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.10.1/dist/pptxgen.bundle.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
    <style>
      :root {
        --bg: #ffffff;
        --panel: #f9fafb;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --accent: #1a73e8;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: linear-gradient(145deg, #042c1a, #064a2c); color: #e8f5e9; }

      .layout { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
      .topbar { display:flex; align-items:center; gap:10px; padding: 8px 12px; background: rgba(255, 255, 255, 0.07); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,0.1); position: relative; z-index: 9000; }
      .topbar .btn { border:1px solid var(--border); background:#fff; border-radius:8px; padding:8px 12px; font-weight:700; cursor:pointer; transition: opacity .2s; }
      .topbar .btn:hover { opacity: 0.9; }
      .toolbar-btn { display: flex; align-items: center; justify-content: center; gap: 6px; min-width: 40px; padding: 8px 12px; }
      .toolbar-btn i { font-size: 16px; }
      .topbar .btn.blue { background:#1a73e8; border-color:#1a73e8; color:#fff; }
      .topbar .btn.gray { background:#f3f4f6; }
      .topbar .btn.red { background:#fee2e2; border-color:#fecaca; color:#991b1b; }
      .topbar .btn.light { background:#f9fafb; }
      .topbar .btn.green { background:#10b981; border-color:#059669; color:#06221e; }
      .topbar .btn.emerald { background:#10b981; border-color:#059669; color:#fff; }
      .save-as-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        z-index: 11000;
      }
      .save-as-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .save-as-toggle .caret {
        font-size: 11px;
        opacity: 0.75;
        margin-left: 2px;
      }
      .save-as-menu {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        padding: 8px 0;
        min-width: 200px;
        display: flex;
        flex-direction: column;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 12000;
      }
      .save-as-menu.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .save-as-option {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        font-weight: 600;
        text-align: left;
        padding: 10px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .save-as-option:hover {
        background: rgba(46, 213, 115, 0.2);
        color: #22c55e;
        transform: translateX(3px);
      }
      .save-as-option .option-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        font-size: 16px;
      }
      .save-as-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 13000;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        background: rgba(0, 0, 0, 0.6);
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
      .save-as-modal.show {
        display: flex !important;
        opacity: 1;
        visibility: visible;
      }
      .save-as-modal-content {
        width: min(90vw, 420px);
        max-width: 420px;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 18px;
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.6);
        padding: 24px;
        color: #ecfdf5;
        position: relative;
        margin: auto;
        transform: scale(0.96);
        transition: transform 0.2s ease;
      }
      .save-as-modal.show .save-as-modal-content {
        transform: scale(1);
      }
      .save-as-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(46, 213, 115, 0.2);
      }
      .save-as-modal-title {
        font-size: 20px;
        font-weight: 700;
        color: #ecfdf5;
        margin: 0;
      }
      .save-as-modal-close {
        background: transparent;
        border: none;
        color: #a9d9c1;
        font-size: 24px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }
      .save-as-modal-close:hover {
        background: rgba(46, 213, 115, 0.2);
        color: #22c55e;
      }
      .save-as-form-group {
        margin-bottom: 18px;
        display: block;
      }
      .save-as-form-group:last-of-type {
        margin-bottom: 0;
      }
      .save-as-form-label {
        display: block;
        margin-bottom: 8px;
        color: #a9d9c1;
        font-weight: 600;
        font-size: 14px;
      }
      .save-as-form-select,
      .save-as-form-input {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(0, 0, 0, 0.3);
        color: #ecfdf5;
        font-size: 14px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
        display: block;
        min-height: 44px;
      }
      .save-as-form-select option {
        background: rgba(8, 45, 30, 0.95);
        color: #ecfdf5;
        padding: 8px;
      }
      .save-as-form-select:focus,
      .save-as-form-input:focus {
        outline: none;
        border-color: rgba(46, 213, 115, 0.7);
        background: rgba(0, 0, 0, 0.4);
        box-shadow: 0 0 0 3px rgba(46, 213, 115, 0.1);
      }
      .save-as-form-select {
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23a9d9c1' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        padding-right: 40px;
        display: block;
        width: 100%;
      }
      .save-as-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 24px;
        padding-top: 20px;
        border-top: 1px solid rgba(46, 213, 115, 0.2);
      }
      .save-as-modal-btn {
        border: none;
        border-radius: 10px;
        padding: 10px 20px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .save-as-modal-btn-cancel {
        background: rgba(255, 255, 255, 0.08);
        color: #ecfdf5;
        border: 1px solid rgba(255, 255, 255, 0.18);
      }
      .save-as-modal-btn-cancel:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-1px);
      }
      .save-as-modal-btn-save {
        background: linear-gradient(135deg, rgba(46, 213, 115, 0.9) 0%, rgba(34, 197, 94, 0.9) 100%);
        color: #0f172a;
        border: 1px solid rgba(46, 213, 115, 0.5);
      }
      .save-as-modal-btn-save:hover {
        background: linear-gradient(135deg, rgba(46, 213, 115, 1) 0%, rgba(34, 197, 94, 1) 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(46, 213, 115, 0.3);
      }
      .save-as-modal-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .main { display:grid; grid-template-columns: 260px 1fr; gap: 12px; padding: 12px; min-height:0; }
      .main.show-translator {
        grid-template-columns: 260px 1fr 280px;
      }
      .sidebar { 
        background: rgba(0, 40, 20, 0.85); 
        backdrop-filter: blur(8px); 
        border-right: 1px solid rgba(255, 255, 255, 0.05); 
        border-radius:12px; 
        padding:10px; 
        padding-bottom: 60px; 
        overflow-y: auto; 
        overflow-x: visible; 
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .sidebar-view-toggle {
        margin-top: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
  transform: translateY(-6px);
      }
      .sidebar-view-button {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 10px;
        border: 1px solid rgba(46, 213, 115, 0.35);
        background: rgba(4, 30, 20, 0.7);
        color: #ecfdf5;
        font-weight: 600;
        padding: 6px 14px;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .sidebar-view-button:hover {
        background: rgba(46, 213, 115, 0.2);
        transform: translateY(-1px);
      }
      .sidebar-view-button.active {
        background: rgba(46, 213, 115, 0.4);
        color: #06221e;
        box-shadow: 0 8px 18px rgba(46, 213, 115, 0.25);
      }
      .sidebar.list-view .slide-preview-title {
        font-size: 14px;
        font-weight: 600;
      }
      .sidebar.thumbnail-view {
        gap: 14px;
      }
      .sidebar.thumbnail-view .slide-item {
        align-items: stretch;
        margin-bottom: 4px;
      }
      .sidebar.thumbnail-view .slide-preview {
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        width: 100%;
      }
      .slide-thumbnail-frame {
        position: relative;
        width: 100%;
        padding-top: 56.25%;
        border-radius: 12px;
        overflow: hidden;
        background: rgba(12, 38, 28, 0.9);
        border: 1px solid rgba(46, 213, 115, 0.25);
        box-shadow: inset 0 0 0 1px rgba(12, 83, 60, 0.25);
      }
      .slide-thumbnail-frame img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .slide-thumbnail-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 12px;
        color: rgba(236, 253, 245, 0.65);
        background: rgba(12, 83, 60, 0.65);
      }
      .sidebar.thumbnail-view .slide-preview-title {
        display: block;
        margin-top: 8px;
        font-size: 13px;
        font-weight: 600;
        color: #ecfdf5;
        text-align: center;
      }
      .sidebar.thumbnail-view .slide-preview.active .slide-thumbnail-frame {
        border-color: rgba(46, 213, 115, 0.8);
        box-shadow: 0 0 0 2px rgba(46, 213, 115, 0.25);
      }
      .sidebar.thumbnail-view .slide-action-bar {
        justify-content: center;
        margin-top: 8px;
      }
      .slide-item { 
        position: relative; 
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.3s ease;
      }
      .slide-item.dragging {
        opacity: 0.6;
        transform: scale(0.98);
      }
      .slide-preview { 
        background: rgba(255, 255, 255, 0.05); 
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px; 
        padding: 10px 14px; 
        cursor:pointer; 
        transition: all 0.3s ease; 
        color: #e8f5e9; 
        width: 100%;
      }
      .slide-preview:hover { background: rgba(255, 255, 255, 0.1); }
      .slide-preview.active { outline:2px solid #2ecc71; background: rgba(46, 204, 113, 0.2); }
      .slide-preview.drop-target {
        border-color: rgba(46, 213, 115, 0.65);
        background: rgba(46, 213, 115, 0.15);
      }
      .slide-preview.drop-target-before {
        box-shadow: inset 0 3px 0 rgba(46, 213, 115, 0.85);
      }
      .slide-preview.drop-target-after {
        box-shadow: inset 0 -3px 0 rgba(46, 213, 115, 0.85);
      }
      .transition-control-button {
        background: rgba(20, 60, 45, 0.9);
        border: 1px solid rgba(46, 213, 115, 0.35);
        color: #bbf7d0;
        font-size: 14px;
        border-radius: 8px;
        padding: 6px 8px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 40px;
        justify-content: center;
      }
      .transition-control-button .transition-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-icon i {
        font-size: 12px;
      }
      .transition-control-button .transition-icon svg {
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-caret {
        font-size: 10px;
        opacity: 0.75;
        margin-left: 0;
      }
      .transition-control-button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #22c55e;
        transform: translateY(-1px);
      }
      .transition-control-button.disabled,
      .transition-control-button:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none;
      }
      .transition-control-button.disabled:hover,
      .transition-control-button:disabled:hover {
        background: rgba(20, 60, 45, 0.9);
        color: #bbf7d0;
      }
      .transition-select {
        min-width: 150px;
      }
      .transition-select option {
        color: #111827;
      }
      .slide-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 140px;
        padding: 6px 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        z-index: 5000;
      }
      .slide-context-menu.show {
        display: flex;
      }
      .slide-context-menu button {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        text-align: left;
        padding: 10px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .slide-context-menu button:hover {
        background: rgba(46, 213, 115, 0.2);
        transform: translateX(2px);
      }
      .slide-context-menu button.active {
        background: rgba(46, 213, 115, 0.25);
        color: #22c55e;
      }
      .image-context-menu,
      .slide-canvas-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 180px;
        padding: 8px 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        z-index: 6000;
        opacity: 0;
        transform: translateY(-6px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }
      .image-context-menu.show,
      .slide-canvas-context-menu.show {
        display: flex;
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .image-context-menu button,
      .slide-canvas-context-menu button {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        text-align: left;
        padding: 10px 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .image-context-menu button:hover:not([disabled]),
      .slide-canvas-context-menu button:hover:not([disabled]) {
        background: rgba(46, 213, 115, 0.2);
        color: #22c55e;
        transform: translateX(2px);
      }
      .spell-suggestion-label {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(236, 253, 245, 0.65);
        padding: 6px 18px 4px;
      }
      .image-context-menu button[data-role="spell-suggestion"] {
        display: flex;
        gap: 12px;
        justify-content: space-between;
        align-items: center;
      }
      .image-context-menu button[data-role="spell-suggestion"] .spell-suggestion-hint {
        font-size: 11px;
        opacity: 0.6;
      }
      .image-context-menu button[data-role="spell-suggestion"][disabled] {
        opacity: 0.65;
        cursor: default;
        transform: none;
      }
      .image-context-menu button[disabled],
      .slide-canvas-context-menu button[disabled] {
        opacity: 0.55;
        cursor: default;
        transform: none;
      }
      .image-context-menu .menu-icon,
      .slide-canvas-context-menu .menu-icon {
        width: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        opacity: 0.8;
      }
      .slide-action-bar { 
        margin-top: 6px;
        display: flex;
        justify-content: center;
        gap: 8px;
        background: rgba(10, 60, 40, 0.9);
        border-radius: 8px;
        padding: 6px 0;
        height: 0;
        overflow: hidden;
        opacity: 0;
        transform: scaleY(0);
        transform-origin: top;
        transition: all 0.3s ease-in-out;
        width: 100%;
      }
      .slide-item:hover .slide-action-bar {
        height: auto;
        opacity: 1;
        transform: scaleY(1);
        margin-bottom: 10px;
      }
      .slide-action-bar button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-size: 17px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 36px;
      }
      .slide-action-bar button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #2ed573;
        transform: scale(1.1);
      }
      .slide-action-bar button i {
        font-size: 16px;
      }
      .slide-preview-title {
        display: block;
        font-weight: 600;
        font-size: 14px;
        letter-spacing: 0.3px;
      }
      .slide-preview-title.editing {
        background: rgba(46, 213, 115, 0.16);
        outline: 2px solid rgba(46, 213, 115, 0.7);
        border-radius: 6px;
        padding: 2px 6px;
        color: #e8f5e9;
      }

      /* Dark metallic gradient background */
      body.dark-theme {
        background: linear-gradient(135deg, #0b0b0b 0%, #0d0d0d 40%, #000000 100%) !important;
        background-attachment: fixed;
        background-repeat: no-repeat;
        background-size: cover;
        color: #eaeaea;
        position: relative;
      }

      body.dark-theme::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.05), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }

      body.dark-theme > * {
        position: relative;
        z-index: 1;
      }

      /* Light mode background with frosted glass effect */
      body.light-mode {
        background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,240,240,0.8)) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #1a1a1a;
        transition: all 0.3s ease-in-out;
        position: relative;
      }

      body.light-mode > * {
        position: relative;
        z-index: 1;
      }

      /* Card or container glass effect in light mode */
      body.light-mode .editor {
        background: rgba(255, 255, 255, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
      }

      body.light-mode .sidebar {
        background: rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-right: 1px solid rgba(0, 0, 0, 0.1);
      }

      body.light-mode .topbar {
        background: rgba(255, 255, 255, 0.4);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }

      /* Navigation and text colors in light mode */
      body.light-mode .tool,
      body.light-mode .tool-select,
      body.light-mode .slide-preview {
        color: #1a1a1a !important;
      }

      body.light-mode .slide-preview {
        background: rgba(255, 255, 255, 0.4);
        border-color: rgba(0, 0, 0, 0.15);
      }

      body.light-mode .tool-select::placeholder {
        color: #666 !important;
      }

      body.light-mode .title-box,
      body.light-mode .text-box {
        color: #000000 !important;
      }

      body.light-mode .topbar {
        color: #1a1a1a !important;
      }

      .editor { display:grid; grid-template-rows: auto 1fr; background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border-radius:12px; box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); }
      .toolbar { 
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        gap: 12px;
        background: rgba(5, 60, 35, 0.95);
        padding: 10px 20px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
      }
      .toolbar-tabs {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .toolbar-tab {
        background: rgba(9, 44, 28, 0.82);
        border: 1px solid rgba(42, 132, 96, 0.55);
        color: #d5fbe7;
        font-weight: 600;
        font-size: 15px;
        border-radius: 16px;
        padding: 9px 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: none;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 8px 18px rgba(5, 20, 14, 0.42);
        backdrop-filter: blur(10px);
        letter-spacing: 0.015em;
      }
      .toolbar-tab:hover {
        background: rgba(18, 74, 49, 0.88);
        transform: translateY(-1px);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), 0 10px 22px rgba(6, 32, 20, 0.52);
      }
      .toolbar-tab.active {
        background: linear-gradient(125deg, #1e6f4b 0%, #0f3f2b 65%, #0a291c 100%);
        color: #effff6;
        border-color: rgba(152, 255, 204, 0.75);
        transform: translateY(0);
        box-shadow: 0 12px 28px rgba(6, 27, 17, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.12);
      }
      .toolbar-tab:focus-visible {
        outline: 2px solid rgba(80, 200, 150, 0.9);
        outline-offset: 3px;
      }
      .toolbar-panels {
        position: relative;
      }
      .toolbar-panel { display: none; align-items: center; gap: 12px; flex-wrap: nowrap; opacity: 0; transform: translateY(4px); transition: opacity 0.2s ease, transform 0.2s ease; }
      .toolbar-panel.active { display: flex; opacity: 1; transform: translateY(0); }
      .toolbar-panel[data-tab-panel="view"] { margin-top: 0; }
      .toolbar-panel[hidden] {
        display: none !important;
      }
      .transition-controls {
        display: flex;
        align-items: flex-end;
        flex-wrap: wrap;
        gap: 12px;
      }
      .transition-field {
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        gap: 4px;
        min-width: 160px;
      }
      .transition-label {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(232, 245, 233, 0.82);
      }
      .transition-field .tool-select {
        width: 100%;
      }
      .transition-select-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        height: 40px;
        padding: 0 12px;
        border-radius: 10px;
        border: 1px solid rgba(46, 213, 115, 0.25);
        background: rgba(15, 60, 45, 0.65);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      }
      .transition-select-wrapper:hover {
        background: rgba(27, 94, 60, 0.75);
        border-color: rgba(46, 213, 115, 0.45);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.22);
        transform: translateY(-1px);
      }
      .transition-select-wrapper:focus-within {
        border-color: rgba(46, 213, 115, 0.6);
        box-shadow: 0 0 0 2px rgba(46, 213, 115, 0.25);
      }
      .transition-select-icon,
      .transition-select-caret {
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(232, 245, 233, 0.85);
      }
      .transition-select-icon i {
        font-size: 15px;
      }
      .transition-select-caret i {
        font-size: 12px;
      }
      .transition-select {
        flex: 1;
        min-width: 0;
        height: 100%;
        border: none;
        background: transparent;
        color: #ecfdf5;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        appearance: none;
        padding: 0;
        margin: 0;
        line-height: 1;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .transition-select:focus {
        outline: none;
      }
      .transition-duration-control {
        display: flex;
        align-items: center;
        gap: 6px;
        height: 40px;
      }
      .transition-duration-input {
        width: 88px;
        text-align: right;
      }
      .transition-duration-suffix {
        font-size: 13px;
        font-weight: 600;
        color: rgba(232, 245, 233, 0.85);
      }
      .transition-apply-all-button {
        gap: 8px;
        height: 40px;
        padding: 0 16px;
        margin-left: auto;
        flex-shrink: 0;
        align-self: flex-end;
      }
      .animation-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        width: 100%;
      }
      .animation-controls {
        display: flex;
        align-items: flex-end;
        flex-wrap: wrap;
        gap: 12px;
      }
      .animation-field {
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        gap: 4px;
        min-width: 160px;
      }
      .animation-field .animation-label {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(232, 245, 233, 0.82);
      }
      .animation-duration-control {
        display: flex;
        align-items: center;
        gap: 6px;
        height: 40px;
      }
      .animation-duration-control input {
        width: 88px;
        text-align: right;
      }
      .animation-duration-suffix {
        font-size: 13px;
        font-weight: 600;
        color: rgba(232, 245, 233, 0.85);
      }
      .animation-assign-button,
      .animation-remove-button {
        height: 40px;
        padding: 0 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      .animation-sequence-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 100%;
      }
      .animation-sequence-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: rgba(232, 245, 233, 0.9);
        font-weight: 600;
        font-size: 14px;
      }
      .animation-sequence-hint {
        font-size: 12px;
        font-weight: 500;
        color: rgba(232, 245, 233, 0.6);
      }
      .animation-sequence-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 220px;
        overflow-y: auto;
        padding-right: 4px;
      }
      .animation-sequence-empty {
        font-size: 13px;
        color: rgba(232, 245, 233, 0.65);
        font-style: italic;
      }
      .animation-sequence-item {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(16, 61, 46, 0.75);
        border: 1px solid rgba(46, 213, 115, 0.25);
        border-radius: 10px;
        padding: 10px 12px;
        cursor: grab;
        transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      }
      .animation-sequence-item:hover {
        border-color: rgba(46, 213, 115, 0.45);
        background: rgba(27, 94, 60, 0.75);
        transform: translateY(-1px);
      }
      .animation-sequence-item.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }
      .animation-sequence-item.drop-target {
        border-color: rgba(46, 213, 115, 0.65);
        box-shadow: 0 0 0 2px rgba(46, 213, 115, 0.25);
      }
      .animation-sequence-item.selected {
        border-color: rgba(46, 213, 115, 0.75);
        background: rgba(27, 94, 60, 0.85);
      }
      .animation-item-order {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 8px;
        background: rgba(46, 213, 115, 0.15);
        color: rgba(46, 213, 115, 0.95);
        font-weight: 700;
        font-size: 13px;
      }
      .animation-item-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex: 1;
        min-width: 0;
      }
      .animation-item-title {
        font-weight: 600;
        font-size: 14px;
        color: rgba(232, 245, 233, 0.95);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .animation-item-meta {
        font-size: 12px;
        color: rgba(232, 245, 233, 0.7);
      }
      .animation-item-remove {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 8px;
        border: 1px solid rgba(239, 68, 68, 0.35);
        color: rgba(248, 113, 113, 0.95);
        background: rgba(127, 29, 29, 0.35);
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .animation-item-remove:hover {
        background: rgba(239, 68, 68, 0.35);
        border-color: rgba(239, 68, 68, 0.55);
        transform: translateY(-1px);
      }
      .animation-sequence-container.hidden {
        display: none;
      }
      .animation-sequence-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .animation-sequence-close {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        background: rgba(15, 40, 30, 0.65);
        border: 1px solid rgba(46, 213, 115, 0.25);
        color: rgba(232, 245, 233, 0.85);
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .animation-sequence-close:hover {
        background: rgba(27, 94, 60, 0.75);
        border-color: rgba(46, 213, 115, 0.45);
        transform: translateY(-1px);
      }
      .animation-order-badge {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: rgba(15, 40, 30, 0.78);
        border: 1px solid rgba(255, 255, 255, 0.35);
        color: rgba(255, 255, 255, 0.92);
        font-size: 11px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        cursor: pointer;
        z-index: 2000;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        transition: background 0.2s ease, transform 0.2s ease;
        user-select: none;
      }
      .animation-order-badge:hover {
        background: rgba(27, 94, 60, 0.82);
        transform: translateY(-1px);
      }
      .presentation-animation-hidden {
        opacity: 0 !important;
        pointer-events: none !important;
      }
      .presentation-animation-effect-fade-in {
        animation: animationFadeIn var(--animation-duration, 0.7s) ease-out forwards;
      }
      .presentation-animation-effect-pop-up {
        animation: animationPopUp var(--animation-duration, 0.7s) cubic-bezier(0.26, 0.72, 0, 1.02) forwards;
      }
      .presentation-animation-effect-slide-in-right {
        animation: animationSlideInRight var(--animation-duration, 0.7s) ease-out forwards;
      }
      .presentation-animation-effect-slide-in-left {
        animation: animationSlideInLeft var(--animation-duration, 0.7s) ease-out forwards;
      }
      .presentation-animation-effect-slide-in-up {
        animation: animationSlideInUp var(--animation-duration, 0.7s) ease-out forwards;
      }
      @keyframes animationFadeIn {
        0% { opacity: 0; }
        100% { opacity: 1; }
      }
      @keyframes animationPopUp {
        0% { opacity: 0; transform: var(--animation-base-transform, none) scale(0.7); }
        60% { opacity: 1; transform: var(--animation-base-transform, none) scale(1.05); }
        100% { opacity: 1; transform: var(--animation-base-transform, none) scale(1); }
      }
      @keyframes animationSlideInRight {
        0% { opacity: 0; transform: var(--animation-base-transform, none) translateX(40px); }
        100% { opacity: 1; transform: var(--animation-base-transform, none); }
      }
      @keyframes animationSlideInLeft {
        0% { opacity: 0; transform: var(--animation-base-transform, none) translateX(-40px); }
        100% { opacity: 1; transform: var(--animation-base-transform, none); }
      }
      @keyframes animationSlideInUp {
        0% { opacity: 0; transform: var(--animation-base-transform, none) translateY(40px); }
        100% { opacity: 1; transform: var(--animation-base-transform, none); }
      }
      .transition-preview-overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(4px);
        z-index: 12050;
        padding: 24px;
      }
      .transition-preview-overlay.show {
        display: flex;
      }
      .transition-preview-stage {
        position: relative;
        width: min(960px, 80vw);
        aspect-ratio: 16 / 9;
        background: rgba(8, 45, 30, 0.88);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 16px;
        box-shadow: 0 22px 44px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }
      .transition-preview-stage .presentation-slide {
        width: 100%;
        height: 100%;
      }
      .toolbar-panel .group-title {
        font-weight: 700;
        color: #e8f5e9;
        margin-right: 8px;
      }
      .toolbar-panel .tool-divider {
        width: 1px;
        height: 28px;
        background: rgba(255, 255, 255, 0.15);
        margin: 0 4px;
      }
      .tool[disabled],
      .tool[aria-disabled="true"] {
        opacity: 0.5;
        cursor: default;
        pointer-events: none;
      }
      .tool { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-weight: 600;
        font-size: 15px;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .tool.present-button {
        margin-left: 12px;
        padding: 8px 16px;
        gap: 0;
        font-size: 15px;
        border: 2px solid rgba(255, 255, 255, 0.65);
        background: transparent;
        color: #f8fafc;
        min-width: 52px;
      }
      .tool.present-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.85);
        transform: translateY(-1px);
      }
      .tool.present-button svg {
        width: 18px;
        height: 18px;
        display: block;
      }
      .tool:hover { 
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .tool.active { 
        background: #1c7c54;
        color: #fff;
        border-color: #2ed573;
      }
      .tool i {
        font-size: 14px;
      }
      .tool.spell-check-toggle {
        gap: 10px;
        padding: 8px 20px;
        justify-content: flex-start;
      }
      .tool.spell-check-toggle .tool-label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
      }
      .tool.spell-check-toggle .tool-state {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #2ed573;
      }
      .tool.spell-check-toggle:not(.active) .tool-state {
        color: #fca5a5;
      }
      .translator-panel {
        position: relative;
        display: flex;
        flex-direction: column;
        background: rgba(0, 40, 20, 0.85);
        border-left: 1px solid rgba(46, 213, 115, 0.25);
        border-radius: 12px;
        padding: 12px;
        gap: 10px;
        min-width: 260px;
        color: #ecfdf5;
      }
      .translator-panel.hidden {
        display: none;
      }
      .translator-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .translator-title {
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 0.04em;
      }
      .translator-close {
        background: transparent;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 4px 6px;
        border-radius: 6px;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .translator-close:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateY(-1px);
      }
      .translator-body {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex: 1;
      }
      .translator-source,
      .translator-result {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .translator-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .translator-label {
        font-size: 11px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        font-weight: 700;
        color: rgba(236, 253, 245, 0.7);
      }
      .translator-textarea {
        min-height: 80px;
        border-radius: 10px;
        border: 1px solid rgba(46, 213, 115, 0.35);
        background: rgba(4, 24, 16, 0.8);
        color: #ecfdf5;
        font-size: 13px;
        line-height: 1.5;
        padding: 8px 10px;
        resize: vertical;
        font-family: inherit;
      }
      .translator-textarea[readonly] {
        background: rgba(4, 24, 16, 0.6);
      }
      .translator-select {
        appearance: none;
        -webkit-appearance: none;
        width: 100%;
        height: 40px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.08);
        color: #ecfdf5;
        font-size: 14px;
        font-weight: 600;
        padding: 0 14px;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        cursor: pointer;
      }
      .translator-select:hover {
        background: rgba(255, 255, 255, 0.18);
        border-color: rgba(46, 213, 115, 0.45);
        transform: translateY(-1px);
      }
      .translator-select:focus {
        outline: 2px solid #2ed573;
        outline-offset: 2px;
      }
      .translator-select option {
        background: rgba(4, 24, 16, 0.95);
        color: #ecfdf5;
      }
      .translator-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }
      .translator-actions .tool {
        min-width: 80px;
      }
      .translator-status {
        font-size: 12px;
        color: rgba(236, 253, 245, 0.75);
      }
      .tool svg {
        width: 18px;
        height: 18px;
      }
      .new-slide-toolbar-button {
        gap: 8px;
        padding: 8px 16px;
        white-space: nowrap;
      }
      .new-slide-button-icon i {
        font-size: 16px;
      }
      .new-slide-button-label {
        font-size: 14px;
        font-weight: 600;
        line-height: 1;
        color: inherit;
      }
      .font-picker-button {
        position: relative;
        min-width: 140px;
        padding: 8px 16px;
        justify-content: center;
      }
      .font-picker-label {
        font-size: 15px;
        font-weight: 600;
        line-height: 1.2;
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .color-controls {
        display: flex;
        gap: 8px;
      }
      .color-tool-button {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
        padding: 8px 12px;
      }
      .color-tool-button .color-bar {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 26px;
        height: 4px;
        border-radius: 999px;
        background: currentColor;
        border: 1px solid rgba(255, 255, 255, 0.3);
        pointer-events: none;
      }
      .font-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 220px;
        gap: 4px;
      }
      .font-dropdown.show {
        display: flex;
      }
      .font-option {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        text-align: left;
        transition: all 0.2s ease;
        font-size: 15px;
      }
      .font-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .font-option.active {
        background: #1c7c54;
        border-color: #2ed573;
        color: #fff;
      }
      .shape-picker-button,
      .chart-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .image-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .video-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .table-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .shape-dropdown,
      .chart-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 240px;
        gap: 6px;
      }
      .shape-dropdown.show,
      .chart-dropdown.show {
        display: flex;
      }
      .table-insert-panel {
        position: fixed;
        display: flex;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 12px;
        gap: 10px;
        z-index: 4100;
        width: 220px;
        color: #e8f5e9;
        transition: opacity 0.2s ease, transform 0.2s ease;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px) scale(0.96);
        pointer-events: none;
      }
      .table-insert-panel.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .table-insert-panel h4 {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 0.3px;
        color: #a7f3d0;
        cursor: grab;
        user-select: none;
      }
      .table-insert-panel.dragging h4 {
        cursor: grabbing;
      }
      .table-insert-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      .table-insert-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .table-insert-field label {
        font-size: 13px;
        font-weight: 600;
        color: rgba(232, 245, 233, 0.75);
      }
      .table-insert-field input {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 6px 8px;
        color: #e8f5e9;
        font-size: 14px;
        font-weight: 600;
      }
      .table-insert-field input:focus {
        outline: none;
        border-color: rgba(46, 213, 115, 0.6);
        box-shadow: 0 0 0 2px rgba(46, 213, 115, 0.25);
      }
      .table-insert-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .table-insert-actions button {
        background: rgba(46, 213, 115, 0.25);
        border: 1px solid rgba(46, 213, 115, 0.5);
        color: #bbf7d0;
        font-weight: 600;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }
      .table-insert-actions button:hover {
        background: rgba(46, 213, 115, 0.35);
        transform: translateY(-1px);
      }
      .table-element {
        position: absolute;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.55);
        border-radius: 8px;
        overflow: visible;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
        cursor: move;
        color: #0f172a;
      }
      .table-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.3);
      }
      .table-drag-handle {
        position: absolute;
        left: 50%;
        bottom: -28px;
        transform: translateX(-50%);
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        background: rgba(4, 44, 28, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.32);
        box-shadow: 0 14px 28px rgba(15, 23, 42, 0.35);
        color: #c4e3ff;
        cursor: grab;
        user-select: none;
        pointer-events: auto;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
        opacity: 0;
        visibility: hidden;
        transform-origin: center;
        transform: translateX(-50%) scale(0.88);
      }
      .table-drag-handle i {
        font-size: 14px;
        pointer-events: none;
      }
      .table-drag-handle:hover {
        transform: translateX(-50%) translateY(-1px);
        background: rgba(4, 44, 28, 0.98);
        border-color: rgba(148, 232, 203, 0.42);
        box-shadow: 0 18px 36px rgba(15, 23, 42, 0.45);
      }
      .table-drag-handle:active {
        cursor: grabbing;
        background: rgba(26, 115, 232, 0.4);
        border-color: rgba(59, 130, 246, 0.55);
        transform: translateX(-50%) scale(0.97);
      }
      .table-element.selected .table-drag-handle {
        border-color: rgba(59, 130, 246, 0.45);
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) scale(1);
      }
      .table-element table {
        width: 100%;
        height: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }
      .table-element td,
      .table-element th {
        border: 1px solid rgba(15, 118, 110, 0.25);
        padding: 8px;
        min-width: 40px;
        min-height: 28px;
        background: rgba(236, 253, 245, 0.75);
        color: #0f172a;
      }
      .table-element .table-cell-selected {
        position: relative;
      }
      .table-element .table-cell-selected::after {
        content: "";
        position: absolute;
        inset: -2px;
        border-radius: 6px;
        border: 2px solid rgba(46, 213, 115, 0.7);
        background: rgba(134, 239, 172, 0.2);
        pointer-events: none;
        box-shadow: 0 0 0 1px rgba(12, 83, 60, 0.15);
      }
      .table-element td:focus,
      .table-element th:focus {
        outline: none;
        background: rgba(134, 239, 172, 0.35);
      }
      .table-element td,
      .table-element th {
        position: relative;
      }
      .table-element .table-resize-handle {
        position: absolute;
        background: rgba(46, 213, 115, 0.6);
        border-radius: 4px;
        z-index: 6;
        opacity: 0;
        transition: opacity 0.18s ease, transform 0.18s ease;
      }
      .table-element .table-resize-handle::after {
        content: '';
        position: absolute;
        inset: 0;
        background: rgba(46, 213, 115, 0.75);
        border-radius: inherit;
      }
      .table-element .table-resize-handle.table-resize-col {
        width: 6px;
        top: 0;
        bottom: 0;
        cursor: col-resize;
        transform: translateX(-3px);
      }
      .table-element .table-resize-handle.table-resize-row {
        height: 6px;
        left: 0;
        right: 0;
        cursor: row-resize;
        transform: translateY(-3px);
      }
      .table-element.selected .table-resize-handle,
      .table-element .table-resize-handle.active,
      .table-element:hover .table-resize-handle {
        opacity: 1;
      }
      .shape-option,
      .chart-option {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .shape-option:hover,
      .chart-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .shape-option svg {
        width: 36px;
        height: 36px;
      }
      .shape-option-preview {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .shape-option-label,
      .chart-option-label {
        font-size: 15px;
        font-weight: 600;
      }
      .chart-option-preview {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chart-option-preview .chart-mini {
        width: 100%;
        height: 100%;
        border-radius: 10px;
        background: rgba(26, 115, 232, 0.18);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }
      .chart-option-preview .chart-mini.bar::before,
      .chart-option-preview .chart-mini.bar::after {
        content: '';
        position: absolute;
        bottom: 6px;
        width: 8px;
        background: rgba(37, 204, 247, 0.9);
        border-radius: 4px 4px 0 0;
      }
      .chart-option-preview .chart-mini.bar::before {
        left: 10px;
        height: 16px;
        background: rgba(56, 189, 248, 0.95);
      }
      .chart-option-preview .chart-mini.bar::after {
        right: 10px;
        height: 26px;
        background: rgba(14, 165, 233, 0.95);
      }
      .chart-option-preview .chart-mini.bar span {
        position: absolute;
        left: 18px;
        bottom: 6px;
        width: 8px;
        height: 20px;
        border-radius: 4px 4px 0 0;
        background: rgba(6, 182, 212, 0.95);
      }
      .chart-option-preview .chart-mini.line {
        position: relative;
        background: transparent;
      }
      .chart-option-preview .chart-mini.line::before {
        content: '';
        position: absolute;
        inset: 10px 8px 12px 8px;
        border: 2px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
      }
      .chart-option-preview .chart-mini.line span {
        position: absolute;
        left: 8px;
        right: 8px;
        top: 50%;
        height: 2px;
        background: linear-gradient(90deg, #38bdf8, #a855f7);
        transform: rotate(-12deg);
        border-radius: 999px;
      }
      .chart-option-preview .chart-mini.pie {
        border-radius: 50%;
        background: conic-gradient(#60a5fa 0deg 140deg, #34d399 140deg 260deg, #fbbf24 260deg 360deg);
        position: relative;
      }
      .chart-option-preview .chart-mini.pie.chart-mini--donut::after {
        content: '';
        position: absolute;
        inset: 22%;
        background: rgba(12, 25, 25, 0.06);
        border-radius: 50%;
        box-shadow: inset 0 2px 4px rgba(15, 23, 42, 0.18);
      }
      .chart-option-preview .chart-mini.pie.chart-mini--outline {
        box-shadow: inset 0 0 0 5px rgba(255, 255, 255, 0.85);
      }
      .chart-element {
        background: #fff;
        border-radius: 12px;
        border: 2px solid transparent;
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25);
        cursor: move;
        flex-direction: column;
        padding: 16px;
        gap: 12px;
        color: #0f172a;
      }
      .chart-element:hover,
      .chart-element.selected,
      .chart-element.resizing {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .chart-element .chart-title {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.3px;
        color: #1e293b;
      }
      .chart-element .chart-visual {
        flex: 1;
        width: 100%;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 10px;
      }
      .chart-element .chart-bars {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 14px;
        width: 100%;
        height: 100%;
        padding: 12px 0 4px;
        box-sizing: border-box;
      }
      .chart-element .chart-bar {
        width: 32px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
        transition: transform 0.18s ease;
      }
      .chart-element .chart-bar:hover {
        transform: translateY(-4px);
      }
      .chart-element .chart-bars--rounded .chart-bar {
        box-shadow: 0 10px 22px rgba(59, 130, 246, 0.22);
      }
      .chart-element .chart-bars--gradient .chart-bar {
        box-shadow: 0 12px 24px rgba(14, 165, 233, 0.25);
      }
      .chart-element .chart-bar-wrapper {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        height: 100%;
      }
      .chart-element .chart-bar-value {
        position: absolute;
        bottom: 100%;
        transform: translateY(-6px);
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        pointer-events: none;
        white-space: nowrap;
      }
      .chart-element .chart-pie {
        width: 140px;
        height: 140px;
        border-radius: 50%;
        background: conic-gradient(#60a5fa 0deg 150deg, #34d399 150deg 270deg, #fbbf24 270deg 360deg);
        box-shadow: 0 10px 24px rgba(59, 130, 246, 0.35);
        position: relative;
        overflow: hidden;
      }
      .chart-element .chart-pie::after {
        content: '';
        display: none;
      }
      .chart-element .chart-pie.chart-pie--donut::after {
        display: block;
        position: absolute;
        inset: 18%;
        background: #fff;
        border-radius: 50%;
        box-shadow: inset 0 6px 18px rgba(15, 23, 42, 0.12);
      }
      .chart-element .chart-pie.chart-pie--outline {
        box-shadow: 0 12px 28px rgba(15, 118, 110, 0.3), inset 0 0 0 14px rgba(255, 255, 255, 0.85);
      }
      .chart-element .chart-pie.chart-pie--outline::after {
        display: none;
      }
      .chart-element .chart-pie-wrapper {
        position: relative;
        width: 140px;
        height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chart-element .chart-pie-labels {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .chart-element .chart-pie-label {
        position: absolute;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        white-space: nowrap;
      }
      .chart-element .chart-line-wrapper {
        position: relative;
        width: 240px;
        height: 140px;
      }
      .chart-element .chart-line-svg {
        width: 240px;
        height: 140px;
      }
      .chart-element .chart-line-path {
        fill: none;
        stroke-width: 3;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .chart-element .chart-line-path.line-smooth {
        stroke-linejoin: round;
      }
      .chart-element .chart-line-path.line-dotted {
        stroke-dasharray: 6 6;
      }
      .chart-element .chart-line-point {
        stroke: #ffffff;
        stroke-width: 2;
      }
      .chart-element .chart-line-value {
        position: absolute;
        transform: translate(-50%, -120%);
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        pointer-events: none;
        white-space: nowrap;
      }
      .chart-element .chart-line-axis {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .chart-element .chart-line-axis-label {
        position: absolute;
        bottom: 0;
        transform: translate(-50%, 110%);
        font-size: 12px;
        font-weight: 600;
        color: #4b5563;
        white-space: nowrap;
      }
      .chart-element .chart-legend {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .chart-element .chart-legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: #334155;
        font-weight: 600;
      }
      .chart-element .chart-legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }
      .chart-data-editor {
        position: fixed;
        top: 120px;
        right: 36px;
        width: 300px;
        background: #ffffff;
        border-radius: 14px;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.22);
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 16px;
        display: none;
        z-index: 4500;
        font-size: 13px;
        color: #0f172a;
        cursor: default;
      }
      .chart-data-editor.visible {
        display: block;
      }
      .chart-data-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        cursor: move;
      }
      .chart-data-title {
        font-size: 15px;
        font-weight: 700;
        color: #1f2937;
        letter-spacing: 0.2px;
      }
      .chart-data-close {
        border: none;
        background: rgba(15, 23, 42, 0.06);
        color: #1f2937;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .chart-data-close:hover {
        background: rgba(26, 115, 232, 0.12);
        transform: translateY(-1px);
      }
      .chart-data-subtitle {
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.2px;
        text-transform: uppercase;
        margin-bottom: 12px;
      }
      .chart-data-variant {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      .chart-data-variant-label {
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.35px;
        text-transform: uppercase;
      }
      .chart-data-variant-options {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .chart-data-variant-button {
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: rgba(240, 249, 255, 0.85);
        color: #1f2937;
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .chart-data-variant-button:hover {
        background: rgba(59, 130, 246, 0.12);
        border-color: rgba(59, 130, 246, 0.35);
        color: #1d4ed8;
      }
      .chart-data-variant-button.active {
        background: rgba(59, 130, 246, 0.16);
        border-color: rgba(59, 130, 246, 0.55);
        color: #1d4ed8;
        box-shadow: 0 4px 10px rgba(59, 130, 246, 0.15);
      }
      .chart-data-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 12px;
      }
      .chart-data-toggle-label {
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.35px;
      }
      .chart-data-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
      }
      .chart-data-toggle.hidden {
        display: none;
      }
      .chart-element .chart-bars {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 14px;
        width: 100%;
        height: 100%;
        padding: 12px 0 4px;
        box-sizing: border-box;
      }
      .chart-element .chart-bar {
        width: 32px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
        transition: transform 0.18s ease;
      }
      .chart-element .chart-bar:hover {
        transform: translateY(-4px);
      }
      .chart-element .chart-bars--rounded .chart-bar {
        box-shadow: 0 10px 22px rgba(59, 130, 246, 0.22);
      }
      .chart-element .chart-bars--gradient .chart-bar {
        box-shadow: 0 12px 24px rgba(14, 165, 233, 0.25);
      }
      .chart-element .chart-bar-wrapper {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        height: 100%;
      }
      .chart-element .chart-bar-value {
        position: absolute;
        bottom: 100%;
        transform: translateY(-6px);
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        pointer-events: none;
        white-space: nowrap;
      }
      .chart-element .chart-pie-wrapper {
        position: relative;
        width: 140px;
        height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chart-element .chart-pie-labels {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .chart-element .chart-pie-label {
        position: absolute;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        white-space: nowrap;
      }
      .chart-data-table-wrapper {
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(248, 250, 252, 0.9);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65);
        margin-bottom: 14px;
      }
      .chart-data-table {
        width: 100%;
        border-collapse: collapse;
      }
      .chart-data-table thead {
        background: rgba(15, 118, 110, 0.08);
      }
      .chart-data-table th {
        text-align: left;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.55);
        padding: 8px 10px;
      }
      .chart-data-table th:nth-child(3) {
        text-align: center;
      }
      .chart-data-table td {
        padding: 8px 10px;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
        background: rgba(255, 255, 255, 0.85);
      }
      .chart-data-table td:nth-child(3) {
        text-align: center;
      }
      .chart-data-input {
        width: 100%;
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 13px;
        font-weight: 600;
        color: #0f172a;
        background: rgba(248, 250, 252, 0.9);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .chart-data-input::placeholder {
        color: rgba(15, 23, 42, 0.35);
      }
      .chart-data-input:focus {
        outline: none;
        border-color: rgba(26, 115, 232, 0.4);
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.25);
        background: #ffffff;
      }
      .chart-data-color-input {
        width: 42px;
        height: 32px;
        border: 1px solid rgba(15, 23, 42, 0.18);
        border-radius: 8px;
        padding: 0;
        background: #ffffff;
        cursor: pointer;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }
      .chart-data-color-input::-webkit-color-swatch {
        border: none;
        border-radius: 6px;
      }
      .chart-data-color-input::-webkit-color-swatch-wrapper {
        padding: 4px;
        border-radius: 6px;
      }
      .chart-data-color-input:focus {
        outline: none;
        border-color: rgba(26, 115, 232, 0.4);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      .chart-data-table td:nth-child(3) .chart-data-color-input {
        margin: 0 auto;
      }
      .chart-data-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .chart-data-actions button {
        flex: 1;
        background: rgba(46, 213, 115, 0.16);
        border: 1px solid rgba(46, 213, 115, 0.35);
        color: #065f46;
        font-weight: 700;
        font-size: 13px;
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
      }
      .chart-data-actions button:hover:not(:disabled) {
        background: rgba(46, 213, 115, 0.26);
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(16, 185, 129, 0.25);
      }
      .chart-data-actions button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .chart-data-line-editor {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .chart-data-line-editor.hidden {
        display: none;
      }
      .chart-line-series-section,
      .chart-line-points-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .chart-line-series-header,
      .chart-line-points-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .chart-line-series-title,
      .chart-line-points-title {
        font-size: 13px;
        font-weight: 700;
        color: #0f172a;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .chart-line-series-header button,
      .chart-line-points-actions button {
        background: rgba(59, 130, 246, 0.12);
        border: 1px solid rgba(59, 130, 246, 0.28);
        color: #1d4ed8;
        font-weight: 700;
        font-size: 12px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
      }
      .chart-line-series-header button:hover,
      .chart-line-points-actions button:hover {
        background: rgba(59, 130, 246, 0.18);
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(37, 99, 235, 0.18);
      }
      .chart-line-points-actions {
        display: flex;
        gap: 8px;
      }
      .chart-line-series-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .chart-line-series-item {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px;
        align-items: center;
      }
      .chart-line-series-remove {
        background: rgba(239, 68, 68, 0.12);
        border: 1px solid rgba(239, 68, 68, 0.28);
        color: #b91c1c;
        font-weight: 700;
        font-size: 12px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
      }
      .chart-line-series-remove:hover {
        background: rgba(239, 68, 68, 0.18);
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(220, 38, 38, 0.18);
      }
      .chart-line-values-table-wrapper {
        overflow-x: auto;
      }
      .chart-line-values-table th,
      .chart-line-values-table td {
        white-space: nowrap;
      }
      .chart-line-point-label {
        width: 140px;
      }
      .canvas-marquee {
        position: absolute;
        border: 1px dashed rgba(37, 99, 235, 0.65);
        background: rgba(59, 130, 246, 0.16);
        pointer-events: none;
        z-index: 2000;
      }
      .group-selection-frame {
        position: absolute;
        border: 1px solid rgba(37, 99, 235, 0.8);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.65);
        pointer-events: auto;
        background: rgba(59, 130, 246, 0.05);
        z-index: 1999;
      }
      .group-selection-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        border-radius: 4px;
        border: 2px solid #fff;
        background: rgba(37, 99, 235, 0.9);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.65);
        pointer-events: auto;
      }
      .group-selection-handle[data-handle="top-left"] {
        top: -7px;
        left: -7px;
        cursor: nwse-resize;
      }
      .group-selection-handle[data-handle="top-right"] {
        top: -7px;
        right: -7px;
        cursor: nesw-resize;
      }
      .group-selection-handle[data-handle="bottom-left"] {
        bottom: -7px;
        left: -7px;
        cursor: nesw-resize;
      }
      .group-selection-handle[data-handle="bottom-right"] {
        bottom: -7px;
        right: -7px;
        cursor: nwse-resize;
      }
      .group-selection-handle[data-handle="top"] {
        top: -7px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }
      .group-selection-handle[data-handle="bottom"] {
        bottom: -7px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }
      .group-selection-handle[data-handle="left"] {
        left: -7px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
      .group-selection-handle[data-handle="right"] {
        right: -7px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
      .group-selected {
        outline: 2px solid rgba(37, 99, 235, 0.35);
      }
      .chart-data-empty {
        text-align: center;
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.45);
        padding: 12px 0;
      }
      .shape-element,
      .chart-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        color: #e8f5e9;
        user-select: none;
        transform-origin: center center;
      }
      .shape-element svg,
      .chart-element svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .image-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        cursor: move;
        transform-origin: center center;
        border: 2px solid transparent;
        border-radius: 8px;
        transition: border-color 0.15s ease;
      }
      .image-element img {
        width: 100%;
        height: 100%;
        object-fit: fill;
        border-radius: inherit;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.3);
        pointer-events: none;
      }
      .image-element:hover,
      .image-element.resizing,
      .image-element.selected {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .image-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .video-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        cursor: move;
        transform-origin: center center;
        border: 2px solid transparent;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.45);
        transition: border-color 0.15s ease;
      }
      .video-element video {
        width: 100%;
        height: 100%;
        border-radius: inherit;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.3);
        background: #000;
        position: relative;
        z-index: 1;
      }
      .video-element.selected video,
      .video-element.resizing video {
        pointer-events: none;
      }
      .video-element:hover,
      .video-element.resizing,
      .video-element.selected {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .video-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .text-box,
      .title-box,
      .additional-text-box {
        transform-origin: center center;
      }
      .shape-element.selected,
      .chart-element.selected {
        outline: 2px solid #1a73e8;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .shape-element .resize-edge,
      .chart-element .resize-edge,
      .image-element .resize-edge,
      .text-box .resize-edge,
      .title-box .resize-edge,
      .additional-text-box .resize-edge {
        position: absolute;
        border-radius: 50%;
        border: 2px solid rgba(14, 165, 233, 0.9);
        background: rgba(230, 249, 255, 0.98);
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
        opacity: 0;
        transform: translate(-50%, -50%);
        transition: opacity 0.15s ease;
      }
      .shape-element.selected .resize-edge,
      .chart-element.selected .resize-edge,
      .image-element.selected .resize-edge,
      .video-element.selected .resize-edge,
      .text-box.selected .resize-edge,
      .title-box.selected .resize-edge,
      .additional-text-box.selected .resize-edge {
        opacity: 1;
      }
      .image-element:hover .resize-edge,
      .image-element.resizing .resize-edge {
        opacity: 1;
      }
      .video-element:hover .resize-edge,
      .video-element.resizing .resize-edge {
        opacity: 1;
      }
      .shape-element .resize-edge.side,
      .chart-element .resize-edge.side,
      .image-element .resize-edge.side,
      .video-element .resize-edge.side,
      .text-box .resize-edge.side,
      .title-box .resize-edge.side,
      .additional-text-box .resize-edge.side {
        width: 14px;
        height: 14px;
        background: rgba(219, 246, 255, 0.9);
      }
      .shape-element .resize-edge.corner,
      .chart-element .resize-edge.corner,
      .image-element .resize-edge.corner,
      .video-element .resize-edge.corner,
      .text-box .resize-edge.corner,
      .title-box .resize-edge.corner,
      .additional-text-box .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-element .resize-edge.top,
      .chart-element .resize-edge.top,
      .image-element .resize-edge.top,
      .video-element .resize-edge.top,
      .text-box .resize-edge.top,
      .title-box .resize-edge.top,
      .additional-text-box .resize-edge.top {
        top: -12px;
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.bottom,
      .chart-element .resize-edge.bottom,
      .image-element .resize-edge.bottom,
      .video-element .resize-edge.bottom,
      .text-box .resize-edge.bottom,
      .title-box .resize-edge.bottom,
      .additional-text-box .resize-edge.bottom {
        top: calc(100% + 12px);
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.left,
      .chart-element .resize-edge.left,
      .image-element .resize-edge.left,
      .video-element .resize-edge.left,
      .text-box .resize-edge.left,
      .title-box .resize-edge.left,
      .additional-text-box .resize-edge.left {
        left: -12px;
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.right,
      .chart-element .resize-edge.right,
      .image-element .resize-edge.right,
      .video-element .resize-edge.right,
      .text-box .resize-edge.right,
      .title-box .resize-edge.right,
      .additional-text-box .resize-edge.right {
        left: calc(100% + 12px);
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.top-left,
      .chart-element .resize-edge.top-left,
      .image-element .resize-edge.top-left,
      .video-element .resize-edge.top-left,
      .text-box .resize-edge.top-left,
      .title-box .resize-edge.top-left,
      .additional-text-box .resize-edge.top-left {
        top: -16px;
        left: -16px;
        cursor: nwse-resize;
      }
      .shape-element .resize-edge.top-right,
      .chart-element .resize-edge.top-right,
      .image-element .resize-edge.top-right,
      .video-element .resize-edge.top-right,
      .text-box .resize-edge.top-right,
      .title-box .resize-edge.top-right,
      .additional-text-box .resize-edge.top-right {
        top: -16px;
        left: calc(100% + 16px);
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-left,
      .chart-element .resize-edge.bottom-left,
      .image-element .resize-edge.bottom-left,
      .video-element .resize-edge.bottom-left,
      .text-box .resize-edge.bottom-left,
      .title-box .resize-edge.bottom-left,
      .additional-text-box .resize-edge.bottom-left {
        top: calc(100% + 16px);
        left: -16px;
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-right,
      .chart-element .resize-edge.bottom-right,
      .image-element .resize-edge.bottom-right,
      .video-element .resize-edge.bottom-right,
      .text-box .resize-edge.bottom-right,
      .title-box .resize-edge.bottom-right,
      .additional-text-box .resize-edge.bottom-right {
        top: calc(100% + 18px);
        left: calc(100% + 18px);
        cursor: nwse-resize;
        background: linear-gradient(135deg, rgba(59,130,246,0.95), rgba(129,230,217,0.95));
        border-color: rgba(56, 189, 248, 0.85);
      }
      .video-element .resize-edge.bottom-right {
        top: calc(100% + 14px);
        left: calc(100% + 14px);
      }
      .image-element .resize-edge {
        background: rgba(219, 246, 255, 0.95);
        border-color: rgba(59, 130, 246, 0.75);
      }
      .image-element .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .video-element .resize-edge {
        background: rgba(219, 246, 255, 0.95);
        border-color: rgba(59, 130, 246, 0.75);
        z-index: 2;
      }
      .video-element .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-color-picker {
        position: fixed;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(4, 44, 28, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 6px;
        gap: 8px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        transform: translateY(8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 4100;
      }
      .shape-color-picker.visible {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .shape-rotation-handle {
        position: fixed;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: rgba(4, 44, 28, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transform: translateY(8px) scale(0.95);
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-rotation-handle.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0) scale(1);
      }
      .shape-rotation-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 2px solid rgba(59, 130, 246, 0.4);
        background: rgba(14, 116, 144, 0.2);
        color: #bae6fd;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }
      .shape-rotation-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.25);
      }
      .shape-rotation-button:active {
        cursor: grabbing;
        background: rgba(59, 130, 246, 0.35);
      }
      .shape-rotation-button i {
        pointer-events: none;
        font-size: 14px;
      }
      .shape-rotation-angle {
        font-size: 13px;
        font-weight: 600;
        color: #c4e3ff;
        letter-spacing: 0.4px;
        pointer-events: none;
      }
      .shape-size-badge {
        position: fixed;
        padding: 6px 12px;
        background: rgba(4, 44, 28, 0.95);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        color: #d1fae5;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.4px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.28);
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-size-badge.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .image-crop-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.75);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 14000;
        backdrop-filter: blur(6px);
      }
      .image-crop-overlay.visible {
        display: flex;
      }
      .image-crop-dialog {
        width: min(90vw, 720px);
        background: rgba(0, 40, 20, 0.92);
        border: 1px solid rgba(46, 213, 115, 0.45);
        border-radius: 18px;
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.6);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        color: #ecfdf5;
      }
      .image-crop-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        font-weight: 700;
        background: rgba(4, 44, 28, 0.65);
        letter-spacing: 0.3px;
      }
      .image-crop-content {
        position: relative;
        padding: 20px;
        background: rgba(2, 32, 20, 0.65);
      }
      .image-crop-content img {
        max-width: 100%;
        max-height: 60vh;
        display: block;
        margin: 0 auto;
      }
      .image-crop-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        padding: 16px 20px;
        background: rgba(4, 44, 28, 0.65);
      }
      .image-crop-actions button {
        border: none;
        border-radius: 999px;
        padding: 10px 20px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, background 0.15s ease;
      }
      #imageCropCancel {
        background: rgba(255, 255, 255, 0.08);
        color: #ecfdf5;
        border: 1px solid rgba(255, 255, 255, 0.18);
      }
      #imageCropCancel:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-1px);
      }
      #imageCropApply {
        background: rgba(46, 213, 115, 0.2);
        color: #bbf7d0;
        border: 1px solid rgba(46, 213, 115, 0.45);
      }
      #imageCropApply:hover {
        background: rgba(46, 213, 115, 0.35);
        transform: translateY(-1px);
      }
      .image-crop-close {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 20px;
        cursor: pointer;
        transition: transform 0.15s ease, color 0.15s ease;
      }
      .image-crop-close:hover {
        transform: scale(1.1);
        color: #22c55e;
      }
      @keyframes imageInsertFade {
        from {
          opacity: 0;
          transform: scale(0.94);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      .image-element.image-insert-animation {
        animation: imageInsertFade 0.28s ease-out;
      }
      .shape-color-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.12);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #0f172a;
        font-size: 16px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      .shape-color-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      }
      .shape-color-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      .tool-select { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        font-weight: 600;
      }
      .tool-select::placeholder {
        color: rgba(232, 245, 233, 0.6);
      }
      .tool-select:hover {
        background: rgba(255, 255, 255, 0.25);
      }
      .tool-color { 
        width: 40px; 
        height: 36px; 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px; 
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .tool-color:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .color-picker-button {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(50%);
        white-space: nowrap;
        border: 0;
      }
      .canvas-wrap { display:grid; place-items:center; padding:24px; overflow:auto; position:relative; }
      .canvas { width:min(92vw, 960px); aspect-ratio:16/9; background:#ffffff; border-radius:10px; box-shadow: 0 0 25px rgba(0, 0, 0, 0.25); padding:24px; position: relative; background-size: cover; background-position: center; background-repeat: no-repeat; transition: background 0.6s ease-in-out; transform-origin: center center; }
      .comments-panel { width:min(92vw, 960px); margin: 12px auto 24px; background: rgba(8, 45, 30, 0.9); border: 1px solid rgba(46, 213, 115, 0.35); border-radius: 14px; box-shadow: 0 18px 30px rgba(0, 0, 0, 0.35); padding: 20px 24px; color: #ecfdf5; display: flex; flex-direction: column; gap: 16px; }
      .comments-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .comments-title { font-size: 18px; font-weight: 700; margin: 0; }
      .comments-count { font-size: 14px; font-weight: 600; color: rgba(236, 253, 245, 0.75); }
      .comments-list { display: flex; flex-direction: column; gap: 14px; max-height: 240px; overflow-y: auto; padding-right: 4px; }
      .comments-list::-webkit-scrollbar { width: 6px; }
      .comments-list::-webkit-scrollbar-thumb { background: rgba(46, 213, 115, 0.4); border-radius: 999px; }
      .comment-item { background: rgba(15, 60, 40, 0.9); border: 1px solid rgba(46, 213, 115, 0.2); border-radius: 12px; padding: 12px 14px; display: flex; flex-direction: column; gap: 8px; box-shadow: inset 0 0 0 1px rgba(12, 83, 60, 0.15); }
      .comment-text { font-size: 14px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
      .comment-meta { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: rgba(236, 253, 245, 0.6); }
      .comment-delete { background: transparent; border: none; color: rgba(248, 113, 113, 0.85); font-size: 12px; font-weight: 600; cursor: pointer; transition: color 0.2s ease, transform 0.2s ease; }
      .comment-delete:hover { color: rgba(252, 165, 165, 0.95); transform: translateY(-1px); }
      .comment-empty { font-size: 14px; color: rgba(236, 253, 245, 0.6); text-align: center; padding: 20px 12px; border: 1px dashed rgba(46, 213, 115, 0.35); border-radius: 12px; }
      .comment-form { display: flex; flex-direction: column; gap: 10px; }
      .comment-input { width: 100%; min-height: 72px; resize: vertical; border-radius: 12px; border: 1px solid rgba(46, 213, 115, 0.35); background: rgba(4, 30, 20, 0.85); color: #ecfdf5; padding: 12px 14px; font-size: 14px; font-family: inherit; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
      .comment-input::placeholder { color: rgba(236, 253, 245, 0.45); }
      .comment-input:focus { outline: none; border-color: rgba(46, 213, 115, 0.7); box-shadow: 0 0 0 3px rgba(46, 213, 115, 0.18); }
      .comment-form-actions { display: flex; align-items: center; justify-content: flex-end; gap: 12px; }
      .comment-submit { border: none; border-radius: 999px; padding: 10px 22px; font-weight: 700; letter-spacing: 0.3px; cursor: pointer; background: linear-gradient(135deg, rgba(46, 213, 115, 0.95) 0%, rgba(34, 197, 94, 0.95) 100%); color: #06221e; box-shadow: 0 10px 20px rgba(46, 213, 115, 0.25); transition: transform 0.2s ease, box-shadow 0.2s ease; }
      .comment-submit:hover { transform: translateY(-1px); box-shadow: 0 14px 26px rgba(46, 213, 115, 0.33); }
      .comment-submit:disabled { opacity: 0.6; cursor: not-allowed; transform: none; box-shadow: none; }
      .zoom-controls { display:flex; align-items:center; gap:8px; margin-left:12px; padding:6px 10px; border:1px solid rgba(255, 255, 255, 0.35); border-radius:10px; background: rgba(255, 255, 255, 0.08); box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.2); }
      .zoom-display { min-width:60px; text-align:center; font-weight:600; color:#e8f5e9; }
      .tool.zoom-button { min-width:36px; padding:6px 10px; font-size:16px; }
      .tool.zoom-reset-button { padding:6px 12px; font-size:14px; }
      @keyframes transitionFade {
        from { opacity: 0; transform: scale(0.985); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes transitionSlideLeft {
        from { opacity: 0; transform: translateX(60px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes transitionSlideRight {
        from { opacity: 0; transform: translateX(-60px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes transitionSlideUp {
        from { opacity: 0; transform: translateY(60px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes transitionSlideDown {
        from { opacity: 0; transform: translateY(-60px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes transitionZoomIn {
        from { opacity: 0; transform: scale(0.88); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes transitionZoomOut {
        from { opacity: 0; transform: scale(1.12); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes transitionFlip {
        from { opacity: 0; transform: rotateX(50deg); transform-origin: center; }
        to { opacity: 1; transform: rotateX(0deg); transform-origin: center; }
      }
      @keyframes transitionRotate {
        from { opacity: 0; transform: rotate(-14deg) scale(0.94); }
        to { opacity: 1; transform: rotate(0deg) scale(1); }
      }
      .presentation-stage .presentation-slide.transition-effect-fade { animation: transitionFade var(--transition-duration, 0.7s) ease both; }
      .presentation-stage .presentation-slide.transition-effect-slide-left { animation: transitionSlideLeft var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-slide-right { animation: transitionSlideRight var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-slide-up { animation: transitionSlideUp var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-slide-down { animation: transitionSlideDown var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-zoom-in { animation: transitionZoomIn var(--transition-duration, 0.7s) ease both; }
      .presentation-stage .presentation-slide.transition-effect-zoom-out { animation: transitionZoomOut var(--transition-duration, 0.7s) ease both; }
      .presentation-stage .presentation-slide.transition-effect-flip { animation: transitionFlip var(--transition-duration, 0.7s) ease-in-out both; }
      .presentation-stage .presentation-slide.transition-effect-rotate { animation: transitionRotate var(--transition-duration, 0.7s) ease-in-out both; }
      
      .presentation-overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: #000;
        z-index: 9999;
        color: #f9fafb;
      }
      .presentation-overlay.visible {
        display: block;
      }
      .presentation-stage {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #111;
      }
      .presentation-stage .presentation-slide {
        width: 100%;
        height: 100%;
        position: absolute;
        inset: 0;
        background: #fff;
        overflow: hidden;
      }
      .presentation-stage .title-box,
      .presentation-stage .text-box,
      .presentation-stage .additional-text-box {
        border: none !important;
        box-shadow: none !important;
        outline: none !important;
        cursor: default !important;
        user-select: none;
      }
      .presentation-stage .title-box::before,
      .presentation-stage .text-box::before,
      .presentation-stage .additional-text-box::before {
        display: none !important;
        content: none !important;
      }
      .presentation-stage .shape-element {
        outline: none !important;
        box-shadow: none !important;
        cursor: default !important;
      }
      .presentation-stage .resize-edge {
        display: none !important;
      }
      .presentation-overlay .presentation-meta {
        position: absolute;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 16px;
        font-size: 14px;
        letter-spacing: 0.4px;
        background: rgba(15, 23, 42, 0.5);
        padding: 10px 18px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay .presentation-meta span {
        display: flex;
        align-items: center;
        gap: 8px;
        text-transform: uppercase;
        font-weight: 600;
      }
      .presentation-overlay .presentation-counter {
        position: absolute;
        bottom: 32px;
        right: 40px;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.6px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay.show-controls .presentation-meta,
      .presentation-overlay.show-controls .presentation-counter {
        opacity: 1;
        pointer-events: auto;
      }
      body.presenting {
        overflow: hidden;
      }
      body.presenting .layout {
        visibility: hidden;
      }
      body.presenting .presentation-overlay {
        visibility: visible;
      }

      /* Template Background Styles */
      .canvas.marketing-template {
        background-image: url('./CURSOR-Project/Background/B1.avif');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.marketing-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.business-template {
        background-image: url('./CURSOR-Project/Background/business-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.business-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.education-template {
        background-image: url('./CURSOR-Project/Background/education-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.education-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.project-template {
        background-image: url('./CURSOR-Project/Background/project-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.project-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      /* Ensure content is above overlay */
      .canvas .title-box,
      .canvas .text-box {
        position: relative;
        z-index: 1;
      }
      
      /* Title box per Editor.json */
      .title-box {
        font-size: 28px;
        font-weight: bold;
        color: #000000;
        border: 1px dashed transparent;
        padding: 10px;
        min-height: 50px;
        min-width: 200px;
        outline: none;
        position: absolute;
        top: 24px;
        left: 24px;
        width: calc(100% - 48px);
        outline: none;
      }
      .title-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .title-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      .title-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .title-box.resizing {
        user-select: none;
      }
      
      /* Resize edges for title box */
      .title-box .resize-edge {
        position: absolute;
        background: transparent;
        z-index: 10;
      }
      .title-box .resize-edge.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.left { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.right { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.corner { width: 15px; height: 15px; }
      .title-box .resize-edge.top-left { top: -5px; left: -5px; cursor: nw-resize; }
      .title-box .resize-edge.top-right { top: -5px; right: -5px; cursor: ne-resize; }
      .title-box .resize-edge.bottom-left { bottom: -5px; left: -5px; cursor: sw-resize; }
      .title-box .resize-edge.bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }

      /* Text box per Editor.json */
      .text-box {
        font-size: 16px;
        border: 1px dashed transparent;
        padding: 10px;
        min-height: 250px;
        min-width: 200px;
        outline: none;
        overflow: visible;
        color: #000000;
        position: absolute;
        top: 100px;
        left: 24px;
        width: calc(100% - 48px);
        bottom: 24px;
        outline: none;
      }
      .text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .additional-text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .text-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      
      /* Selected state for text boxes and title box */
      .text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .additional-text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .title-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      
      .text-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .text-box.resizing {
        user-select: none;
      }
      

      /* Save notification */
      .save-notification {
        position: fixed;
        top: 70px;
        right: 20px;
        background: #10b981;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity .3s, transform .3s;
        z-index: 1000;
        pointer-events: none;
      }
      .save-notification.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="topbar">
        <button class="btn blue toolbar-btn" id="btnBack" data-action="back" title="Back (Cmd+Z / Ctrl+Z)">
          <i class="fas fa-arrow-left"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnForward" data-action="forward" title="Forward (Cmd+Shift+Z / Ctrl+Shift+Z)">
          <i class="fas fa-arrow-right"></i>
        </button>
        <button class="btn red toolbar-btn" id="btnDel" data-action="delete_slide" title="Delete Slide">
          <i class="fas fa-trash"></i>
        </button>
        <button class="btn light toolbar-btn" id="btnReset" data-action="reset_slides" title="Reset Slides">
          <i class="fas fa-rotate-right"></i>
        </button>
        <button class="btn green toolbar-btn" id="btnSave" title="Save Presentation">
          <i class="fas fa-save"></i>
        </button>
        <div class="save-as-wrapper">
          <button class="btn green toolbar-btn save-as-toggle" id="btnSaveAs" title="Save As">
            <i class="fas fa-folder-open"></i>
            <span class="caret"><i class="fas fa-caret-down"></i></span>
          </button>
          <div class="save-as-menu" id="saveAsMenu" role="menu" aria-label="Export presentation" style="display: none;">
            <button type="button" class="save-as-option" data-format="pdf" role="menuitem">
              <span class="option-icon"><i class="fas fa-file-pdf"></i></span>
              <span>Export as PDF</span>
            </button>
            <button type="button" class="save-as-option" data-format="pptx" role="menuitem">
              <span class="option-icon"><i class="fas fa-file-powerpoint"></i></span>
              <span>Export as PPTX</span>
            </button>
          </div>
        </div>
        <!-- Save As Modal -->
        <div class="save-as-modal" id="saveAsModal" role="dialog" aria-modal="true" aria-labelledby="saveAsModalTitle">
          <div class="save-as-modal-content">
            <div class="save-as-modal-header">
              <h3 class="save-as-modal-title" id="saveAsModalTitle">Save As</h3>
              <button type="button" class="save-as-modal-close" id="saveAsModalClose" aria-label="Close">&times;</button>
            </div>
            <div class="save-as-form-group">
              <label for="saveAsFormat" class="save-as-form-label">File Format</label>
              <select id="saveAsFormat" class="save-as-form-select">
                <option value="pptx">PowerPoint (.pptx)</option>
                <option value="pdf">PDF (.pdf)</option>
                <option value="png">PNG Image (.png)</option>
                <option value="json">JSON Data (.json)</option>
                <option value="html">HTML Document (.html)</option>
              </select>
            </div>
            <div class="save-as-form-group">
              <label for="saveAsFileName" class="save-as-form-label">File Name</label>
              <input type="text" id="saveAsFileName" class="save-as-form-input" placeholder="Enter file name" autocomplete="off">
            </div>
            <div class="save-as-modal-actions">
              <button type="button" class="save-as-modal-btn save-as-modal-btn-cancel" id="saveAsModalCancel">Cancel</button>
              <button type="button" class="save-as-modal-btn save-as-modal-btn-save" id="saveAsModalSave">Save</button>
            </div>
          </div>
        </div>
        <div style="flex:1"></div>
        <button class="btn emerald toolbar-btn" id="btnHome" data-action="go_home" title="Return Home">
          <i class="fas fa-home"></i>
        </button>
      </div>

      <div class="main" id="layoutMain">
        <aside class="sidebar" id="sidebar"></aside>
        <section class="editor">
          <div class="toolbar" id="toolbar">
            <div class="toolbar-tabs" role="tablist" aria-label="Editor toolbar categories">
              <button class="toolbar-tab active" type="button" role="tab" aria-selected="true" aria-controls="toolbar-panel-home" data-tab-target="home" id="toolbar-tab-home">Home</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-insert" data-tab-target="insert" id="toolbar-tab-insert" tabindex="-1">Insert</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-transitions" data-tab-target="transitions" id="toolbar-tab-transitions" tabindex="-1">Transitions</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-animations" data-tab-target="animations" id="toolbar-tab-animations" tabindex="-1">Animations</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-view" data-tab-target="view" id="toolbar-tab-view" tabindex="-1">View</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-tools" data-tab-target="tools" id="toolbar-tab-tools" tabindex="-1">Tools</button>
            </div>
            <div class="toolbar-panels">
              <div class="toolbar-panel active" role="tabpanel" id="toolbar-panel-home" aria-labelledby="toolbar-tab-home" data-tab-panel="home" tabindex="0">
                <button class="tool" data-action="bold" title="Bold"><i class="fas fa-bold"></i></button>
                <button class="tool" data-action="italic" title="Italic"><i class="fas fa-italic"></i></button>
                <button class="tool" data-action="underline" title="Underline"><i class="fas fa-underline"></i></button>
                <button class="tool" data-action="strikeThrough" title="Strikethrough"><i class="fas fa-strikethrough"></i></button>
                <button class="tool" data-action="subscript" title="Subscript"><i class="fas fa-subscript"></i></button>
                <button class="tool" data-action="superscript" title="Superscript"><i class="fas fa-superscript"></i></button>
                <div class="tool-divider" aria-hidden="true"></div>
                <input type="number" class="tool-select" id="fontSize" title="Font Size" min="8" max="72" step="2" value="16" style="width: 80px; color: #e8f5e9;">
                <button type="button" class="tool font-picker-button" id="fontPickerButton" title="Font Family" aria-haspopup="true" aria-expanded="false">
                  <span class="font-picker-label" id="fontPickerLabel">Aa</span>
                </button>
                <div id="colorControlsRoot" class="color-controls"></div>
                <div class="tool-divider" aria-hidden="true"></div>
                <button class="tool" data-action="justifyLeft" title="Align Left"><i class="fas fa-align-left"></i></button>
                <button class="tool" data-action="justifyCenter" title="Align Center"><i class="fas fa-align-center"></i></button>
                <button class="tool" data-action="justifyRight" title="Align Right"><i class="fas fa-align-right"></i></button>
                <button class="tool" data-action="justifyFull" title="Justify"><i class="fas fa-align-justify"></i></button>
                <button class="tool" data-action="insertUnorderedList" title="Bullet List"><i class="fas fa-list-ul"></i></button>
                <button class="tool" data-action="insertOrderedList" title="Numbered List"><i class="fas fa-list-ol"></i></button>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-insert" aria-labelledby="toolbar-tab-insert" data-tab-panel="insert" aria-hidden="true" hidden tabindex="0">
                <button type="button" class="tool new-slide-toolbar-button" id="insertNewSlideButton" title="New Slide" aria-label="Add new slide">
                  <span class="new-slide-button-icon">
                    <i class="fas fa-square-plus"></i>
                  </span>
                  <span class="new-slide-button-label">New Slide</span>
                </button>
                <button type="button" class="tool shape-picker-button" id="shapePickerButton" title="Insert Shape" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-shapes"></i>
                </button>
                <button type="button" class="tool image-picker-button" id="imagePickerButton" title="Insert Image">
                  <i class="fas fa-image"></i>
                </button>
                <button type="button" class="tool video-picker-button" id="videoPickerButton" title="Insert Video">
                  <i class="fas fa-film"></i>
                </button>
                <button type="button" class="tool chart-picker-button" id="chartPickerButton" title="Insert Chart" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-chart-pie"></i>
                </button>
                <button type="button" class="tool table-picker-button" id="tablePickerButton" title="Insert Table" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-table"></i>
                </button>
                <button class="tool" data-action="addTextBox" title="Add Text Box"><i class="fas fa-text-width"></i> Text Box</button>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-transitions" aria-labelledby="toolbar-tab-transitions" data-tab-panel="transitions" aria-hidden="true" hidden tabindex="0">
                <div class="transition-controls" role="group" aria-label="Slide transition controls">
                  <label class="transition-field" for="transitionEffectSelect">
                    <span class="transition-label">Effect</span>
                    <div class="transition-select-wrapper">
                      <span class="transition-select-icon" aria-hidden="true">
                        <i class="fas fa-wand-magic-sparkles"></i>
                      </span>
                    <select class="tool-select transition-select" id="transitionEffectSelect" title="Transition Effect">
                      <option value="none">None</option>
                      <option value="fade">Fade</option>
                      <option value="slide-left">Slide Left</option>
                      <option value="slide-right">Slide Right</option>
                      <option value="slide-up">Slide Up</option>
                      <option value="slide-down">Slide Down</option>
                      <option value="zoom-in">Zoom In</option>
                      <option value="zoom-out">Zoom Out</option>
                      <option value="flip">Flip</option>
                      <option value="rotate">Rotate</option>
                    </select>
                      <span class="transition-select-caret" aria-hidden="true">
                        <i class="fas fa-chevron-down"></i>
                      </span>
                    </div>
                  </label>
                  <label class="transition-field" for="transitionDurationInput">
                    <span class="transition-label">Duration</span>
                    <div class="transition-duration-control">
                      <input type="number" class="tool-select transition-duration-input" id="transitionDurationInput" title="Transition Duration (seconds)" min="0.1" max="5" step="0.1" value="0.7" inputmode="decimal" autocomplete="off">
                      <span class="transition-duration-suffix">s</span>
                    </div>
                  </label>
                  <button class="tool transition-apply-all-button" type="button" id="applyTransitionAllButton" title="Apply transition to all slides">
                    <i class="fas fa-layer-group" aria-hidden="true"></i>
                    <span>Apply to All</span>
                  </button>
                </div>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-animations" aria-labelledby="toolbar-tab-animations" data-tab-panel="animations" aria-hidden="true" hidden tabindex="0">
                <div class="animation-panel">
                  <div class="animation-controls" role="group" aria-label="Object animation controls">
                    <label class="animation-field" for="animationEffectSelect">
                      <span class="animation-label">Effect</span>
                      <div class="transition-select-wrapper">
                        <span class="transition-select-icon" aria-hidden="true">
                          <i class="fas fa-wand-magic-sparkles"></i>
                        </span>
                        <select class="tool-select transition-select animation-select" id="animationEffectSelect" title="Animation Effect">
                          <option value="fade-in">Fade In</option>
                          <option value="pop-up">Pop Up</option>
                          <option value="slide-in-right">Slide In Right</option>
                          <option value="slide-in-left">Slide In Left</option>
                          <option value="slide-in-up">Slide In Up</option>
                        </select>
                        <span class="transition-select-caret" aria-hidden="true">
                          <i class="fas fa-chevron-down"></i>
                        </span>
                      </div>
                    </label>
                    <label class="animation-field" for="animationDurationInput">
                      <span class="animation-label">Duration</span>
                      <div class="animation-duration-control">
                        <input type="number" class="tool-select" id="animationDurationInput" title="Animation Duration (seconds)" min="0.1" max="5" step="0.1" value="0.7" inputmode="decimal" autocomplete="off">
                        <span class="animation-duration-suffix">s</span>
                      </div>
                    </label>
                    <button class="tool animation-assign-button" type="button" id="assignAnimationButton" title="Apply animation to selected object">
                      <i class="fas fa-wand-magic-sparkles" aria-hidden="true"></i>
                      <span>Apply</span>
                    </button>
                    <button class="tool animation-remove-button" type="button" id="removeAnimationButton" title="Remove animation from selected object">
                      <i class="fas fa-ban" aria-hidden="true"></i>
                      <span>Remove</span>
                  </button>
                  </div>
                  <div class="animation-sequence-container hidden">
                    <div class="animation-sequence-header">
                      <span>Animation Sequence</span>
                      <div class="animation-sequence-actions">
                        <span class="animation-sequence-hint">Drag to reorder</span>
                        <button type="button" class="animation-sequence-close" id="closeAnimationSequenceButton" title="Close animation sequence panel" aria-label="Close animation sequence panel">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                    <div class="animation-sequence-list" id="animationSequenceList" role="list"></div>
                  </div>
                </div>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-view" aria-labelledby="toolbar-tab-view" data-tab-panel="view" aria-hidden="true" hidden tabindex="0">
                <div class="zoom-controls" role="group" aria-label="Canvas zoom controls">
                  <button class="tool zoom-button" type="button" id="zoomOutButton" title="Zoom out" aria-label="Zoom out">-</button>
                  <span class="zoom-display" id="zoomDisplay">100%</span>
                  <button class="tool zoom-button" type="button" id="zoomInButton" title="Zoom in" aria-label="Zoom in">+</button>
                  <button class="tool zoom-reset-button" type="button" id="zoomResetButton" title="Reset zoom" aria-label="Reset zoom">Reset</button>
                </div>
                <div class="sidebar-view-toggle" role="group" aria-label="Sidebar layout">
                  <button type="button" class="tool sidebar-view-button" data-sidebar-view="list" id="sidebarViewListButton" aria-pressed="false">
                    <i class="fas fa-list" aria-hidden="true"></i>
                    <span>Compact</span>
                  </button>
                  <button type="button" class="tool sidebar-view-button" data-sidebar-view="thumbnail" id="sidebarViewThumbnailButton" aria-pressed="false">
                    <i class="fas fa-table-cells-large" aria-hidden="true"></i>
                    <span>Preview</span>
                  </button>
                </div>
                <button class="tool present-button" data-action="present" title="Present Slideshow" aria-label="Present">
                  <svg class="present-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M6 4l12 8-12 8z" fill="currentColor"></path>
                  </svg>
                </button>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-tools" aria-labelledby="toolbar-tab-tools" data-tab-panel="tools" aria-hidden="true" hidden tabindex="0">
                <button type="button" class="tool spell-check-toggle active" id="spellCheckToggle" aria-pressed="true" title="Toggle spell check">
                  <i class="fas fa-spell-check" aria-hidden="true"></i>
                  <span class="tool-label">
                    Spell Check
                    <span class="tool-state" data-role="spell-toggle-state">On</span>
                  </span>
                </button>
                <button type="button" class="tool" id="translateToolButton" title="Translate text" aria-label="Translate text">
                  <i class="fas fa-language" aria-hidden="true"></i>
                  <span>Translate</span>
                </button>
              </div>
            </div>
          </div>
          <div class="canvas-wrap">
            <div class="canvas" id="canvas">
              <div class="title-box" contenteditable="true" spellcheck="true" id="titleBox" data-placeholder="Click to add title"></div>
              <div class="text-box" contenteditable="true" spellcheck="true" id="textBox" data-placeholder="Click to add text"></div>
            </div>
          </div>
          <section class="comments-panel" id="commentsPanel" aria-label="Slide comments">
            <div class="comments-header">
              <h3 class="comments-title">Comments</h3>
              <span class="comments-count" id="commentsCount">0 comments</span>
            </div>
            <div class="comments-list" id="commentsList" role="list"></div>
            <form class="comment-form" id="commentForm" novalidate>
              <label for="commentInput" class="visually-hidden">Add a comment</label>
              <textarea id="commentInput" class="comment-input" placeholder="Share your thoughts about this slideâ€¦" rows="3"></textarea>
              <div class="comment-form-actions">
                <button type="submit" class="comment-submit" id="commentSubmitButton">Post Comment</button>
              </div>
            </form>
          </section>
        </section>
        <aside class="translator-panel hidden" id="translatorPanel" aria-label="Translator">
          <div class="translator-header">
            <span class="translator-title">Translate Text</span>
            <button type="button" class="translator-close" id="translatorCloseButton" aria-label="Close translation panel">&times;</button>
          </div>
          <div class="translator-body">
            <div class="translator-source">
              <label class="translator-label" for="translatorSourceInput">Original Text</label>
              <textarea class="translator-textarea" id="translatorSourceInput" placeholder="Select text to translate"></textarea>
            </div>
            <div class="translator-field">
              <label class="translator-label" for="translatorLanguageSelect">Target Language</label>
              <select class="translator-select" id="translatorLanguageSelect"></select>
            </div>
            <div class="translator-result">
              <label class="translator-label" for="translatorResultArea">Translation</label>
              <textarea class="translator-textarea" id="translatorResultArea" readonly placeholder="Translation will appear here"></textarea>
            </div>
          </div>
          <div class="translator-actions">
            <span class="translator-status" id="translatorStatusLabel"></span>
            <button type="button" class="tool" id="translatorInsertButton">
              <i class="fas fa-check" aria-hidden="true"></i>
              <span>Insert</span>
            </button>
          </div>
        </aside>
      </div>
    </div>

    <div class="save-notification" id="saveNotification">Presentation saved!</div>

    <script type="module">
      import React, { useEffect, useRef, useState } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { PaintBucket } from 'https://esm.sh/lucide-react@0.312.0?deps=react@18.2.0';

      const { createElement, Fragment } = React;

      const TextIcon = (props) => createElement(
        'svg',
        Object.assign({
          width: 18,
          height: 18,
          viewBox: '0 0 24 24',
          fill: 'none',
          stroke: 'currentColor',
          strokeWidth: 2,
          strokeLinecap: 'round',
          strokeLinejoin: 'round'
        }, props),
        createElement('path', { d: 'M5 20h14' }),
        createElement('path', { d: 'M12 4l5 12' }),
        createElement('path', { d: 'M12 4L7 16' }),
        createElement('line', { x1: 10.5, y1: 12, x2: 13.5, y2: 12 })
      );

      const DEFAULT_TEXT_COLOR = '#000000';
      const DEFAULT_BG_COLOR = '#ffff00';

      const ColorControls = ({ textColorHandler, bgColorHandler }) => {
        const [textColor, setTextColor] = useState(DEFAULT_TEXT_COLOR);
        const [bgColor, setBgColor] = useState(DEFAULT_BG_COLOR);
        const textInputRef = useRef(null);
        const bgInputRef = useRef(null);

        useEffect(() => {
          if (textInputRef.current) {
            setTextColor(textInputRef.current.value || DEFAULT_TEXT_COLOR);
          }
          if (bgInputRef.current) {
            setBgColor(bgInputRef.current.value || DEFAULT_BG_COLOR);
          }
        }, []);

        const handleTextColorChange = (event) => {
          const color = event.target.value;
          setTextColor(color);
          if (typeof textColorHandler === 'function') {
            textColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-text-color', { detail: { color } }));
          }
        };

        const handleBgColorChange = (event) => {
          const color = event.target.value;
          setBgColor(color);
          if (typeof bgColorHandler === 'function') {
            bgColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-bg-color', { detail: { color } }));
          }
        };

        const triggerTextPicker = () => {
          if (textInputRef.current) {
            textInputRef.current.click();
          }
        };

        const triggerBgPicker = () => {
          if (bgInputRef.current) {
            bgInputRef.current.click();
          }
        };

        return createElement(
          Fragment,
          null,
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerTextPicker,
              title: 'Font Color',
              'aria-label': 'Font Color'
            },
            createElement(TextIcon, { className: 'color-tool-icon' }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: textColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'fontColor',
            ref: textInputRef,
            defaultValue: DEFAULT_TEXT_COLOR,
            className: 'visually-hidden',
            onChange: handleTextColorChange
          }),
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerBgPicker,
              title: 'Text Box Background Color',
              'aria-label': 'Text Box Background Color'
            },
            createElement(PaintBucket, { size: 18 }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: bgColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'highlightColor',
            ref: bgInputRef,
            defaultValue: DEFAULT_BG_COLOR,
            className: 'visually-hidden',
            onChange: handleBgColorChange
          })
        );
      };

      const rootElement = document.getElementById('colorControlsRoot');
      if (rootElement) {
        const handlers = window.slideEditorColorHandlers || {};
        createRoot(rootElement).render(createElement(ColorControls, {
          textColorHandler: handlers.onTextColor,
          bgColorHandler: handlers.onBackgroundColor
        }));
      }
    </script>

    <script>
      // Route Protection - Check authentication on page load
      (function() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        // If not authenticated and not a guest, redirect to welcome page
        if (!currentUser && !isGuest) {
          window.location.href = './index.html';
          return;
        }
      })();
      
      const DEFAULT_FONT_STACK = 'Inter, system-ui, -apple-system, "Segoe UI", sans-serif';
      const DEFAULT_TRANSITION_DURATION = 0.7;
      const TRANSITION_DURATION_MIN = 0.1;
      const TRANSITION_DURATION_MAX = 5;
      const ANIMATION_DURATION_MIN = 0.1;
      const ANIMATION_DURATION_MAX = 5;
      const DEFAULT_ANIMATION_DURATION = 0.7;
      const ANIMATION_EFFECTS = [
        { value: 'fade-in', label: 'Fade In' },
        { value: 'pop-up', label: 'Pop Up' },
        { value: 'slide-in-right', label: 'Slide In Right' },
        { value: 'slide-in-left', label: 'Slide In Left' },
        { value: 'slide-in-up', label: 'Slide In Up' }
      ];
      const DEFAULT_ANIMATION_EFFECT = 'fade-in';
      const ANIMATION_EFFECT_VALUE_SET = new Set(ANIMATION_EFFECTS.map(opt => opt.value));
      const ANIMATION_EFFECT_LABEL_MAP = new Map(ANIMATION_EFFECTS.map(opt => [opt.value, opt.label]));
      const ANIMATION_EFFECT_CLASS_NAMES = ANIMATION_EFFECTS.map(opt => `presentation-animation-effect-${opt.value}`);
      const SPELLCHECK_STORAGE_KEY = 'slideEditorSpellCheckEnabled';
      const SPELLCHECK_TARGET_SELECTOR = '.text-box, .title-box, td[contenteditable="true"], th[contenteditable="true"]';
      let isSpellCheckEnabled = true;

      let elementIdCounter = 0;
      function generateElementId(prefix = 'el') {
        if (window.crypto && typeof window.crypto.randomUUID === 'function') {
          return `${prefix}_${window.crypto.randomUUID()}`;
        }
        elementIdCounter += 1;
        return `${prefix}_${Date.now().toString(36)}_${elementIdCounter.toString(36)}`;
      }
      function ensureElementHasId(element, prefix = 'el') {
        if (!element) return null;
        if (!element.dataset.elementId) {
          element.dataset.elementId = generateElementId(prefix);
        }
        return element.dataset.elementId;
      }
      function escapeSelector(value) {
        if (window.CSS && typeof window.CSS.escape === 'function') {
          return window.CSS.escape(value);
        }
        return String(value).replace(/([.*+?^${}()|[\]\\])/g, '\\$1');
      }
      function truncateText(text, maxLength = 32) {
        if (!text) return '';
        const normalized = text.trim();
        if (normalized.length <= maxLength) {
          return normalized;
        }
        return `${normalized.slice(0, maxLength - 1)}â€¦`;
      }
      function normalizeAnimationEffect(effect) {
        if (ANIMATION_EFFECT_VALUE_SET.has(effect)) {
          return effect;
        }
        return DEFAULT_ANIMATION_EFFECT;
      }
      function clampAnimationDuration(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_ANIMATION_DURATION;
        }
        return Math.min(ANIMATION_DURATION_MAX, Math.max(ANIMATION_DURATION_MIN, numeric));
      }

      function createEmptySlide() {
        return {
        title: '', 
        content: '',
          titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false, id: generateElementId('title') },
          textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false, id: generateElementId('body') },
        titleFontFamily: DEFAULT_FONT_STACK,
        textFontFamily: DEFAULT_FONT_STACK,
        shapes: [],
        charts: [],
        additionalTextBoxes: [],
      tables: [],
      images: [],
        videos: [],
        comments: [],
          animations: [],
        transition: 'none',
        transitionDuration: DEFAULT_TRANSITION_DURATION,
        background: { image: '', size: '', position: '', repeat: '' }
        };
      }

      // Model per Editor.json: starting with one slide titled "Title"
      const slides = [createEmptySlide()];
      let active = 0;
      let slideDragSourceIndex = null;

      const sidebar = document.getElementById('sidebar');
      const titleBox = document.getElementById('titleBox');
      const textBox = document.getElementById('textBox');
      const saveNotification = document.getElementById('saveNotification');
      const saveAsButton = document.getElementById('btnSaveAs');
      const saveAsMenu = document.getElementById('saveAsMenu');
      const canvas = document.getElementById('canvas');
      const insertNewSlideButton = document.getElementById('insertNewSlideButton');
      const fontPickerButton = document.getElementById('fontPickerButton');
      const fontPickerLabel = document.getElementById('fontPickerLabel');
      const shapePickerButton = document.getElementById('shapePickerButton');
      const chartPickerButton = document.getElementById('chartPickerButton');
      const imagePickerButton = document.getElementById('imagePickerButton');
      const videoPickerButton = document.getElementById('videoPickerButton');
      const tablePickerButton = document.getElementById('tablePickerButton');
      const transitionEffectSelect = document.getElementById('transitionEffectSelect');
      const transitionDurationInput = document.getElementById('transitionDurationInput');
      const applyTransitionAllButton = document.getElementById('applyTransitionAllButton');
      const animationEffectSelect = document.getElementById('animationEffectSelect');
      const animationDurationInput = document.getElementById('animationDurationInput');
      const assignAnimationButton = document.getElementById('assignAnimationButton');
      const removeAnimationButton = document.getElementById('removeAnimationButton');
      const animationSequenceList = document.getElementById('animationSequenceList');
      const animationSequenceContainer = document.querySelector('.animation-sequence-container');
      const animationSequenceCloseButton = document.getElementById('closeAnimationSequenceButton');
      const animationTabButton = document.getElementById('toolbar-tab-animations');
      const spellCheckToggleButton = document.getElementById('spellCheckToggle');
      const spellCheckToggleState = spellCheckToggleButton
        ? spellCheckToggleButton.querySelector('[data-role="spell-toggle-state"]')
        : null;
      const translateToolButton = document.getElementById('translateToolButton');
      const zoomOutButton = document.getElementById('zoomOutButton');
      const zoomInButton = document.getElementById('zoomInButton');
      const zoomResetButton = document.getElementById('zoomResetButton');
      const zoomDisplay = document.getElementById('zoomDisplay');
      const canvasWrap = document.querySelector('.canvas-wrap');
      const commentsPanel = document.getElementById('commentsPanel');
      const commentsList = document.getElementById('commentsList');
      const commentsCount = document.getElementById('commentsCount');
      const commentForm = document.getElementById('commentForm');
      const commentInput = document.getElementById('commentInput');
      const commentSubmitButton = document.getElementById('commentSubmitButton');
      const sidebarViewButtons = Array.from(document.querySelectorAll('[data-sidebar-view]'));
      const SIDEBAR_VIEW_STORAGE_KEY = 'editorSidebarViewMode';
      let sidebarViewMode = (localStorage.getItem(SIDEBAR_VIEW_STORAGE_KEY) || 'list') === 'thumbnail' ? 'thumbnail' : 'list';
      let sidebarThumbnails = null;
      let sidebarThumbnailsPromise = null;
      function ensureSlideComments(slide) {
        if (!slide) return [];
        if (!Array.isArray(slide.comments)) {
          slide.comments = [];
        }
        return slide.comments;
      }

      function invalidateSidebarThumbnails() {
        sidebarThumbnails = null;
      }

      function updateSidebarViewButtons() {
        if (!sidebarViewButtons.length) return;
        sidebarViewButtons.forEach((button) => {
          const mode = button.dataset.sidebarView;
          const isActive = mode === sidebarViewMode;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      function setSidebarViewMode(mode) {
        if (mode !== 'list' && mode !== 'thumbnail') return;
        if (sidebarViewMode === mode) return;
        sidebarViewMode = mode;
        localStorage.setItem(SIDEBAR_VIEW_STORAGE_KEY, sidebarViewMode);
        updateSidebarViewButtons();
        if (sidebarViewMode === 'thumbnail') {
          ensureSidebarThumbnails();
        }
        renderSidebar();
      }

      if (sidebarViewButtons.length) {
        sidebarViewButtons.forEach((button) => {
          button.addEventListener('click', () => {
            setSidebarViewMode(button.dataset.sidebarView);
          });
        });
      }
      updateSidebarViewButtons();
      if (sidebarViewMode === 'thumbnail') {
        ensureSidebarThumbnails();
      }

      function formatCommentTimestamp(value) {
        if (!value) return '';
        try {
          return new Date(value).toLocaleString(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short'
          });
        } catch (error) {
          return value;
        }
      }

      function renderComments() {
        if (!commentsList || !commentsCount) return;
        const slide = slides[active];
        const comments = ensureSlideComments(slide);
        commentsList.innerHTML = '';
        if (commentInput) {
          commentInput.value = '';
        }
        if (commentSubmitButton) {
          commentSubmitButton.disabled = true;
        }
        if (!comments.length) {
          const emptyState = document.createElement('div');
          emptyState.className = 'comment-empty';
          emptyState.textContent = 'No comments yet. Share your thoughts about this slide.';
          commentsList.appendChild(emptyState);
        } else {
          comments.forEach((comment) => {
            const commentItem = document.createElement('article');
            commentItem.className = 'comment-item';
            commentItem.setAttribute('role', 'listitem');

            const textElement = document.createElement('p');
            textElement.className = 'comment-text';
            textElement.textContent = comment.text || '';
            commentItem.appendChild(textElement);

            const metaRow = document.createElement('div');
            metaRow.className = 'comment-meta';

            const timestamp = document.createElement('span');
            timestamp.textContent = formatCommentTimestamp(comment.createdAt);
            metaRow.appendChild(timestamp);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'comment-delete';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
              deleteComment(comment.id);
            });
            metaRow.appendChild(deleteButton);

            commentItem.appendChild(metaRow);
            commentsList.appendChild(commentItem);
          });
        }

        const count = comments.length;
        commentsCount.textContent = count === 1 ? '1 comment' : `${count} comments`;
      }

      function addComment(text) {
        const trimmed = text.trim();
        if (!trimmed) return;
        const slide = slides[active];
        const comments = ensureSlideComments(slide);
        const comment = {
          id: generateElementId('comment'),
          text: trimmed,
          createdAt: new Date().toISOString()
        };
        comments.push(comment);
        renderComments();
        if (commentInput) {
          commentInput.focus();
        }
        capture();
        saveEditorState('add_comment');
      }

      function deleteComment(commentId) {
        const slide = slides[active];
        const comments = ensureSlideComments(slide);
        const index = comments.findIndex((comment) => comment.id === commentId);
        if (index === -1) return;
        comments.splice(index, 1);
        renderComments();
        if (commentInput) {
          commentInput.focus();
        }
        capture();
        saveEditorState('delete_comment');
      }

      async function ensureSidebarThumbnails() {
        if (sidebarViewMode !== 'thumbnail') return;
        if (sidebarThumbnails && sidebarThumbnails.length === slides.length) return;
        if (sidebarThumbnailsPromise) return sidebarThumbnailsPromise;
        sidebarThumbnailsPromise = (async () => {
          try {
            await ensureHtml2Canvas();
            const images = await captureSlidesAsImages();
            sidebarThumbnails = images.map((image) => image.dataUrl);
          } catch (error) {
            console.error('Failed to generate slide previews:', error);
            sidebarThumbnails = null;
          } finally {
            sidebarThumbnailsPromise = null;
            renderSidebar();
          }
        })();
        return sidebarThumbnailsPromise;
      }

      function handleCommentSubmit(event) {
        event.preventDefault();
        if (!commentInput) return;
        const value = commentInput.value || '';
        if (!value.trim()) return;
        addComment(value);
      }

      if (commentForm) {
        commentForm.addEventListener('submit', handleCommentSubmit);
      }

      if (commentInput && commentSubmitButton) {
        commentSubmitButton.disabled = true;
        commentInput.addEventListener('input', () => {
          const hasText = Boolean(commentInput.value && commentInput.value.trim());
          commentSubmitButton.disabled = !hasText;
        });
      }

      let canvasZoom = 1;
      const MIN_CANVAS_ZOOM = 0.25;
      const MAX_CANVAS_ZOOM = 3;
      const CANVAS_ZOOM_STEP = 0.1;
      const CANVAS_WHEEL_ZOOM_STEP = 0.05;
      let animationDragState = {
        sourceId: null,
        targetId: null
      };
      let isAnimationSequencePanelVisible = false;
      if (animationEffectSelect) {
        animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
      }
      if (animationDurationInput) {
        animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
      }
      const initialSlide = slides[0];
      if (initialSlide) {
        if (!initialSlide.titleBox) {
          initialSlide.titleBox = { id: ensureElementHasId(titleBox, 'title') };
        }
        if (!initialSlide.titleBox.id) {
          initialSlide.titleBox.id = ensureElementHasId(titleBox, 'title');
        } else {
          titleBox.dataset.elementId = initialSlide.titleBox.id;
        }
        if (!initialSlide.textBox) {
          initialSlide.textBox = { id: ensureElementHasId(textBox, 'body') };
        }
        if (!initialSlide.textBox.id) {
          initialSlide.textBox.id = ensureElementHasId(textBox, 'body');
        } else {
          textBox.dataset.elementId = initialSlide.textBox.id;
        }
        if (!Array.isArray(initialSlide.animations)) {
          initialSlide.animations = [];
        }
      } else {
        ensureElementHasId(titleBox, 'title');
        ensureElementHasId(textBox, 'body');
      }
      const DEFAULT_FONT_FAMILY = window.getComputedStyle(textBox).fontFamily || DEFAULT_FONT_STACK;
      titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
      textBox.dataset.rotation = textBox.dataset.rotation || '0';
      titleBox.style.transform = `rotate(${parseFloat(titleBox.dataset.rotation || '0')}deg)`;
      textBox.style.transform = `rotate(${parseFloat(textBox.dataset.rotation || '0')}deg)`;
      titleBox.dataset.minWidth = titleBox.dataset.minWidth || '200';
      titleBox.dataset.minHeight = titleBox.dataset.minHeight || '50';
      textBox.dataset.minWidth = textBox.dataset.minWidth || '200';
      textBox.dataset.minHeight = textBox.dataset.minHeight || '50';
      titleBox.style.display = 'none';
      textBox.style.display = 'none';
      let isExportingPresentation = false;
      const CANVAS_INTERACTIVE_SELECTOR = '.text-box, #titleBox, #textBox, .additional-text-box, .shape-element, .chart-element, .image-element, .video-element, .table-element, .table-resize-handle, .resize-edge, .shape-rotation-handle';

      if (canvas) {
        canvas.addEventListener('pointerdown', handleCanvasPointerDown, { passive: false });
        canvas.addEventListener('dblclick', (event) => {
          if (isPresenting) return;
          const interactiveTarget = event.target.closest(CANVAS_INTERACTIVE_SELECTOR);
          if (interactiveTarget && interactiveTarget !== canvas) {
            return;
          }
          const { x: canvasX, y: canvasY } = getCanvasPointFromClient(event.clientX, event.clientY);
          lastCanvasInsertPosition = {
            x: canvasX,
            y: canvasY
          };
          const newTextBox = addTextBoxAtCanvasPosition(canvasX, canvasY);
          if (newTextBox) {
            event.preventDefault();
            event.stopPropagation();
          }
        });
        canvas.addEventListener('click', (event) => {
          const point = getCanvasPointFromClient(event.clientX, event.clientY);
          lastCanvasInsertPosition = {
            x: point.x,
            y: point.y
          };
        });
        canvas.addEventListener('contextmenu', (event) => {
          const objectTarget = event.target.closest('.image-element, .video-element, .shape-element, .chart-element, .table-element, .additional-text-box, #titleBox, #textBox');
          if (objectTarget) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          const point = getCanvasPointFromClient(event.clientX, event.clientY);
          lastCanvasInsertPosition = {
            x: point.x,
            y: point.y
          };
          showSlideCanvasContextMenu(event, active);
        });
      }
      if (titleBox) {
        titleBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(titleBox);
          showElementContextMenu(event, titleBox);
        });
      }
      if (textBox) {
        textBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(textBox);
          showElementContextMenu(event, textBox);
        });
      }

      function showNotification(message) {
        if (!saveNotification) return;
        saveNotification.textContent = message;
        saveNotification.classList.add('show');
        setTimeout(() => {
          saveNotification.classList.remove('show');
        }, 2200);
      }

      function getCanvasZoom() {
        return canvasZoom || 1;
      }

      function updateZoomUI() {
        if (zoomDisplay) {
          zoomDisplay.textContent = `${Math.round(getCanvasZoom() * 100)}%`;
        }
        if (zoomOutButton) {
          zoomOutButton.disabled = getCanvasZoom() <= MIN_CANVAS_ZOOM + 0.0001;
        }
        if (zoomInButton) {
          zoomInButton.disabled = getCanvasZoom() >= MAX_CANVAS_ZOOM - 0.0001;
        }
      }

      function applyCanvasZoomTransform() {
        if (!canvas) return;
        canvas.style.transformOrigin = '50% 50%';
        canvas.style.transform = `scale(${getCanvasZoom()})`;
      }

      function setCanvasZoom(newZoom, options = {}) {
        if (!canvas) return;
        const clampedZoom = Math.min(MAX_CANVAS_ZOOM, Math.max(MIN_CANVAS_ZOOM, newZoom));
        if (Math.abs(clampedZoom - canvasZoom) < 0.0001) {
          return;
        }
        const previousZoom = getCanvasZoom();
        const previousScrollLeft = canvasWrap ? canvasWrap.scrollLeft : 0;
        const previousScrollTop = canvasWrap ? canvasWrap.scrollTop : 0;
        let focusPoint = options.focus;
        if (!focusPoint && canvasWrap) {
          const centerX = previousScrollLeft + canvasWrap.clientWidth / 2;
          const centerY = previousScrollTop + canvasWrap.clientHeight / 2;
          focusPoint = {
            x: centerX / Math.max(previousZoom, 0.0001),
            y: centerY / Math.max(previousZoom, 0.0001)
          };
        }
        canvasZoom = clampedZoom;
        applyCanvasZoomTransform();
        if (canvasWrap && focusPoint) {
          const scaledWidth = canvas.clientWidth * canvasZoom;
          const scaledHeight = canvas.clientHeight * canvasZoom;
          const maxScrollLeft = Math.max(0, scaledWidth - canvasWrap.clientWidth);
          const maxScrollTop = Math.max(0, scaledHeight - canvasWrap.clientHeight);
          const targetScrollLeft = focusPoint.x * canvasZoom - canvasWrap.clientWidth / 2;
          const targetScrollTop = focusPoint.y * canvasZoom - canvasWrap.clientHeight / 2;
          canvasWrap.scrollLeft = Math.min(maxScrollLeft, Math.max(0, targetScrollLeft));
          canvasWrap.scrollTop = Math.min(maxScrollTop, Math.max(0, targetScrollTop));
        }
        updateZoomUI();
      }

      function adjustCanvasZoom(delta, options = {}) {
        setCanvasZoom(getCanvasZoom() + delta, options);
      }

      function resetCanvasZoom() {
        setCanvasZoom(1);
      }

      function getCanvasPointFromClient(clientX, clientY) {
        if (!canvas) {
          return { x: clientX, y: clientY };
        }
        const rect = canvas.getBoundingClientRect();
        const zoom = getCanvasZoom();
        return {
          x: (clientX - rect.left) / zoom,
          y: (clientY - rect.top) / zoom
        };
      }

      function getElementCanvasCoordinates(element) {
        if (!element) {
          return { left: 0, top: 0 };
        }
        const leftStyle = parseFloat(element.style.left);
        const topStyle = parseFloat(element.style.top);
        if (Number.isFinite(leftStyle) && Number.isFinite(topStyle)) {
          return { left: leftStyle, top: topStyle };
        }
        if (!canvas) {
          return { left: 0, top: 0 };
        }
        const rect = element.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const zoom = getCanvasZoom();
        return {
          left: (rect.left - canvasRect.left) / zoom,
          top: (rect.top - canvasRect.top) / zoom
        };
      }

      applyCanvasZoomTransform();
      updateZoomUI();

      if (zoomOutButton) {
        zoomOutButton.addEventListener('click', () => {
          adjustCanvasZoom(-CANVAS_ZOOM_STEP);
        });
      }
      if (zoomInButton) {
        zoomInButton.addEventListener('click', () => {
          adjustCanvasZoom(CANVAS_ZOOM_STEP);
        });
      }
      if (zoomResetButton) {
        zoomResetButton.addEventListener('click', () => {
          resetCanvasZoom();
        });
      }
      if (canvasWrap) {
        canvasWrap.addEventListener('wheel', (event) => {
          if (!event.ctrlKey && !event.metaKey) {
            return;
          }
          event.preventDefault();
          const delta = event.deltaY < 0 ? CANVAS_WHEEL_ZOOM_STEP : -CANVAS_WHEEL_ZOOM_STEP;
          const focus = getCanvasPointFromClient(event.clientX, event.clientY);
          adjustCanvasZoom(delta, { focus });
        }, { passive: false });
      }

      const FONT_OPTIONS = [
        { name: 'Inter', stack: DEFAULT_FONT_STACK },
        { name: 'System UI', stack: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif' },
        { name: 'Roboto', stack: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Open Sans', stack: '"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Lato', stack: 'Lato, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Montserrat', stack: 'Montserrat, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Poppins', stack: 'Poppins, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Source Sans Pro', stack: '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Nunito', stack: 'Nunito, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway', stack: 'Raleway, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Oswald', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Cabin', stack: 'Cabin, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Fira Sans', stack: '"Fira Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Arial', stack: 'Arial, Helvetica, sans-serif' },
        { name: 'Verdana', stack: 'Verdana, Geneva, sans-serif' },
        { name: 'Tahoma', stack: 'Tahoma, Geneva, sans-serif' },
        { name: 'Trebuchet MS', stack: '"Trebuchet MS", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Helvetica Neue', stack: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Times New Roman', stack: '"Times New Roman", Times, serif' },
        { name: 'Georgia', stack: 'Georgia, serif' },
        { name: 'Garamond', stack: 'Garamond, Baskerville, "Times New Roman", serif' },
        { name: 'Merriweather', stack: 'Merriweather, Georgia, serif' },
        { name: 'Playfair Display', stack: '"Playfair Display", Georgia, serif' },
        { name: 'Cambria', stack: 'Cambria, Georgia, serif' },
        { name: 'Palatino', stack: '"Palatino Linotype", "Book Antiqua", Palatino, serif' },
        { name: 'Courier New', stack: '"Courier New", Courier, monospace' },
        { name: 'IBM Plex Mono', stack: '"IBM Plex Mono", "Courier New", Courier, monospace' },
        { name: 'Consolas', stack: 'Consolas, "Liberation Mono", Courier, monospace' },
        { name: 'Fira Code', stack: '"Fira Code", "Fira Mono", "DejaVu Sans Mono", monospace' },
        { name: 'Lucida Console', stack: '"Lucida Console", Monaco, monospace' },
        { name: 'Brush Script', stack: '"Brush Script MT", cursive' },
        { name: 'Pacifico', stack: 'Pacifico, "Brush Script MT", cursive' },
        { name: 'Dancing Script', stack: '"Dancing Script", "Brush Script MT", cursive' },
        { name: 'Great Vibes', stack: '"Great Vibes", "Brush Script MT", cursive' },
        { name: 'Oswald Condensed', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Bebas Neue', stack: '"Bebas Neue", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway Dots', stack: '"Raleway Dots", "Helvetica Neue", Helvetica, Arial, sans-serif' }
      ];

      const fontDropdown = document.createElement('div');
      fontDropdown.id = 'fontDropdown';
      fontDropdown.className = 'font-dropdown';
      document.body.appendChild(fontDropdown);
      const imageFileInput = document.createElement('input');
      imageFileInput.type = 'file';
      imageFileInput.accept = 'image/*';
      imageFileInput.id = 'imageFileInput';
      imageFileInput.className = 'visually-hidden';
      document.body.appendChild(imageFileInput);
      const videoFileInput = document.createElement('input');
      videoFileInput.type = 'file';
      videoFileInput.accept = 'video/*';
      videoFileInput.id = 'videoFileInput';
      videoFileInput.className = 'visually-hidden';
      document.body.appendChild(videoFileInput);

      const fontOptionButtons = new Map();
      const fontStackToName = new Map();
      const fontNameToStack = new Map();

      const shapeDropdown = document.createElement('div');
      shapeDropdown.id = 'shapeDropdown';
      shapeDropdown.className = 'shape-dropdown';
      document.body.appendChild(shapeDropdown);
      const shapeOptionButtons = new Map();
      const chartDropdown = document.createElement('div');
      chartDropdown.id = 'chartDropdown';
      chartDropdown.className = 'chart-dropdown';
      document.body.appendChild(chartDropdown);
      const chartOptionButtons = new Map();

      const tableInsertPanel = document.createElement('div');
      tableInsertPanel.id = 'tableInsertPanel';
      tableInsertPanel.className = 'table-insert-panel';
      tableInsertPanel.innerHTML = `
        <h4>Insert Table</h4>
        <div class="table-insert-grid">
          <div class="table-insert-field">
            <label for="tableRowsInput">Rows</label>
            <input type="number" id="tableRowsInput" min="1" max="12" value="3">
          </div>
          <div class="table-insert-field">
            <label for="tableColsInput">Columns</label>
            <input type="number" id="tableColsInput" min="1" max="12" value="3">
          </div>
        </div>
        <div class="table-insert-actions">
          <button type="button" id="tableInsertConfirm">Insert</button>
        </div>
      `;
      document.body.appendChild(tableInsertPanel);
      const tableRowsInput = tableInsertPanel.querySelector('#tableRowsInput');
      const tableColsInput = tableInsertPanel.querySelector('#tableColsInput');
      const tableInsertConfirm = tableInsertPanel.querySelector('#tableInsertConfirm');

      let tablePanelManualPosition = null;
      const tablePanelDragState = {
        isDragging: false,
        pointerId: null,
        offsetX: 0,
        offsetY: 0
      };

      function clampTablePanelPosition(left, top) {
        const margin = 16;
        const panelRect = tableInsertPanel.getBoundingClientRect();
        const width = panelRect.width || tableInsertPanel.offsetWidth || 0;
        const height = panelRect.height || tableInsertPanel.offsetHeight || 0;
        const maxLeft = Math.max(margin, window.innerWidth - width - margin);
        const maxTop = Math.max(margin, window.innerHeight - height - margin);
        const clampedLeft = Math.min(Math.max(left, margin), maxLeft);
        const clampedTop = Math.min(Math.max(top, margin), maxTop);
        return { left: clampedLeft, top: clampedTop };
      }

      const tableInsertPanelHeader = tableInsertPanel.querySelector('h4');
      if (tableInsertPanelHeader) {
        tableInsertPanelHeader.addEventListener('pointerdown', (event) => {
          if (typeof event.button === 'number' && event.button > 0) {
            return;
          }
          event.preventDefault();
          const panelRect = tableInsertPanel.getBoundingClientRect();
          tablePanelDragState.isDragging = true;
          tablePanelDragState.pointerId = event.pointerId;
          tablePanelDragState.offsetX = event.clientX - panelRect.left;
          tablePanelDragState.offsetY = event.clientY - panelRect.top;
          tableInsertPanel.classList.add('dragging');
          try {
            tableInsertPanelHeader.setPointerCapture(event.pointerId);
          } catch (error) {
            // Ignore if pointer capture is not supported.
          }
        });

        tableInsertPanelHeader.addEventListener('pointermove', (event) => {
          if (!tablePanelDragState.isDragging || event.pointerId !== tablePanelDragState.pointerId) {
            return;
          }
          const desiredLeft = event.clientX - tablePanelDragState.offsetX;
          const desiredTop = event.clientY - tablePanelDragState.offsetY;
          const { left, top } = clampTablePanelPosition(desiredLeft, desiredTop);
          tableInsertPanel.style.left = `${left}px`;
          tableInsertPanel.style.top = `${top}px`;
          tablePanelManualPosition = { left, top };
        });

        const endTablePanelDrag = (event) => {
          if (!tablePanelDragState.isDragging || (event.pointerId !== undefined && event.pointerId !== tablePanelDragState.pointerId)) {
            return;
          }
          tablePanelDragState.isDragging = false;
          tablePanelDragState.pointerId = null;
          tableInsertPanel.classList.remove('dragging');
          try {
            tableInsertPanelHeader.releasePointerCapture(event.pointerId);
          } catch (error) {
            // Ignore if pointer capture cannot be released.
          }
        };

        tableInsertPanelHeader.addEventListener('pointerup', endTablePanelDrag);
        tableInsertPanelHeader.addEventListener('pointercancel', endTablePanelDrag);
      }

      const COLOR_CANVAS = document.createElement('canvas');
      COLOR_CANVAS.width = COLOR_CANVAS.height = 1;
      const COLOR_CTX = COLOR_CANVAS.getContext('2d');
      function normalizeColorHex(color) {
        if (!color) return '#ffffff';
        try {
          COLOR_CTX.fillStyle = '#000000';
          COLOR_CTX.fillStyle = color;
          return COLOR_CTX.fillStyle;
        } catch (err) {
          return '#ffffff';
        }
      }

      const SHAPE_OPTIONS = [
        {
          id: 'rectangle',
          name: 'Rectangle',
          viewBox: '0 0 100 70',
          svg: '<rect x="6" y="10" width="88" height="50" rx="10" ry="10"></rect>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#9ae6b4'
        },
        {
          id: 'square',
          name: 'Square',
          viewBox: '0 0 100 100',
          svg: '<rect x="12" y="12" width="76" height="76" rx="12" ry="12"></rect>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#a5b4fc'
        },
        {
          id: 'circle',
          name: 'Circle',
          viewBox: '0 0 100 100',
          svg: '<circle cx="50" cy="50" r="38"></circle>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#fbb6ce'
        },
        {
          id: 'triangle',
          name: 'Triangle',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 12 L90 78 H10 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#f6ad55'
        },
        {
          id: 'star',
          name: 'Star',
          viewBox: '0 0 100 100',
          svg: '<path d="M50 6 L61 36 H92 L66 54 L76 84 L50 66 L24 84 L34 54 L8 36 H39 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 160,
          minWidth: 80,
          minHeight: 80,
          defaultColor: '#fcd34d'
        },
        {
          id: 'arrow-right',
          name: 'Arrow',
          viewBox: '0 0 120 70',
          svg: '<path d="M16 28 H70 V14 L104 35 L70 56 V42 H16 Z"></path>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#4ade80'
        },
        {
          id: 'line',
          name: 'Line',
          viewBox: '0 0 100 40',
          svg: '<line x1="8" y1="32" x2="92" y2="8" stroke-linecap="round" fill="none"></line>',
          defaultWidth: 220,
          defaultHeight: 60,
          minWidth: 80,
          minHeight: 30,
          defaultColor: '#63b3ed',
          strokeWidth: 8
        },
        {
          id: 'pentagon',
          name: 'Pentagon',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 8 L90 36 L74 80 H26 L10 36 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 70,
          defaultColor: '#f472b6'
        }
      ];

      const SHAPE_OPTION_MAP = new Map(SHAPE_OPTIONS.map(shape => [shape.id, shape]));
      const CHART_OPTIONS = [
        {
          id: 'bar-classic',
          type: 'bar',
          variant: 'classic',
          variantLabel: 'Classic',
          name: 'Bar Chart (Classic)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          bars: [60, 85, 70],
          legend: [
            { label: 'Alpha', color: '#60a5fa' },
            { label: 'Beta', color: '#34d399' },
            { label: 'Gamma', color: '#fbbf24' }
          ]
        },
        {
          id: 'bar-rounded',
          type: 'bar',
          variant: 'rounded',
          variantLabel: 'Rounded',
          name: 'Bar Chart (Rounded)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          bars: [55, 78, 64],
          legend: [
            { label: 'Series A', color: '#818cf8' },
            { label: 'Series B', color: '#34d399' },
            { label: 'Series C', color: '#f97316' }
          ]
        },
        {
          id: 'bar-gradient',
          type: 'bar',
          variant: 'gradient',
          variantLabel: 'Gradient',
          name: 'Bar Chart (Gradient)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          bars: [48, 68, 80, 56],
          legend: [
            { label: 'Q1', color: '#38bdf8' },
            { label: 'Q2', color: '#22d3ee' },
            { label: 'Q3', color: '#818cf8' },
            { label: 'Q4', color: '#f472b6' }
          ]
        },
        {
          id: 'line-straight',
          type: 'line',
          variant: 'straight',
          variantLabel: 'Classic',
          name: 'Line Chart (Classic)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 260,
          minHeight: 180,
          points: [40, 55, 48, 70, 65],
          series: [
            {
              label: 'Series A',
              color: '#3b82f6',
              values: [40, 55, 48, 70, 65]
            },
            {
              label: 'Series B',
              color: '#ef4444',
              values: [32, 48, 52, 62, 58]
            }
          ],
          legend: [
            { label: 'Jan', color: '#3b82f6' },
            { label: 'Feb', color: '#22c55e' },
            { label: 'Mar', color: '#f97316' },
            { label: 'Apr', color: '#a855f7' },
            { label: 'May', color: '#14b8a6' }
          ]
        },
        {
          id: 'line-smooth',
          type: 'line',
          variant: 'smooth',
          variantLabel: 'Smooth',
          name: 'Line Chart (Smooth)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 260,
          minHeight: 180,
          points: [35, 62, 58, 74, 82],
          series: [
            {
              label: 'Series A',
              color: '#6366f1',
              values: [35, 62, 58, 74, 82]
            },
            {
              label: 'Series B',
              color: '#22c55e',
              values: [28, 54, 60, 68, 75]
            }
          ],
          legend: [
            { label: 'North', color: '#6366f1' },
            { label: 'South', color: '#22d3ee' },
            { label: 'West', color: '#f59e0b' },
            { label: 'East', color: '#ef4444' },
            { label: 'Central', color: '#10b981' }
          ]
        },
        {
          id: 'line-dotted',
          type: 'line',
          variant: 'dotted',
          variantLabel: 'Dotted',
          name: 'Line Chart (Dotted)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 260,
          minHeight: 180,
          points: [28, 46, 52, 64, 58],
          series: [
            {
              label: 'Series A',
              color: '#f97316',
              values: [28, 46, 52, 64, 58]
            },
            {
              label: 'Series B',
              color: '#3b82f6',
              values: [22, 40, 48, 60, 54]
            }
          ],
          legend: [
            { label: 'Week 1', color: '#f97316' },
            { label: 'Week 2', color: '#38bdf8' },
            { label: 'Week 3', color: '#a855f7' },
            { label: 'Week 4', color: '#4ade80' },
            { label: 'Week 5', color: '#facc15' }
          ]
        },
        {
          id: 'pie-solid',
          type: 'pie',
          variant: 'solid',
          variantLabel: 'Solid',
          name: 'Pie Chart (Solid)',
          defaultWidth: 320,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          slices: [40, 35, 25],
          legend: [
            { label: 'North', color: '#60a5fa' },
            { label: 'South', color: '#34d399' },
            { label: 'West', color: '#f97316' }
          ]
        },
        {
          id: 'pie-donut',
          type: 'pie',
          variant: 'donut',
          variantLabel: 'Donut',
          name: 'Pie Chart (Donut)',
          defaultWidth: 320,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          slices: [30, 28, 22, 20],
          legend: [
            { label: 'Q1', color: '#4f46e5' },
            { label: 'Q2', color: '#22d3ee' },
            { label: 'Q3', color: '#f59e0b' },
            { label: 'Q4', color: '#f97316' }
          ]
        },
        {
          id: 'pie-outline',
          type: 'pie',
          variant: 'outline',
          variantLabel: 'Outline',
          name: 'Pie Chart (Outline)',
          defaultWidth: 320,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          slices: [50, 30, 20],
          legend: [
            { label: 'Completed', color: '#22c55e' },
            { label: 'Pending', color: '#f97316' },
            { label: 'Upcoming', color: '#a855f7' }
          ]
        }
      ];

      const CHART_OPTION_MAP = new Map(CHART_OPTIONS.map(chart => [chart.id, chart]));
      const CHART_OPTION_ALIASES = new Map([
        ['pie', 'pie-solid'],
        ['bar', 'bar-classic'],
        ['line', 'line-straight']
      ]);
      const PIE_VARIANT_OPTIONS = CHART_OPTIONS.filter(chart => (chart.type || chart.id) === 'pie');

      const CHART_VARIANT_MAP = new Map();
      CHART_OPTIONS.forEach((chart) => {
        const typeKey = chart.type || chart.id;
        if (!CHART_VARIANT_MAP.has(typeKey)) {
          CHART_VARIANT_MAP.set(typeKey, []);
        }
        CHART_VARIANT_MAP.get(typeKey).push(chart);
      });

      function getChartOptionById(id) {
        if (!id) return CHART_OPTIONS[0];
        const normalized = CHART_OPTION_MAP.has(id)
          ? id
          : (CHART_OPTION_ALIASES.get(id) || id);
        return CHART_OPTION_MAP.get(normalized) || CHART_OPTIONS[0];
      }

      function normalizeFontStack(value) {
        if (!value) return '';
        return value.replace(/"/g, "'").split(',').map(part => part.replace(/['"]/g, '').trim().toLowerCase()).join(',');
      }

      FONT_OPTIONS.forEach(font => {
        const normalized = normalizeFontStack(font.stack);
        fontStackToName.set(normalized, font.name);
        fontNameToStack.set(font.name.toLowerCase(), font.stack);
      });

      function renderFontOptions() {
        fontDropdown.innerHTML = '';
        fontOptionButtons.clear();
        FONT_OPTIONS.forEach(font => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'font-option';
          option.textContent = font.name;
          option.style.fontFamily = font.stack;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            applyFontFamilyToCurrent(font.stack);
            hideFontDropdown();
          });
          fontDropdown.appendChild(option);
          fontOptionButtons.set(normalizeFontStack(font.stack), option);
        });
      }

      function renderShapeOptions() {
        shapeDropdown.innerHTML = '';
        shapeOptionButtons.clear();
        SHAPE_OPTIONS.forEach(shape => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'shape-option';
          option.innerHTML = `
            <div class="shape-option-preview">${renderShapeSvg(shape)}</div>
            <span class="shape-option-label">${shape.name}</span>
          `;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            insertShape(shape.id);
            hideShapeDropdown();
          });
          shapeDropdown.appendChild(option);
          shapeOptionButtons.set(shape.id, option);
        });
      }

      function renderChartOptions() {
        chartDropdown.innerHTML = '';
        chartOptionButtons.clear();
        const seenTypes = new Set();
        CHART_OPTIONS.forEach(chart => {
          const chartTypeKey = chart.type || chart.id;
          if (seenTypes.has(chartTypeKey)) {
            return;
          }
          seenTypes.add(chartTypeKey);
        const option = document.createElement('button');
        option.type = 'button';
        option.className = 'chart-option';
        const isPieChart = chart.type === 'pie' || chartTypeKey === 'pie';
        const isLineChart = chart.type === 'line' || chartTypeKey === 'line';
        let preview;
        let label;
        if (isPieChart) {
          preview = '<div class="chart-mini pie"></div>';
          label = 'Pie Chart';
        } else if (isLineChart) {
          preview = '<div class="chart-mini line"><span></span></div>';
          label = 'Line Chart';
        } else {
          preview = '<div class="chart-mini bar"><span></span></div>';
          label = 'Bar Chart';
        }
        option.innerHTML = `
          <div class="chart-option-preview">
            ${preview}
          </div>
          <span class="chart-option-label">${label}</span>
        `;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            insertChart(chart.id);
            hideChartDropdown();
          });
          chartDropdown.appendChild(option);
          chartOptionButtons.set(chart.id, option);
        });
      }

      renderShapeOptions();
      renderChartOptions();

      renderFontOptions();

      const shapeColorPicker = document.createElement('div');
      shapeColorPicker.id = 'shapeColorPicker';
      shapeColorPicker.className = 'shape-color-picker';
      shapeColorPicker.innerHTML = `
        <button type="button" id="shapeColorButton" class="shape-color-button" title="Shape Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="shapeColorInput" class="shape-color-input" value="#e8f5e9" aria-label="Shape Fill Color Picker">
      `;
      document.body.appendChild(shapeColorPicker);
      const shapeColorButton = document.getElementById('shapeColorButton');
      const shapeColorInput = document.getElementById('shapeColorInput');
      const shapeSizeBadge = document.createElement('div');
      shapeSizeBadge.id = 'shapeSizeBadge';
      shapeSizeBadge.className = 'shape-size-badge';
      document.body.appendChild(shapeSizeBadge);

      const tableColumnColorPicker = document.createElement('div');
      tableColumnColorPicker.id = 'tableColumnColorPicker';
      tableColumnColorPicker.className = 'shape-color-picker table-column-color-picker';
      tableColumnColorPicker.innerHTML = `
        <button type="button" id="tableColumnColorButton" class="shape-color-button" title="Column Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="tableColumnColorInput" class="shape-color-input" value="#ecfdf5" aria-label="Column Fill Color Picker">
      `;
      document.body.appendChild(tableColumnColorPicker);
      const tableColumnColorButton = tableColumnColorPicker.querySelector('#tableColumnColorButton');
      const tableColumnColorInput = tableColumnColorPicker.querySelector('#tableColumnColorInput');

      const chartDataEditor = document.createElement('div');
      chartDataEditor.id = 'chartDataEditor';
      chartDataEditor.className = 'chart-data-editor';
      chartDataEditor.innerHTML = `
        <div class="chart-data-header">
          <div class="chart-data-title">Chart Data</div>
          <button type="button" class="chart-data-close" aria-label="Close chart data editor">&times;</button>
        </div>
        <div class="chart-data-subtitle" id="chartDataSubtitle"></div>
        <div class="chart-data-variant" id="chartDataVariantContainer" hidden>
          <span class="chart-data-variant-label">Style</span>
          <div class="chart-data-variant-options" id="chartDataVariantOptions"></div>
        </div>
        <div class="chart-data-toggle hidden" id="chartDataShowValuesRow">
          <span class="chart-data-toggle-label">Show values on chart</span>
          <input type="checkbox" id="chartDataShowValuesCheckbox" aria-label="Show values on chart">
        </div>
        <div class="chart-data-table-wrapper" id="chartDataStandardEditor">
          <table class="chart-data-table">
            <thead>
              <tr>
                <th>Label</th>
                <th>Value</th>
                <th>Color</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <div class="chart-data-empty" id="chartDataEmptyMessage" hidden>No data rows yet</div>
        </div>
        <div class="chart-data-line-editor hidden" id="chartDataLineEditor">
          <div class="chart-line-series-section">
            <div class="chart-line-series-header">
              <span class="chart-line-series-title">Lines</span>
              <button type="button" id="lineSeriesAddButton">Add Line</button>
            </div>
            <div class="chart-line-series-list" id="lineSeriesList"></div>
          </div>
          <div class="chart-line-points-section">
            <div class="chart-line-points-header">
              <span class="chart-line-points-title">Data Points</span>
              <div class="chart-line-points-actions">
                <button type="button" id="linePointAddButton">Add Point</button>
                <button type="button" id="linePointRemoveButton">Remove Point</button>
              </div>
            </div>
            <div class="chart-line-values-table-wrapper">
              <table class="chart-data-table chart-line-values-table" id="lineValuesTable">
                <thead></thead>
                <tbody></tbody>
              </table>
              <div class="chart-data-empty" id="lineValuesEmptyMessage" hidden>No data points yet</div>
            </div>
          </div>
        </div>
        <div class="chart-data-actions" id="chartDataStandardActions">
          <button type="button" id="chartDataAddRowButton">Add Row</button>
          <button type="button" id="chartDataRemoveRowButton">Remove Row</button>
        </div>
      `;
      document.body.appendChild(chartDataEditor);
      const chartDataSubtitle = document.getElementById('chartDataSubtitle');
      const chartDataEmptyMessage = document.getElementById('chartDataEmptyMessage');
      const chartDataStandardEditor = document.getElementById('chartDataStandardEditor');
      const chartDataStandardActions = document.getElementById('chartDataStandardActions');
      const chartDataEditorTableBody = chartDataStandardEditor.querySelector('tbody');
      const chartDataAddRowButton = document.getElementById('chartDataAddRowButton');
      const chartDataRemoveRowButton = document.getElementById('chartDataRemoveRowButton');
      const chartDataCloseButton = chartDataEditor.querySelector('.chart-data-close');
      const chartDataVariantContainer = document.getElementById('chartDataVariantContainer');
      const chartDataVariantOptions = document.getElementById('chartDataVariantOptions');
      const chartDataShowValuesRow = document.getElementById('chartDataShowValuesRow');
      const chartDataShowValuesCheckbox = document.getElementById('chartDataShowValuesCheckbox');
      const chartDataLineEditor = document.getElementById('chartDataLineEditor');
      const lineSeriesList = document.getElementById('lineSeriesList');
      const lineSeriesAddButton = document.getElementById('lineSeriesAddButton');
      const linePointAddButton = document.getElementById('linePointAddButton');
      const linePointRemoveButton = document.getElementById('linePointRemoveButton');
      const lineValuesTable = document.getElementById('lineValuesTable');
      const lineValuesTableHead = lineValuesTable.querySelector('thead');
      const lineValuesTableBody = lineValuesTable.querySelector('tbody');
      const lineValuesEmptyMessage = document.getElementById('lineValuesEmptyMessage');
      let chartDataDragState = null;

      const CHART_COLOR_SEQUENCE = ['#60a5fa', '#34d399', '#f97316', '#fbbf24', '#a78bfa', '#f472b6', '#10b981', '#f87171'];
      let activeChartDataElement = null;
      let chartDataAutoSaveTimeout = null;

      function applyChartVariantToElement(element, variantId) {
        if (!element) return;
        const chartConfig = getChartOptionById(variantId);
        if (!chartConfig) return;
        const chartType = chartConfig.type || chartConfig.id;
        if (chartType === 'line') {
          element.dataset.chartType = chartConfig.id;
          if (chartConfig.variant) {
            element.dataset.chartVariant = chartConfig.variant;
          } else {
            delete element.dataset.chartVariant;
          }
          if (chartConfig.minWidth) {
            element.dataset.minWidth = String(chartConfig.minWidth);
          }
          if (chartConfig.minHeight) {
            element.dataset.minHeight = String(chartConfig.minHeight);
          }
          const showValues = element.dataset.showValues === 'true';
          const currentState = getLineChartState(element, chartConfig);
          setLineChartState(element, chartConfig, {
            categories: currentState.categories,
            series: currentState.series,
            title: element.dataset.title || chartConfig.name || 'Chart',
            showValues
          });
          return;
        }
        let legend = normalizeChartLegend(element.dataset.legend, chartConfig.legend || []);
        let values = chartType === 'pie'
          ? normalizeNumberArray(element.dataset.slices, [])
          : normalizeNumberArray(element.dataset.bars, []);
        const defaults = chartType === 'pie' ? (chartConfig.slices || []) : (chartConfig.bars || []);
        if (!values.length) {
          values = defaults.length ? [...defaults] : [chartType === 'pie' ? 25 : 50];
        }
        const targetLength = defaults.length || Math.max(values.length, legend.length, 1);
        if (values.length < targetLength) {
          for (let i = values.length; i < targetLength; i += 1) {
            values.push(defaults[i] != null ? defaults[i] : values[values.length - 1] || (chartType === 'pie' ? 25 : 50));
          }
        } else if (values.length > targetLength) {
          values = values.slice(0, targetLength);
        }
        if (legend.length < targetLength) {
          const baseLegend = chartConfig.legend || [];
          for (let i = legend.length; i < targetLength; i += 1) {
            const fallback = baseLegend[i] || {};
            legend.push({
              label: fallback.label || `${chartType === 'pie' ? 'Slice' : 'Series'} ${i + 1}`,
            color: normalizeColorHex(fallback.color || CHART_COLOR_SEQUENCE[i % CHART_COLOR_SEQUENCE.length])
            });
          }
        } else if (legend.length > targetLength) {
          legend = legend.slice(0, targetLength);
        }
        element.dataset.chartType = chartConfig.id;
        if (chartConfig.variant) {
          element.dataset.chartVariant = chartConfig.variant;
        } else {
          delete element.dataset.chartVariant;
        }
        if (chartConfig.minWidth) {
          element.dataset.minWidth = String(chartConfig.minWidth);
        }
        if (chartConfig.minHeight) {
          element.dataset.minHeight = String(chartConfig.minHeight);
        }
        const showValues = element.dataset.showValues === 'true';
        element.dataset.showValues = showValues ? 'true' : 'false';
        element.dataset.legend = JSON.stringify(legend);
        if (chartType === 'pie') {
          element.dataset.slices = JSON.stringify(values);
          delete element.dataset.bars;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        } else {
          element.dataset.bars = JSON.stringify(values);
          delete element.dataset.slices;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        }
        const payload = {
          legend,
          title: element.dataset.title || chartConfig.name || 'Chart',
          showValues
        };
        if (chartType === 'pie') {
          payload.slices = values;
        } else if (chartType === 'line') {
          payload.points = values;
        } else {
          payload.bars = values;
        }
        element.innerHTML = renderChartMarkup(chartConfig, payload);
        createResizeEdges(element);
      }

      function getChartConfigForElement(element) {
        if (!element) return null;
        const chartKey = element.dataset.chartType || 'bar';
        return getChartOptionById(chartKey);
      }

      function getChartValuesForElement(element, chartConfig) {
        if (!element) return [];
        const chartKey = element.dataset.chartType || chartConfig?.id || 'bar';
        const chartType = chartConfig?.type || chartKey;
        if (chartType === 'pie') {
          return normalizeNumberArray(element.dataset.slices, chartConfig?.slices || []);
        }
        if (chartType === 'line') {
          const state = getLineChartState(element, chartConfig);
          return state.series[0]?.values || normalizeNumberArray(element.dataset.points, chartConfig?.points || []);
        }
        return normalizeNumberArray(element.dataset.bars, chartConfig?.bars || []);
      }

      function applyChartDataToElement(element, legendInput, valuesInput) {
        if (!element) return;
        const chartConfig = getChartConfigForElement(element);
        const chartKey = element.dataset.chartType || chartConfig?.id || 'bar';
        const chartType = chartConfig?.type || chartKey;
        if (chartType === 'line') {
          const existingState = getLineChartState(element, chartConfig);
          const categories = legendInput.length
            ? legendInput.map((legendItem, index) => ({
                label: typeof legendItem?.label === 'string' && legendItem.label.trim()
                  ? legendItem.label.trim()
                  : (existingState.categories[index]?.label || `Point ${index + 1}`),
                color: normalizeColorHex(
                  legendItem?.color
                  || existingState.categories[index]?.color
                  || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
                )
              }))
            : existingState.categories;
          const firstSeriesValues = valuesInput.map((rawValue, index) => {
            const numericValue = Number(rawValue);
            const fallbackValue = existingState.series[0]?.values?.[index];
            if (Number.isFinite(numericValue)) return numericValue;
            if (Number.isFinite(fallbackValue)) return fallbackValue;
            return 0;
          });
          const adjustedValues = adjustNumberArrayLength(
            firstSeriesValues,
            Math.max(categories.length, firstSeriesValues.length, 1),
            existingState.series[0]?.values || []
          );
          const series = existingState.series.length
            ? existingState.series.map((seriesItem, index) => {
                if (index === 0) {
                  return {
                    label: seriesItem.label || 'Line 1',
                    color: normalizeColorHex(seriesItem.color || CHART_COLOR_SEQUENCE[0]),
                    values: adjustedValues
                  };
                }
                const paddedValues = adjustNumberArrayLength(
                  Array.isArray(seriesItem.values) ? seriesItem.values : [],
                  adjustedValues.length,
                  seriesItem.values || []
                );
                return {
                  label: seriesItem.label || `Line ${index + 1}`,
                  color: normalizeColorHex(seriesItem.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]),
                  values: paddedValues
                };
              })
            : [{
                label: 'Line 1',
                color: normalizeColorHex(CHART_COLOR_SEQUENCE[0]),
                values: adjustedValues
              }];
          setLineChartState(element, chartConfig, {
            categories,
            series,
            title: element.dataset.title || '',
            showValues: element.dataset.showValues === 'true'
          });
          return;
        }
        const targetLength = Math.max(legendInput.length, valuesInput.length, 1);
        const legend = [];
        const values = [];
        for (let index = 0; index < targetLength; index += 1) {
          const legendItem = legendInput[index] || {};
          const label = typeof legendItem?.label === 'string' ? legendItem.label.trim() : '';
          const fallbackColor = (chartConfig?.legend && chartConfig.legend[index]?.color)
            || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length];
          const color = legendItem?.color && legendItem.color.trim() ? legendItem.color : fallbackColor;
          legend.push({ label, color });
          const rawValue = valuesInput[index];
          const numericValue = Number(rawValue);
          values.push(Number.isFinite(numericValue) ? numericValue : 0);
        }
        element.dataset.legend = JSON.stringify(legend);
        if (chartType === 'pie') {
          element.dataset.slices = JSON.stringify(values);
          delete element.dataset.bars;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        } else {
          element.dataset.bars = JSON.stringify(values);
          delete element.dataset.slices;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        }
        const payload = {
          legend,
          title: element.dataset.title || '',
          showValues: element.dataset.showValues === 'true'
        };
        if (chartType === 'pie') {
          payload.slices = values;
        } else if (chartType === 'line') {
          payload.points = values;
        } else {
          payload.bars = values;
        }
        element.innerHTML = renderChartMarkup(chartConfig, payload);
        createResizeEdges(element);
      }

      function populateChartDataEditor(element) {
        if (!element) return;
        const chartConfig = getChartConfigForElement(element);
        const legend = normalizeChartLegend(element.dataset.legend, chartConfig?.legend || []);
        const values = getChartValuesForElement(element, chartConfig);
        const chartType = chartConfig?.type || chartConfig?.id;
        const supportsToggle = chartType === 'bar' || chartType === 'pie' || chartType === 'line';
        if (chartDataShowValuesRow && chartDataShowValuesCheckbox) {
          if (supportsToggle) {
            chartDataShowValuesRow.classList.remove('hidden');
            chartDataShowValuesCheckbox.checked = element.dataset.showValues === 'true';
            chartDataShowValuesCheckbox.disabled = false;
          } else {
            chartDataShowValuesRow.classList.add('hidden');
            chartDataShowValuesCheckbox.checked = false;
            chartDataShowValuesCheckbox.disabled = true;
          }
        }
        if (chartDataVariantContainer && chartDataVariantOptions) {
          const variantOptions = CHART_VARIANT_MAP.get(chartType) || [];
          if (variantOptions.length > 1) {
            chartDataVariantContainer.hidden = false;
            chartDataVariantOptions.innerHTML = '';
            const currentVariantConfig = getChartOptionById(element.dataset.chartType || chartConfig.id);
            const currentVariantId = currentVariantConfig?.id || chartConfig.id;
            variantOptions.forEach((variant) => {
              const button = document.createElement('button');
              button.type = 'button';
              button.className = 'chart-data-variant-button' + (variant.id === currentVariantId ? ' active' : '');
              const variantLabel = variant.variantLabel
                || (variant.variant ? variant.variant.charAt(0).toUpperCase() + variant.variant.slice(1) : 'Default');
              button.textContent = variantLabel;
              button.title = variant.name;
              button.dataset.variantId = variant.id;
              button.addEventListener('click', () => {
                const activeConfig = getChartOptionById(element.dataset.chartType || chartConfig.id);
                if (activeConfig?.id === variant.id) {
                  return;
                }
                applyChartVariantToElement(element, variant.id);
                populateChartDataEditor(element);
                capture();
                renderSidebar();
                saveEditorState('change_chart_style');
              });
              chartDataVariantOptions.appendChild(button);
            });
          } else {
            chartDataVariantContainer.hidden = true;
            chartDataVariantOptions.innerHTML = '';
          }
        }
        const length = Math.max(legend.length, values.length, 1);
        const table = chartDataEditorTableBody.closest('table');
        if (chartType === 'line') {
          chartDataStandardEditor.classList.add('hidden');
          chartDataStandardActions.classList.add('hidden');
          chartDataLineEditor.classList.remove('hidden');
          const state = getLineChartState(element, chartConfig, { ensureDataset: true });
          renderLineChartEditor(state.categories, state.series, chartConfig);
          chartDataSubtitle.textContent = chartConfig?.name ? `${chartConfig.name}` : 'Chart';
          return;
        }
        chartDataLineEditor.classList.add('hidden');
        chartDataStandardEditor.classList.remove('hidden');
        chartDataStandardActions.classList.remove('hidden');
        chartDataEditorTableBody.innerHTML = '';
        for (let index = 0; index < length; index += 1) {
          const row = document.createElement('tr');
          row.dataset.index = String(index);

          const labelCell = document.createElement('td');
          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.placeholder = 'Label';
          labelInput.value = legend[index]?.label || '';
          labelInput.className = 'chart-data-input';
          labelInput.dataset.field = 'label';
          labelCell.appendChild(labelInput);

          const valueCell = document.createElement('td');
          const valueInput = document.createElement('input');
          valueInput.type = 'number';
          valueInput.step = 'any';
          valueInput.placeholder = '0';
          const numericValue = Number(values[index]);
          valueInput.value = Number.isFinite(numericValue) ? String(numericValue) : '';
          valueInput.className = 'chart-data-input';
          valueInput.dataset.field = 'value';
          valueCell.appendChild(valueInput);

          const colorCell = document.createElement('td');
          const colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.className = 'chart-data-color-input';
          colorInput.value = normalizeColorHex(legend[index]?.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]);
          colorInput.dataset.field = 'color';
          colorCell.appendChild(colorInput);

          row.appendChild(labelCell);
          row.appendChild(valueCell);
          row.appendChild(colorCell);
          chartDataEditorTableBody.appendChild(row);
        }
        const rowCount = chartDataEditorTableBody.querySelectorAll('tr').length;
        if (rowCount > 0) {
          table.removeAttribute('hidden');
          chartDataEmptyMessage.hidden = true;
        } else {
          table.setAttribute('hidden', 'hidden');
          chartDataEmptyMessage.hidden = false;
        }
        chartDataRemoveRowButton.disabled = rowCount <= 1;
        chartDataSubtitle.textContent = chartConfig?.name ? `${chartConfig.name}` : 'Chart';
      }

      function renderLineChartEditor(categories, series, chartConfig) {
        const categoryCount = Math.max(
          Array.isArray(categories) ? categories.length : 0,
          series.reduce((max, item) => Math.max(max, Array.isArray(item?.values) ? item.values.length : 0), 0),
          1
        );
        const normalizedCategories = normalizeLineCategories(categories, chartConfig?.legend || [], categoryCount);
        const normalizedSeries = normalizeLineSeries(series, chartConfig?.series || [], categoryCount);
        lineSeriesList.innerHTML = '';
        normalizedSeries.forEach((seriesItem, index) => {
          const item = document.createElement('div');
          item.className = 'chart-line-series-item';
          item.dataset.index = String(index);

          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.className = 'chart-data-input line-series-label';
          labelInput.placeholder = 'Line Name';
          labelInput.value = seriesItem.label || `Line ${index + 1}`;

          const colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.className = 'chart-data-color-input line-series-color';
          colorInput.value = normalizeColorHex(seriesItem.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]);

          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'chart-line-series-remove';
          removeButton.dataset.index = String(index);
          removeButton.textContent = 'Remove';
          if (normalizedSeries.length <= 1) {
            removeButton.disabled = true;
            removeButton.hidden = true;
          }

          item.appendChild(labelInput);
          item.appendChild(colorInput);
          item.appendChild(removeButton);
          lineSeriesList.appendChild(item);
        });

        lineValuesTableHead.innerHTML = '';
        const headerRow = document.createElement('tr');
        const labelHeader = document.createElement('th');
        labelHeader.textContent = 'Point Label';
        headerRow.appendChild(labelHeader);
        normalizedSeries.forEach((seriesItem, index) => {
          const th = document.createElement('th');
          th.textContent = seriesItem.label || `Line ${index + 1}`;
          th.dataset.seriesIndex = String(index);
          headerRow.appendChild(th);
        });
        lineValuesTableHead.appendChild(headerRow);

        lineValuesTableBody.innerHTML = '';
        normalizedCategories.forEach((categoryItem, index) => {
          const row = document.createElement('tr');
          row.dataset.index = String(index);

          const labelCell = document.createElement('td');
          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.className = 'chart-data-input line-point-label';
          labelInput.placeholder = 'Label';
          labelInput.value = categoryItem.label || `Point ${index + 1}`;
          labelCell.appendChild(labelInput);
          row.appendChild(labelCell);

          normalizedSeries.forEach((seriesItem, seriesIndex) => {
            const valueCell = document.createElement('td');
            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.step = 'any';
            valueInput.className = 'chart-data-input line-point-value';
            valueInput.dataset.seriesIndex = String(seriesIndex);
            const numericValue = Number(seriesItem.values?.[index]);
            valueInput.value = Number.isFinite(numericValue) ? String(numericValue) : '';
            valueCell.appendChild(valueInput);
            row.appendChild(valueCell);
          });

          lineValuesTableBody.appendChild(row);
        });
        const hasRows = lineValuesTableBody.querySelectorAll('tr').length > 0;
        lineValuesEmptyMessage.hidden = hasRows;
        ensureLineEditorButtonState(normalizedCategories.length, normalizedSeries.length);
      }

      function ensureLineEditorButtonState(categoriesLength, seriesLength) {
        if (linePointRemoveButton) {
          linePointRemoveButton.disabled = categoriesLength <= 1;
        }
        const removeButtons = lineSeriesList.querySelectorAll('.chart-line-series-remove');
        removeButtons.forEach((button) => {
          button.disabled = seriesLength <= 1;
          button.hidden = seriesLength <= 1;
        });
      }

      function updateLineHeaderLabels() {
        const headerCells = lineValuesTableHead.querySelectorAll('th[data-series-index]');
        headerCells.forEach((cell) => {
          const index = Number(cell.dataset.seriesIndex);
          if (!Number.isFinite(index)) return;
          const labelInput = lineSeriesList.querySelector(`.chart-line-series-item[data-index="${index}"] .line-series-label`);
          if (labelInput) {
            cell.textContent = labelInput.value || `Line ${index + 1}`;
          }
        });
      }

      function collectLineEditorState(chartConfig) {
        const previousState = activeChartDataElement
          ? getLineChartState(activeChartDataElement, chartConfig)
          : { categories: [], series: [] };
        const seriesNodes = Array.from(lineSeriesList.querySelectorAll('.chart-line-series-item'));
        const series = seriesNodes.map((node, index) => {
          const labelInput = node.querySelector('.line-series-label');
          const colorInput = node.querySelector('.line-series-color');
          const fallbackSeries = previousState.series[index] || {};
          return {
            label: labelInput ? labelInput.value : (fallbackSeries.label || `Line ${index + 1}`),
            color: normalizeColorHex(
              colorInput ? colorInput.value || fallbackSeries.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
                : (fallbackSeries.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length])
            ),
            values: []
          };
        });
        const rows = Array.from(lineValuesTableBody.querySelectorAll('tr'));
        const categories = rows.map((row, rowIndex) => {
          const labelInput = row.querySelector('.line-point-label');
          const fallbackCategory = previousState.categories[rowIndex] || {};
          return {
            label: labelInput ? labelInput.value : (fallbackCategory.label || `Point ${rowIndex + 1}`),
            color: normalizeColorHex(
              fallbackCategory.color
              || chartConfig?.legend?.[rowIndex]?.color
              || CHART_COLOR_SEQUENCE[rowIndex % CHART_COLOR_SEQUENCE.length]
            )
          };
        });
        rows.forEach((row, rowIndex) => {
          series.forEach((seriesItem, seriesIndex) => {
            const valueInput = row.querySelector(`input[data-series-index="${seriesIndex}"]`);
            const numericValue = valueInput ? Number(valueInput.value) : NaN;
            if (Number.isFinite(numericValue)) {
              seriesItem.values.push(numericValue);
            } else {
              const fallbackValue = previousState.series[seriesIndex]?.values?.[rowIndex];
              seriesItem.values.push(Number.isFinite(fallbackValue) ? fallbackValue : 0);
            }
          });
        });
        const categoriesLength = categories.length;
        series.forEach((seriesItem, seriesIndex) => {
          seriesItem.values = adjustNumberArrayLength(
            seriesItem.values,
            Math.max(categoriesLength, 1),
            previousState.series[seriesIndex]?.values || []
          );
        });
        return { categories, series };
      }

      function addLineChartSeries() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        const newIndex = state.series.length;
        const categoriesLength = Math.max(state.categories.length, 1);
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        const templateSeries = fallbackSeries[newIndex] || fallbackSeries[0] || {};
        const defaultLabel = templateSeries.label || `Line ${newIndex + 1}`;
        const defaultColor = normalizeColorHex(
          templateSeries.color || CHART_COLOR_SEQUENCE[newIndex % CHART_COLOR_SEQUENCE.length]
        );
        const templateValues = Array.isArray(templateSeries.values) && templateSeries.values.length
          ? templateSeries.values
          : (state.series[0]?.values || []);
        const paddedValues = adjustNumberArrayLength(
          templateValues.map((value) => {
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : 0;
          }),
          categoriesLength,
          templateValues
        );
        state.series.push({
          label: defaultLabel,
          color: defaultColor,
          values: paddedValues
        });
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function removeLineChartSeries(index) {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        if (state.series.length <= 1) return;
        if (!Number.isFinite(index) || index < 0 || index >= state.series.length) return;
        state.series.splice(index, 1);
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function addLineChartPoint() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        const newIndex = state.categories.length;
        const fallbackCategory = chartConfig?.legend?.[newIndex] || {};
        state.categories.push({
          label: fallbackCategory.label || `Point ${newIndex + 1}`,
          color: normalizeColorHex(
            fallbackCategory.color || CHART_COLOR_SEQUENCE[newIndex % CHART_COLOR_SEQUENCE.length]
          )
        });
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        state.series = state.series.map((seriesItem, seriesIndex) => {
          const fallbackValues = fallbackSeries[seriesIndex]?.values || seriesItem.values;
          const fallbackValue = Number(fallbackValues?.[fallbackValues.length - 1]);
          const priorValue = seriesItem.values.length ? seriesItem.values[seriesItem.values.length - 1] : 50;
          const valueToAdd = Number.isFinite(fallbackValue) ? fallbackValue : priorValue;
          return {
            ...seriesItem,
            values: [...seriesItem.values, Number.isFinite(valueToAdd) ? valueToAdd : 0]
          };
        });
        state.series.forEach((seriesItem, seriesIndex) => {
          seriesItem.values = adjustNumberArrayLength(
            seriesItem.values,
            state.categories.length,
            chartConfig?.series?.[seriesIndex]?.values || seriesItem.values
          );
        });
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function removeLineChartPoint() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        if (state.categories.length <= 1) return;
        state.categories.pop();
        state.series.forEach((seriesItem) => {
          if (Array.isArray(seriesItem.values) && seriesItem.values.length) {
            seriesItem.values.pop();
          }
        });
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function scheduleChartDataStateSave() {
        clearTimeout(chartDataAutoSaveTimeout);
        chartDataAutoSaveTimeout = setTimeout(() => {
          capture();
          renderSidebar();
          saveEditorState('edit_chart_data');
        }, 600);
      }

      function syncActiveChartDataFromEditor() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        if ((chartConfig?.type || chartConfig?.id) === 'line') {
          const state = collectLineEditorState(chartConfig);
          setLineChartState(activeChartDataElement, chartConfig, {
            categories: state.categories,
            series: state.series,
            title: activeChartDataElement.dataset.title || '',
            showValues: activeChartDataElement.dataset.showValues === 'true'
          });
          updateLineHeaderLabels();
          scheduleChartDataStateSave();
          return;
        }
        const existingLegend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
        const rows = Array.from(chartDataEditorTableBody.querySelectorAll('tr'));
        if (!rows.length) {
          applyChartDataToElement(activeChartDataElement, existingLegend.length ? existingLegend : (chartConfig?.legend || []), getChartValuesForElement(activeChartDataElement, chartConfig));
          scheduleChartDataStateSave();
          return;
        }
        const updatedLegend = [];
        const updatedValues = [];
        rows.forEach((row, index) => {
          const labelInput = row.querySelector('input[data-field="label"]');
          const valueInput = row.querySelector('input[data-field="value"]');
          const colorInput = row.querySelector('input[data-field="color"]');
          const baseLegendItem = existingLegend[index] || {};
          const label = labelInput ? labelInput.value : '';
          const valueRaw = valueInput ? valueInput.value : '';
          const fallbackColor = normalizeColorHex(
            baseLegendItem.color
            || (chartConfig?.legend && chartConfig.legend[index]?.color)
            || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
          );
          const colorValue = colorInput ? normalizeColorHex(colorInput.value || fallbackColor) : fallbackColor;
          updatedLegend.push({
            label,
            color: colorValue
          });
          const numericValue = Number(valueRaw);
          updatedValues.push(Number.isFinite(numericValue) ? numericValue : 0);
        });
        applyChartDataToElement(activeChartDataElement, updatedLegend, updatedValues);
        scheduleChartDataStateSave();
      }

      function addChartDataRow() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        if ((chartConfig?.type || chartConfig?.id) === 'line') {
          addLineChartPoint();
          return;
        }
        const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
        const values = getChartValuesForElement(activeChartDataElement, chartConfig);
        const nextIndex = Math.max(legend.length, values.length);
        const typeForBase = chartConfig?.type || chartConfig?.id;
        let defaultLabelBase = 'Series';
        if (typeForBase === 'pie') {
          defaultLabelBase = 'Slice';
        } else if (typeForBase === 'line') {
          defaultLabelBase = 'Point';
        }
        legend.push({
          label: `${defaultLabelBase} ${nextIndex + 1}`,
          color: normalizeColorHex(
            (chartConfig?.legend && chartConfig.legend[nextIndex]?.color) || CHART_COLOR_SEQUENCE[nextIndex % CHART_COLOR_SEQUENCE.length]
          )
        });
        const previousValue = values.length ? values[values.length - 1] : ((chartConfig?.type || chartConfig?.id) === 'pie' ? 25 : 50);
        values.push(previousValue);
        applyChartDataToElement(activeChartDataElement, legend, values);
        populateChartDataEditor(activeChartDataElement);
        scheduleChartDataStateSave();
      }

      function removeChartDataRow() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        if ((chartConfig?.type || chartConfig?.id) === 'line') {
          removeLineChartPoint();
          return;
        }
        const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
        const values = getChartValuesForElement(activeChartDataElement, chartConfig);
        if (legend.length <= 1 || values.length <= 1) {
          return;
        }
        legend.pop();
        values.pop();
        applyChartDataToElement(activeChartDataElement, legend, values);
        populateChartDataEditor(activeChartDataElement);
        scheduleChartDataStateSave();
      }

      function showChartDataEditor(element) {
        if (!element) return;
        activeChartDataElement = element;
        populateChartDataEditor(element);
        chartDataEditor.classList.add('visible');
        chartDataEditor.style.left = '';
        chartDataEditor.style.top = '';
        chartDataEditor.style.right = '36px';
        chartDataEditor.style.top = '120px';
      }

      function hideChartDataEditor() {
        chartDataEditor.classList.remove('visible');
        activeChartDataElement = null;
      }

      function getConstrainedChartDataPosition(left, top) {
        const padding = 16;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const rect = chartDataEditor.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        const maxLeft = viewportWidth - width - padding;
        const maxTop = viewportHeight - height - padding;
        return {
          left: Math.min(Math.max(padding, left), Math.max(padding, maxLeft)),
          top: Math.min(Math.max(padding, top), Math.max(padding, maxTop))
        };
      }

      function handleChartDataHeaderPointerDown(event) {
        const header = event.target.closest('.chart-data-header');
        if (!header || event.target.closest('.chart-data-close')) {
          return;
        }
        event.preventDefault();
        const rect = chartDataEditor.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        chartDataDragState = { offsetX, offsetY };
        chartDataEditor.style.right = 'auto';
        chartDataEditor.setPointerCapture?.(event.pointerId);
      }

      function handleChartDataHeaderPointerMove(event) {
        if (!chartDataDragState) return;
        const { offsetX, offsetY } = chartDataDragState;
        const left = event.clientX - offsetX;
        const top = event.clientY - offsetY;
        const constrained = getConstrainedChartDataPosition(left, top);
        chartDataEditor.style.left = `${constrained.left}px`;
        chartDataEditor.style.top = `${constrained.top}px`;
      }

      function handleChartDataHeaderPointerUp(event) {
        if (!chartDataDragState) return;
        chartDataDragState = null;
        chartDataEditor.releasePointerCapture?.(event.pointerId);
      }

      chartDataEditor.addEventListener('pointerdown', handleChartDataHeaderPointerDown);
      chartDataEditor.addEventListener('pointermove', handleChartDataHeaderPointerMove);
      chartDataEditor.addEventListener('pointerup', handleChartDataHeaderPointerUp);
      chartDataEditor.addEventListener('pointercancel', handleChartDataHeaderPointerUp);

      chartDataEditorTableBody.addEventListener('input', (event) => {
        if (!(event.target instanceof HTMLInputElement)) return;
        if (!event.target.classList.contains('chart-data-input') && !event.target.classList.contains('chart-data-color-input')) return;
        syncActiveChartDataFromEditor();
      });

      chartDataEditorTableBody.addEventListener('change', (event) => {
        if (!(event.target instanceof HTMLInputElement)) return;
        if (!event.target.classList.contains('chart-data-input') && !event.target.classList.contains('chart-data-color-input')) return;
        syncActiveChartDataFromEditor();
      });

      if (lineSeriesAddButton) {
        lineSeriesAddButton.addEventListener('click', () => {
          if (!activeChartDataElement) return;
          addLineChartSeries();
        });
      }

      if (linePointAddButton) {
        linePointAddButton.addEventListener('click', () => {
          if (!activeChartDataElement) return;
          addLineChartPoint();
        });
      }

      if (linePointRemoveButton) {
        linePointRemoveButton.addEventListener('click', () => {
          if (!activeChartDataElement) return;
          removeLineChartPoint();
        });
      }

      if (lineSeriesList) {
        lineSeriesList.addEventListener('click', (event) => {
          if (!activeChartDataElement) return;
          const removeButton = event.target instanceof HTMLElement ? event.target.closest('.chart-line-series-remove') : null;
          if (removeButton) {
            const buttonIndex = Number(removeButton.dataset.index);
            const itemIndex = Number(removeButton.closest('.chart-line-series-item')?.dataset.index);
            const index = Number.isFinite(buttonIndex) ? buttonIndex : itemIndex;
            if (Number.isFinite(index)) {
              removeLineChartSeries(index);
            }
          }
        });
        lineSeriesList.addEventListener('input', (event) => {
          if (!activeChartDataElement) return;
          if (event.target instanceof HTMLInputElement && event.target.classList.contains('line-series-label')) {
            updateLineHeaderLabels();
            syncActiveChartDataFromEditor();
          }
        });
        lineSeriesList.addEventListener('change', (event) => {
          if (!activeChartDataElement) return;
          if (event.target instanceof HTMLInputElement && event.target.classList.contains('line-series-color')) {
            syncActiveChartDataFromEditor();
          }
        });
      }

      if (lineValuesTableBody) {
        lineValuesTableBody.addEventListener('input', (event) => {
          if (!activeChartDataElement) return;
          if (event.target instanceof HTMLInputElement && (event.target.classList.contains('line-point-label') || event.target.classList.contains('line-point-value'))) {
            syncActiveChartDataFromEditor();
          }
        });
      }

      if (chartDataShowValuesCheckbox) {
        chartDataShowValuesCheckbox.addEventListener('change', () => {
          if (!activeChartDataElement) return;
          const showValues = chartDataShowValuesCheckbox.checked;
          activeChartDataElement.dataset.showValues = showValues ? 'true' : 'false';
          const chartConfig = getChartConfigForElement(activeChartDataElement);
          const chartType = chartConfig?.type || chartConfig?.id;
          if (chartType === 'line') {
            const state = getLineChartState(activeChartDataElement, chartConfig);
            setLineChartState(activeChartDataElement, chartConfig, {
              categories: state.categories,
              series: state.series,
              title: activeChartDataElement.dataset.title || '',
              showValues
            });
          } else {
            const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
            const values = getChartValuesForElement(activeChartDataElement, chartConfig);
            const payload = {
              legend,
              title: activeChartDataElement.dataset.title || '',
              showValues
            };
            if (chartType === 'pie') {
              payload.slices = values;
            } else {
              payload.bars = values;
            }
            activeChartDataElement.innerHTML = renderChartMarkup(chartConfig, payload);
            createResizeEdges(activeChartDataElement);
          }
          capture();
          renderSidebar();
          saveEditorState('toggle_chart_values');
        });
      }

      chartDataAddRowButton.addEventListener('click', (event) => {
        event.preventDefault();
        addChartDataRow();
      });

      chartDataRemoveRowButton.addEventListener('click', (event) => {
        event.preventDefault();
        removeChartDataRow();
      });

      chartDataCloseButton.addEventListener('click', (event) => {
        event.preventDefault();
        hideChartDataEditor();
      });

      chartDataEditor.addEventListener('mousedown', (event) => {
        event.stopPropagation();
      });

      const slideContextMenu = document.createElement('div');
      slideContextMenu.id = 'slideContextMenu';
      slideContextMenu.className = 'slide-context-menu';
      slideContextMenu.innerHTML = `
        <button type="button" data-action="rename-slide">
          <i class="fas fa-pen"></i>
          <span>Rename</span>
        </button>
      `;
      document.body.appendChild(slideContextMenu);
      const slideContextRenameBtn = slideContextMenu.querySelector('[data-action="rename-slide"]');

      const slideTransitionMenu = document.createElement('div');
      slideTransitionMenu.id = 'slideTransitionMenu';
      slideTransitionMenu.className = 'slide-context-menu';
      slideTransitionMenu.innerHTML = '';
      document.body.appendChild(slideTransitionMenu);
      const elementContextMenu = document.createElement('div');
      elementContextMenu.id = 'elementContextMenu';
      elementContextMenu.className = 'image-context-menu';
      elementContextMenu.innerHTML = `
        <button type="button" data-action="copy">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
        </button>
        <button type="button" data-action="cut">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
        </button>
        <button type="button" data-action="paste">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
        </button>
        <button type="button" data-action="translate">
          <span class="menu-icon"><i class="fas fa-language"></i></span>
          <span>Translate</span>
        </button>
        <button type="button" data-action="delete">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete</span>
        </button>
        <button type="button" data-action="crop">
          <span class="menu-icon"><i class="fas fa-crop"></i></span>
          <span>Crop Image</span>
        </button>
        <button type="button" data-action="background">
          <span class="menu-icon"><i class="fas fa-image"></i></span>
          <span>Set Image as Background</span>
        </button>
      `;
      document.body.appendChild(elementContextMenu);
      const elementContextButtons = {
        copy: elementContextMenu.querySelector('[data-action="copy"]'),
        cut: elementContextMenu.querySelector('[data-action="cut"]'),
        paste: elementContextMenu.querySelector('[data-action="paste"]'),
        translate: elementContextMenu.querySelector('[data-action="translate"]'),
        delete: elementContextMenu.querySelector('[data-action="delete"]'),
        crop: elementContextMenu.querySelector('[data-action="crop"]'),
        background: elementContextMenu.querySelector('[data-action="background"]')
      };
      const spellSuggestionEntries = [];
      let spellSuggestionLabel = null;
      const SPELL_SUGGESTION_LIMIT = 5;
      const SPELL_SUGGESTION_API = 'https://api.datamuse.com/words';
      const SpellCheckManager = (() => {
        const suggestionCache = new Map();
        const pendingRequests = new Map();
        const sanitizeWord = (word) => {
          if (!word) return '';
          return word.replace(/[^A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿']/g, '');
        };
        const normalizeWord = (word) => (word || '').toLowerCase();
        const getSuggestions = async (word) => {
          const sanitized = sanitizeWord(word);
          const normalized = normalizeWord(sanitized);
          if (!normalized || normalized.length < 2) {
            return [];
          }
          if (suggestionCache.has(normalized)) {
            return suggestionCache.get(normalized);
          }
          if (pendingRequests.has(normalized)) {
            return pendingRequests.get(normalized);
          }
          const controller = new AbortController();
          const timeoutId = window.setTimeout(() => controller.abort(), 4000);
          const request = fetch(`${SPELL_SUGGESTION_API}?max=${SPELL_SUGGESTION_LIMIT}&sp=${encodeURIComponent(normalized)}&v=enwiki`, {
            signal: controller.signal,
            headers: {
              'Accept': 'application/json'
            }
          })
            .then((response) => {
              if (!response.ok) {
                throw new Error('Spell suggestion request failed');
              }
              return response.json();
            })
            .then((data) => {
              if (!Array.isArray(data)) {
                return [];
              }
              const suggestions = data
                .map((item) => (item && typeof item.word === 'string') ? item.word : '')
                .filter(Boolean);
              suggestionCache.set(normalized, suggestions);
              return suggestions;
            })
            .catch(() => {
              suggestionCache.set(normalized, []);
              return [];
            })
            .finally(() => {
              window.clearTimeout(timeoutId);
              pendingRequests.delete(normalized);
            });
          pendingRequests.set(normalized, request);
          return request;
        };
        return {
          getSuggestions,
          sanitizeWord,
          normalizeWord
        };
      })();
      let spellSuggestionContext = null;
      function isSpellCheckTextElement(element) {
        if (!element) return false;
        if (element === titleBox || element === textBox) return true;
        return element.classList && element.classList.contains('additional-text-box');
      }
      function removeSpellSuggestionEntries() {
        while (spellSuggestionEntries.length) {
          const entry = spellSuggestionEntries.pop();
          if (entry && entry.parentNode) {
            entry.parentNode.removeChild(entry);
          }
        }
        if (spellSuggestionLabel && spellSuggestionLabel.parentNode) {
          spellSuggestionLabel.parentNode.removeChild(spellSuggestionLabel);
        }
        spellSuggestionLabel = null;
      }
      function addSpellSuggestionLabel() {
        if (spellSuggestionLabel || !elementContextButtons.copy) return;
        spellSuggestionLabel = document.createElement('div');
        spellSuggestionLabel.className = 'spell-suggestion-label';
        spellSuggestionLabel.textContent = 'Suggestions';
        elementContextMenu.insertBefore(spellSuggestionLabel, elementContextButtons.copy);
      }
      function showSpellSuggestionPlaceholder(message) {
        removeSpellSuggestionEntries();
        if (!elementContextButtons.copy) return;
        addSpellSuggestionLabel();
        if (!message) return;
        const placeholder = document.createElement('button');
        placeholder.type = 'button';
        placeholder.setAttribute('data-role', 'spell-suggestion');
        placeholder.disabled = true;
        placeholder.innerHTML = `<span>${message}</span>`;
        spellSuggestionEntries.push(placeholder);
        elementContextMenu.insertBefore(placeholder, elementContextButtons.copy);
      }
      function clearSpellSuggestionSection() {
        removeSpellSuggestionEntries();
        spellSuggestionContext = null;
      }
      function applySpellCheckStateToElement(element, enabled = isSpellCheckEnabled) {
        if (!element) return;
        element.spellcheck = enabled;
        element.setAttribute('spellcheck', enabled ? 'true' : 'false');
      }
      function refreshSpellCheckTargets() {
        const scope = canvas || document;
        scope.querySelectorAll(SPELLCHECK_TARGET_SELECTOR).forEach((el) => {
          applySpellCheckStateToElement(el);
        });
      }
      function updateSpellCheckToggleUI() {
        if (!spellCheckToggleButton) return;
        spellCheckToggleButton.classList.toggle('active', isSpellCheckEnabled);
        spellCheckToggleButton.setAttribute('aria-pressed', String(isSpellCheckEnabled));
        spellCheckToggleButton.setAttribute(
          'title',
          isSpellCheckEnabled ? 'Turn off spell check' : 'Turn on spell check'
        );
        spellCheckToggleButton.setAttribute(
          'aria-label',
          isSpellCheckEnabled ? 'Disable spell check' : 'Enable spell check'
        );
        if (spellCheckToggleState) {
          spellCheckToggleState.textContent = isSpellCheckEnabled ? 'On' : 'Off';
        }
      }
      function setSpellCheckEnabled(enabled, { persist = true } = {}) {
        const normalized = Boolean(enabled);
        if (isSpellCheckEnabled === normalized) {
          refreshSpellCheckTargets();
          updateSpellCheckToggleUI();
          return;
        }
        isSpellCheckEnabled = normalized;
        if (persist) {
          try {
            localStorage.setItem(SPELLCHECK_STORAGE_KEY, normalized ? 'true' : 'false');
          } catch (error) { /* ignore persistence errors */ }
        }
        refreshSpellCheckTargets();
        updateSpellCheckToggleUI();
        if (!normalized) {
          clearSpellSuggestionSection();
          hideElementContextMenu();
        }
      }
      function initializeSpellCheckControls() {
        let storedPreference = null;
        try {
          storedPreference = localStorage.getItem(SPELLCHECK_STORAGE_KEY);
        } catch (error) { /* ignore read errors */ }
        const shouldEnable = storedPreference === null ? true : storedPreference === 'true';
        isSpellCheckEnabled = shouldEnable;
        refreshSpellCheckTargets();
        updateSpellCheckToggleUI();
        if (!shouldEnable) {
          clearSpellSuggestionSection();
        }
        if (spellCheckToggleButton) {
          spellCheckToggleButton.addEventListener('click', () => {
            setSpellCheckEnabled(!isSpellCheckEnabled);
          });
        }
      }
      function getPreferredTranslationElement() {
        if (selectedTextBox && document.contains(selectedTextBox)) {
          return selectedTextBox;
        }
        const context = getSelectedElementContext();
        if (context && context.element && context.element.isContentEditable) {
          return context.element;
        }
        const activeElement = document.activeElement;
        if (activeElement && activeElement.isContentEditable) {
          return activeElement;
        }
        if (textBox && textBox.style.display !== 'none') {
          return textBox;
        }
        if (titleBox && titleBox.style.display !== 'none') {
          return titleBox;
        }
        return null;
      }
      function showTranslatorPanel() {
        if (!translatorPanel) return;
        translatorPanel.classList.remove('hidden');
        if (layoutMain) {
          layoutMain.classList.add('show-translator');
        }
      }
      function hideTranslatorPanel({ refocus = true } = {}) {
        if (!translatorPanel) return;
        translatorPanel.classList.add('hidden');
        if (layoutMain) {
          layoutMain.classList.remove('show-translator');
        }
        setTranslatorStatus('');
        if (translatorSourceInput) translatorSourceInput.value = '';
        if (translatorResultArea) translatorResultArea.value = '';
        if (refocus && translatorTargetElement && document.contains(translatorTargetElement)) {
          try {
            translatorTargetElement.focus({ preventScroll: true });
          } catch (error) {
            translatorTargetElement.focus();
          }
        }
        translatorTargetElement = null;
        translatorSelectionRange = null;
        isTranslatorBusy = false;
        if (translatorInsertButton) translatorInsertButton.disabled = false;
      }
      function captureSelectionRange(element) {
        translatorSelectionRange = null;
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);
        if (element && element.contains(range.commonAncestorContainer)) {
          translatorSelectionRange = range.cloneRange();
        }
      }
      function getSelectedTextWithinElement(element) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
          return '';
        }
        const selected = selection.toString();
        if (!selected) return '';
        if (element && element.contains(selection.anchorNode) && element.contains(selection.focusNode)) {
          return selected;
        }
        return '';
      }
      function openTranslatorPanel(targetElement = null, { autoTranslate = false } = {}) {
        translatorTargetElement = targetElement && document.contains(targetElement)
          ? targetElement
          : getPreferredTranslationElement();
        const selectedText = translatorTargetElement
          ? getSelectedTextWithinElement(translatorTargetElement)
          : '';
        const sourceText = selectedText && selectedText.trim().length
          ? selectedText.trim()
          : translatorTargetElement
            ? (translatorTargetElement.innerText || translatorTargetElement.textContent || '')
            : '';
        if (translatorSourceInput) translatorSourceInput.value = sourceText.trim();
        if (translatorResultArea) translatorResultArea.value = '';
        setTranslatorStatus(sourceText
          ? 'Choose a language and click Translate.'
          : 'Select text to translate.');
        captureSelectionRange(translatorTargetElement);
        showTranslatorPanel();
        requestAnimationFrame(() => {
          if (translatorSourceInput) {
            translatorSourceInput.focus({ preventScroll: true });
            translatorSourceInput.setSelectionRange(translatorSourceInput.value.length, translatorSourceInput.value.length);
          }
        });
        if (autoTranslate && sourceText) {
          performTranslatorLookup();
        }
      }
      async function performTranslatorLookup() {
        if (isTranslatorBusy) return;
        if (!translatorSourceInput || !translatorLanguageSelect) return;
        const sourceText = translatorSourceInput.value.trim();
        if (!sourceText) {
          setTranslatorStatus('Select or enter text to translate.');
          translatorSourceInput.focus({ preventScroll: true });
          return;
        }
        const targetLanguage = translatorLanguageSelect.value;
        if (!targetLanguage) {
          setTranslatorStatus('Select a target language.');
          translatorLanguageSelect.focus({ preventScroll: true });
          return;
        }
        isTranslatorBusy = true;
        if (translatorInsertButton) translatorInsertButton.disabled = true;
        setTranslatorStatus('Translatingâ€¦');
        try {
          const controller = new AbortController();
          const timeoutId = window.setTimeout(() => controller.abort(), 12000);
          const response = await fetch(TRANSLATION_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              q: sourceText,
              source: 'auto',
              target: targetLanguage,
              format: 'text'
            }),
            signal: controller.signal
          });
          window.clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          const translated = typeof data === 'object' && data !== null && typeof data.translatedText === 'string'
            ? data.translatedText
            : '';
          if (translatorResultArea) {
            translatorResultArea.value = translated;
          }
          if (translated) {
            const inserted = insertTranslatedText(translated, { updatePanel: false });
            setTranslatorStatus(inserted ? 'Translation inserted.' : 'Translation ready.');
            if (!inserted && translatorResultArea) {
              translatorResultArea.value = translated;
            }
            try {
              localStorage.setItem(TRANSLATION_STORAGE_KEY, targetLanguage);
            } catch (error) { /* ignore persistence issues */ }
            lastTranslationLanguage = targetLanguage;
          } else {
            setTranslatorStatus('No translation available.');
          }
        } catch (error) {
          setTranslatorStatus('Unable to translate. Please try again.');
        } finally {
          isTranslatorBusy = false;
          if (translatorInsertButton) translatorInsertButton.disabled = false;
        }
      }
      function cloneTextBoxOptions(element) {
        const computed = window.getComputedStyle(element);
        const coords = getElementCanvasCoordinates(element);
        return {
          top: coords.top,
          left: coords.left,
          width: element.offsetWidth,
          height: element.offsetHeight,
          fontSize: computed.fontSize,
          fontFamily: computed.fontFamily,
          color: computed.color,
          backgroundColor: computed.backgroundColor,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          textAlign: computed.textAlign,
          fontWeight: computed.fontWeight,
          fontStyle: computed.fontStyle,
          textDecoration: computed.textDecoration,
          letterSpacing: computed.letterSpacing,
          lineHeight: computed.lineHeight
        };
      }
      function insertTranslatedText(translatedText, { updatePanel = true } = {}) {
        const normalized = typeof translatedText === 'string' ? translatedText.trim() : '';
        if (!normalized) {
          setTranslatorStatus('Translate text before inserting.');
          return false;
        }
        const element = translatorTargetElement && document.contains(translatorTargetElement)
          ? translatorTargetElement
          : getPreferredTranslationElement();
        if (!element) {
          setTranslatorStatus('Select a text box to insert translation.');
          return false;
        }
        const options = cloneTextBoxOptions(element);
        capture();
        const newBox = createAdditionalTextBox({
          top: options.top + 24,
          left: options.left + 24,
          width: options.width,
          height: options.height,
          fontSize: options.fontSize,
          fontFamily: options.fontFamily,
          color: options.color,
          backgroundColor: options.backgroundColor,
          rotation: options.rotation,
          zIndex: options.zIndex
        });
        if (!newBox) {
          setTranslatorStatus('Unable to insert translation.');
          return false;
        }
        newBox.textContent = normalized;
        newBox.style.fontWeight = options.fontWeight;
        newBox.style.fontStyle = options.fontStyle;
        newBox.style.textDecoration = options.textDecoration;
        newBox.style.textAlign = options.textAlign;
        if (options.letterSpacing && options.letterSpacing !== 'normal') {
          newBox.style.letterSpacing = options.letterSpacing;
        }
        if (options.lineHeight && options.lineHeight !== 'normal') {
          newBox.style.lineHeight = options.lineHeight;
        }
        translatorSelectionRange = null;
        queueMicrotask(() => {
          newBox.dispatchEvent(new Event('input', { bubbles: true }));
          newBox.dispatchEvent(new Event('change', { bubbles: true }));
          saveEditorState('translate_text_insert');
        });
        if (updatePanel && translatorResultArea) {
          translatorResultArea.value = normalized;
        }
        if (updatePanel) {
          setTranslatorStatus('Translation inserted.');
        }
        showNotification('Translation inserted');
        return true;
      }
      function insertTranslatorResult() {
        if (!translatorResultArea) return;
        const translation = translatorResultArea.value;
        insertTranslatedText(translation);
      }
      function repositionElementContextMenu() {
        if (!elementContextMenu || !elementContextMenu.classList.contains('show')) return;
        const padding = 12;
        const rect = elementContextMenu.getBoundingClientRect();
        let top = parseFloat(elementContextMenu.style.top || '0');
        let left = parseFloat(elementContextMenu.style.left || '0');
        if (Number.isNaN(top)) top = rect.top;
        if (Number.isNaN(left)) left = rect.left;
        if (rect.bottom > window.innerHeight - padding) {
          top = Math.max(padding, window.innerHeight - rect.height - padding);
        }
        if (rect.right > window.innerWidth - padding) {
          left = Math.max(padding, window.innerWidth - rect.width - padding);
        }
        elementContextMenu.style.top = `${top}px`;
        elementContextMenu.style.left = `${left}px`;
      }
      function getCaretRangeFromPoint(x, y) {
        if (typeof document.caretRangeFromPoint === 'function') {
          try {
            return document.caretRangeFromPoint(x, y);
          } catch (error) {
            return null;
          }
        }
        if (typeof document.caretPositionFromPoint === 'function') {
          const position = document.caretPositionFromPoint(x, y);
          if (!position) return null;
          const range = document.createRange();
          range.setStart(position.offsetNode, position.offset);
          range.collapse(true);
          return range;
        }
        return null;
      }
      function isWordCharacter(char) {
        if (!char) return false;
        return /[A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿']/u.test(char);
      }
      function extractWordInfoFromPoint(element, event) {
        if (!element || !event) return null;
        const range = getCaretRangeFromPoint(event.clientX, event.clientY);
        if (!range) return null;
        let container = range.startContainer;
        let offset = range.startOffset;
        if (container.nodeType !== Node.TEXT_NODE) {
          if (container.childNodes && container.childNodes.length > 0) {
            const childIndex = Math.min(offset, container.childNodes.length - 1);
            const childNode = container.childNodes[childIndex];
            if (childNode && childNode.nodeType === Node.TEXT_NODE) {
              container = childNode;
              offset = container.textContent ? container.textContent.length : 0;
            } else if (childIndex > 0) {
              const previousNode = container.childNodes[childIndex - 1];
              if (previousNode && previousNode.nodeType === Node.TEXT_NODE) {
                container = previousNode;
                offset = container.textContent ? container.textContent.length : 0;
              }
            }
          } else if (container.parentNode && container.parentNode.nodeType === Node.TEXT_NODE) {
            container = container.parentNode;
            offset = container.textContent ? container.textContent.length : offset;
          }
        }
        if (!container || container.nodeType !== Node.TEXT_NODE) return null;
        if (!element.contains(container)) return null;
        const textContent = container.textContent || '';
        if (!textContent.trim()) return null;
        let start = offset;
        let end = offset;
        while (start > 0 && isWordCharacter(textContent[start - 1])) {
          start -= 1;
        }
        while (end < textContent.length && isWordCharacter(textContent[end])) {
          end += 1;
        }
        if (start === end) {
          return null;
        }
        const rawWord = textContent.slice(start, end);
        const sanitized = SpellCheckManager.sanitizeWord(rawWord);
        if (!sanitized) {
          return null;
        }
        const wordRange = document.createRange();
        wordRange.setStart(container, start);
        wordRange.setEnd(container, end);
        return {
          id: Symbol('spell-word'),
          element,
          range: wordRange,
          word: rawWord,
          cleaned: SpellCheckManager.normalizeWord(sanitized)
        };
      }
      function renderSpellSuggestions(wordInfo) {
        if (!isSpellCheckEnabled) {
          clearSpellSuggestionSection();
          return;
        }
        if (!wordInfo) {
          clearSpellSuggestionSection();
          return;
        }
        SpellCheckManager.getSuggestions(wordInfo.cleaned)
          .then((suggestions) => {
            if (!spellSuggestionContext || spellSuggestionContext.id !== wordInfo.id) {
              return;
            }
            if (!isSpellCheckEnabled) {
              clearSpellSuggestionSection();
              repositionElementContextMenu();
              return;
            }
            const hasExactMatch = Array.isArray(suggestions)
              ? suggestions.some((suggestion) => SpellCheckManager.normalizeWord(suggestion) === wordInfo.cleaned)
              : false;
            if (hasExactMatch) {
              clearSpellSuggestionSection();
              repositionElementContextMenu();
              return;
            }
            const uniqueSuggestions = [];
            const lowerSeen = new Set();
            suggestions.forEach((suggestion) => {
              if (!suggestion || typeof suggestion !== 'string') return;
              const trimmed = suggestion.trim();
              if (!trimmed) return;
              const lowered = SpellCheckManager.normalizeWord(trimmed);
              if (lowered === wordInfo.cleaned) return;
              if (lowerSeen.has(lowered)) return;
              lowerSeen.add(lowered);
              uniqueSuggestions.push(trimmed);
            });
            if (!uniqueSuggestions.length) {
              showSpellSuggestionPlaceholder('No suggestions');
              repositionElementContextMenu();
              return;
            }
            removeSpellSuggestionEntries();
            addSpellSuggestionLabel();
            const reference = elementContextButtons.copy;
            uniqueSuggestions
              .slice(0, SPELL_SUGGESTION_LIMIT)
              .reverse()
              .forEach((suggestion) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.setAttribute('data-role', 'spell-suggestion');
                button.innerHTML = `<span>${suggestion}</span><span class="spell-suggestion-hint">â†µ</span>`;
                button.addEventListener('click', () => applySpellSuggestion(suggestion));
                spellSuggestionEntries.push(button);
                elementContextMenu.insertBefore(button, reference);
              });
            repositionElementContextMenu();
          })
          .catch(() => {
            if (!spellSuggestionContext || spellSuggestionContext.id !== wordInfo.id) {
              return;
            }
            if (!isSpellCheckEnabled) {
              clearSpellSuggestionSection();
              return;
            }
            showSpellSuggestionPlaceholder('No suggestions');
          });
      }
      function prepareSpellSuggestions(event, element) {
        if (!isSpellCheckEnabled) {
          clearSpellSuggestionSection();
          return false;
        }
        if (!isSpellCheckTextElement(element)) {
          clearSpellSuggestionSection();
          return false;
        }
        const wordInfo = extractWordInfoFromPoint(element, event);
        if (!wordInfo || !wordInfo.cleaned || wordInfo.cleaned.length < 2) {
          clearSpellSuggestionSection();
          return false;
        }
        spellSuggestionContext = wordInfo;
        showSpellSuggestionPlaceholder('Checkingâ€¦');
        renderSpellSuggestions(wordInfo);
        return true;
      }
      function applySpellSuggestion(suggestion) {
        if (!spellSuggestionContext || !suggestion) return;
        const { range, element } = spellSuggestionContext;
        if (!range || !element || !document.contains(element)) {
          clearSpellSuggestionSection();
          return;
        }
        const replacement = suggestion;
        const workingRange = range.cloneRange();
        workingRange.deleteContents();
        const textNode = document.createTextNode(replacement);
        workingRange.insertNode(textNode);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          const caretRange = document.createRange();
          caretRange.setStart(textNode, textNode.textContent.length);
          caretRange.collapse(true);
          selection.addRange(caretRange);
        }
        element.normalize();
        clearSpellSuggestionSection();
        hideElementContextMenu();
        queueMicrotask(() => {
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        });
      }
      clearSpellSuggestionSection();
      const slideCanvasContextMenu = document.createElement('div');
      slideCanvasContextMenu.id = 'slideCanvasContextMenu';
      slideCanvasContextMenu.className = 'slide-canvas-context-menu';
      slideCanvasContextMenu.innerHTML = `
        <button type="button" data-action="copy-slide">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
        </button>
        <button type="button" data-action="cut-slide">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
        </button>
        <button type="button" data-action="paste-slide">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
        </button>
        <button type="button" data-action="new-slide">
          <span class="menu-icon"><i class="fas fa-plus"></i></span>
          <span>New Slide</span>
        </button>
        <button type="button" data-action="duplicate-slide">
          <span class="menu-icon"><i class="fas fa-clone"></i></span>
          <span>Duplicate Slide</span>
        </button>
        <button type="button" data-action="delete-slide">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete Slide</span>
        </button>
      `;
      document.body.appendChild(slideCanvasContextMenu);
      const slideCanvasMenuButtons = {
        copy: slideCanvasContextMenu.querySelector('[data-action="copy-slide"]'),
        cut: slideCanvasContextMenu.querySelector('[data-action="cut-slide"]'),
        paste: slideCanvasContextMenu.querySelector('[data-action="paste-slide"]'),
        newSlide: slideCanvasContextMenu.querySelector('[data-action="new-slide"]'),
        duplicate: slideCanvasContextMenu.querySelector('[data-action="duplicate-slide"]'),
        delete: slideCanvasContextMenu.querySelector('[data-action="delete-slide"]')
      };
      const TRANSLATION_LANGUAGES = [
        { code: 'es', label: 'Spanish' },
        { code: 'fr', label: 'French' },
        { code: 'de', label: 'German' },
        { code: 'it', label: 'Italian' },
        { code: 'pt', label: 'Portuguese' },
        { code: 'ar', label: 'Arabic' },
        { code: 'zh', label: 'Chinese (Simplified)' },
        { code: 'ja', label: 'Japanese' },
        { code: 'ko', label: 'Korean' },
        { code: 'ru', label: 'Russian' }
      ];
      const TRANSLATION_ENDPOINT = 'https://libretranslate.de/translate';
      const TRANSLATION_STORAGE_KEY = 'slideEditorTranslationLanguage';
      const layoutMain = document.getElementById('layoutMain');
      const translatorPanel = document.getElementById('translatorPanel');
      const translatorCloseButton = document.getElementById('translatorCloseButton');
      const translatorSourceInput = document.getElementById('translatorSourceInput');
      const translatorLanguageSelect = document.getElementById('translatorLanguageSelect');
      const translatorResultArea = document.getElementById('translatorResultArea');
      const translatorStatusLabel = document.getElementById('translatorStatusLabel');
      const translatorInsertButton = document.getElementById('translatorInsertButton');
      let translatorTargetElement = null;
      let translatorSelectionRange = null;
      let isTranslatorBusy = false;
      let lastTranslationLanguage = (() => {
        try {
          return localStorage.getItem(TRANSLATION_STORAGE_KEY) || 'es';
        } catch (error) {
          return 'es';
        }
      })();
      if (translatorLanguageSelect) {
        TRANSLATION_LANGUAGES.forEach(({ code, label }) => {
          const option = document.createElement('option');
          option.value = code;
          option.textContent = label;
          translatorLanguageSelect.appendChild(option);
        });
        if (TRANSLATION_LANGUAGES.some(({ code }) => code === lastTranslationLanguage)) {
          translatorLanguageSelect.value = lastTranslationLanguage;
        }
      }
      function setTranslatorStatus(message) {
        if (!translatorStatusLabel) return;
        translatorStatusLabel.textContent = message || '';
      }
      const imageCropOverlay = document.createElement('div');
      imageCropOverlay.id = 'imageCropOverlay';
      imageCropOverlay.className = 'image-crop-overlay';
      imageCropOverlay.innerHTML = `
        <div class="image-crop-dialog" role="dialog" aria-modal="true" aria-labelledby="imageCropTitle">
          <div class="image-crop-header">
            <span id="imageCropTitle">Crop Image</span>
            <button type="button" id="imageCropClose" class="image-crop-close" aria-label="Close crop dialog">&times;</button>
          </div>
          <div class="image-crop-content">
            <img id="imageCropperImage" alt="Image crop preview">
          </div>
          <div class="image-crop-actions">
            <button type="button" id="imageCropCancel">Cancel</button>
            <button type="button" id="imageCropApply">Apply Crop</button>
          </div>
        </div>
      `;
      document.body.appendChild(imageCropOverlay);
      const imageCropperImage = imageCropOverlay.querySelector('#imageCropperImage');
      const imageCropCancel = imageCropOverlay.querySelector('#imageCropCancel');
      const imageCropApply = imageCropOverlay.querySelector('#imageCropApply');
      const imageCropClose = imageCropOverlay.querySelector('#imageCropClose');
      let elementContextTarget = null;
      let editorClipboard = {
        type: null,
        mode: 'copy',
        data: null,
        offset: 0
      };
      let imageCropperInstance = null;
      let imageCropTargetElement = null;
      let slideCanvasContextTargetIndex = null;
      function setEditorClipboard(type, data, mode = 'copy') {
        editorClipboard = {
          type,
          data,
          mode,
          offset: 0
        };
        updateSlideCanvasMenuState();
        updateElementContextMenuState();
      }
      function hideElementContextMenu() {
        if (!elementContextMenu) return;
        clearSpellSuggestionSection();
        elementContextMenu.classList.remove('show');
        elementContextMenu.style.top = '-9999px';
        elementContextMenu.style.left = '-9999px';
        elementContextTarget = null;
      }
      function updateElementContextMenuState() {
        if (!elementContextMenu) return;
        if (elementContextButtons.paste) {
          const hasElementsClipboard = editorClipboard.type === 'elements'
            && editorClipboard.data
            && Array.isArray(editorClipboard.data.items)
            && editorClipboard.data.items.length > 0;
          elementContextButtons.paste.disabled = !hasElementsClipboard;
        }
      }
      function getElementPosition(element) {
        return getElementCanvasCoordinates(element);
      }
      function serializeImageElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'image');
        const img = element.querySelector('img');
        if (!img) return null;
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          src: img.getAttribute('src'),
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '80'),
          minHeight: parseFloat(element.dataset.minHeight || '60'),
          aspectRatio: parseFloat(element.dataset.aspectRatio || (element.offsetWidth / Math.max(element.offsetHeight, 0.01))),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeVideoElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'video');
        const video = element.querySelector('video');
        if (!video) return null;
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          src: video.getAttribute('src'),
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '160'),
          minHeight: parseFloat(element.dataset.minHeight || '90'),
          aspectRatio: parseFloat(element.dataset.aspectRatio || (element.offsetWidth / Math.max(element.offsetHeight, 0.01))),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeShapeElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'shape');
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          shapeId: element.dataset.shape,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          color: normalizeColorHex(element.dataset.color || element.style.color || '#e8f5e9'),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          minWidth: element.dataset.minWidth ? parseFloat(element.dataset.minWidth) : undefined,
          minHeight: element.dataset.minHeight ? parseFloat(element.dataset.minHeight) : undefined,
          rotation: parseFloat(element.dataset.rotation || '0') || 0
        };
      }
      function serializeChartElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'chart');
        const { left, top } = getElementPosition(element);
        const chartType = element.dataset.chartType || 'bar';
        const legend = normalizeChartLegend(element.dataset.legend, []);
        const lineSeries = (chartType.startsWith('line') || (chartType === 'line'))
          ? normalizeLineSeries(element.dataset.lineSeries, [], legend.length)
          : [];
        return {
          id: elementId,
          chartType,
          chartVariant: element.dataset.chartVariant || null,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '220'),
          minHeight: parseFloat(element.dataset.minHeight || '160'),
          bars: normalizeNumberArray(element.dataset.bars, []),
          slices: normalizeNumberArray(element.dataset.slices, []),
          lineSeries,
          legend,
          title: element.dataset.title || '',
          showValues: element.dataset.showValues === 'true',
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeTableElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'table');
        const table = element.querySelector('table');
        const rows = table ? table.rows.length : parseInt(element.dataset.rows || '1', 10) || 1;
        const cols = table && table.rows[0] ? table.rows[0].cells.length : parseInt(element.dataset.cols || '1', 10) || 1;
        const clone = element.cloneNode(true);
        clone.querySelectorAll('.table-resize-handle').forEach((handle) => handle.remove());
        clone.querySelectorAll('.table-cell-selected').forEach(cell => cell.classList.remove('table-cell-selected'));
        const sanitizedHtml = clone.innerHTML;
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          rows,
          cols,
          html: sanitizedHtml,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          minWidth: parseFloat(element.dataset.minWidth || '240'),
          minHeight: parseFloat(element.dataset.minHeight || '160'),
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeTextBoxElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, element === titleBox ? 'title' : element === textBox ? 'body' : 'textbox');
        const { left, top } = getElementPosition(element);
        const computed = window.getComputedStyle(element);
        const minWidthValue = parseFloat(element.dataset.minWidth || element.style.minWidth || 200);
        const minHeightValue = parseFloat(element.dataset.minHeight || element.style.minHeight || 50);
        const sanitizedClone = element.cloneNode(true);
        sanitizedClone.querySelectorAll('.animation-order-badge').forEach(badge => badge.remove());
        const sanitizedHtml = sanitizedClone.innerHTML;
        return {
          id: elementId,
          html: sanitizedHtml,
          top,
          left,
          width: element.offsetWidth,
          height: element.offsetHeight,
          fontSize: element.style.fontSize || computed.fontSize,
          fontFamily: computed.fontFamily,
          display: element.style.display || '',
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: minWidthValue,
          minHeight: minHeightValue,
          backgroundColor: element.style.backgroundColor || '',
          color: element.style.color || '',
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          isTitle: element === titleBox,
          isBody: element === textBox
        };
      }
      function applyTextBoxData(element, data) {
        if (!element || !data) return;
        const elementId = data.id || ensureElementHasId(element, element === titleBox ? 'title' : element === textBox ? 'body' : 'textbox');
        element.dataset.elementId = elementId;
        if (!data.id) {
          data.id = elementId;
        }
        if (Number.isFinite(data.left)) {
          element.style.left = `${data.left}px`;
        }
        if (Number.isFinite(data.top)) {
          element.style.top = `${data.top}px`;
        }
        if (Number.isFinite(data.width)) {
          element.style.width = `${data.width}px`;
        }
        if (Number.isFinite(data.height)) {
          element.style.height = `${data.height}px`;
        }
        if (Number.isFinite(data.minWidth)) {
          element.dataset.minWidth = String(data.minWidth);
          element.style.minWidth = `${data.minWidth}px`;
        }
        if (Number.isFinite(data.minHeight)) {
          element.dataset.minHeight = String(data.minHeight);
          element.style.minHeight = `${data.minHeight}px`;
        }
        element.style.fontSize = data.fontSize || element.style.fontSize || '16px';
        element.style.fontFamily = data.fontFamily || element.style.fontFamily || DEFAULT_FONT_FAMILY;
        elementFontSizes.set(element, parseFloat(element.style.fontSize) || 16);
        elementFontFamilies.set(element, element.style.fontFamily || DEFAULT_FONT_FAMILY);
        element.style.backgroundColor = data.backgroundColor || '';
        element.style.color = data.color || '';
        element.style.display = data.display || '';
        const rotation = Number.isFinite(data.rotation) ? data.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = data.html || '';
        if (Number.isFinite(data.zIndex)) {
          element.style.zIndex = String(data.zIndex);
        }
        applySpellCheckStateToElement(element);
        createResizeEdges(element);
      }
      function serializeElement(element) {
        if (!element) return null;
        if (element.classList.contains('image-element')) {
          const data = serializeImageElement(element);
          return data ? { type: 'image', data } : null;
        }
        if (element.classList.contains('video-element')) {
          const data = serializeVideoElement(element);
          return data ? { type: 'video', data } : null;
        }
        if (element.classList.contains('shape-element')) {
          const data = serializeShapeElement(element);
          return data ? { type: 'shape', data } : null;
        }
        if (element.classList.contains('chart-element')) {
          const data = serializeChartElement(element);
          return data ? { type: 'chart', data } : null;
        }
        if (element.classList.contains('table-element')) {
          const data = serializeTableElement(element);
          return data ? { type: 'table', data } : null;
        }
        if (element.classList.contains('additional-text-box') || element === titleBox || element === textBox) {
          const data = serializeTextBoxElement(element);
          return data ? { type: 'textbox', data } : null;
        }
        return null;
      }
      function showElementContextMenu(event, element) {
        if (!elementContextMenu || !element) return;
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        elementContextTarget = element;
        prepareSpellSuggestions(event, element);
        elementContextMenu.classList.add('show');
        elementContextMenu.style.top = '0px';
        elementContextMenu.style.left = '0px';
        const menuRect = elementContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        elementContextMenu.style.top = `${Math.max(padding, top)}px`;
        elementContextMenu.style.left = `${Math.max(padding, left)}px`;
        const isImage = element.classList.contains('image-element');
        if (elementContextButtons.crop) {
          elementContextButtons.crop.style.display = isImage ? 'flex' : 'none';
        }
        if (elementContextButtons.background) {
          elementContextButtons.background.style.display = isImage ? 'flex' : 'none';
        }
        updateElementContextMenuState();
        repositionElementContextMenu();
      }
      function getSelectedElementContext() {
        if (selectedImage) return { type: 'image', element: selectedImage };
        if (selectedVideo) return { type: 'video', element: selectedVideo };
        if (selectedShape) return { type: 'shape', element: selectedShape };
        if (selectedChart) return { type: 'chart', element: selectedChart };
        if (selectedTable) return { type: 'table', element: selectedTable };
        if (selectedTextBox) return { type: 'textbox', element: selectedTextBox };
        return null;
      }
      function isEditableShortcutTarget(target) {
        if (!target) return false;
        if (target.nodeType === Node.TEXT_NODE) {
          target = target.parentElement;
        }
        if (!target) return false;
        if (!(target instanceof HTMLElement)) return false;
        if (target.matches('input, textarea, [contenteditable="true"]')) return true;
        const editableAncestor = target.closest('input, textarea, [contenteditable="true"]');
        return Boolean(editableAncestor);
      }
      function removeElementElement(element) {
        if (!element) return false;
        if (element.classList.contains('image-element')) {
          deleteImage(element);
          return true;
        }
        if (element.classList.contains('video-element')) {
          deleteVideo(element);
          return true;
        }
        if (element.classList.contains('shape-element')) {
          deleteShape(element);
          return true;
        }
        if (element.classList.contains('chart-element')) {
          deleteChart(element);
          return true;
        }
        if (element.classList.contains('table-element')) {
          deleteTable(element);
          return true;
        }
        if (element.classList.contains('additional-text-box') || element === titleBox || element === textBox) {
          deleteTextBox(element);
          return true;
        }
        return false;
      }
      function copySelectedElements(targetElement = null) {
        const context = targetElement
          ? { element: targetElement }
          : getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('No object selected');
          return false;
        }
        const serialized = serializeElement(context.element);
        if (!serialized) {
          showNotification('Cannot copy this object');
          return false;
        }
        setEditorClipboard('elements', { items: [serialized] }, 'copy');
        showNotification('Copied object');
        return true;
      }
      function cutSelectedElements(targetElement = null) {
        const context = targetElement
          ? { element: targetElement }
          : getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('No object selected');
          return false;
        }
        const serialized = serializeElement(context.element);
        if (!serialized) {
          showNotification('Cannot cut this object');
          return false;
        }
        setEditorClipboard('elements', { items: [serialized] }, 'cut');
        if (removeElementElement(context.element)) {
          showNotification('Cut object');
          return true;
        }
        return false;
      }
      function instantiateClipboardElement(item, offsetMultiplier = 1, referenceElement = null) {
        if (!item || !item.type || !item.data) return null;
        const offsetAmount = 24 * offsetMultiplier;
        const preserveId = editorClipboard.mode === 'cut';
        let baseLeft = item.data.left;
        let baseTop = item.data.top;
        if (referenceElement) {
          const refPos = getElementPosition(referenceElement);
          baseLeft = refPos.left;
          baseTop = refPos.top;
        } else if (editorClipboard.mode === 'copy' && lastCanvasInsertPosition && Number.isFinite(item.data.width) && Number.isFinite(item.data.height)) {
          baseLeft = lastCanvasInsertPosition.x - item.data.width / 2;
          baseTop = lastCanvasInsertPosition.y - item.data.height / 2;
        }
        if (!Number.isFinite(baseLeft)) {
          baseLeft = 0;
        }
        if (!Number.isFinite(baseTop)) {
          baseTop = 0;
        }
        switch (item.type) {
          case 'image': {
            const element = createImageElement({
              id: preserveId ? item.data.id : undefined,
              src: item.data.src,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount,
              width: item.data.width,
              height: item.data.height,
              rotation: item.data.rotation,
              minWidth: item.data.minWidth,
              minHeight: item.data.minHeight,
              aspectRatio: item.data.aspectRatio,
              zIndex: item.data.zIndex,
              animate: false,
              select: true
            });
            return element;
          }
          case 'video': {
            const element = createVideoElement({
              id: preserveId ? item.data.id : undefined,
              src: item.data.src,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount,
              width: item.data.width,
              height: item.data.height,
              rotation: item.data.rotation,
              minWidth: item.data.minWidth,
              minHeight: item.data.minHeight,
              aspectRatio: item.data.aspectRatio,
              zIndex: item.data.zIndex,
              animate: false,
              select: true
            });
            return element;
          }
          case 'shape': {
            const shapeData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = instantiateShape(shapeData);
            if (element) {
              selectShape(element);
            }
            return element;
          }
          case 'chart': {
            const chartData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = instantiateChart(chartData);
            if (element) {
              selectChart(element);
            }
            return element;
          }
          case 'table': {
            const tableData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = instantiateTable(tableData);
            if (element) {
              selectTableElement(element);
            }
            return element;
          }
          case 'textbox': {
            const isTitle = !!item.data.isTitle;
            const isBody = !!item.data.isBody;
            const restoringMain = editorClipboard.mode === 'cut';
            if (isTitle && titleBox && restoringMain) {
              applyTextBoxData(titleBox, item.data);
              selectTextBox(titleBox);
              return titleBox;
            }
            if (isBody && textBox && restoringMain) {
              applyTextBoxData(textBox, item.data);
              selectTextBox(textBox);
              return textBox;
            }
            const textboxData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = createAdditionalTextBox(textboxData);
            if (element) {
              selectTextBox(element);
            }
            return element;
          }
          default:
            return null;
        }
      }
      function pasteElementsFromClipboard(options = {}) {
        if (!editorClipboard || editorClipboard.type !== 'elements' || !editorClipboard.data || !Array.isArray(editorClipboard.data.items)) {
          showNotification('Clipboard is empty');
          return false;
        }
        const items = editorClipboard.data.items;
        if (!items.length) {
          showNotification('Clipboard is empty');
          return false;
        }
        const baseOffset = (editorClipboard.offset || 0) + 1;
        editorClipboard.offset = baseOffset;
        const createdElements = [];
        const referenceElement = options.referenceElement || elementContextTarget || null;
        items.forEach((item, index) => {
          const element = instantiateClipboardElement(item, baseOffset + index - 1, referenceElement);
          if (element) {
            createdElements.push(element);
          }
        });
        if (!createdElements.length) {
          showNotification('Nothing to paste');
          return false;
        }
        const lastElement = createdElements[createdElements.length - 1];
        if (lastElement) {
          if (lastElement.classList.contains('image-element')) {
            selectImage(lastElement);
          } else if (lastElement.classList.contains('video-element')) {
            selectVideo(lastElement);
          } else if (lastElement.classList.contains('shape-element')) {
            selectShape(lastElement);
          } else if (lastElement.classList.contains('table-element')) {
            selectTableElement(lastElement);
          } else if (lastElement.classList.contains('additional-text-box')) {
            selectTextBox(lastElement);
          }
        }
        capture();
        saveEditorState('paste_elements');
        editorClipboard.mode = 'copy';
        showNotification('Pasted object');
        updateElementContextMenuState();
        updateSlideCanvasMenuState();
        return true;
      }
      function openImageCropper(element) {
        if (!element) return;
        if (typeof window.Cropper !== 'function') {
          alert('Image crop tools are still loading. Please try again in a moment.');
          return;
        }
        const img = element.querySelector('img');
        if (!img) return;
        imageCropTargetElement = element;
        imageCropOverlay.classList.add('visible');
        if (imageCropperInstance) {
          imageCropperInstance.destroy();
          imageCropperInstance = null;
        }
        const source = img.getAttribute('src');
        imageCropperImage.onload = () => {
          if (imageCropperInstance) {
            imageCropperInstance.destroy();
          }
          imageCropperInstance = new window.Cropper(imageCropperImage, {
            viewMode: 1,
            autoCropArea: 1,
            responsive: true,
            background: false,
            movable: true,
            zoomable: true,
            scalable: false,
            modal: true
          });
        };
        if (imageCropperImage.getAttribute('src') === source) {
          imageCropperImage.onload();
        } else {
          imageCropperImage.setAttribute('src', source || '');
        }
      }
      function closeImageCropper() {
        if (imageCropperInstance) {
          imageCropperInstance.destroy();
          imageCropperInstance = null;
        }
        imageCropOverlay.classList.remove('visible');
        imageCropperImage.removeAttribute('src');
        imageCropperImage.onload = null;
        imageCropTargetElement = null;
      }
      function applyImageCrop() {
        if (!imageCropperInstance || !imageCropTargetElement) return;
        const croppedCanvas = imageCropperInstance.getCroppedCanvas();
        if (!croppedCanvas) return;
        const dataUrl = croppedCanvas.toDataURL('image/png');
        const img = imageCropTargetElement.querySelector('img');
        if (!img) return;
        img.src = dataUrl;
        const newAspect = croppedCanvas.width / Math.max(croppedCanvas.height, 0.01);
        const minWidth = parseFloat(imageCropTargetElement.dataset.minWidth || '80');
        imageCropTargetElement.dataset.aspectRatio = String(newAspect);
        imageCropTargetElement.dataset.minHeight = String(Math.max(60, minWidth / Math.max(newAspect, 0.01)));
        capture();
        saveEditorState('crop_image');
        showNotification('Cropped image');
        closeImageCropper();
      }
      function setImageAsBackground(element) {
        if (!element) return;
        const img = element.querySelector('img');
        if (!img) return;
        const src = img.getAttribute('src');
        if (!src) return;
        const backgroundConfig = {
          image: `url(${src})`,
          size: 'cover',
          position: 'center center',
          repeat: 'no-repeat'
        };
        canvas.style.backgroundImage = backgroundConfig.image;
        canvas.style.backgroundSize = backgroundConfig.size;
        canvas.style.backgroundPosition = backgroundConfig.position;
        canvas.style.backgroundRepeat = backgroundConfig.repeat;
        deleteImage(element, { skipCapture: true, skipHistory: true });
        if (slides[active]) {
          slides[active].background = { ...backgroundConfig };
        }
        capture();
        saveEditorState('set_image_background');
        showNotification('Set image as background');
      }
      function hideSlideCanvasContextMenu() {
        if (!slideCanvasContextMenu) return;
        slideCanvasContextMenu.classList.remove('show');
        slideCanvasContextMenu.style.top = '-9999px';
        slideCanvasContextMenu.style.left = '-9999px';
        slideCanvasContextTargetIndex = null;
      }
      function updateSlideCanvasMenuState() {
        if (!slideCanvasContextMenu) return;
        let hasClipboard = false;
        if (editorClipboard) {
          if (editorClipboard.type === 'slide') {
            hasClipboard = !!(editorClipboard.data && editorClipboard.data.slide);
          } else if (editorClipboard.type === 'elements') {
            hasClipboard = !!(editorClipboard.data && Array.isArray(editorClipboard.data.items) && editorClipboard.data.items.length > 0);
          }
        }
        if (slideCanvasMenuButtons.paste) {
          slideCanvasMenuButtons.paste.disabled = !hasClipboard;
        }
        const singleSlide = slides.length <= 1;
        if (slideCanvasMenuButtons.cut) {
          slideCanvasMenuButtons.cut.disabled = singleSlide;
        }
        if (slideCanvasMenuButtons.delete) {
          slideCanvasMenuButtons.delete.disabled = singleSlide;
        }
      }
      function showSlideCanvasContextMenu(event, index) {
        if (!slideCanvasContextMenu) return;
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        slideCanvasContextTargetIndex = index;
        slideCanvasContextMenu.classList.add('show');
        slideCanvasContextMenu.style.top = '0px';
        slideCanvasContextMenu.style.left = '0px';
        const menuRect = slideCanvasContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        slideCanvasContextMenu.style.top = `${Math.max(padding, top)}px`;
        slideCanvasContextMenu.style.left = `${Math.max(padding, left)}px`;
        updateSlideCanvasMenuState();
      }
      function copySlideAt(index) {
        if (!Number.isInteger(index) || index < 0 || index >= slides.length) return false;
        capture();
        setEditorClipboard('slide', {
          slide: JSON.parse(JSON.stringify(slides[index]))
        }, 'copy');
        return true;
      }
      function deleteSlide(index, options = {}) {
        if (!Number.isInteger(index) || index < 0 || index >= slides.length) return false;
        if (slides.length <= 1) {
          showNotification('Cannot delete the only slide');
          return false;
        }
        const { skipHistory = false } = options;
        capture();
        slides.splice(index, 1);
        if (active > index) {
          active -= 1;
        } else if (active >= slides.length) {
          active = slides.length - 1;
        }
        load();
        renderSidebar();
        if (!skipHistory) {
          saveEditorState('delete_slide');
        }
        updateSlideCanvasMenuState();
        return true;
      }
      function cutSlideAt(index) {
        if (slides.length <= 1) {
          showNotification('Cannot cut the only slide');
          return false;
        }
        if (!copySlideAt(index)) return false;
      editorClipboard.mode = 'cut';
        return deleteSlide(index);
      }
      function pasteSlideAfter(index) {
        if (!editorClipboard || editorClipboard.type !== 'slide' || !editorClipboard.data || !editorClipboard.data.slide) {
          showNotification('Clipboard is empty');
          return false;
        }
        const insertIndex = Math.min(slides.length, Math.max(0, index) + 1);
        capture();
        const newSlide = JSON.parse(JSON.stringify(editorClipboard.data.slide));
        slides.splice(insertIndex, 0, newSlide);
        active = insertIndex;
        load();
        renderSidebar();
        saveEditorState('paste_slide');
        editorClipboard.mode = 'copy';
        updateSlideCanvasMenuState();
        updateElementContextMenuState();
        showNotification('Pasted slide');
        return true;
      }
      if (elementContextButtons.copy) {
        elementContextButtons.copy.addEventListener('click', () => {
          copySelectedElements(elementContextTarget);
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.cut) {
        elementContextButtons.cut.addEventListener('click', () => {
          cutSelectedElements(elementContextTarget);
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.paste) {
        elementContextButtons.paste.addEventListener('click', () => {
          pasteElementsFromClipboard({ referenceElement: elementContextTarget });
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.translate) {
        elementContextButtons.translate.addEventListener('click', () => {
          const target = elementContextTarget || (getSelectedElementContext()?.element ?? null);
          hideElementContextMenu();
          openTranslatorPanel(target, { autoTranslate: true });
        });
      }
      if (translatorInsertButton) {
        translatorInsertButton.addEventListener('click', insertTranslatorResult);
      }
      if (translatorCloseButton) {
        translatorCloseButton.addEventListener('click', () => hideTranslatorPanel());
      }
      if (translatorLanguageSelect) {
        translatorLanguageSelect.addEventListener('change', () => {
          setTranslatorStatus('');
        });
      }
      if (translatorSourceInput) {
        translatorSourceInput.addEventListener('input', () => {
          setTranslatorStatus('');
          if (translatorResultArea) {
            translatorResultArea.value = '';
          }
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && translatorPanel && !translatorPanel.classList.contains('hidden')) {
          hideTranslatorPanel();
        }
      });
      if (translateToolButton) {
        translateToolButton.addEventListener('click', () => {
          openTranslatorPanel(getPreferredTranslationElement(), { autoTranslate: true });
        });
      }
      if (elementContextButtons.delete) {
        elementContextButtons.delete.addEventListener('click', () => {
          const target = elementContextTarget || (getSelectedElementContext()?.element ?? null);
          if (target && removeElementElement(target)) {
            showNotification('Deleted object');
          } else {
            showNotification('No object selected');
          }
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.crop) {
        elementContextButtons.crop.addEventListener('click', () => {
          if (elementContextTarget && elementContextTarget.classList.contains('image-element')) {
            hideElementContextMenu();
            openImageCropper(elementContextTarget);
          }
        });
      }
      if (elementContextButtons.background) {
        elementContextButtons.background.addEventListener('click', () => {
          if (elementContextTarget && elementContextTarget.classList.contains('image-element')) {
            hideElementContextMenu();
            setImageAsBackground(elementContextTarget);
          }
        });
      }
      if (slideCanvasMenuButtons.copy) {
        slideCanvasMenuButtons.copy.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (copySlideAt(index)) {
            showNotification('Copied slide');
          }
        });
      }
      if (slideCanvasMenuButtons.cut) {
        slideCanvasMenuButtons.cut.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (cutSlideAt(index)) {
            showNotification('Cut slide');
          }
        });
      }
      if (slideCanvasMenuButtons.paste) {
        slideCanvasMenuButtons.paste.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (editorClipboard.type === 'slide') {
            pasteSlideAfter(index);
          } else if (editorClipboard.type === 'elements') {
            pasteElementsFromClipboard({ referenceElement: null });
          } else {
            showNotification('Clipboard is empty');
          }
        });
      }
      if (slideCanvasMenuButtons.newSlide) {
        slideCanvasMenuButtons.newSlide.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          createNewSlide(index);
        });
      }
      if (slideCanvasMenuButtons.duplicate) {
        slideCanvasMenuButtons.duplicate.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          duplicateCurrentSlide(index);
        });
      }
      if (slideCanvasMenuButtons.delete) {
        slideCanvasMenuButtons.delete.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (deleteSlide(index)) {
            showNotification('Deleted slide');
          }
        });
      }
      if (elementContextMenu) {
        elementContextMenu.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });
        elementContextMenu.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }
      if (slideCanvasContextMenu) {
        slideCanvasContextMenu.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });
        slideCanvasContextMenu.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }
      document.addEventListener('click', (event) => {
        if (elementContextMenu && elementContextMenu.classList.contains('show') && !elementContextMenu.contains(event.target)) {
          hideElementContextMenu();
        }
        if (slideCanvasContextMenu && slideCanvasContextMenu.classList.contains('show') && !slideCanvasContextMenu.contains(event.target)) {
          hideSlideCanvasContextMenu();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (imageCropOverlay.classList.contains('visible')) {
            closeImageCropper();
          } else {
            hideElementContextMenu();
            hideSlideCanvasContextMenu();
          }
        }
      });
      window.addEventListener('resize', () => {
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
      });
      window.addEventListener('scroll', (event) => {
        if (elementContextMenu && elementContextMenu.classList.contains('show') && !elementContextMenu.contains(event.target)) {
          hideElementContextMenu();
        }
        if (slideCanvasContextMenu && slideCanvasContextMenu.classList.contains('show') && !slideCanvasContextMenu.contains(event.target)) {
          hideSlideCanvasContextMenu();
        }
      }, true);
      if (imageCropOverlay) {
        imageCropOverlay.addEventListener('click', (event) => {
          if (event.target === imageCropOverlay) {
            closeImageCropper();
          }
        });
        imageCropOverlay.addEventListener('contextmenu', (event) => event.preventDefault());
      }
      if (imageCropCancel) {
        imageCropCancel.addEventListener('click', () => closeImageCropper());
      }
      if (imageCropClose) {
        imageCropClose.addEventListener('click', () => closeImageCropper());
      }
      if (imageCropApply) {
        imageCropApply.addEventListener('click', () => applyImageCrop());
      }

      const presentationOverlay = document.createElement('div');
      presentationOverlay.id = 'presentationOverlay';
      presentationOverlay.className = 'presentation-overlay';
      presentationOverlay.setAttribute('tabindex', '-1');
      presentationOverlay.innerHTML = `
        <div class="presentation-stage" tabindex="-1"></div>
        <div class="presentation-meta">
          <span><i class="fas fa-arrow-left"></i> Prev</span>
          <span>Esc to Exit</span>
          <span>Next <i class="fas fa-arrow-right"></i></span>
        </div>
        <div class="presentation-counter"></div>
      `;
      document.body.appendChild(presentationOverlay);
      const presentationStage = presentationOverlay.querySelector('.presentation-stage');
      const presentationCounterEl = presentationOverlay.querySelector('.presentation-counter');
      const transitionPreviewOverlay = document.createElement('div');
      transitionPreviewOverlay.id = 'transitionPreviewOverlay';
      transitionPreviewOverlay.className = 'transition-preview-overlay';
      transitionPreviewOverlay.innerHTML = '<div class="transition-preview-stage"></div>';
      document.body.appendChild(transitionPreviewOverlay);
      const transitionPreviewStage = transitionPreviewOverlay.querySelector('.transition-preview-stage');
      let transitionPreviewTimeout = null;
      let isPresenting = false;
      let presentationIndex = 0;
      let presentationReturnIndex = 0;
      let presentationControlsTimeout = null;
      const PRESENTATION_CONTROLS_AUTOHIDE_DELAY = 4000;
      let presentationControlsLocked = false;
      let slideContextMenuTarget = null;
      let slideContextMenuTitle = null;
      let slideContextMenuIndex = null;
      let currentAnimationQueue = [];
      let currentAnimationStep = 0;
      const TRANSITION_OPTIONS = Object.freeze([
        { value: 'none', label: 'None' },
        { value: 'fade', label: 'Fade' },
        { value: 'slide-left', label: 'Slide Left' },
        { value: 'slide-right', label: 'Slide Right' },
        { value: 'slide-up', label: 'Slide Up' },
        { value: 'slide-down', label: 'Slide Down' },
        { value: 'zoom-in', label: 'Zoom In' },
        { value: 'zoom-out', label: 'Zoom Out' },
        { value: 'flip', label: 'Flip' },
        { value: 'rotate', label: 'Rotate' }
      ]);
      const DEFAULT_TRANSITION = 'none';
      const TRANSITION_CLASS_NAMES = TRANSITION_OPTIONS
        .filter(opt => opt.value !== 'none')
        .map(opt => `transition-effect-${opt.value}`);
      const TRANSITION_VALUE_SET = new Set(TRANSITION_OPTIONS.map(opt => opt.value));
      let slideTransitionMenuIndex = null;
      let slideTransitionMenuAnchor = null;

      function renderSlideTransitionMenuOptions() {
        if (!slideTransitionMenu) return;
        slideTransitionMenu.innerHTML = '';
        TRANSITION_OPTIONS.forEach(opt => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.transition = opt.value;
          btn.innerHTML = `${getTransitionIconHtml(opt.value)}<span>${opt.label}</span>`;
          slideTransitionMenu.appendChild(btn);
        });
      }
      renderSlideTransitionMenuOptions();

      function showSaveAsMenu() {
        if (!saveAsMenu) return;
        saveAsMenu.classList.add('show');
      }

      function hideSaveAsMenu() {
        if (!saveAsMenu) return;
        saveAsMenu.classList.remove('show');
      }

      function toggleSaveAsMenu() {
        if (!saveAsMenu) return;
        if (saveAsMenu.classList.contains('show')) {
          hideSaveAsMenu();
        } else {
          showSaveAsMenu();
        }
      }

      const saveAsModal = document.getElementById('saveAsModal');
      const saveAsModalClose = document.getElementById('saveAsModalClose');
      const saveAsModalCancel = document.getElementById('saveAsModalCancel');
      const saveAsModalSave = document.getElementById('saveAsModalSave');
      const saveAsFormat = document.getElementById('saveAsFormat');
      const saveAsFileName = document.getElementById('saveAsFileName');

      function showSaveAsModal() {
        if (!saveAsModal) return;
        // Set default filename based on current slide title
        const currentSlide = slides[active] || slides[0] || {};
        const rawTitle = (currentSlide.title || '').trim();
        const sanitizedTitle = rawTitle
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_');
        const defaultName = sanitizedTitle || 'Presentation';
        saveAsFileName.value = defaultName;
        saveAsModal.classList.add('show');
        // Focus the filename input
        setTimeout(() => {
          saveAsFileName.focus();
          saveAsFileName.select();
        }, 100);
      }

      function hideSaveAsModal() {
        if (!saveAsModal) return;
        saveAsModal.classList.remove('show');
      }

      if (saveAsButton) {
        saveAsButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          showSaveAsModal();
        });
      }

      if (saveAsModalClose) {
        saveAsModalClose.addEventListener('click', () => {
          hideSaveAsModal();
        });
      }

      if (saveAsModalCancel) {
        saveAsModalCancel.addEventListener('click', () => {
          hideSaveAsModal();
        });
      }

      if (saveAsModal) {
        saveAsModal.addEventListener('click', (event) => {
          if (event.target === saveAsModal) {
            hideSaveAsModal();
          }
        });
      }

      if (saveAsModalSave) {
        saveAsModalSave.addEventListener('click', async () => {
          const format = saveAsFormat ? saveAsFormat.value : 'pptx';
          const fileName = saveAsFileName ? saveAsFileName.value.trim() : '';
          if (!fileName) {
            alert('Please enter a file name');
            return;
          }
          hideSaveAsModal();
          await handleSaveAsExport(format, fileName);
        });
      }

      // Allow Enter key to save
      if (saveAsFileName) {
        saveAsFileName.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && saveAsModalSave) {
            event.preventDefault();
            saveAsModalSave.click();
          }
        });
      }

      // Keep old menu handlers for backward compatibility (hidden menu)
      if (saveAsMenu) {
        document.addEventListener('click', (event) => {
          if (!saveAsMenu.contains(event.target) && !saveAsButton.contains(event.target)) {
            hideSaveAsMenu();
          }
        });
        window.addEventListener('resize', hideSaveAsMenu);
        window.addEventListener('scroll', hideSaveAsMenu, true);
      }

      function prepareCanvasForPresentation(clone) {
        clone.removeAttribute('id');
        clone.classList.add('presentation-slide');
        clone.style.width = '100%';
        clone.style.height = '100%';
        clone.style.pointerEvents = 'none';
        clone.querySelectorAll('[id]').forEach(el => {
          if (el.id) {
            el.removeAttribute('id');
          }
        });
        clone.querySelectorAll('[contenteditable]').forEach(el => {
          el.removeAttribute('contenteditable');
          el.classList.remove('selected');
          el.removeAttribute('spellcheck');
        });
        clone.querySelectorAll('.resize-edge').forEach(el => el.remove());
        clone.querySelectorAll('[data-placeholder]').forEach(el => el.removeAttribute('data-placeholder'));
        clone.querySelectorAll('.shape-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.chart-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.video-element').forEach(el => {
          el.classList.remove('selected');
          const video = el.querySelector('video');
          if (video) {
            video.controls = true;
          }
        });
        clone.querySelectorAll('.image-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.table-resize-handle').forEach(el => el.remove());
        clone.querySelectorAll('.table-cell-selected').forEach(el => el.classList.remove('table-cell-selected'));
        clone.querySelectorAll('.table-element').forEach(el => {
          el.style.border = '1px solid rgba(148, 232, 203, 0.35)';
          el.style.boxShadow = 'none';
        });
        clone.querySelectorAll('.table-element').forEach(el => {
          el.classList.remove('selected');
          el.style.border = '1px solid rgba(148, 232, 203, 0.35)';
          el.style.boxShadow = 'none';
        });
        clone.querySelectorAll('.title-box, .text-box, .additional-text-box').forEach(el => {
          el.style.border = 'none';
          el.style.boxShadow = 'none';
          el.style.backgroundColor = el.style.backgroundColor || 'transparent';
        });
        clone.querySelectorAll('.animation-order-badge').forEach(el => el.remove());
      }

      function cloneCanvasForPresentation(index, options = {}) {
        const originalActive = active;
        const restoreActiveIndex = Number.isInteger(options.restoreActiveIndex)
          ? options.restoreActiveIndex
          : (isPresenting ? presentationReturnIndex : originalActive);
        active = index;
        load();
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        const config = getSlideTransitionConfig(slides[index]);
        applySlideTransitionClass(clone, config.effect, config.duration, options);
        active = restoreActiveIndex;
        load();
        return clone;
      }

      function waitForNextFrame() {
        return new Promise((resolve) => requestAnimationFrame(() => resolve()));
      }

      function getCanvasBackgroundColor() {
        const computed = window.getComputedStyle(canvas);
        return computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)'
          ? computed.backgroundColor
          : '#ffffff';
      }

      async function renderSlideToImage() {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Export library html2canvas is not available.');
        }
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        clone.style.width = `${canvas.offsetWidth}px`;
        clone.style.height = `${canvas.offsetHeight}px`;
        clone.style.pointerEvents = 'none';
        clone.style.transform = 'none';
        const wrapper = document.createElement('div');
        wrapper.className = 'export-slide-wrapper';
        wrapper.style.position = 'fixed';
        wrapper.style.top = '-12000px';
        wrapper.style.left = '-12000px';
        wrapper.style.width = `${canvas.offsetWidth}px`;
        wrapper.style.height = `${canvas.offsetHeight}px`;
        wrapper.style.pointerEvents = 'none';
        wrapper.style.opacity = '0';
        wrapper.style.background = getCanvasBackgroundColor();
        wrapper.appendChild(clone);
        document.body.appendChild(wrapper);
        try {
          const exportCanvas = await window.html2canvas(clone, {
            backgroundColor: wrapper.style.background || '#ffffff',
            scale: 2,
            useCORS: true,
            logging: false
          });
          return {
            dataUrl: exportCanvas.toDataURL('image/png'),
            width: exportCanvas.width,
            height: exportCanvas.height
          };
        } finally {
          document.body.removeChild(wrapper);
        }
      }

      async function captureSlidesAsImages() {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Export libraries are still loading.');
        }
        const originalActiveIndex = active;
        capture();
        const slideImages = [];
        try {
          for (let index = 0; index < slides.length; index += 1) {
            active = index;
            load();
            await waitForNextFrame();
            const image = await renderSlideToImage();
            slideImages.push(image);
          }
        } finally {
          active = originalActiveIndex;
          load();
        }
        return slideImages;
      }

      function getExportFileName(extension) {
        const currentSlide = slides[active] || slides[0] || {};
        const rawTitle = (currentSlide.title || '').trim();
        const sanitizedTitle = rawTitle
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_');
        const base = sanitizedTitle || 'Presentation';
        const dateStamp = new Date().toISOString().slice(0, 10);
        return `${base}_${dateStamp}.${extension}`;
      }

      async function exportSlidesToPdf(slideImages, fileName) {
        const jspdfNamespace = window.jspdf;
        if (!jspdfNamespace || typeof jspdfNamespace.jsPDF !== 'function') {
          throw new Error('PDF export library is not available.');
        }
        if (!slideImages.length) {
          throw new Error('No slides available to export.');
        }
        const { jsPDF } = jspdfNamespace;
        const pxToPt = 72 / 96;
        const firstSlide = slideImages[0];
        const firstOrientation = firstSlide.width >= firstSlide.height ? 'landscape' : 'portrait';
        const doc = new jsPDF({
          orientation: firstOrientation,
          unit: 'pt',
          format: [firstSlide.width * pxToPt, firstSlide.height * pxToPt]
        });
        doc.addImage(
          firstSlide.dataUrl,
          'PNG',
          0,
          0,
          firstSlide.width * pxToPt,
          firstSlide.height * pxToPt,
          undefined,
          'FAST'
        );
        for (let i = 1; i < slideImages.length; i += 1) {
          const slide = slideImages[i];
          const orientation = slide.width >= slide.height ? 'landscape' : 'portrait';
          doc.addPage([slide.width * pxToPt, slide.height * pxToPt], orientation);
          doc.addImage(
            slide.dataUrl,
            'PNG',
            0,
            0,
            slide.width * pxToPt,
            slide.height * pxToPt,
            undefined,
            'FAST'
          );
        }
        const pdfFileName = fileName ? getExportFileNameWithExtension(fileName, 'pdf') : getExportFileName('pdf');
        doc.save(pdfFileName);
      }

      async function exportSlidesToPptx(slideImages, fileName) {
        if (typeof window.PptxGenJS !== 'function') {
          throw new Error('PPTX export library is not available.');
        }
        if (!slideImages.length) {
          throw new Error('No slides available to export.');
        }
        const pptx = new window.PptxGenJS();
        pptx.layout = 'LAYOUT_16x9';
        slideImages.forEach((slide) => {
          const slideDeck = pptx.addSlide();
          slideDeck.background = { color: 'FFFFFF' };
          slideDeck.addImage({
            data: slide.dataUrl,
            x: 0,
            y: 0,
            w: pptx.width,
            h: pptx.height
          });
        });
        const pptxFileName = fileName ? getExportFileNameWithExtension(fileName, 'pptx') : getExportFileName('pptx');
        await pptx.writeFile({ fileName: pptxFileName });
      }

      function sanitizeFileName(fileName) {
        // Remove invalid characters and sanitize filename
        return fileName
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_')
          .substring(0, 100); // Limit length
      }

      function getExportFileNameWithExtension(baseName, extension) {
        const sanitized = sanitizeFileName(baseName);
        return `${sanitized}.${extension}`;
      }

      async function exportSlidesToPng(fileName) {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Image export tools are not available.');
        }
        if (typeof window.JSZip === 'undefined') {
          throw new Error('ZIP export tools are not available.');
        }
        const zip = new JSZip();
        const slideImages = await captureSlidesAsImages();
        slideImages.forEach((slide, index) => {
          const slideNumber = String(index + 1).padStart(2, '0');
          const slideFileName = `${fileName}_slide_${slideNumber}.png`;
          // Remove data URL prefix and add base64 data to zip
          const base64Data = slide.dataUrl.split(',')[1];
          zip.file(slideFileName, base64Data, { base64: true });
        });
        const blob = await zip.generateAsync({ type: 'blob' });
        const zipFileName = `${fileName}_PNG_slides.zip`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function exportSlidesToJson(fileName) {
        const payload = {
          generatedAt: new Date().toISOString(),
          fileName: fileName,
          slides: slides.map(slide => ({
            id: slide.id,
            title: slide.title,
            content: slide.content,
            background: slide.background,
            shapes: slide.shapes,
            charts: slide.charts,
            images: slide.images,
            videos: slide.videos,
            tables: slide.tables,
            additionalTextBoxes: slide.additionalTextBoxes,
            comments: Array.isArray(slide.comments) ? JSON.parse(JSON.stringify(slide.comments)) : [],
            animations: slide.animations,
            transition: slide.transition,
            transitionDuration: slide.transitionDuration
          }))
        };
        const jsonString = JSON.stringify(payload, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = getExportFileNameWithExtension(fileName, 'json');
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function exportSlidesToHtml(fileName) {
        // Generate a standalone HTML document with all slides
        let htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${fileName}</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0f172a;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }
    .slide-container {
      max-width: 1200px;
      margin: 0 auto 40px;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }
    .slide-header {
      background: #0f172a;
      color: white;
      padding: 16px 24px;
      font-weight: 700;
      font-size: 18px;
      border-bottom: 2px solid #22c55e;
    }
    .slide-content {
      padding: 24px;
      min-height: 400px;
    }
  </style>
</head>
<body>
  <h1 style="color: white; text-align: center; margin-bottom: 40px;">${fileName}</h1>
`;

        slides.forEach((slide, index) => {
          htmlContent += `
  <div class="slide-container">
    <div class="slide-header">Slide ${index + 1}: ${(slide.title || 'Untitled').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
    <div class="slide-content">${slide.content || ''}</div>
  </div>
`;
        });

        htmlContent += `
</body>
</html>`;

        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = getExportFileNameWithExtension(fileName, 'html');
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      async function handleSaveAsExport(format, fileName) {
        if (!format || !fileName || isExportingPresentation) return;
        const validFormats = ['pdf', 'pptx', 'png', 'json', 'html'];
        if (!validFormats.includes(format)) {
          alert('Invalid file format selected.');
          return;
        }
        
        // Check for required libraries based on format
        if ((format === 'pdf' || format === 'pptx' || format === 'png') && typeof window.html2canvas !== 'function') {
          alert('Export tools are still loading. Please try again in a moment.');
          return;
        }
        if (format === 'pdf' && (!window.jspdf || typeof window.jspdf.jsPDF !== 'function')) {
          alert('PDF export tools are still loading. Please try again in a moment.');
          return;
        }
        if (format === 'pptx' && typeof window.PptxGenJS !== 'function') {
          alert('PPTX export tools are still loading. Please try again in a moment.');
          return;
        }
        if (format === 'png' && typeof window.JSZip === 'undefined') {
          alert('ZIP export tools are still loading. Please try again in a moment.');
          return;
        }

        isExportingPresentation = true;
        const previousCursor = document.body.style.cursor;
        document.body.style.cursor = 'wait';
        try {
          if (format === 'pdf') {
            const slideImages = await captureSlidesAsImages();
            await exportSlidesToPdf(slideImages, fileName);
            showNotification('Exported presentation as PDF');
          } else if (format === 'pptx') {
            const slideImages = await captureSlidesAsImages();
            await exportSlidesToPptx(slideImages, fileName);
            showNotification('Exported presentation as PPTX');
          } else if (format === 'png') {
            await exportSlidesToPng(fileName);
            showNotification('Exported slides as PNG images');
          } else if (format === 'json') {
            exportSlidesToJson(fileName);
            showNotification('Exported presentation as JSON');
          } else if (format === 'html') {
            exportSlidesToHtml(fileName);
            showNotification('Exported presentation as HTML');
          }
        } catch (error) {
          console.error('Export failed:', error);
          alert(`Unable to export the presentation: ${error.message || 'Please try again.'}`);
        } finally {
          document.body.style.cursor = previousCursor || '';
          isExportingPresentation = false;
        }
      }

      function updatePresentationCounter() {
        if (presentationCounterEl) {
          presentationCounterEl.textContent = `${presentationIndex + 1} / ${slides.length}`;
        }
      }

      function resetPresentationAnimations() {
        currentAnimationQueue = [];
        currentAnimationStep = 0;
      }

      function setupPresentationAnimations(clone, slide) {
        resetPresentationAnimations();
        if (!clone || !slide) return;
        const animations = sortSlideAnimations(slide).filter(anim => anim && anim.targetId);
        animations.forEach((anim) => {
          const target = clone.querySelector(`[data-element-id="${escapeSelector(anim.targetId)}"]`);
          if (!target) return;
          const duration = clampAnimationDuration(anim.duration ?? DEFAULT_ANIMATION_DURATION);
          const effect = normalizeAnimationEffect(anim.effect);
          const computed = window.getComputedStyle(target);
          const baseTransform = computed.transform && computed.transform !== 'none'
            ? computed.transform
            : 'none';
          target.style.setProperty('--animation-base-transform', baseTransform);
          target.style.setProperty('--animation-duration', `${duration}s`);
          ANIMATION_EFFECT_CLASS_NAMES.forEach(cls => target.classList.remove(cls));
          target.classList.add('presentation-animation-hidden');
          currentAnimationQueue.push({
            element: target,
            effect,
            duration
          });
        });
      }

      function triggerPresentationAnimation(entry) {
        if (!entry || !entry.element) return;
        const { element, effect, duration } = entry;
        element.classList.remove('presentation-animation-hidden');
        ANIMATION_EFFECT_CLASS_NAMES.forEach(cls => element.classList.remove(cls));
        element.style.setProperty('--animation-duration', `${duration}s`);
        element.classList.add(`presentation-animation-effect-${effect}`);
      }

      function playNextSlideAnimation() {
        if (!currentAnimationQueue.length || currentAnimationStep >= currentAnimationQueue.length) {
          return false;
        }
        const entry = currentAnimationQueue[currentAnimationStep];
        currentAnimationStep += 1;
        triggerPresentationAnimation(entry);
        return true;
      }

      function showPresentationSlide(index) {
        if (index < 0 || index >= slides.length) return;
        presentationIndex = index;
        const clone = cloneCanvasForPresentation(index);
        if (presentationStage) {
          presentationStage.innerHTML = '';
          presentationStage.appendChild(clone);
          clone.querySelectorAll('video').forEach((videoEl) => {
            videoEl.controls = true;
            videoEl.addEventListener('click', (event) => {
              event.stopPropagation();
              if (videoEl.paused) {
                videoEl.play().catch(() => {});
              } else {
                videoEl.pause();
              }
            });
          });
          const config = getSlideTransitionConfig(slides[index]);
          applySlideTransitionClass(clone, config.effect, config.duration);
          setupPresentationAnimations(clone, slides[index]);
        }
        updatePresentationCounter();
      }

      function hidePresentationControls(lock = false) {
        if (!isPresenting) return;
        presentationOverlay.classList.remove('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (lock) {
          presentationControlsLocked = true;
        }
      }

      function showPresentationControls(autoHide = true) {
        if (!isPresenting || presentationControlsLocked) return;
        presentationOverlay.classList.add('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
        }
        if (autoHide) {
          presentationControlsTimeout = setTimeout(() => {
            presentationControlsTimeout = null;
            hidePresentationControls(true);
          }, PRESENTATION_CONTROLS_AUTOHIDE_DELAY);
        } else {
          presentationControlsTimeout = null;
        }
      }

      function startPresentation() {
        if (isPresenting) return;
        capture();
        presentationReturnIndex = active;
        isPresenting = true;
        presentationOverlay.classList.add('visible');
        showPresentationSlide(active);
        document.body.classList.add('presenting');
        presentationControlsLocked = false;
        showPresentationControls(true);
        requestAnimationFrame(() => {
          try {
            presentationOverlay.focus({ preventScroll: true });
          } catch (err) {
            presentationOverlay.focus();
          }
          if (presentationOverlay.requestFullscreen) {
            presentationOverlay.requestFullscreen().catch(() => {});
          }
        });
      }

      function exitPresentation(fromFullscreenChange = false) {
        if (!isPresenting) return;
        isPresenting = false;
        resetPresentationAnimations();
        presentationOverlay.classList.remove('visible');
        presentationOverlay.classList.remove('show-controls');
        document.body.classList.remove('presenting');
        presentationControlsLocked = false;
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (presentationStage) {
          presentationStage.innerHTML = '';
        }
        active = presentationReturnIndex;
        load();
        renderSidebar();
        if (!fromFullscreenChange && document.fullscreenElement && document.exitFullscreen) {
          document.exitFullscreen().catch(() => {});
        }
      }

      function goToNextSlide() {
        if (isPresenting && playNextSlideAnimation()) {
          return;
        }
        if (presentationIndex < slides.length - 1) {
          showPresentationSlide(presentationIndex + 1);
        }
      }

      function goToPreviousSlide() {
        if (presentationIndex > 0) {
          showPresentationSlide(presentationIndex - 1);
        }
      }

      function hideTransitionPreview() {
        if (transitionPreviewTimeout) {
          clearTimeout(transitionPreviewTimeout);
          transitionPreviewTimeout = null;
        }
        transitionPreviewOverlay.classList.remove('show');
        if (transitionPreviewStage) {
          transitionPreviewStage.innerHTML = '';
        }
      }

      function showTransitionPreview(effect, duration) {
        if (!transitionPreviewOverlay || !transitionPreviewStage) return;
        if (isPresenting) {
          showPresentationSlide(presentationIndex);
          return;
        }
        const normalizedEffect = normalizeTransitionEffect(effect);
        const normalizedDuration = clampTransitionDuration(duration);
        const previewClone = cloneCanvasForPresentation(active, { force: true, restoreActiveIndex: active });
        transitionPreviewStage.innerHTML = '';
        transitionPreviewStage.appendChild(previewClone);
        if (normalizedEffect === DEFAULT_TRANSITION) {
          previewClone.classList.remove(...TRANSITION_CLASS_NAMES);
          previewClone.style.removeProperty('--transition-duration');
        }
        transitionPreviewOverlay.classList.add('show');
        const totalDurationMs = (normalizedEffect === DEFAULT_TRANSITION
          ? 1200
          : Math.min(normalizedDuration + 0.6, TRANSITION_DURATION_MAX + 0.6) * 1000);
        if (transitionPreviewTimeout) {
          clearTimeout(transitionPreviewTimeout);
        }
        transitionPreviewTimeout = window.setTimeout(() => {
          hideTransitionPreview();
        }, totalDurationMs);
      }

      transitionPreviewOverlay.addEventListener('click', (event) => {
        if (event.target === transitionPreviewOverlay) {
          hideTransitionPreview();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && transitionPreviewOverlay.classList.contains('show') && !isPresenting) {
          hideTransitionPreview();
        }
      });

      presentationOverlay.addEventListener('click', (event) => {
        if (!isPresenting) return;
        if (event.target.closest('.presentation-meta') || event.target.closest('.presentation-counter')) return;
        const stageRect = presentationStage ? presentationStage.getBoundingClientRect() : presentationOverlay.getBoundingClientRect();
        if (!stageRect || stageRect.width === 0) return;
        if (event.clientX > stageRect.left + stageRect.width / 2) {
          goToNextSlide();
        } else {
          goToPreviousSlide();
        }
      });

      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && isPresenting) {
          exitPresentation(true);
        }
      });


      shapeColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      shapeColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        shapeColorInput.click();
      });

      function updateShapeColorButtonAppearance(color) {
        shapeColorButton.style.background = color;
        const shadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
        shapeColorButton.style.boxShadow = shadow;
        const hex = color.replace('#', '');
        const bigint = parseInt(hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        shapeColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
      }

      const SHAPE_PICKER_MARGIN = 12;

      function positionShapeColorPicker(element) {
        if (!element || !shapeColorPicker.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const pickerRect = shapeColorPicker.getBoundingClientRect();
        let top = rect.top - pickerRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - pickerRect.width / 2;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }

        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }

        shapeColorPicker.style.top = `${top}px`;
        shapeColorPicker.style.left = `${left}px`;
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
      }

      function showShapeColorPicker(element) {
        if (!element) return;
        const color = normalizeColorHex(element.dataset.color || window.getComputedStyle(element).color || '#e8f5e9');
        shapeColorInput.value = color;
        updateShapeColorButtonAppearance(color);
        shapeColorPicker.classList.add('visible');
        positionShapeColorPicker(element);
        showRotationHandle(element);
      }

      function hideShapeColorPicker() {
        shapeColorPicker.classList.remove('visible');
        hideRotationHandle();
      }

      shapeColorInput.addEventListener('change', (event) => {
        if (!selectedShape) return;
        const color = normalizeColorHex(event.target.value);
        selectedShape.dataset.color = color;
        selectedShape.style.color = color;
        updateShapeColorButtonAppearance(color);
        positionShapeColorPicker(selectedShape);
        if (rotationTarget === selectedShape) {
          positionRotationHandle(selectedShape);
        }
        capture();
        saveEditorState('change_shape_color');
      });

      const shapeRotationHandle = document.createElement('div');
      shapeRotationHandle.id = 'shapeRotationHandle';
      shapeRotationHandle.className = 'shape-rotation-handle';
      shapeRotationHandle.innerHTML = `
        <button type="button" class="shape-rotation-button" title="Rotate Shape">
          <i class="fas fa-sync-alt"></i>
        </button>
        <span class="shape-rotation-angle">0Â°</span>
      `;
      document.body.appendChild(shapeRotationHandle);
      const shapeRotationButton = shapeRotationHandle.querySelector('.shape-rotation-button');
      const shapeRotationAngle = shapeRotationHandle.querySelector('.shape-rotation-angle');

      let tableColumnColorPickerBusy = false;

      tableColumnColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      tableColumnColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        tableColumnColorPickerBusy = true;
        tableColumnColorInput.click();
      });

      function handleTableColumnColorInputEvent(event, final = false) {
        if (!tableColumnColorTarget || tableColumnColorIndex == null) return;
        const color = normalizeColorHex(event.target.value);
        updateTableColumnColorButtonAppearance(color);
        applyColorToTableColumn(tableColumnColorTarget, tableColumnColorIndex, color, final);
        positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        tableColumnColorPickerBusy = false;
      }

      tableColumnColorInput.addEventListener('input', (event) => {
        handleTableColumnColorInputEvent(event, false);
      });

      tableColumnColorInput.addEventListener('change', (event) => {
        handleTableColumnColorInputEvent(event, true);
      });

      tableColumnColorInput.addEventListener('focus', () => {
        tableColumnColorPickerBusy = true;
      });

      tableColumnColorInput.addEventListener('blur', () => {
        tableColumnColorPickerBusy = false;
      });

      tableColumnColorPicker.addEventListener('mouseenter', () => {
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
          tableColumnHideTimeout = null;
        }
      });

      tableColumnColorPicker.addEventListener('mouseleave', () => {
        if (tableColumnColorPickerBusy) return;
        hideTableColumnColorPicker();
      });

      let rotationTarget = null;
      let isRotatingTarget = false;
      let rotationStartAngle = 0;
      let rotationInitial = 0;
      let rotationCenter = { x: 0, y: 0 };
      let activeResizeShape = null;
      let shapeResizeAnimating = false;

      function updateRotationAngleLabel(element, angleOverride) {
        if (!element || !shapeRotationAngle) return;
        const angle = angleOverride !== undefined ? angleOverride : (parseFloat(element.dataset.rotation || '0') || 0);
        shapeRotationAngle.textContent = `${Math.round(angle)}Â°`;
      }

      function positionRotationHandle(element) {
        if (!element || !shapeRotationHandle.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const handleRect = shapeRotationHandle.getBoundingClientRect();
        const colorRect = shapeColorPicker.getBoundingClientRect();
        const horizontalOffset = shapeColorPicker.classList.contains('visible')
          ? (colorRect.width / 2 + 28)
          : 70;
        let top = rect.top - handleRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 + horizontalOffset;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + handleRect.width > window.innerWidth - 16) {
          left = window.innerWidth - handleRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + handleRect.height > window.innerHeight - 16) {
          top = window.innerHeight - handleRect.height - 16;
        }

        shapeRotationHandle.style.top = `${top}px`;
        shapeRotationHandle.style.left = `${left}px`;
      }

      function showRotationHandle(element) {
        if (!element) return;
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        const currentRotation = parseFloat(element.dataset.rotation || '0') || 0;
        element.style.transform = `rotate(${currentRotation}deg)`;
        rotationTarget = element;
        updateRotationAngleLabel(element);
        positionRotationHandle(element);
        shapeRotationHandle.classList.add('visible');
      }

      function hideRotationHandle() {
        shapeRotationHandle.classList.remove('visible');
        endRotation(false);
        rotationTarget = null;
      }

      function endRotation(save = true) {
        if (!isRotatingTarget) return;
        isRotatingTarget = false;
        shapeRotationButton.classList.remove('active');
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleRotationMove);
        document.removeEventListener('mouseup', handleRotationUp);
        if (save && rotationTarget) {
          updateRotationAngleLabel(rotationTarget);
          positionRotationHandle(rotationTarget);
          capture();
          saveEditorState('rotate_shape');
        }
      }

      function handleRotationMove(event) {
        if (!isRotatingTarget || !rotationTarget) return;
        const current = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        let delta = (current - rotationStartAngle) * (180 / Math.PI);
        let newRotation = rotationInitial + delta;
        newRotation = ((newRotation % 360) + 360) % 360;
        rotationTarget.dataset.rotation = String(newRotation);
        rotationTarget.style.transform = `rotate(${newRotation}deg)`;
        updateRotationAngleLabel(rotationTarget, newRotation);
        if (rotationTarget.classList.contains('shape-element')) {
          positionShapeColorPicker(rotationTarget);
        }
        positionRotationHandle(rotationTarget);
      }

      function handleRotationUp() {
        endRotation(true);
      }

      shapeRotationButton.addEventListener('mousedown', (event) => {
        if (!rotationTarget) return;
        event.preventDefault();
        event.stopPropagation();
        const rect = rotationTarget.getBoundingClientRect();
        rotationCenter = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        rotationStartAngle = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        rotationInitial = parseFloat(rotationTarget.dataset.rotation || '0') || 0;
        isRotatingTarget = true;
        shapeRotationButton.classList.add('active');
        document.body.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleRotationMove);
        document.addEventListener('mouseup', handleRotationUp);
      });

      shapeRotationHandle.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      function updateShapeSizeBadge(element, width, height) {
        if (!element) return;
        shapeSizeBadge.textContent = `${Math.round(width)} Ã— ${Math.round(height)} px`;
        const rect = element.getBoundingClientRect();
        const badgeRect = shapeSizeBadge.getBoundingClientRect();
        let top = rect.top - badgeRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - badgeRect.width / 2;
        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + badgeRect.width > window.innerWidth - 16) {
          left = window.innerWidth - badgeRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        shapeSizeBadge.style.top = `${top}px`;
        shapeSizeBadge.style.left = `${left}px`;
      }

      function showShapeSizeBadge() {
        if (!shapeSizeBadge.classList.contains('visible')) {
          shapeSizeBadge.classList.add('visible');
        }
      }

      function hideShapeSizeBadge() {
        shapeSizeBadge.classList.remove('visible');
      }

      let isFontDropdownVisible = false;

      function setActiveFontOption(fontFamily) {
        const normalized = normalizeFontStack(fontFamily);
        fontOptionButtons.forEach((button, key) => {
          const isActive = key === normalized;
          button.classList.toggle('active', isActive);
          if (isActive) {
            button.scrollIntoView({ block: 'nearest' });
          }
        });
      }

      function extractPrimaryFontName(fontFamily) {
        if (!fontFamily) return 'Inter';
        const primary = fontFamily.split(',')[0].replace(/['"]/g, '').trim();
        if (!primary) return 'Inter';
        return primary;
      }

      function positionFontDropdown() {
        if (!fontPickerButton) return;
        const rect = fontPickerButton.getBoundingClientRect();
        fontDropdown.style.top = '0px';
        fontDropdown.style.left = '0px';
        fontDropdown.classList.add('show');
        const dropdownRect = fontDropdown.getBoundingClientRect();
        let top = rect.bottom + 8;
        let left = rect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = rect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(rect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        fontDropdown.style.top = `${Math.max(16, top)}px`;
        fontDropdown.style.left = `${left}px`;
      }

      function showFontDropdown() {
        if (!fontPickerButton) return;
        const currentFont = getCurrentFontFamily(currentActiveElement);
        setActiveFontOption(currentFont);
        fontDropdown.classList.add('show');
        positionFontDropdown();
        isFontDropdownVisible = true;
        fontPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideFontDropdown() {
        fontDropdown.classList.remove('show');
        isFontDropdownVisible = false;
        if (fontPickerButton) {
          fontPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleFontDropdown() {
        if (isFontDropdownVisible) {
          hideFontDropdown();
        } else {
          showFontDropdown();
        }
      }

      if (fontPickerButton) {
        fontPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleFontDropdown();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target) || (fontPickerButton && fontPickerButton.contains(event.target))) {
          return;
        }
        hideFontDropdown();
      });

      window.addEventListener('resize', () => {
        if (isFontDropdownVisible) {
          positionFontDropdown();
        }
      });

      window.addEventListener('scroll', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target)) {
          return;
        }
        hideFontDropdown();
      }, true);

      let isShapeDropdownVisible = false;
      let isChartDropdownVisible = false;
      let selectedShape = null;
      let selectedChart = null;
      let selectedImage = null;
      let selectedVideo = null;
      let selectedTable = null;
      let currentAnimationSelectedElementId = null;
      let lastCanvasInsertPosition = null;
      const TABLE_MIN_COLUMN_WIDTH = 48;
      const TABLE_MIN_ROW_HEIGHT = 28;
      const tableResizeObservers = new WeakMap();
      const tableMutationObservers = new WeakMap();
      const tableColumnHoverHandlers = new WeakMap();
      let activeTableResize = null;
      let isTablePanelVisible = false;
      let tableColumnColorTarget = null;
      let tableColumnColorIndex = null;
      let tableColumnHideTimeout = null;
      const GROUP_SELECTABLE_SELECTOR = '.shape-element, .chart-element, .image-element, .video-element, .table-element, .additional-text-box, #titleBox, #textBox';
      const MARQUEE_MIN_SIZE = 4;
      const groupSelectionState = {
        elements: [],
        frame: null,
        handles: [],
        metrics: [],
        dragState: null,
        resizeState: null
      };
      let marqueeState = null;

      function clearGroupSelection() {
        if (groupSelectionState.elements.length) {
          groupSelectionState.elements.forEach((element) => {
            element.classList.remove('group-selected');
          });
        }
        groupSelectionState.elements = [];
        groupSelectionState.metrics = [];
        groupSelectionState.dragState = null;
        groupSelectionState.resizeState = null;
        groupSelectionState.bounds = null;
        groupSelectionState.pendingBounds = null;
        groupSelectionState.minGroupWidth = 0;
        groupSelectionState.minGroupHeight = 0;
        if (groupSelectionState.frame && groupSelectionState.frame.parentElement) {
          groupSelectionState.frame.remove();
        }
        groupSelectionState.frame = null;
        groupSelectionState.handles = [];
        updateElementContextMenuState();
      }

      function clearAllSingleSelections() {
        clearShapeSelection();
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
      }

      function collectGroupSelectableElements() {
        if (!canvas) return [];
        return Array.from(canvas.querySelectorAll(GROUP_SELECTABLE_SELECTOR))
          .filter((element) => element !== canvas && element.offsetParent !== null && element.style.display !== 'none');
      }

      function getElementCanvasBounds(element) {
        const rect = element.getBoundingClientRect();
        const topLeft = getCanvasPointFromClient(rect.left, rect.top);
        const bottomRight = getCanvasPointFromClient(rect.right, rect.bottom);
        return {
          left: Math.min(topLeft.x, bottomRight.x),
          top: Math.min(topLeft.y, bottomRight.y),
          right: Math.max(topLeft.x, bottomRight.x),
          bottom: Math.max(topLeft.y, bottomRight.y),
          width: Math.abs(bottomRight.x - topLeft.x),
          height: Math.abs(bottomRight.y - topLeft.y)
        };
      }

      function selectElementByType(element) {
        if (!element) return;
        if (element.classList.contains('shape-element')) {
          selectShape(element);
          return;
        }
        if (element.classList.contains('chart-element')) {
          selectChart(element);
          return;
        }
        if (element.classList.contains('image-element')) {
          selectImage(element);
          return;
        }
        if (element.classList.contains('video-element')) {
          selectVideo(element);
          return;
        }
        if (element.classList.contains('table-element')) {
          selectTableElement(element);
          return;
        }
        if (element.classList.contains('additional-text-box') || element.id === 'titleBox' || element.id === 'textBox') {
          selectTextBox(element);
        }
      }

      function ensureGroupSelectionFrame() {
        if (groupSelectionState.frame && groupSelectionState.frame.parentElement) {
          return groupSelectionState.frame;
        }
        const frame = document.createElement('div');
        frame.className = 'group-selection-frame';
        const handles = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
        handles.forEach((handle) => {
          const node = document.createElement('div');
          node.className = 'group-selection-handle';
          node.dataset.handle = handle;
          frame.appendChild(node);
        });
        canvas.appendChild(frame);
        frame.addEventListener('pointerdown', handleGroupFramePointerDown);
        Array.from(frame.querySelectorAll('.group-selection-handle')).forEach((handle) => {
          handle.addEventListener('pointerdown', handleGroupFramePointerDown);
        });
        groupSelectionState.frame = frame;
        groupSelectionState.handles = Array.from(frame.querySelectorAll('.group-selection-handle'));
        return frame;
      }

      function updateGroupSelectionFrame(bounds) {
        if (!bounds || !canvas) return;
        const frame = ensureGroupSelectionFrame();
        frame.style.left = `${bounds.left}px`;
        frame.style.top = `${bounds.top}px`;
        frame.style.width = `${bounds.width}px`;
        frame.style.height = `${bounds.height}px`;
      }

      function setGroupSelection(elements) {
        clearGroupSelection();
        const uniqueElements = Array.from(new Set(elements.filter(Boolean)));
        if (!uniqueElements.length) {
          return;
        }
        if (uniqueElements.length === 1) {
          clearAllSingleSelections();
          selectElementByType(uniqueElements[0]);
          return;
        }
        clearAllSingleSelections();
        hideRotationHandle();
        const boundsList = uniqueElements.map((element) => getElementCanvasBounds(element));
        const selectionBounds = boundsList.reduce((acc, bounds) => ({
          left: Math.min(acc.left, bounds.left),
          top: Math.min(acc.top, bounds.top),
          right: Math.max(acc.right, bounds.right),
          bottom: Math.max(acc.bottom, bounds.bottom)
        }), {
          left: boundsList[0].left,
          top: boundsList[0].top,
          right: boundsList[0].right,
          bottom: boundsList[0].bottom
        });
        selectionBounds.width = selectionBounds.right - selectionBounds.left;
        selectionBounds.height = selectionBounds.bottom - selectionBounds.top;
        uniqueElements.forEach((element) => {
          element.classList.add('group-selected');
        });
        groupSelectionState.elements = uniqueElements;
        groupSelectionState.metrics = uniqueElements.map((element, index) => {
          const bounds = boundsList[index];
          const baseWidth = selectionBounds.width || 1;
          const baseHeight = selectionBounds.height || 1;
          const minWidth = Number.parseFloat(element.dataset?.minWidth || element.style.minWidth || '0') || 0;
          const minHeight = Number.parseFloat(element.dataset?.minHeight || element.style.minHeight || '0') || 0;
          return {
            element,
            bounds,
            relLeft: (bounds.left - selectionBounds.left) / baseWidth,
            relTop: (bounds.top - selectionBounds.top) / baseHeight,
            relWidth: bounds.width / baseWidth,
            relHeight: bounds.height / baseHeight,
            minWidth,
            minHeight
          };
        });
        const minGroupWidth = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relWidth <= 0) return acc;
          const required = metric.minWidth / Math.max(metric.relWidth, 0.0001);
          return Math.max(acc, required);
        }, 20);
        const minGroupHeight = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relHeight <= 0) return acc;
          const required = metric.minHeight / Math.max(metric.relHeight, 0.0001);
          return Math.max(acc, required);
        }, 20);
        groupSelectionState.bounds = selectionBounds;
        groupSelectionState.minGroupWidth = minGroupWidth;
        groupSelectionState.minGroupHeight = minGroupHeight;
        groupSelectionState.pendingBounds = selectionBounds;
        updateGroupSelectionFrame(selectionBounds);
        updateElementContextMenuState();
      }

      function handleCanvasPointerDown(event) {
        if (!canvas || isPresenting) return;
        if (event.button !== 0) return;
        const pointerTarget = event.target;
        if (pointerTarget.closest('.group-selection-frame') || pointerTarget.closest('.group-selection-handle')) {
          return;
        }
        const interactiveTarget = pointerTarget.closest(CANVAS_INTERACTIVE_SELECTOR);
        if (interactiveTarget && interactiveTarget !== canvas) {
          if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
            clearGroupSelection();
          }
          return;
        }
        beginMarqueeSelection(event);
      }

      function beginMarqueeSelection(event) {
        const container = canvasWrap || canvas.parentElement || document.body;
        const containerRect = container.getBoundingClientRect();
        const overlay = document.createElement('div');
        overlay.className = 'canvas-marquee';
        container.appendChild(overlay);
        marqueeState = {
          pointerId: event.pointerId,
          startClient: { x: event.clientX, y: event.clientY },
          startCanvas: getCanvasPointFromClient(event.clientX, event.clientY),
          overlay,
          containerRect
        };
        container.setPointerCapture?.(event.pointerId);
        document.addEventListener('pointermove', handleMarqueePointerMove);
        document.addEventListener('pointerup', handleMarqueePointerUp);
        document.addEventListener('pointercancel', handleMarqueePointerUp);
        event.preventDefault();
      }

      function handleMarqueePointerMove(event) {
        if (!marqueeState || event.pointerId !== marqueeState.pointerId) return;
        const current = { x: event.clientX, y: event.clientY };
        const { startClient, overlay, containerRect } = marqueeState;
        const left = Math.min(startClient.x, current.x) - containerRect.left;
        const top = Math.min(startClient.y, current.y) - containerRect.top;
        const width = Math.abs(current.x - startClient.x);
        const height = Math.abs(current.y - startClient.y);
        overlay.style.left = `${left}px`;
        overlay.style.top = `${top}px`;
        overlay.style.width = `${width}px`;
        overlay.style.height = `${height}px`;
      }

      function handleMarqueePointerUp(event) {
        if (!marqueeState || event.pointerId !== marqueeState.pointerId) return;
        const { overlay, startClient, startCanvas } = marqueeState;
        const container = canvasWrap || canvas.parentElement || document.body;
        container.releasePointerCapture?.(event.pointerId);
        overlay.remove();
        document.removeEventListener('pointermove', handleMarqueePointerMove);
        document.removeEventListener('pointerup', handleMarqueePointerUp);
        document.removeEventListener('pointercancel', handleMarqueePointerUp);
        const distance = Math.hypot(event.clientX - startClient.x, event.clientY - startClient.y);
        marqueeState = null;
        if (distance < MARQUEE_MIN_SIZE) {
          clearGroupSelection();
          clearAllSingleSelections();
          hideRotationHandle();
          updateElementContextMenuState();
          return;
        }
        const endCanvas = getCanvasPointFromClient(event.clientX, event.clientY);
        const rect = {
          left: Math.min(startCanvas.x, endCanvas.x),
          top: Math.min(startCanvas.y, endCanvas.y),
          right: Math.max(startCanvas.x, endCanvas.x),
          bottom: Math.max(startCanvas.y, endCanvas.y)
        };
        const selected = collectGroupSelectableElements().filter((element) => {
          const bounds = getElementCanvasBounds(element);
          return !(bounds.right < rect.left || bounds.left > rect.right || bounds.bottom < rect.top || bounds.top > rect.bottom);
        });
        if (!selected.length) {
          clearGroupSelection();
          clearAllSingleSelections();
          hideRotationHandle();
          updateElementContextMenuState();
          return;
        }
        setGroupSelection(selected);
      }

      function handleGroupFramePointerDown(event) {
        if (!groupSelectionState.elements.length) return;
        if (event.button !== 0) return;
        event.preventDefault();
        event.stopPropagation();
        const handleNode = event.target.closest('.group-selection-handle');
        const mode = handleNode ? 'resize' : 'move';
        const pointerId = event.pointerId;
        const startCanvas = getCanvasPointFromClient(event.clientX, event.clientY);
        const baseBounds = { ...groupSelectionState.bounds };
        const baseMetrics = groupSelectionState.metrics.map((metric) => ({
          element: metric.element,
          left: metric.bounds.left,
          top: metric.bounds.top,
          width: metric.bounds.width,
          height: metric.bounds.height,
          minWidth: metric.minWidth,
          minHeight: metric.minHeight,
          relLeft: metric.relLeft,
          relTop: metric.relTop,
          relWidth: metric.relWidth,
          relHeight: metric.relHeight
        }));
        groupSelectionState.dragState = {
          pointerId,
          mode,
          handle: handleNode ? handleNode.dataset.handle : null,
          startCanvas,
          baseBounds,
          baseMetrics
        };
        groupSelectionState.pendingBounds = baseBounds;
        document.addEventListener('pointermove', handleGroupPointerMove);
        document.addEventListener('pointerup', handleGroupPointerUp);
        document.addEventListener('pointercancel', handleGroupPointerUp);
        event.target.setPointerCapture?.(pointerId);
      }

      function handleGroupPointerMove(event) {
        const dragState = groupSelectionState.dragState;
        if (!dragState || event.pointerId !== dragState.pointerId) return;
        const current = getCanvasPointFromClient(event.clientX, event.clientY);
        const deltaX = current.x - dragState.startCanvas.x;
        const deltaY = current.y - dragState.startCanvas.y;
        if (dragState.mode === 'move') {
          applyGroupMove(deltaX, deltaY, dragState);
        } else if (dragState.mode === 'resize') {
          applyGroupResize(deltaX, deltaY, dragState);
        }
      }

      function applyGroupMove(deltaX, deltaY, dragState) {
        const { baseBounds, baseMetrics } = dragState;
        const newBounds = {
          left: baseBounds.left + deltaX,
          top: baseBounds.top + deltaY,
          width: baseBounds.width,
          height: baseBounds.height
        };
        updateGroupSelectionFrame(newBounds);
        groupSelectionState.elements.forEach((element, index) => {
          const metric = baseMetrics[index];
          const newLeft = metric.left + deltaX;
          const newTop = metric.top + deltaY;
          element.style.left = `${newLeft}px`;
          element.style.top = `${newTop}px`;
        });
        groupSelectionState.pendingBounds = newBounds;
      }

      function applyGroupResize(deltaX, deltaY, dragState) {
        const { baseBounds, baseMetrics, handle } = dragState;
        let newLeft = baseBounds.left;
        let newTop = baseBounds.top;
        let newWidth = baseBounds.width;
        let newHeight = baseBounds.height;
        if (handle === 'top' || handle === 'top-left' || handle === 'top-right') {
          newTop = baseBounds.top + deltaY;
          newHeight = baseBounds.height - deltaY;
        }
        if (handle === 'bottom' || handle === 'bottom-left' || handle === 'bottom-right') {
          newHeight = baseBounds.height + deltaY;
        }
        if (handle === 'left' || handle === 'top-left' || handle === 'bottom-left') {
          newLeft = baseBounds.left + deltaX;
          newWidth = baseBounds.width - deltaX;
        }
        if (handle === 'right' || handle === 'top-right' || handle === 'bottom-right') {
          newWidth = baseBounds.width + deltaX;
        }
        const minWidth = groupSelectionState.minGroupWidth || 20;
        const minHeight = groupSelectionState.minGroupHeight || 20;
        if (newWidth < minWidth) {
          if (handle === 'left' || handle === 'top-left' || handle === 'bottom-left') {
            newLeft = baseBounds.left + (baseBounds.width - minWidth);
          }
          newWidth = minWidth;
        }
        if (newHeight < minHeight) {
          if (handle === 'top' || handle === 'top-left' || handle === 'top-right') {
            newTop = baseBounds.top + (baseBounds.height - minHeight);
          }
          newHeight = minHeight;
        }
        if (newWidth <= 0 || newHeight <= 0) {
          return;
        }
        const newBounds = {
          left: newLeft,
          top: newTop,
          width: newWidth,
          height: newHeight
        };
        updateGroupSelectionFrame(newBounds);
        groupSelectionState.elements.forEach((element, index) => {
          const metric = baseMetrics[index];
          const relLeft = metric.relLeft;
          const relTop = metric.relTop;
          const relWidth = metric.relWidth;
          const relHeight = metric.relHeight;
          const desiredWidth = relWidth * newWidth;
          const desiredHeight = relHeight * newHeight;
          const elementLeft = newLeft + relLeft * newWidth;
          const elementTop = newTop + relTop * newHeight;
          element.style.left = `${elementLeft}px`;
          element.style.top = `${elementTop}px`;
          if (Number.isFinite(desiredWidth) && desiredWidth > 0) {
            const adjustedWidth = Math.max(metric.minWidth || 0, desiredWidth);
            element.style.width = `${adjustedWidth}px`;
          }
          if (Number.isFinite(desiredHeight) && desiredHeight > 0) {
            const adjustedHeight = Math.max(metric.minHeight || 0, desiredHeight);
            element.style.height = `${adjustedHeight}px`;
          }
        });
        groupSelectionState.pendingBounds = newBounds;
      }

      function handleGroupPointerUp(event) {
        const dragState = groupSelectionState.dragState;
        if (!dragState || event.pointerId !== dragState.pointerId) return;
        event.target.releasePointerCapture?.(dragState.pointerId);
        document.removeEventListener('pointermove', handleGroupPointerMove);
        document.removeEventListener('pointerup', handleGroupPointerUp);
        document.removeEventListener('pointercancel', handleGroupPointerUp);
        const finalBounds = groupSelectionState.pendingBounds || groupSelectionState.bounds;
        groupSelectionState.bounds = finalBounds;
        groupSelectionState.metrics = groupSelectionState.elements.map((element) => {
          const bounds = getElementCanvasBounds(element);
          const baseWidth = finalBounds.width || 1;
          const baseHeight = finalBounds.height || 1;
          const minWidth = Number.parseFloat(element.dataset?.minWidth || element.style.minWidth || '0') || 0;
          const minHeight = Number.parseFloat(element.dataset?.minHeight || element.style.minHeight || '0') || 0;
          return {
            element,
            bounds,
            relLeft: (bounds.left - finalBounds.left) / baseWidth,
            relTop: (bounds.top - finalBounds.top) / baseHeight,
            relWidth: bounds.width / baseWidth,
            relHeight: bounds.height / baseHeight,
            minWidth,
            minHeight
          };
        });
        const minGroupWidth = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relWidth <= 0) return acc;
          const required = metric.minWidth / Math.max(metric.relWidth, 0.0001);
          return Math.max(acc, required);
        }, 20);
        const minGroupHeight = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relHeight <= 0) return acc;
          const required = metric.minHeight / Math.max(metric.relHeight, 0.0001);
          return Math.max(acc, required);
        }, 20);
        groupSelectionState.minGroupWidth = minGroupWidth;
        groupSelectionState.minGroupHeight = minGroupHeight;
        groupSelectionState.dragState = null;
        groupSelectionState.pendingBounds = null;
        groupSelectionState.elements.forEach((element) => {
          createResizeEdges(element);
        });
        const action = dragState.mode === 'move' ? 'group_move' : 'group_resize';
        capture();
        renderSidebar();
        saveEditorState(action);
      }

      function positionShapeDropdown() {
        if (!shapePickerButton) return;
        shapeDropdown.style.top = '0px';
        shapeDropdown.style.left = '0px';
        shapeDropdown.classList.add('show');
        const buttonRect = shapePickerButton.getBoundingClientRect();
        const dropdownRect = shapeDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        shapeDropdown.style.top = `${Math.max(16, top)}px`;
        shapeDropdown.style.left = `${left}px`;
      }

      function showShapeDropdown() {
        if (!shapePickerButton) return;
        positionShapeDropdown();
        isShapeDropdownVisible = true;
        shapeDropdown.classList.add('show');
        shapePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideShapeDropdown() {
        shapeDropdown.classList.remove('show');
        isShapeDropdownVisible = false;
        if (shapePickerButton) {
          shapePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleShapeDropdown() {
        if (isShapeDropdownVisible) {
          hideShapeDropdown();
        } else {
          showShapeDropdown();
        }
      }

      function positionChartDropdown() {
        if (!chartPickerButton) return;
        chartDropdown.style.top = '0px';
        chartDropdown.style.left = '0px';
        chartDropdown.classList.add('show');
        const buttonRect = chartPickerButton.getBoundingClientRect();
        const dropdownRect = chartDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        chartDropdown.style.top = `${Math.max(16, top)}px`;
        chartDropdown.style.left = `${left}px`;
      }

      function showChartDropdown() {
        if (!chartPickerButton) return;
        positionChartDropdown();
        isChartDropdownVisible = true;
        chartDropdown.classList.add('show');
        chartPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideChartDropdown() {
        chartDropdown.classList.remove('show');
        isChartDropdownVisible = false;
        if (chartPickerButton) {
          chartPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleChartDropdown() {
        if (isChartDropdownVisible) {
          hideChartDropdown();
        } else {
          showChartDropdown();
        }
      }

      if (shapePickerButton) {
        shapePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleShapeDropdown();
        });
      }

      if (chartPickerButton) {
        chartPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleChartDropdown();
        });
      }

      if (imagePickerButton && imageFileInput) {
        imagePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          imageFileInput.value = '';
          imageFileInput.click();
        });
        imageFileInput.addEventListener('change', (event) => {
          const { files } = event.target;
          if (!files || !files.length) return;
          const file = files[0];
          if (!file.type || !file.type.startsWith('image/')) {
            alert('Please select a valid image file.');
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            insertImageFromDataUrl(reader.result);
          };
          reader.onerror = () => {
            alert('Unable to read the selected image.');
          };
          reader.readAsDataURL(file);
        });
      }

      if (videoPickerButton && videoFileInput) {
        videoPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          videoFileInput.value = '';
          videoFileInput.click();
        });
        videoFileInput.addEventListener('change', (event) => {
          const { files } = event.target;
          if (!files || !files.length) return;
          const file = files[0];
          if (!file.type || !file.type.startsWith('video/')) {
            alert('Please select a valid video file.');
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            insertVideoFromDataUrl(reader.result);
          };
          reader.onerror = () => {
            alert('Unable to read the selected video.');
          };
          reader.readAsDataURL(file);
        });
      }

      function positionTableInsertPanel() {
        if (!tablePickerButton) return;
        if (tablePanelDragState.isDragging) return;
        tableInsertPanel.classList.add('show');
        if (tablePanelManualPosition) {
          const { left, top } = clampTablePanelPosition(tablePanelManualPosition.left, tablePanelManualPosition.top);
          tableInsertPanel.style.top = `${top}px`;
          tableInsertPanel.style.left = `${left}px`;
          tablePanelManualPosition = { left, top };
          return;
        }
        tableInsertPanel.style.top = '0px';
        tableInsertPanel.style.left = '0px';
        const buttonRect = tablePickerButton.getBoundingClientRect();
        const panelRect = tableInsertPanel.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + panelRect.height > window.innerHeight - 16) {
          top = buttonRect.top - panelRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - panelRect.height - 16);
        }
        if (left + panelRect.width > window.innerWidth - 16) {
          left = window.innerWidth - panelRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        const clamped = clampTablePanelPosition(left, Math.max(16, top));
        tableInsertPanel.style.top = `${clamped.top}px`;
        tableInsertPanel.style.left = `${clamped.left}px`;
      }

      function showTableInsertPanel() {
        if (!tablePickerButton) return;
        positionTableInsertPanel();
        isTablePanelVisible = true;
        tablePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideTableInsertPanel() {
        tableInsertPanel.classList.remove('show');
        isTablePanelVisible = false;
        if (tablePickerButton) {
          tablePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleTableInsertPanel() {
        if (isTablePanelVisible) {
          hideTableInsertPanel();
        } else {
          showTableInsertPanel();
        }
      }

      if (tablePickerButton) {
        tablePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleTableInsertPanel();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isShapeDropdownVisible) return;
        if (shapeDropdown.contains(event.target) || (shapePickerButton && shapePickerButton.contains(event.target))) {
          return;
        }
        hideShapeDropdown();
      });

      document.addEventListener('click', (event) => {
        if (!isChartDropdownVisible) return;
        if (chartDropdown.contains(event.target) || (chartPickerButton && chartPickerButton.contains(event.target))) {
          return;
        }
        hideChartDropdown();
      });

      document.addEventListener('click', (event) => {
        if (!isTablePanelVisible) return;
        if (tableInsertPanel.contains(event.target) || (tablePickerButton && tablePickerButton.contains(event.target))) {
          return;
        }
        hideTableInsertPanel();
      });

      window.addEventListener('resize', () => {
        if (isShapeDropdownVisible) {
          positionShapeDropdown();
        }
        if (isChartDropdownVisible) {
          positionChartDropdown();
        }
        if (isTablePanelVisible) {
          positionTableInsertPanel();
        }
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget) {
          positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        }
      });

      window.addEventListener('scroll', (event) => {
        if (isShapeDropdownVisible && !shapeDropdown.contains(event.target)) {
          hideShapeDropdown();
        }
        if (isChartDropdownVisible && !chartDropdown.contains(event.target)) {
          hideChartDropdown();
        }
        if (isTablePanelVisible && !tableInsertPanel.contains(event.target)) {
          hideTableInsertPanel();
        }
      }, true);

      window.addEventListener('scroll', () => {
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (isChartDropdownVisible) {
          positionChartDropdown();
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
        if (isTablePanelVisible) {
          positionTableInsertPanel();
        }
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget) {
          positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        }
      }, true);

      function clearShapeSelection() {
        if (selectedShape) {
          const removedId = selectedShape.dataset.elementId;
          selectedShape.classList.remove('selected');
          selectedShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
        hideShapeColorPicker();
        hideShapeSizeBadge();
        hideRotationHandle();
        activeResizeShape = null;
      }

      function clearChartSelection() {
        if (selectedChart) {
          const removedId = selectedChart.dataset.elementId;
          selectedChart.classList.remove('selected');
          if (rotationTarget === selectedChart) {
            hideRotationHandle();
          }
          selectedChart = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
        hideChartDataEditor();
      }

      function clearImageSelection() {
        if (selectedImage) {
          const removedId = selectedImage.dataset.elementId;
          selectedImage.classList.remove('selected');
          if (rotationTarget === selectedImage) {
            hideRotationHandle();
          }
          selectedImage = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
      }

      function clearVideoSelection() {
        if (selectedVideo) {
          const removedId = selectedVideo.dataset.elementId;
          selectedVideo.classList.remove('selected');
          if (rotationTarget === selectedVideo) {
            hideRotationHandle();
          }
          selectedVideo = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
      }

      function clearSelectedTableElement() {
        if (selectedTable) {
          const removedId = selectedTable.dataset.elementId;
          clearTableSelection(selectedTable);
          selectedTable.classList.remove('selected');
          selectedTable = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
        if (rotationTarget && rotationTarget.classList && rotationTarget.classList.contains('table-element')) {
          hideRotationHandle();
        }
        hideTableColumnColorPicker(true);
        clearChartSelection();
        clearVideoSelection();
      }

      function selectShape(element) {
        if (!element || !element.classList.contains('shape-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        if (selectedShape && selectedShape !== element) {
          selectedShape.classList.remove('selected');
        }
        selectedShape = element;
        element.classList.add('selected');
        showShapeColorPicker(element);
        handleAnimationSelectionChange(element);

        setTimeout(() => {
          document.addEventListener('click', function shapeDeselectHandler(e) {
            if (!element.contains(e.target)) {
              if (selectedShape === element) {
                clearShapeSelection();
              }
              document.removeEventListener('click', shapeDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteShape(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedShape === element) {
          selectedShape = null;
          hideShapeColorPicker();
          hideRotationHandle();
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_shape');
        updateElementContextMenuState();
      }

      function deleteChart(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedChart === element) {
          selectedChart = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        if (activeChartDataElement === element) {
          hideChartDataEditor();
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_chart');
        updateElementContextMenuState();
      }

      function selectChart(element) {
        if (!element || !element.classList.contains('chart-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        if (selectedChart && selectedChart !== element) {
          selectedChart.classList.remove('selected');
        }
        clearShapeSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        selectedChart = element;
        element.classList.add('selected');
        showChartDataEditor(element);
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function chartDeselectHandler(event) {
            if (!element.contains(event.target) && !event.target.closest('#chartDataEditor')) {
              if (selectedChart === element) {
                clearChartSelection();
              }
              document.removeEventListener('click', chartDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function selectImage(element) {
        if (!element || !element.classList.contains('image-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearShapeSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        if (selectedImage && selectedImage !== element) {
          selectedImage.classList.remove('selected');
        }
        selectedImage = element;
        element.classList.add('selected');
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function imageDeselectHandler(event) {
            if (!element.contains(event.target)) {
              if (selectedImage === element) {
                clearImageSelection();
              }
              document.removeEventListener('click', imageDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteImage(element, options = {}) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        const { skipCapture = false, skipHistory = false } = options;
        if (selectedImage === element) {
          selectedImage = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        if (!skipCapture) {
          capture();
        }
        if (!skipHistory) {
          saveEditorState('delete_image');
        }
        updateElementContextMenuState();
      }

      function selectVideo(element) {
        if (!element || !element.classList.contains('video-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearShapeSelection();
        clearImageSelection();
        clearSelectedTableElement();
        if (selectedVideo && selectedVideo !== element) {
          selectedVideo.classList.remove('selected');
        }
        selectedVideo = element;
        element.classList.add('selected');
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function videoDeselectHandler(event) {
            if (!element.contains(event.target)) {
              if (selectedVideo === element) {
                clearVideoSelection();
              }
              document.removeEventListener('click', videoDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteVideo(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedVideo === element) {
          selectedVideo = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        const video = element.querySelector('video');
        if (video) {
          video.pause();
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_video');
        updateElementContextMenuState();
      }

      function selectTableElement(element) {
        if (!element || !element.classList.contains('table-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearShapeSelection();
        clearImageSelection();
        clearChartSelection();
        if (selectedTable && selectedTable !== element) {
          clearTableSelection(selectedTable);
          selectedTable.classList.remove('selected');
          if (rotationTarget === selectedTable) {
            hideRotationHandle();
          }
        }
        selectedTable = element;
        element.classList.add('selected');
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function tableDeselectHandler(event) {
            if (!element.contains(event.target) && event.target !== element) {
              if (selectedTable === element) {
                clearSelectedTableElement();
              }
              document.removeEventListener('click', tableDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteTable(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedTable === element) {
          selectedTable = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
        }
        if (tableColumnColorTarget === element) {
          hideTableColumnColorPicker(true);
        }
        clearTableSelection(element);
        teardownTableResizing(element);
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_table');
        updateElementContextMenuState();
      }

      function renderShapeSvg(shape) {
        const strokeWidth = typeof shape.strokeWidth === 'number' ? shape.strokeWidth : 0;
        return `
          <svg class="shape-svg" viewBox="${shape.viewBox}" preserveAspectRatio="none">
            <g class="shape-geometry" fill="currentColor" stroke="currentColor"
               stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round">
              ${shape.svg}
            </g>
          </svg>
        `;
      }

      function escapeHtml(value) {
        if (value == null) return '';
        return String(value).replace(/[&<>"']/g, (char) => {
          switch (char) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            case "'": return '&#39;';
            default: return char;
          }
        });
      }

      function normalizeNumberArray(value, fallback = []) {
        if (Array.isArray(value)) {
          return value
            .map((num) => Number(num))
            .filter((num) => Number.isFinite(num));
        }
        if (typeof value === 'string' && value.trim()) {
          try {
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) {
              return parsed
                .map((num) => Number(num))
                .filter((num) => Number.isFinite(num));
            }
          } catch (error) {
            // ignore
          }
        }
        return Array.isArray(fallback)
          ? fallback.map((num) => Number(num)).filter((num) => Number.isFinite(num))
          : [];
      }

      function normalizeChartLegend(value, fallback = []) {
        let source = fallback;
        if (Array.isArray(value)) {
          source = value;
        } else if (typeof value === 'string' && value.trim()) {
          try {
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) {
              source = parsed;
            }
          } catch (error) {
            source = fallback;
          }
        }
        return (Array.isArray(source) ? source : [])
          .map((item) => ({
            label: typeof item?.label === 'string' ? item.label : '',
            color: item?.color || '#60a5fa'
          }));
      }

      function renderChartLegendHtml(legend, values = [], { showValues = false } = {}) {
        if (!Array.isArray(legend) || !legend.length) return '';
        const items = legend.map((item, index) => {
          const swatchColor = normalizeColorHex(item.color || '#60a5fa');
          const swatch = `<span class="chart-legend-swatch" style="background:${escapeHtml(swatchColor)};"></span>`;
          const label = escapeHtml(item.label || '');
          let valueMarkup = '';
          if (showValues && Array.isArray(values)) {
            const value = values[index];
            const numericValue = Number(value);
            const displayValue = Number.isFinite(numericValue) ? numericValue.toString() : (value != null ? String(value) : '');
            if (displayValue) {
              valueMarkup = ` <span class="chart-legend-value">${escapeHtml(displayValue)}</span>`;
            }
          }
          return `
          <div class="chart-legend-item">
            ${swatch}
            ${label}${valueMarkup}
          </div>`;
        }).join('');
        return `<div class="chart-legend">${items}</div>`;
      }

      function normalizeLineCategories(value, fallback = [], desiredLength = 0) {
        let categories = normalizeChartLegend(value, fallback);
        const baseFallback = Array.isArray(fallback) ? fallback : [];
        if (desiredLength > 0) {
          if (categories.length > desiredLength) {
            categories = categories.slice(0, desiredLength);
          }
          while (categories.length < desiredLength) {
            const index = categories.length;
            const fallbackItem = baseFallback[index] || {};
            categories.push({
              label: typeof fallbackItem.label === 'string' && fallbackItem.label.trim()
                ? fallbackItem.label.trim()
                : `Point ${index + 1}`,
              color: normalizeColorHex(
                fallbackItem.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
              )
            });
          }
        }
        return categories;
      }

      function adjustNumberArrayLength(values, desiredLength, fallbackValues = []) {
        if (!Number.isFinite(desiredLength) || desiredLength <= 0) {
          return values.slice();
        }
        const result = values.slice(0, desiredLength);
        const fallbackArray = Array.isArray(fallbackValues) ? fallbackValues : [];
        while (result.length < desiredLength) {
          const fallbackValue = Number(fallbackArray[result.length]);
          if (Number.isFinite(fallbackValue)) {
            result.push(fallbackValue);
          } else if (result.length) {
            result.push(result[result.length - 1]);
          } else {
            result.push(0);
          }
        }
        return result;
      }

      function normalizeLineSeries(value, fallback = [], pointCount = 0) {
        let source = value;
        if (typeof source === 'string' && source.trim()) {
          try {
            const parsed = JSON.parse(source);
            if (Array.isArray(parsed)) {
              source = parsed;
            }
          } catch (error) {
            source = [];
          }
        }
        if (!Array.isArray(source) || !source.length) {
          source = Array.isArray(fallback) ? fallback : [];
        }
        const fallbackArray = Array.isArray(fallback) ? fallback : [];
        const length = Math.max(Array.isArray(source) ? source.length : 0, 1);
        const normalized = [];
        for (let index = 0; index < length; index += 1) {
          const baseItem = Array.isArray(source) ? source[index] : null;
          const fallbackItem = fallbackArray[index] || {};
          const baseLabel = typeof baseItem?.label === 'string' && baseItem.label.trim()
            ? baseItem.label.trim()
            : '';
          const fallbackLabel = typeof fallbackItem.label === 'string' && fallbackItem.label.trim()
            ? fallbackItem.label.trim()
            : `Line ${index + 1}`;
          const label = baseLabel || fallbackLabel;
          const color = normalizeColorHex(
            baseItem?.color
            || fallbackItem.color
            || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
          );
          const rawValues = Array.isArray(baseItem?.values) && baseItem.values.length
            ? baseItem.values
            : (Array.isArray(fallbackItem.values) ? fallbackItem.values : []);
          const numericValues = rawValues
            .map((num) => {
              const parsed = Number(num);
              return Number.isFinite(parsed) ? parsed : 0;
            });
          const adjustedValues = pointCount > 0
            ? adjustNumberArrayLength(numericValues, pointCount, fallbackItem.values || [])
            : numericValues.slice();
          normalized.push({
            label,
            color,
            values: adjustedValues
          });
        }
        if (!normalized.length) {
          const defaultLength = pointCount > 0 ? pointCount : 1;
          normalized.push({
            label: 'Line 1',
            color: normalizeColorHex(CHART_COLOR_SEQUENCE[0]),
            values: Array.from({ length: defaultLength }, () => 50)
          });
        }
        return normalized;
      }

      function getLineChartState(element, chartConfig, { ensureDataset = false } = {}) {
        if (!element) {
          return { categories: [], series: [] };
        }
        const fallbackCategories = chartConfig?.legend || [];
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        const legacyPoints = normalizeNumberArray(element.dataset.points, chartConfig?.points || []);
        let pointCount = 0;
        let categories = normalizeLineCategories(element.dataset.legend, fallbackCategories);
        pointCount = categories.length;
        if (!pointCount) {
          pointCount = fallbackSeries[0]?.values?.length
            || legacyPoints.length
            || (chartConfig?.points?.length || 5);
        }
        categories = normalizeLineCategories(element.dataset.legend, fallbackCategories, pointCount);
        let series = normalizeLineSeries(element.dataset.lineSeries, fallbackSeries, pointCount);
        if (!series.length && legacyPoints.length) {
          const fallbackColor = fallbackSeries[0]?.color
            || fallbackCategories[0]?.color
            || CHART_COLOR_SEQUENCE[0];
          series = normalizeLineSeries(
            [{
              label: fallbackSeries[0]?.label || 'Line 1',
              color: fallbackColor,
              values: legacyPoints
            }],
            fallbackSeries,
            pointCount
          );
        }
        if (!series.length) {
          series = normalizeLineSeries(fallbackSeries, fallbackSeries, pointCount);
        }
        const normalizedCategories = normalizeLineCategories(categories, fallbackCategories, pointCount);
        const normalizedSeries = normalizeLineSeries(series, fallbackSeries, pointCount);
        if (ensureDataset && (!element.dataset.lineSeries || !element.dataset.lineSeries.length)) {
          setLineChartState(element, chartConfig, {
            categories: normalizedCategories,
            series: normalizedSeries,
            title: element.dataset.title || '',
            showValues: element.dataset.showValues === 'true'
          });
        }
        return {
          categories: normalizedCategories,
          series: normalizedSeries
        };
      }

      function setLineChartState(element, chartConfig, state = {}) {
        if (!element) return;
        const fallbackCategories = chartConfig?.legend || [];
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        const categoriesInput = Array.isArray(state.categories) ? state.categories : [];
        const seriesInput = Array.isArray(state.series) ? state.series : [];
        const inferredLength = Math.max(
          categoriesInput.length,
          seriesInput.reduce((max, series) => Math.max(max, Array.isArray(series?.values) ? series.values.length : 0), 0),
          1
        );
        const normalizedCategories = normalizeLineCategories(categoriesInput, fallbackCategories, inferredLength);
        const normalizedSeries = normalizeLineSeries(seriesInput, fallbackSeries, inferredLength);
        element.dataset.legend = JSON.stringify(normalizedCategories);
        element.dataset.lineSeries = JSON.stringify(normalizedSeries);
        delete element.dataset.points;
        delete element.dataset.bars;
        delete element.dataset.slices;
        if (typeof state.title === 'string') {
          element.dataset.title = state.title;
        }
        if (typeof state.showValues === 'boolean') {
          element.dataset.showValues = state.showValues ? 'true' : 'false';
        }
        const payload = {
          legend: normalizedCategories,
          lineSeries: normalizedSeries,
          title: element.dataset.title || chartConfig?.name || 'Chart',
          showValues: element.dataset.showValues === 'true'
        };
        element.innerHTML = renderChartMarkup(chartConfig, payload);
        createResizeEdges(element);
      }

      function buildPieGradient(slices, legend) {
        const colors = (Array.isArray(legend) && legend.length
          ? legend.map((item) => item.color || '#60a5fa')
          : ['#60a5fa', '#34d399', '#f97316', '#fbbf24']);
        const validSlices = (Array.isArray(slices) && slices.length ? slices : [1, 1, 1])
          .map((value) => Math.max(0, Number(value) || 0));
        const total = validSlices.reduce((sum, value) => sum + value, 0) || 1;
        let start = 0;
        const segments = validSlices.map((value, index) => {
          const angle = (value / total) * 360;
          const end = start + angle;
          const color = colors[index % colors.length];
          const segment = `${color} ${start}deg ${end}deg`;
          start = end;
          return segment;
        });
        return `conic-gradient(${segments.join(', ')})`;
      }

      function renderChartMarkup(chart, data = {}) {
        const legend = normalizeChartLegend(data.legend, chart.legend || []);
        const title = escapeHtml(data.title || chart.name || 'Chart');
        const chartType = chart.type || chart.id;
        const showValues = Boolean(data.showValues);
        if (chartType === 'bar') {
          const bars = normalizeNumberArray(data.bars, chart.bars || [60, 80, 50]);
          const maxBar = Math.max(...bars, 1);
          const colors = legend.length ? legend.map((item) => item.color || '#60a5fa') : ['#60a5fa', '#34d399', '#fbbf24', '#f97316'];
          const variantClass = chart.variant ? ` chart-bars--${chart.variant}` : '';
          const barsHtml = bars.map((value, index) => {
            const heightPercent = Math.max(8, Math.min(100, (value / maxBar) * 100));
            const color = escapeHtml(colors[index % colors.length]);
            let barStyle = `height:${heightPercent}%;`;
            if (chart.variant === 'gradient') {
              barStyle += `background: linear-gradient(180deg, rgba(255,255,255,0.35) 0%, rgba(0,0,0,0.12) 100%), ${color};`;
            } else {
              barStyle += `background:${color};`;
            }
            if (chart.variant === 'rounded') {
              barStyle += 'border-radius:16px 16px 6px 6px;';
            } else {
              barStyle += 'border-radius:10px 10px 4px 4px;';
            }
            if (showValues) {
              const numericValue = Number(value);
              const displayValue = Number.isFinite(numericValue) ? numericValue.toString() : (value != null ? String(value) : '');
              const valueBadge = displayValue ? `<span class="chart-bar-value">${escapeHtml(displayValue)}</span>` : '';
              return `
                <div class="chart-bar-wrapper">
                  <div class="chart-bar" style="${barStyle}"></div>
                  ${valueBadge}
                </div>
              `;
            }
            return `<div class="chart-bar" style="${barStyle}"></div>`;
          }).join('');
          return `
            <div class="chart-title">${title}</div>
            <div class="chart-visual">
              <div class="chart-bars${variantClass}">
                ${barsHtml}
              </div>
            </div>
            ${renderChartLegendHtml(legend, bars, { showValues })}
          `;
        }
        if (chartType === 'line') {
          const width = 240;
          const height = 140;
          const paddingX = 24;
          const paddingY = 16;
          const innerWidth = width - paddingX * 2;
          const innerHeight = height - paddingY * 2;
          const fallbackSeries = Array.isArray(chart.series) ? chart.series : [];
          const legacyPoints = normalizeNumberArray(data.points, chart.points || []);
          let categories = normalizeChartLegend(data.legend, chart.legend || []);
          let pointCount = categories.length;
          if (!pointCount) {
            pointCount = fallbackSeries[0]?.values?.length
              || legacyPoints.length
              || (chart.points?.length || 5);
          }
          let lineSeries = normalizeLineSeries(data.lineSeries, fallbackSeries, pointCount);
          if (!lineSeries.length && legacyPoints.length) {
            const fallbackColor = fallbackSeries[0]?.color || categories[0]?.color || CHART_COLOR_SEQUENCE[0];
            lineSeries = normalizeLineSeries(
              [{
                label: fallbackSeries[0]?.label || 'Line 1',
                color: fallbackColor,
                values: legacyPoints
              }],
              fallbackSeries,
              pointCount
            );
          }
          if (!lineSeries.length) {
            lineSeries = normalizeLineSeries(fallbackSeries, fallbackSeries, pointCount);
          }
          const finalPointCount = Math.max(
            pointCount,
            lineSeries.reduce((max, series) => Math.max(max, Array.isArray(series.values) ? series.values.length : 0), 0),
            1
          );
          const normalizedCategories = normalizeLineCategories(categories, chart.legend || [], finalPointCount);
          const normalizedSeries = normalizeLineSeries(lineSeries, fallbackSeries, finalPointCount);
          const xCoords = [];
          for (let index = 0; index < finalPointCount; index += 1) {
            const x = paddingX + (finalPointCount <= 1
              ? innerWidth / 2
              : (innerWidth / Math.max(finalPointCount - 1, 1)) * index);
            xCoords.push(x);
          }
          const allValues = normalizedSeries.reduce((acc, series) => {
            if (Array.isArray(series.values)) {
              series.values.forEach((value) => {
                const numeric = Number(value);
                if (Number.isFinite(numeric)) {
                  acc.push(numeric);
                }
              });
            }
            return acc;
          }, []);
          const maxValue = allValues.length ? Math.max(...allValues, 1) : 1;
          const minValue = allValues.length ? Math.min(...allValues, 0) : 0;
          const range = Math.max(maxValue - minValue, 1);
          const pathClass = chart.variant === 'dotted'
            ? 'chart-line-path line-dotted'
            : (chart.variant === 'smooth' ? 'chart-line-path line-smooth' : 'chart-line-path');
          const seriesPaths = [];
          const seriesPoints = [];
          const seriesBadges = [];
          normalizedSeries.forEach((series, seriesIndex) => {
            const color = normalizeColorHex(series.color || CHART_COLOR_SEQUENCE[seriesIndex % CHART_COLOR_SEQUENCE.length]);
            const coords = (Array.isArray(series.values) ? series.values : []).map((value, pointIndex) => {
              const numericValue = Number(value);
              const safeValue = Number.isFinite(numericValue) ? numericValue : 0;
              const x = xCoords[pointIndex] ?? xCoords[xCoords.length - 1] ?? paddingX;
              const y = paddingY + innerHeight - ((safeValue - minValue) / range) * innerHeight;
              return { x, y, value: safeValue };
            });
            if (coords.length) {
              let pathD = '';
              coords.forEach((point, index) => {
                pathD += index === 0 ? `M ${point.x} ${point.y}` : ` L ${point.x} ${point.y}`;
              });
              seriesPaths.push(`<path class="${pathClass}" d="${pathD}" stroke="${escapeHtml(color)}"></path>`);
              seriesPoints.push(coords.map((point) => (
                `<circle class="chart-line-point" cx="${point.x}" cy="${point.y}" r="5" fill="${escapeHtml(color)}"></circle>`
              )).join(''));
              if (showValues) {
                seriesBadges.push(coords.map((point) => (
                  `<span class="chart-line-value" style="left:${point.x}px; top:${point.y}px; transform: translate(-50%, calc(-120% - ${seriesIndex * 14}px));">${escapeHtml(String(point.value))}</span>`
                )).join(''));
              }
            }
          });
          const axisLabels = normalizedCategories.map((item, index) => {
            const x = xCoords[index] ?? xCoords[xCoords.length - 1] ?? paddingX;
            return `<span class="chart-line-axis-label" style="left:${x}px;">${escapeHtml(item.label || `Point ${index + 1}`)}</span>`;
          }).join('');
          const axisMarkup = `<div class="chart-line-axis">${axisLabels}</div>`;
          const valueBadgesMarkup = showValues ? seriesBadges.join('') : '';
          return `
            <div class="chart-title">${title}</div>
            <div class="chart-visual">
              <div class="chart-line-wrapper">
                <svg class="chart-line-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                  ${seriesPaths.join('')}
                  ${seriesPoints.join('')}
                </svg>
                ${axisMarkup}
                ${valueBadgesMarkup}
              </div>
            </div>
            ${renderChartLegendHtml(normalizedSeries)}
          `;
        }
        const slices = normalizeNumberArray(data.slices, chart.slices || [40, 35, 25]);
        const positiveSlices = slices.map((value) => Math.max(0, Number(value) || 0));
        const totalSlices = positiveSlices.reduce((sum, value) => sum + value, 0);
        const gradient = buildPieGradient(slices, legend);
        const variantClass = chart.variant ? ` chart-pie--${chart.variant}` : '';
        let pieMarkup;
        if (showValues && totalSlices > 0) {
          let cumulative = 0;
          const radius = 70;
          const innerRadius = chart.variant === 'donut' ? radius * 0.75 : radius * 0.6;
          const labels = positiveSlices.map((value, index) => {
            if (value <= 0) return '';
            const startAngle = cumulative / totalSlices * Math.PI * 2;
            const sliceAngle = value / totalSlices * Math.PI * 2;
            cumulative += value;
            const midAngle = startAngle + sliceAngle / 2;
            const labelRadius = chart.variant === 'donut' ? (radius + innerRadius) / 2 : radius * 0.65;
            let x = radius + Math.cos(midAngle) * labelRadius;
            let y = radius + Math.sin(midAngle) * labelRadius;
            const padding = 14;
            x = Math.min(Math.max(padding, x), radius * 2 - padding);
            y = Math.min(Math.max(padding, y), radius * 2 - padding);
            const numericValue = Number(slices[index]);
            const displayValue = Number.isFinite(numericValue) ? numericValue.toString() : (slices[index] != null ? String(slices[index]) : value.toString());
            return `<span class="chart-pie-label" style="left:${x}px; top:${y}px;">${escapeHtml(displayValue)}</span>`;
          }).join('');
          pieMarkup = `
            <div class="chart-pie-wrapper">
              <div class="chart-pie${variantClass}" style="background:${gradient};"></div>
              <div class="chart-pie-labels">${labels}</div>
            </div>
          `;
        } else {
          pieMarkup = `<div class="chart-pie${variantClass}" style="background:${gradient};"></div>`;
        }
        return `
          <div class="chart-title">${title}</div>
          <div class="chart-visual">
            ${pieMarkup}
          </div>
          ${renderChartLegendHtml(legend, slices, { showValues })}
        `;
      }

      function createChartElement(chart, options = {}) {
        if (!chart) return null;
        const element = document.createElement('div');
        element.className = 'chart-element';
        const elementId = options.id || generateElementId('chart');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        element.dataset.chartType = chart.id;
        if (chart.variant) {
          element.dataset.chartVariant = chart.variant;
        } else {
          delete element.dataset.chartVariant;
        }

        const minWidth = options.minWidth || chart.minWidth || 220;
        const minHeight = options.minHeight || chart.minHeight || 160;
        element.dataset.minWidth = String(minWidth);
        element.dataset.minHeight = String(minHeight);

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;

        const parsedWidth = Number(options.width);
        const parsedHeight = Number(options.height);
        const width = Number.isFinite(parsedWidth) && parsedWidth > 0 ? parsedWidth : chart.defaultWidth || 320;
        const height = Number.isFinite(parsedHeight) && parsedHeight > 0 ? parsedHeight : chart.defaultHeight || 220;
        const actualWidth = Math.max(minWidth, width);
        const actualHeight = Math.max(minHeight, height);
        element.style.width = `${actualWidth}px`;
        element.style.height = `${actualHeight}px`;

        const parsedLeft = Number(options.left);
        const parsedTop = Number(options.top);
        const left = Number.isFinite(parsedLeft) ? parsedLeft : (canvasWidth - actualWidth) / 2;
        const top = Number.isFinite(parsedTop) ? parsedTop : (canvasHeight - actualHeight) / 2;

        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        const rotation = Number.isFinite(Number(options.rotation)) ? Number(options.rotation) : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;

        const legend = normalizeChartLegend(options.legend, chart.legend || []);
        const chartType = chart.type || chart.id;
        const bars = chartType === 'bar' ? normalizeNumberArray(options.bars, chart.bars || []) : [];
        const slices = chartType === 'pie' ? normalizeNumberArray(options.slices, chart.slices || []) : [];
        let lineSeries = [];
        if (chartType === 'line') {
          const fallbackSeries = Array.isArray(chart.series) ? chart.series : [];
          const legacyPoints = normalizeNumberArray(options.points, chart.points || []);
          const pointCount = Math.max(
            legend.length,
            legacyPoints.length,
            fallbackSeries.reduce((max, series) => Math.max(max, Array.isArray(series?.values) ? series.values.length : 0), 0),
            1
          );
          if (Array.isArray(options.lineSeries) && options.lineSeries.length) {
            lineSeries = normalizeLineSeries(options.lineSeries, fallbackSeries, pointCount);
          } else if (legacyPoints.length) {
            const fallbackColor = fallbackSeries[0]?.color || legend[0]?.color || CHART_COLOR_SEQUENCE[0];
            lineSeries = normalizeLineSeries(
              [{
                label: fallbackSeries[0]?.label || 'Line 1',
                color: fallbackColor,
                values: legacyPoints
              }],
              fallbackSeries,
              pointCount
            );
          } else {
            lineSeries = normalizeLineSeries(fallbackSeries, fallbackSeries, pointCount);
          }
          legend.splice(0, legend.length, ...normalizeLineCategories(legend, chart.legend || [], pointCount));
        }
        const chartTitle = typeof options.title === 'string' ? options.title : '';

        element.dataset.legend = JSON.stringify(legend);
        if (chartType === 'bar') {
          element.dataset.bars = JSON.stringify(bars);
        } else if (chartType === 'line') {
          element.dataset.lineSeries = JSON.stringify(lineSeries);
          delete element.dataset.points;
          delete element.dataset.bars;
          delete element.dataset.slices;
        } else {
          element.dataset.slices = JSON.stringify(slices);
          delete element.dataset.bars;
          delete element.dataset.points;
          delete element.dataset.lineSeries;
        }
        element.dataset.title = chartTitle;
        const showValues = options.showValues === true || element.dataset.showValues === 'true';
        element.dataset.showValues = showValues ? 'true' : 'false';

        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '6';
        const payload = {
          legend,
          title: chartTitle,
          showValues
        };
        if (chartType === 'line') {
          payload.lineSeries = lineSeries;
        } else if (chartType === 'bar') {
          payload.bars = bars;
        } else if (chartType === 'pie') {
          payload.slices = slices;
        }
        element.innerHTML = renderChartMarkup(chart, payload);

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectChart(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectChart(element);
        });

        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectChart(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectChart(element);
        }

        return element;
      }

      function instantiateChart(chartData) {
        if (!chartData) return null;
        let chartId = chartData.chartType;
        if ((!chartId || !CHART_OPTION_MAP.has(chartId)) && chartData.chartVariant) {
          chartId = `pie-${chartData.chartVariant}`;
        }
        const chart = getChartOptionById(chartId);
        if (!chart) return null;
        const element = createChartElement(chart, {
          id: chartData.id,
          left: chartData.left,
          top: chartData.top,
          width: chartData.width,
          height: chartData.height,
          rotation: chartData.rotation,
          minWidth: chartData.minWidth,
          minHeight: chartData.minHeight,
          bars: chartData.bars,
          slices: chartData.slices,
          lineSeries: chartData.lineSeries,
          legend: chartData.legend,
          title: chartData.title,
          showValues: chartData.showValues === true || chartData.showValues === 'true',
          zIndex: chartData.zIndex,
          select: false
        });
        return element;
      }

      function insertChart(chartId) {
        const chart = getChartOptionById(chartId);
        if (!chart) return;
        const element = createChartElement(chart, { select: true });
        if (element) {
          capture();
          saveEditorState('add_chart');
        }
      }

      function createShapeElement(shape, options = {}) {
        if (!shape) return null;
        const element = document.createElement('div');
        element.className = 'shape-element';
        const elementId = options.id || generateElementId('shape');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        element.dataset.shape = shape.id;
        const minWidth = options.minWidth || shape.minWidth || 60;
        const minHeight = options.minHeight || shape.minHeight || 60;
        element.dataset.minWidth = String(minWidth);
        element.dataset.minHeight = String(minHeight);
        const color = normalizeColorHex(options.color || shape.defaultColor || '#e8f5e9');
        element.dataset.color = color;
        element.style.color = color;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? options.zIndex : 2;

        const parsedWidth = Number(options.width);
        const parsedHeight = Number(options.height);
        const width = Number.isFinite(parsedWidth) && parsedWidth > 0 ? parsedWidth : (shape.defaultWidth || 160);
        const height = Number.isFinite(parsedHeight) && parsedHeight > 0 ? parsedHeight : (shape.defaultHeight || 140);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        const innerWidth = canvas.clientWidth;
        const innerHeight = canvas.clientHeight;
        const defaultLeft = (innerWidth - width) / 2;
        const defaultTop = (innerHeight - height) / 2;
        const parsedLeft = Number(options.left);
        const parsedTop = Number(options.top);
        const left = Number.isFinite(parsedLeft) ? parsedLeft : defaultLeft;
        const top = Number.isFinite(parsedTop) ? parsedTop : defaultTop;

        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        const rotation = Number.isFinite(Number(options.rotation)) ? Number(options.rotation) : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = renderShapeSvg(shape);
        const svg = element.querySelector('.shape-svg');
        if (svg) {
          svg.style.width = '100%';
          svg.style.height = '100%';
        }

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectShape(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectShape(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectShape(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectShape(element);
        }

        return element;
      }

      function instantiateShape(shapeData) {
        if (!shapeData) return;
        const shape = SHAPE_OPTION_MAP.get(shapeData.shapeId) || SHAPE_OPTIONS[0];
        if (!shape) return;
        const element = createShapeElement(shape, {
          id: shapeData.id,
          left: shapeData.left,
          top: shapeData.top,
          width: shapeData.width,
          height: shapeData.height,
          color: shapeData.color,
          zIndex: shapeData.zIndex,
          minWidth: shapeData.minWidth,
          minHeight: shapeData.minHeight,
          rotation: shapeData.rotation
        });
        if (element && shapeData.color) {
          const normalizedColor = normalizeColorHex(shapeData.color);
          element.dataset.color = normalizedColor;
          element.style.color = normalizedColor;
        }
        return element;
      }

      function insertShape(shapeId) {
        const shape = SHAPE_OPTION_MAP.get(shapeId);
        if (!shape) return;
        const element = createShapeElement(shape, { select: true });
        if (element) {
          capture();
          saveEditorState('add_shape');
        }
      }

      function createImageElement(options = {}) {
        if (!options || !options.src) return null;
        const element = document.createElement('div');
        const shouldAnimate = options.animate !== false;
        element.className = shouldAnimate ? 'image-element image-insert-animation' : 'image-element';
        const elementId = options.id || generateElementId('image');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        const img = document.createElement('img');
        img.src = options.src;
        img.alt = options.alt || 'Slide image';
        img.draggable = false;
        element.appendChild(img);
        const aspectRatio = Number.isFinite(options.aspectRatio)
          ? options.aspectRatio
          : (() => {
              const width = Number(options.width);
              const height = Number(options.height);
              if (Number.isFinite(width) && Number.isFinite(height) && height !== 0) {
                return width / height;
              }
              return 1;
            })();
        const minWidthValue = Number.isFinite(options.minWidth) ? options.minWidth : 80;
        const minHeightValue = Number.isFinite(options.minHeight) ? options.minHeight : Math.max(60, minWidthValue / Math.max(aspectRatio, 0.01));
        element.dataset.aspectRatio = String(aspectRatio || 1);
        element.dataset.minWidth = String(minWidthValue);
        element.dataset.minHeight = String(minHeightValue);
        const rotation = Number.isFinite(options.rotation) ? options.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '4';

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        let width = Number(options.width);
        let height = Number(options.height);
        if (!Number.isFinite(width) || width <= 0) {
          if (Number.isFinite(height) && height > 0) {
            width = height * (aspectRatio || 1);
          } else {
            width = Math.min(canvasWidth - 96, Math.max(240, minWidthValue));
          }
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = width / Math.max(aspectRatio || 1, 0.01);
        }
        width = Math.max(minWidthValue, width);
        height = Math.max(minHeightValue, height);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        let left = Number(options.left);
        let top = Number(options.top);
        if (!Number.isFinite(left)) {
          if (lastCanvasInsertPosition) {
            left = lastCanvasInsertPosition.x - width / 2;
          } else {
            left = (canvasWidth - width) / 2;
          }
        }
        if (!Number.isFinite(top)) {
          if (lastCanvasInsertPosition) {
            top = lastCanvasInsertPosition.y - height / 2;
          } else {
            top = (canvasHeight - height) / 2;
          }
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectImage(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectImage(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectImage(element);
          showElementContextMenu(event, element);
        });

        if (shouldAnimate) {
          setTimeout(() => {
            element.classList.remove('image-insert-animation');
          }, 320);
        }

        if (options.select) {
          selectImage(element);
        }

        return element;
      }

      function instantiateImage(imageData) {
        if (!imageData || !imageData.src) return;
        createImageElement({
          src: imageData.src,
          id: imageData.id,
          left: imageData.left,
          top: imageData.top,
          width: imageData.width,
          height: imageData.height,
          rotation: imageData.rotation,
          minWidth: imageData.minWidth,
          minHeight: imageData.minHeight,
          aspectRatio: imageData.aspectRatio,
          zIndex: imageData.zIndex,
          animate: false
        });
      }

      function insertImageFromDataUrl(dataUrl) {
        if (!dataUrl) return;
        const tempImage = new Image();
        tempImage.onload = () => {
          const intrinsicWidth = tempImage.naturalWidth || tempImage.width || 1;
          const intrinsicHeight = tempImage.naturalHeight || tempImage.height || 1;
          const aspectRatio = intrinsicWidth / intrinsicHeight;
          const maxWidth = canvas.clientWidth - 96;
          const maxHeight = canvas.clientHeight - 96;
          const scale = Math.min(1, maxWidth / intrinsicWidth, maxHeight / intrinsicHeight);
          const width = Math.max(160, intrinsicWidth * scale);
          const height = width / aspectRatio;
          const element = createImageElement({
            src: dataUrl,
            width,
            height,
            aspectRatio,
            minWidth: 80,
            minHeight: 80 / Math.max(aspectRatio, 0.01),
            select: true
          });
          if (element) {
            capture();
            saveEditorState('add_image');
          }
        };
        tempImage.onerror = () => {
          alert('Unable to load the selected image. Please try a different file.');
        };
        tempImage.src = dataUrl;
      }

      function createVideoElement(options = {}) {
        if (!options || !options.src) return null;
        const element = document.createElement('div');
        const shouldAnimate = options.animate !== false;
        element.className = shouldAnimate ? 'video-element image-insert-animation' : 'video-element';
        const elementId = options.id || generateElementId('video');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        const video = document.createElement('video');
        video.src = options.src;
        video.setAttribute('src', options.src);
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.preload = 'metadata';
        video.controls = true;
        video.draggable = false;
        element.appendChild(video);

        const aspectRatio = Number.isFinite(options.aspectRatio)
          ? options.aspectRatio
          : (() => {
              const width = Number(options.width);
              const height = Number(options.height);
              if (Number.isFinite(width) && Number.isFinite(height) && height !== 0) {
                return width / height;
              }
              return 16 / 9;
            })();
        const minWidthValue = Number.isFinite(options.minWidth) ? options.minWidth : 160;
        const minHeightValue = Number.isFinite(options.minHeight) ? options.minHeight : Math.max(90, minWidthValue / Math.max(aspectRatio, 0.01));
        element.dataset.aspectRatio = String(aspectRatio || 1);
        element.dataset.minWidth = String(minWidthValue);
        element.dataset.minHeight = String(minHeightValue);
        const rotation = Number.isFinite(options.rotation) ? options.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '5';

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        let width = Number(options.width);
        let height = Number(options.height);
        if (!Number.isFinite(width) || width <= 0) {
          if (Number.isFinite(height) && height > 0) {
            width = height * (aspectRatio || 1);
          } else {
            width = Math.min(canvasWidth - 120, Math.max(320, minWidthValue));
          }
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = width / Math.max(aspectRatio || 1, 0.01);
        }
        width = Math.max(minWidthValue, width);
        height = Math.max(minHeightValue, height);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        let left = Number(options.left);
        let top = Number(options.top);
        if (!Number.isFinite(left)) {
          if (lastCanvasInsertPosition) {
            left = lastCanvasInsertPosition.x - width / 2;
          } else {
            left = (canvasWidth - width) / 2;
          }
        }
        if (!Number.isFinite(top)) {
          if (lastCanvasInsertPosition) {
            top = lastCanvasInsertPosition.y - height / 2;
          } else {
            top = (canvasHeight - height) / 2;
          }
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          if (event.target === video) return;
          event.stopPropagation();
          selectVideo(element);
        });

        element.addEventListener('click', (event) => {
          if (event.target === video) return;
          event.stopPropagation();
          selectVideo(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectVideo(element);
          showElementContextMenu(event, element);
        });

        video.addEventListener('mousedown', (event) => {
          if (event.button !== 0) return;
          selectVideo(element);
        });
        video.addEventListener('click', (event) => {
          if (event.button !== 0) return;
          selectVideo(element);
        });
        video.addEventListener('dragstart', (event) => {
          event.preventDefault();
        });

        if (shouldAnimate) {
          setTimeout(() => {
            element.classList.remove('image-insert-animation');
          }, 320);
        }

        if (options.select) {
          selectVideo(element);
        }

        return element;
      }

      function instantiateVideo(videoData) {
        if (!videoData || !videoData.src) return;
        createVideoElement({
          src: videoData.src,
          id: videoData.id,
          left: videoData.left,
          top: videoData.top,
          width: videoData.width,
          height: videoData.height,
          rotation: videoData.rotation,
          minWidth: videoData.minWidth,
          minHeight: videoData.minHeight,
          aspectRatio: videoData.aspectRatio,
          zIndex: videoData.zIndex,
          animate: false
        });
      }

      function insertVideoFromDataUrl(dataUrl) {
        if (!dataUrl) return;
        const tempVideo = document.createElement('video');
        tempVideo.preload = 'metadata';
        tempVideo.src = dataUrl;
        tempVideo.addEventListener('loadedmetadata', () => {
          const intrinsicWidth = tempVideo.videoWidth || 640;
          const intrinsicHeight = tempVideo.videoHeight || 360;
          const aspectRatio = intrinsicWidth / Math.max(intrinsicHeight, 0.01);
          const maxWidth = canvas.clientWidth - 96;
          const maxHeight = canvas.clientHeight - 96;
          const scale = Math.min(1, maxWidth / intrinsicWidth, maxHeight / intrinsicHeight);
          const width = Math.max(240, intrinsicWidth * scale);
          const height = width / aspectRatio;
          const element = createVideoElement({
            src: dataUrl,
            width,
            height,
            aspectRatio,
            minWidth: 200,
            minHeight: 120,
            select: true
          });
          if (element) {
            capture();
            saveEditorState('add_video');
          }
        }, { once: true });
        tempVideo.addEventListener('error', () => {
          alert('Unable to load the selected video. Please try a different file.');
        }, { once: true });
      }

      function instantiateTable(tableData) {
        if (!tableData) return;
        const element = createTableElement(
          tableData.rows || 1,
          tableData.cols || 1,
          {
            id: tableData.id,
            width: tableData.width,
            height: tableData.height,
            left: tableData.left,
            top: tableData.top,
            html: tableData.html,
            rotation: tableData.rotation,
            minWidth: tableData.minWidth,
            minHeight: tableData.minHeight,
            zIndex: tableData.zIndex
          }
        );
        if (element) {
          element.dataset.rows = String(tableData.rows || 1);
          element.dataset.cols = String(tableData.cols || 1);
          element.dataset.minWidth = String(tableData.minWidth || 240);
          element.dataset.minHeight = String(tableData.minHeight || 160);
          element.dataset.rotation = String(Number.isFinite(tableData.rotation) ? tableData.rotation : 0);
          element.style.transform = `rotate(${parseFloat(element.dataset.rotation || '0')}deg)`;
        }
        return element;
      }

      function buildTableMarkup(rows, cols) {
        const safeRows = Math.max(1, Math.min(20, rows));
        const safeCols = Math.max(1, Math.min(20, cols));
        let html = '<table>';
        html += '<colgroup>';
        const defaultWidthPercent = 100 / safeCols;
        for (let c = 0; c < safeCols; c += 1) {
          html += `<col style="width:${defaultWidthPercent}%">`;
        }
        html += '</colgroup><tbody>';
        for (let r = 0; r < safeRows; r += 1) {
          html += '<tr>';
          for (let c = 0; c < safeCols; c += 1) {
            html += '<td contenteditable="true"></td>';
          }
          html += '</tr>';
        }
        html += '</tbody></table>';
        return html;
      }

      function setupTableCell(cell, container) {
        if (!cell) return;
        cell.contentEditable = 'true';
        applySpellCheckStateToElement(cell);
        setupFontSizeTracking(cell);
        setupFontFamilyTracking(cell);
        cell.addEventListener('focus', () => {
          currentActiveElement = cell;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
          if (container) {
            selectTableElement(container);
          }
        });
        cell.addEventListener('click', (event) => {
          event.stopPropagation();
          if (container) {
            selectTableElement(container);
          }
        });
      }

      function initializeTableElement(element) {
        if (!element) return;
        const cells = element.querySelectorAll('td, th');
        cells.forEach((cell) => {
          setupTableCell(cell, element);
        });
        ensureTableDragHandle(element);
      }

      function ensureTableDragHandle(element) {
        if (!element || element.querySelector('.table-drag-handle')) return;
        const dragHandle = document.createElement('div');
        dragHandle.className = 'table-drag-handle';
        dragHandle.innerHTML = `<i class="fas fa-arrows-alt"></i>`;
        dragHandle.title = 'Drag table';
        dragHandle.setAttribute('role', 'button');
        dragHandle.setAttribute('tabindex', '0');
        dragHandle.setAttribute('aria-label', 'Drag table');
        dragHandle.addEventListener('pointerdown', () => {
          selectTableElement(element);
        });
        dragHandle.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectTableElement(element);
          }
        });
        element.appendChild(dragHandle);
      }

      function ensureTableColGroup(table) {
        if (!table) return [];
        const firstRow = table.rows[0];
        const columnCount = firstRow ? firstRow.cells.length : 0;
        if (!columnCount) return [];
        let colgroup = table.querySelector('colgroup');
        if (!colgroup) {
          colgroup = document.createElement('colgroup');
          table.insertBefore(colgroup, table.firstChild);
        }
        const currentCols = Array.from(colgroup.children);
        if (currentCols.length !== columnCount) {
          while (colgroup.firstChild) {
            colgroup.removeChild(colgroup.firstChild);
          }
          for (let index = 0; index < columnCount; index += 1) {
            const col = document.createElement('col');
            colgroup.appendChild(col);
          }
        }
        return Array.from(colgroup.children);
      }

      function teardownTableResizing(container) {
        if (!container) return;
        container.querySelectorAll('.table-resize-handle').forEach((handle) => handle.remove());
        const resizeObserver = tableResizeObservers.get(container);
        if (resizeObserver) {
          resizeObserver.disconnect();
          tableResizeObservers.delete(container);
        }
        const mutationObserver = tableMutationObservers.get(container);
        if (mutationObserver) {
          mutationObserver.disconnect();
          tableMutationObservers.delete(container);
        }
        unbindTableColumnHover(container);
      }

      function scheduleTableResizeUpdate(container) {
        if (!container) return;
        if (container.__tableResizePending) return;
        container.__tableResizePending = true;
        requestAnimationFrame(() => {
          container.__tableResizePending = false;
          setupTableResizing(container);
        });
      }

      function positionTableResizeHandles(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table) return;
        const containerRect = container.getBoundingClientRect();
        const tableRect = table.getBoundingClientRect();
        const rows = table.rows;
        if (!rows.length) return;
        
        // Position column resize handles
        const colHandles = container.querySelectorAll('.table-resize-handle.table-resize-col');
        if (colHandles.length > 0) {
          const referenceRow = rows[0];
          const cells = referenceRow.cells;
          if (cells.length) {
            colHandles.forEach((handle) => {
              const columnIndex = parseInt(handle.dataset.col, 10);
              const cell = cells[columnIndex];
              if (!cell) return;
              const cellRect = cell.getBoundingClientRect();
              const boundaryLeft = cellRect.right - containerRect.left;
              handle.style.left = `${boundaryLeft}px`;
              handle.style.top = `${tableRect.top - containerRect.top}px`;
              handle.style.height = `${tableRect.height}px`;
            });
          }
        }
        
        // Position row resize handles
        const rowHandles = container.querySelectorAll('.table-resize-handle.table-resize-row');
        if (rowHandles.length > 0) {
          rowHandles.forEach((handle) => {
            const rowIndex = parseInt(handle.dataset.row, 10);
            const row = rows[rowIndex];
            if (!row) return;
            const rowRect = row.getBoundingClientRect();
            const boundaryTop = rowRect.bottom - containerRect.top;
            handle.style.top = `${boundaryTop}px`;
            handle.style.left = `${tableRect.left - containerRect.left}px`;
            handle.style.width = `${tableRect.width}px`;
          });
        }
        
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget === container) {
          positionTableColumnColorPicker(container, tableColumnColorIndex);
        }
      }

      function updateAllTableResizeHandles() {
        document.querySelectorAll('.table-element').forEach((tableEl) => {
          positionTableResizeHandles(tableEl);
        });
      }

      function setupTableResizing(container) {
        if (!container) return;
        teardownTableResizing(container);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        const columnCount = rows[0].cells.length;
        if (!columnCount) return;
        ensureTableColGroup(table);
        // Create column resize handles
        if (columnCount >= 2) {
          for (let index = 0; index < columnCount - 1; index += 1) {
            const handle = document.createElement('div');
            handle.className = 'table-resize-handle table-resize-col';
            handle.dataset.col = String(index);
            handle.addEventListener('mousedown', (event) => {
              startTableColumnResize(event, container, index);
            });
            container.appendChild(handle);
          }
        }
        // Create row resize handles
        if (rows.length >= 2) {
          for (let index = 0; index < rows.length - 1; index += 1) {
            const handle = document.createElement('div');
            handle.className = 'table-resize-handle table-resize-row';
            handle.dataset.row = String(index);
            handle.addEventListener('mousedown', (event) => {
              startTableRowResize(event, container, index);
            });
            container.appendChild(handle);
          }
        }
        positionTableResizeHandles(container);
        const resizeObserver = new ResizeObserver(() => {
          positionTableResizeHandles(container);
        });
        resizeObserver.observe(container);
        tableResizeObservers.set(container, resizeObserver);
        const mutationObserver = new MutationObserver(() => {
          scheduleTableResizeUpdate(container);
        });
        mutationObserver.observe(table, { childList: true, subtree: true });
        tableMutationObservers.set(container, mutationObserver);
        bindTableColumnHover(container);
        ensureTableSelectionHandlers(container);
      }

      function startTableColumnResize(event, container, columnIndex) {
        event.preventDefault();
        event.stopPropagation();
        hideTableColumnColorPicker(true);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        ensureTableColGroup(table);
        const colgroup = table.querySelector('colgroup');
        if (!colgroup) return;
        const columns = Array.from(colgroup.children);
        if (columns.length <= columnIndex + 1) return;
        const firstRow = rows[0];
        const zoom = getCanvasZoom();
        const widths = Array.from(firstRow.cells).map((cell, idx) => {
          const rect = cell.getBoundingClientRect();
          const width = rect.width / zoom;
          columns[idx].style.width = `${width}px`;
          return width;
        });
        activeTableResize = {
          container,
          table,
          columns,
          columnIndex,
          nextIndex: columnIndex + 1,
          initialWidths: widths,
          startX: event.clientX,
          type: 'column'
        };
        container.classList.add('table-resizing');
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', handleTableResizeMove);
        document.addEventListener('mouseup', handleTableResizeEnd, { once: true });
      }

      function handleTableResizeMove(event) {
        if (!activeTableResize) return;
        const { type } = activeTableResize;
        const zoom = getCanvasZoom();
        
        if (type === 'row') {
          const {
            container,
            rows,
            rowIndex,
            nextIndex,
            initialHeights,
            startY
          } = activeTableResize;
          const delta = (event.clientY - startY) / zoom;
          const currentHeight = initialHeights[rowIndex];
          const neighborHeight = initialHeights[nextIndex];
          const minDelta = TABLE_MIN_ROW_HEIGHT - currentHeight;
          const maxDelta = neighborHeight - TABLE_MIN_ROW_HEIGHT;
          const clampedDelta = Math.max(minDelta, Math.min(delta, maxDelta));
          const newHeight = currentHeight + clampedDelta;
          const newNeighborHeight = neighborHeight - clampedDelta;
          rows[rowIndex].style.height = `${newHeight}px`;
          rows[nextIndex].style.height = `${newNeighborHeight}px`;
        } else {
          const {
            container,
            columns,
            columnIndex,
            nextIndex,
            initialWidths,
            startX
          } = activeTableResize;
          const delta = (event.clientX - startX) / zoom;
          const currentWidth = initialWidths[columnIndex];
          const neighborWidth = initialWidths[nextIndex];
          const minDelta = TABLE_MIN_COLUMN_WIDTH - currentWidth;
          const maxDelta = neighborWidth - TABLE_MIN_COLUMN_WIDTH;
          const clampedDelta = Math.max(minDelta, Math.min(delta, maxDelta));
          const newWidth = currentWidth + clampedDelta;
          const newNeighborWidth = neighborWidth - clampedDelta;
          columns[columnIndex].style.width = `${newWidth}px`;
          columns[nextIndex].style.width = `${newNeighborWidth}px`;
        }
        positionTableResizeHandles(activeTableResize.container);
      }

      function handleTableResizeEnd() {
        if (!activeTableResize) return;
        document.removeEventListener('mousemove', handleTableResizeMove);
        document.body.style.cursor = '';
        const { container, type } = activeTableResize;
        container.classList.remove('table-resizing');
        positionTableResizeHandles(container);
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget === container) {
          positionTableColumnColorPicker(container, tableColumnColorIndex);
        }
        const actionType = type === 'row' ? 'resize_table_row' : 'resize_table_column';
        activeTableResize = null;
        capture();
        saveEditorState(actionType);
      }

      function startTableRowResize(event, container, rowIndex) {
        event.preventDefault();
        event.stopPropagation();
        hideTableColumnColorPicker(true);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        if (rows.length <= rowIndex + 1) return;
        const zoom = getCanvasZoom();
        const heights = Array.from(rows).map((row, idx) => {
          const rect = row.getBoundingClientRect();
          const height = rect.height / zoom;
          // Store height in row style if not already set
          if (!row.style.height) {
            row.style.height = `${height}px`;
          }
          return height;
        });
        activeTableResize = {
          container,
          table,
          rows: Array.from(rows),
          rowIndex,
          nextIndex: rowIndex + 1,
          initialHeights: heights,
          startY: event.clientY,
          type: 'row'
        };
        container.classList.add('table-resizing');
        document.body.style.cursor = 'row-resize';
        document.addEventListener('mousemove', handleTableResizeMove);
        document.addEventListener('mouseup', handleTableResizeEnd, { once: true });
      }

      function updateTableColumnColorButtonAppearance(color) {
        tableColumnColorButton.style.background = color;
        const hex = color.replace('#', '');
        const safeHex = hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex;
        const bigint = parseInt(safeHex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        tableColumnColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
        tableColumnColorButton.style.boxShadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
      }

      function hideTableColumnColorPicker(immediate = false) {
        if (!tableColumnColorPicker.classList.contains('visible')) return;
        if (tableColumnColorPickerBusy && !immediate) return;
        const performHide = () => {
          tableColumnColorPicker.classList.remove('visible');
          tableColumnColorTarget = null;
          tableColumnColorIndex = null;
          tableColumnColorPickerBusy = false;
        };
        if (immediate) {
          performHide();
          return;
        }
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
        }
        tableColumnHideTimeout = setTimeout(performHide, 120);
      }

      function showTableColumnColorPicker(container, columnIndex, cell) {
        if (!container || !container.contains(cell)) return;
        tableColumnColorTarget = container;
        tableColumnColorIndex = columnIndex;
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
          tableColumnHideTimeout = null;
        }
        const computed = window.getComputedStyle(cell);
        let color = normalizeColorHex(computed.backgroundColor || cell.style.backgroundColor || '#ecfdf5');
        if (!color || color === '#000000' && computed.backgroundColor === 'rgba(0, 0, 0, 0)') {
          color = '#ecfdf5';
        }
        tableColumnColorInput.value = color;
        updateTableColumnColorButtonAppearance(color);
        tableColumnColorPicker.classList.add('visible');
        positionTableColumnColorPicker(container, columnIndex);
      }

      function positionTableColumnColorPicker(container, columnIndex) {
        if (!tableColumnColorPicker.classList.contains('visible')) return;
        if (!container || columnIndex == null) return;
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        const referenceRow = rows[0];
        const cell = referenceRow.cells[columnIndex];
        if (!cell) return;
        const cellRect = cell.getBoundingClientRect();
        const pickerRect = tableColumnColorPicker.getBoundingClientRect();
        let top = cellRect.top - pickerRect.height - 12;
        let left = cellRect.left + (cellRect.width / 2) - (pickerRect.width / 2);
        if (top < 16) {
          top = cellRect.bottom + 12;
        }
        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }
        tableColumnColorPicker.style.top = `${top}px`;
        tableColumnColorPicker.style.left = `${left}px`;
      }

      function applyColorToTableColumn(container, columnIndex, color, final = true) {
        const table = container.querySelector('table');
        if (!table) return;
        const selectedCells = getTableSelectedCells(container);
        if (selectedCells.length) {
          selectedCells.forEach((cell) => {
            cell.style.backgroundColor = color;
          });
          if (final) {
            capture();
            saveEditorState('color_table_cells');
          }
          return;
        }
        Array.from(table.rows).forEach((row) => {
          const cell = row.cells[columnIndex];
          if (cell) {
            cell.style.backgroundColor = color;
          }
        });
        if (final) {
          capture();
          saveEditorState('color_table_column');
        }
      }

      function bindTableColumnHover(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table || tableColumnHoverHandlers.has(table)) return;
        const moveHandler = (event) => {
          if (activeTableResize) return;
          const cell = event.target.closest('td, th');
          if (!cell || !container.contains(cell)) {
            hideTableColumnColorPicker(true);
            return;
          }
          const columnIndex = cell.cellIndex;
          if (columnIndex === -1) {
            hideTableColumnColorPicker(true);
            return;
          }
          showTableColumnColorPicker(container, columnIndex, cell);
        };
        const leaveHandler = () => {
          hideTableColumnColorPicker();
        };
        table.addEventListener('mousemove', moveHandler);
        table.addEventListener('mouseleave', leaveHandler);
        tableColumnHoverHandlers.set(table, { moveHandler, leaveHandler });
      }

      function unbindTableColumnHover(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table) return;
        const handlers = tableColumnHoverHandlers.get(table);
        if (!handlers) return;
        table.removeEventListener('mousemove', handlers.moveHandler);
        table.removeEventListener('mouseleave', handlers.leaveHandler);
        tableColumnHoverHandlers.delete(table);
      }

      function getCellCoordinates(cell) {
        if (!cell) return null;
        const row = cell.parentElement;
        if (!row) return null;
        const section = row.parentElement;
        if (!section) return null;
        const rowIndex = Array.prototype.indexOf.call(section.children, row);
        const colIndex = cell.cellIndex;
        return { row: rowIndex, col: colIndex };
      }

      function getTableSelectedCells(container) {
        if (!container || !container.__selectedCellsSet) return [];
        return Array.from(container.__selectedCellsSet);
      }

      function setTableSelection(container, cells) {
        if (!container) return;
        const previous = getTableSelectedCells(container);
        previous.forEach((cell) => cell.classList.remove('table-cell-selected'));
        if (!cells || !cells.length) {
          container.__selectedCellsSet = null;
          return;
        }
        const set = new Set();
        cells.forEach((cell) => {
          if (!cell) return;
          cell.classList.add('table-cell-selected');
          set.add(cell);
        });
        container.__selectedCellsSet = set;
      }

      function clearTableSelection(container) {
        setTableSelection(container, null);
      }

      function isEditingTableCell() {
        const active = document.activeElement;
        if (active && active.isContentEditable && active.closest && active.closest('.table-element')) {
          return true;
        }
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          const anchorElement = anchorNode && (anchorNode.nodeType === Node.ELEMENT_NODE ? anchorNode : anchorNode.parentElement);
          if (anchorElement && anchorElement.closest && anchorElement.closest('.table-element') && anchorElement.closest('[contenteditable="true"]')) {
            return true;
          }
        }
        return false;
      }

      function updateTableSelectionRange(container, startCoords, endCoords) {
        if (!container || !startCoords || !endCoords) return;
        const table = container.querySelector('table');
        if (!table) return;
        const minRow = Math.min(startCoords.row, endCoords.row);
        const maxRow = Math.max(startCoords.row, endCoords.row);
        const minCol = Math.min(startCoords.col, endCoords.col);
        const maxCol = Math.max(startCoords.col, endCoords.col);
        const selectedCells = [];
        Array.from(table.rows).forEach((row, rowIndex) => {
          if (rowIndex < minRow || rowIndex > maxRow) return;
          Array.from(row.cells).forEach((cell, colIndex) => {
            if (colIndex >= minCol && colIndex <= maxCol) {
              selectedCells.push(cell);
            }
          });
        });
        setTableSelection(container, selectedCells);
        if (selectedCells.length) {
          selectTableElement(container);
        }
      }

      function ensureTableSelectionHandlers(container) {
        if (!container || container.__tableSelectionBound) return;
        const table = container.querySelector('table');
        if (!table) return;
        table.addEventListener('mousedown', handleTableCellMouseDown);
        container.__tableSelectionBound = true;
      }

      const tableSelectionState = {
        isMouseDown: false,
        table: null,
        anchorCoords: null,
        startCell: null,
        startX: 0,
        startY: 0,
        hasDragged: false
      };

      function handleTableCellMouseDown(event) {
        if (event.button !== 0) return;
        const cell = event.target.closest('td, th');
        if (!cell) return;
        const container = cell.closest('.table-element');
        if (!container) return;
        tableSelectionState.isMouseDown = true;
        tableSelectionState.table = container;
        tableSelectionState.startCell = cell;
        tableSelectionState.anchorCoords = getCellCoordinates(cell);
        tableSelectionState.startX = event.clientX;
        tableSelectionState.startY = event.clientY;
        tableSelectionState.hasDragged = false;
      }

      function handleTableMouseMove(event) {
        if (!tableSelectionState.isMouseDown) return;
        const { table, startX, startY } = tableSelectionState;
        if (!table) return;
        const deltaX = Math.abs(event.clientX - startX);
        const deltaY = Math.abs(event.clientY - startY);
        const threshold = 6;
        if (!tableSelectionState.hasDragged && (deltaX > threshold || deltaY > threshold)) {
          tableSelectionState.hasDragged = true;
        }
        const hoveredElement = document.elementFromPoint(event.clientX, event.clientY);
        const cell = hoveredElement ? hoveredElement.closest('td, th') : null;
        if (!cell || !table.contains(cell)) {
          return;
        }
        const coords = getCellCoordinates(cell);
        if (!coords) return;
        if (tableSelectionState.hasDragged) {
          updateTableSelectionRange(table, tableSelectionState.anchorCoords, coords);
          const selection = window.getSelection();
          if (selection) {
            selection.removeAllRanges();
          }
        }
      }

      function handleTableMouseUp(event) {
        if (!tableSelectionState.isMouseDown) return;
        const { table, startCell, anchorCoords, hasDragged } = tableSelectionState;
        tableSelectionState.isMouseDown = false;
        tableSelectionState.table = null;
        tableSelectionState.startCell = null;
        tableSelectionState.anchorCoords = null;
        tableSelectionState.hasDragged = false;
        if (!table || !startCell) return;
        let cell = event.target.closest ? event.target.closest('td, th') : null;
        if (!cell || !table.contains(cell)) {
          cell = startCell;
        }
        const coords = getCellCoordinates(cell) || anchorCoords;
        if (!coords) return;
        if (!hasDragged) {
          updateTableSelectionRange(table, anchorCoords, coords);
        }
      }

      document.addEventListener('mousemove', handleTableMouseMove);
      document.addEventListener('mouseup', handleTableMouseUp);

      document.addEventListener('mousedown', (event) => {
        const target = event.target;
        if (!target.closest('.table-element') && !target.closest('#tableColumnColorPicker')) {
          document.querySelectorAll('.table-element').forEach((tableEl) => {
            clearTableSelection(tableEl);
          });
          clearSelectedTableElement();
          hideTableColumnColorPicker(true);
        }
        if (!target.closest('.image-element') && !target.closest('#shapeRotationHandle')) {
          clearImageSelection();
        }
        if (!target.closest('.video-element') && !target.closest('#shapeRotationHandle')) {
          clearVideoSelection();
        }
        if (!target.closest('.chart-element') && !target.closest('#shapeRotationHandle') && !target.closest('#chartDataEditor')) {
          clearChartSelection();
        }
      });

      function createTableElement(rows, cols, options = {}) {
        const element = document.createElement('div');
        element.className = 'table-element';
        const elementId = options.id || generateElementId('table');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        element.dataset.rows = String(rows);
        element.dataset.cols = String(cols);
        element.dataset.minWidth = String(options.minWidth || 240);
        element.dataset.minHeight = String(options.minHeight || 160);
        element.dataset.rotation = String(Number.isFinite(options.rotation) ? options.rotation : 0);
        element.style.transform = `rotate(${parseFloat(element.dataset.rotation || '0')}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '3';

        const defaultWidth = options.width || 360;
        const defaultHeight = options.height || 240;
        element.style.width = `${defaultWidth}px`;
        element.style.height = `${defaultHeight}px`;
        element.innerHTML = options.html || buildTableMarkup(rows, cols);

        canvas.appendChild(element);
        initializeTableElement(element);
        ensureTableSelectionHandlers(element);
        setupTableResizing(element);
        clearTableSelection(element);
        const internalTable = element.querySelector('table');
        if (internalTable) {
          const tableRows = internalTable.rows.length || rows;
          const tableCols = internalTable.rows[0] ? internalTable.rows[0].cells.length : cols;
          element.dataset.rows = String(tableRows);
          element.dataset.cols = String(tableCols);
        }

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const initialLeft = options.left !== undefined ? options.left : ((canvasWidth - defaultWidth) / 2);
        const initialTop = options.top !== undefined ? options.top : ((canvasHeight - defaultHeight) / 2);
        element.style.left = `${initialLeft}px`;
        element.style.top = `${initialTop}px`;

        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          if (event.target.closest('td') || event.target.closest('th')) {
            return;
          }
          event.stopPropagation();
          selectTableElement(element);
        });

        element.addEventListener('click', (event) => {
          if (event.target.closest('td') || event.target.closest('th')) {
            return;
          }
          event.stopPropagation();
          selectTableElement(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTableElement(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectTableElement(element);
        }

        return element;
      }

      function insertTable(rows, cols) {
        const safeRows = Math.max(1, Math.min(12, parseInt(rows, 10) || 1));
        const safeCols = Math.max(1, Math.min(12, parseInt(cols, 10) || 1));
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const defaultWidth = Math.min(canvasWidth - 48, safeCols * 120);
        const defaultHeight = Math.min(canvasHeight - 48, safeRows * 80);

        let left = (canvasWidth - defaultWidth) / 2;
        let top = (canvasHeight - defaultHeight) / 2;
        if (lastCanvasInsertPosition) {
          left = lastCanvasInsertPosition.x - defaultWidth / 2;
          top = lastCanvasInsertPosition.y - defaultHeight / 2;
        }

        const tableElement = createTableElement(safeRows, safeCols, {
          width: defaultWidth,
          height: defaultHeight,
          left,
          top,
          select: true
        });
        if (tableElement) {
          selectTableElement(tableElement);
          capture();
          saveEditorState('add_table');
        }
      }

      function handleTableInsert() {
        if (!tableRowsInput || !tableColsInput) return;
        insertTable(tableRowsInput.value, tableColsInput.value);
        hideTableInsertPanel();
      }

      if (tableInsertConfirm) {
        tableInsertConfirm.addEventListener('click', (event) => {
          event.preventDefault();
          handleTableInsert();
        });
      }

      [tableRowsInput, tableColsInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleTableInsert();
          }
        });
      });
      function collectAdditionalTextBoxesData() {
        return Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
          const elementId = ensureElementHasId(box, 'textbox');
          const coords = getElementCanvasCoordinates(box);
          const computed = window.getComputedStyle(box);
          const sanitizedClone = box.cloneNode(true);
          sanitizedClone.querySelectorAll('.animation-order-badge').forEach(badge => badge.remove());
          return {
            id: elementId,
            html: sanitizedClone.innerHTML,
            top: coords.top,
            left: coords.left,
            width: box.offsetWidth,
            height: box.offsetHeight,
            fontSize: box.style.fontSize || computed.fontSize,
            fontFamily: computed.fontFamily,
            display: box.style.display || '',
            rotation: parseFloat(box.dataset.rotation || '0') || 0,
            minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
            minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50),
            backgroundColor: box.style.backgroundColor || '',
            color: box.style.color || '',
            zIndex: box.style.zIndex ? parseInt(box.style.zIndex, 10) : undefined
          };
        });
      }

      function collectTablesData() {
        return Array.from(document.querySelectorAll('.table-element')).map(element => {
          const elementId = ensureElementHasId(element, 'table');
          const table = element.querySelector('table');
          const rowCount = table ? table.rows.length : parseInt(element.dataset.rows || '1', 10) || 1;
          const colCount = table && table.rows[0] ? table.rows[0].cells.length : parseInt(element.dataset.cols || '1', 10) || 1;
          const coords = getElementCanvasCoordinates(element);
          const clone = element.cloneNode(true);
          clone.querySelectorAll('.table-resize-handle').forEach(handle => handle.remove());
          clone.querySelectorAll('.table-cell-selected').forEach(cell => cell.classList.remove('table-cell-selected'));
          clone.querySelectorAll('.animation-order-badge').forEach(badge => badge.remove());
          clone.querySelectorAll('.table-drag-handle').forEach(handle => handle.remove());
          const sanitizedHtml = clone.innerHTML;
          return {
            id: elementId,
            rows: rowCount,
            cols: colCount,
            html: sanitizedHtml,
            left: coords.left,
            top: coords.top,
            width: element.offsetWidth,
            height: element.offsetHeight,
            minWidth: parseFloat(element.dataset.minWidth || '240'),
            minHeight: parseFloat(element.dataset.minHeight || '160'),
            rotation: parseFloat(element.dataset.rotation || '0') || 0,
            zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
          };
        });
      }

      function createAdditionalTextBox(baseOptions = {}) {
        const newTextBox = document.createElement('div');
        newTextBox.className = 'text-box additional-text-box';
        const existingId = baseOptions.id;
        const elementId = existingId || generateElementId('textbox');
        newTextBox.dataset.elementId = elementId;
        if (!baseOptions.id) {
          baseOptions.id = elementId;
        }
        newTextBox.contentEditable = true;
        applySpellCheckStateToElement(newTextBox);
        newTextBox.dataset.placeholder = 'Click to add text';
        newTextBox.style.position = 'absolute';
        newTextBox.style.top = (baseOptions.top !== undefined ? baseOptions.top : (canvas.clientHeight / 2 - 100)) + 'px';
        newTextBox.style.left = (baseOptions.left !== undefined ? baseOptions.left : (canvas.clientWidth / 2 - 150)) + 'px';
        newTextBox.style.width = (baseOptions.width !== undefined ? baseOptions.width : 150) + 'px';
        newTextBox.style.height = (baseOptions.height !== undefined ? baseOptions.height : 40) + 'px';
        const minWidthValue = baseOptions.minWidth !== undefined ? baseOptions.minWidth : 80;
        const minHeightValue = baseOptions.minHeight !== undefined ? baseOptions.minHeight : 30;
        newTextBox.style.minWidth = minWidthValue + 'px';
        newTextBox.style.minHeight = minHeightValue + 'px';
        newTextBox.dataset.minWidth = String(minWidthValue);
        newTextBox.dataset.minHeight = String(minHeightValue);
        newTextBox.style.border = baseOptions.border || '1px dashed transparent';
        newTextBox.style.padding = '10px';
        newTextBox.style.outline = 'none';
        newTextBox.style.overflow = 'visible';
        newTextBox.style.display = 'flex';
        newTextBox.style.alignItems = 'center';
        newTextBox.style.justifyContent = 'flex-start';
        newTextBox.style.textAlign = 'left';
        newTextBox.style.color = baseOptions.color || '#000000';
        const backgroundColor = baseOptions.backgroundColor ?? 'transparent';
        newTextBox.style.backgroundColor = backgroundColor;
        newTextBox.style.fontSize = baseOptions.fontSize || '16px';
        newTextBox.style.fontFamily = baseOptions.fontFamily || DEFAULT_FONT_FAMILY;
        if (baseOptions.display !== undefined) {
          newTextBox.style.display = baseOptions.display;
        }
        const rotation = Number.isFinite(baseOptions.rotation) ? baseOptions.rotation : 0;
        newTextBox.dataset.rotation = String(rotation);
        newTextBox.style.transform = `rotate(${rotation}deg)`;
        if (baseOptions.zIndex !== undefined) {
          newTextBox.style.zIndex = String(baseOptions.zIndex);
        }
        if (baseOptions.html) {
          newTextBox.innerHTML = baseOptions.html;
        }
        const placeholder = newTextBox.dataset.placeholder;
        newTextBox.addEventListener('focus', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        newTextBox.addEventListener('blur', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        canvas.appendChild(newTextBox);
        createResizeEdges(newTextBox);
        makeDraggable(newTextBox);
        makeResizable(newTextBox);
        setupFontSizeTracking(newTextBox);
        setupFontFamilyTracking(newTextBox);
        elementFontSizes.set(newTextBox, parseFloat(newTextBox.style.fontSize) || 16);
        elementFontFamilies.set(newTextBox, newTextBox.style.fontFamily || DEFAULT_FONT_FAMILY);
        newTextBox.addEventListener('click', (e) => {
          if (e.target === newTextBox || !newTextBox.textContent.trim()) {
            selectTextBox(newTextBox);
          }
        });
        newTextBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(newTextBox);
          showElementContextMenu(event, newTextBox);
        });
        return newTextBox;
      }

      function instantiateAdditionalTextBox(boxData) {
        if (!boxData) return;
        createAdditionalTextBox(boxData);
      }

      function collectShapesData() {
        return Array.from(document.querySelectorAll('.shape-element')).map(el => {
          const elementId = ensureElementHasId(el, 'shape');
          const coords = getElementCanvasCoordinates(el);
          return {
            id: elementId,
            shapeId: el.dataset.shape,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            color: normalizeColorHex(el.dataset.color || el.style.color || '#e8f5e9'),
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined,
            minWidth: el.dataset.minWidth ? parseFloat(el.dataset.minWidth) : undefined,
            minHeight: el.dataset.minHeight ? parseFloat(el.dataset.minHeight) : undefined,
            rotation: parseFloat(el.dataset.rotation || '0') || 0
          };
        });
      }

      function collectChartsData() {
        return Array.from(document.querySelectorAll('.chart-element')).map(el => {
          const elementId = ensureElementHasId(el, 'chart');
          const coords = getElementCanvasCoordinates(el);
          const chartType = el.dataset.chartType || 'bar';
          const bars = normalizeNumberArray(el.dataset.bars, []);
          const slices = normalizeNumberArray(el.dataset.slices, []);
          const legend = normalizeChartLegend(el.dataset.legend, []);
          return {
            id: elementId,
            chartType,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation: parseFloat(el.dataset.rotation || '0') || 0,
            minWidth: parseFloat(el.dataset.minWidth || '220'),
            minHeight: parseFloat(el.dataset.minHeight || '160'),
            bars,
            slices,
            legend,
            title: el.dataset.title || '',
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        });
      }

      function collectImagesData() {
        return Array.from(document.querySelectorAll('.image-element')).map(el => {
          const elementId = ensureElementHasId(el, 'image');
          const coords = getElementCanvasCoordinates(el);
          const img = el.querySelector('img');
          const src = img ? img.getAttribute('src') : '';
          if (!src) return null;
          const rotation = parseFloat(el.dataset.rotation || '0') || 0;
          const minWidthValue = parseFloat(el.dataset.minWidth || '80');
          const minHeightValue = parseFloat(el.dataset.minHeight || '60');
          const aspectRatioValue = parseFloat(el.dataset.aspectRatio || (el.offsetWidth / Math.max(el.offsetHeight, 0.01)));
          return {
            id: elementId,
            src,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation,
            minWidth: minWidthValue,
            minHeight: minHeightValue,
            aspectRatio: aspectRatioValue,
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        }).filter(Boolean);
      }

      function collectVideosData() {
        return Array.from(document.querySelectorAll('.video-element')).map(el => {
          const elementId = ensureElementHasId(el, 'video');
          const coords = getElementCanvasCoordinates(el);
          const video = el.querySelector('video');
          const src = video ? video.getAttribute('src') : '';
          if (!src) return null;
          const rotation = parseFloat(el.dataset.rotation || '0') || 0;
          const minWidthValue = parseFloat(el.dataset.minWidth || '160');
          const minHeightValue = parseFloat(el.dataset.minHeight || '90');
          const aspectRatioValue = parseFloat(el.dataset.aspectRatio || (el.offsetWidth / Math.max(el.offsetHeight, 0.01)));
          return {
            id: elementId,
            src,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation,
            minWidth: minWidthValue,
            minHeight: minHeightValue,
            aspectRatio: aspectRatioValue,
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        }).filter(Boolean);
      }

      function ensureSlideAnimations(slide) {
        if (!slide) return [];
        if (!Array.isArray(slide.animations)) {
          slide.animations = [];
        }
        return slide.animations;
      }

      function sortSlideAnimations(slide) {
        const animations = ensureSlideAnimations(slide);
        animations.sort((a, b) => {
          const orderA = Number.isFinite(a?.order) ? a.order : animations.indexOf(a);
          const orderB = Number.isFinite(b?.order) ? b.order : animations.indexOf(b);
          return orderA - orderB;
        });
        animations.forEach((anim, index) => {
          anim.order = index + 1;
        });
        return animations;
      }

      function getSlideElementIdSet(slide) {
        const ids = new Set();
        if (!slide) return ids;
        if (slide.titleBox?.id) ids.add(slide.titleBox.id);
        if (slide.textBox?.id) ids.add(slide.textBox.id);
        if (Array.isArray(slide.additionalTextBoxes)) {
          slide.additionalTextBoxes.forEach(tb => {
            if (tb?.id) ids.add(tb.id);
          });
        }
        if (Array.isArray(slide.shapes)) {
          slide.shapes.forEach(shape => {
            if (shape?.id) ids.add(shape.id);
          });
        }
        if (Array.isArray(slide.charts)) {
          slide.charts.forEach(chart => {
            if (chart?.id) ids.add(chart.id);
          });
        }
        if (Array.isArray(slide.images)) {
          slide.images.forEach(image => {
            if (image?.id) ids.add(image.id);
          });
        }
        if (Array.isArray(slide.tables)) {
          slide.tables.forEach(table => {
            if (table?.id) ids.add(table.id);
          });
        }
        if (Array.isArray(slide.videos)) {
          slide.videos.forEach(video => {
            if (video?.id) ids.add(video.id);
          });
        }
        return ids;
      }

      function pruneSlideAnimations(slide) {
        if (!slide) return;
        const animations = ensureSlideAnimations(slide);
        if (!animations.length) return;
        const validIds = getSlideElementIdSet(slide);
        const filtered = animations.filter(anim => validIds.has(anim.targetId));
        if (filtered.length !== animations.length) {
          slide.animations = filtered;
          sortSlideAnimations(slide);
        }
      }

      function getAnimationEntryByTarget(slide, targetId) {
        const animations = ensureSlideAnimations(slide);
        return animations.find(anim => anim.targetId === targetId);
      }

      function findCanvasElementById(elementId) {
        if (!elementId || !canvas) return null;
        try {
          return canvas.querySelector(`[data-element-id="${escapeSelector(elementId)}"]`);
        } catch (error) {
          return null;
        }
      }

      function describeAnimationTarget(slide, targetId) {
        const descriptor = {
          element: null,
          label: 'Object',
          type: 'object'
        };
        if (!targetId) {
          return descriptor;
        }
        const element = findCanvasElementById(targetId);
        descriptor.element = element;
        if (element) {
          if (element === titleBox) {
            descriptor.label = 'Title';
            descriptor.type = 'title';
            return descriptor;
          }
          if (element === textBox) {
            descriptor.label = 'Body Text';
            descriptor.type = 'body';
            return descriptor;
          }
          if (element.classList.contains('additional-text-box')) {
            const text = truncateText(element.textContent, 28);
            descriptor.label = text ? `Text: ${text}` : 'Text Box';
            descriptor.type = 'textbox';
            return descriptor;
          }
          if (element.classList.contains('shape-element')) {
            const shapeId = element.dataset.shape;
            const shape = SHAPE_OPTION_MAP.get(shapeId);
            descriptor.label = shape ? `Shape: ${shape.name}` : 'Shape';
            descriptor.type = 'shape';
            return descriptor;
          }
          if (element.classList.contains('chart-element')) {
            const chartId = element.dataset.chartType;
            const chart = CHART_OPTION_MAP.get(chartId);
            descriptor.label = chart ? `Chart: ${chart.name}` : 'Chart';
            descriptor.type = 'chart';
            return descriptor;
          }
          if (element.classList.contains('image-element')) {
            descriptor.label = 'Image';
            descriptor.type = 'image';
            return descriptor;
          }
          if (element.classList.contains('video-element')) {
            descriptor.label = 'Video';
            descriptor.type = 'video';
            return descriptor;
          }
          if (element.classList.contains('table-element')) {
            descriptor.label = 'Table';
            descriptor.type = 'table';
            return descriptor;
          }
        }
        if (slide?.titleBox?.id === targetId) {
          descriptor.label = 'Title';
          descriptor.type = 'title';
          return descriptor;
        }
        if (slide?.textBox?.id === targetId) {
          descriptor.label = 'Body Text';
          descriptor.type = 'body';
          return descriptor;
        }
        const additional = slide?.additionalTextBoxes?.find(tb => tb?.id === targetId);
        if (additional) {
          const text = truncateText(additional.html?.replace(/<[^>]+>/g, ' ') || '', 28);
          descriptor.label = text ? `Text: ${text}` : 'Text Box';
          descriptor.type = 'textbox';
          return descriptor;
        }
        const shapeData = slide?.shapes?.find(shape => shape?.id === targetId);
        if (shapeData) {
          const shape = SHAPE_OPTION_MAP.get(shapeData.shapeId);
          descriptor.label = shape ? `Shape: ${shape.name}` : 'Shape';
          descriptor.type = 'shape';
          return descriptor;
        }
        const chartData = slide?.charts?.find(chart => chart?.id === targetId);
        if (chartData) {
          const chart = CHART_OPTION_MAP.get(chartData.chartType);
          descriptor.label = chart ? `Chart: ${chart.name}` : 'Chart';
          descriptor.type = 'chart';
          return descriptor;
        }
        if (slide?.images?.some(image => image?.id === targetId)) {
          descriptor.label = 'Image';
          descriptor.type = 'image';
          return descriptor;
        }
        const tableData = slide?.tables?.find(table => table?.id === targetId);
        if (tableData) {
          if (Number.isFinite(tableData.rows) && Number.isFinite(tableData.cols)) {
            descriptor.label = `Table (${tableData.rows}Ã—${tableData.cols})`;
          } else {
            descriptor.label = 'Table';
          }
          descriptor.type = 'table';
          return descriptor;
        }
        if (slide?.videos?.some(video => video?.id === targetId)) {
          descriptor.label = 'Video';
          descriptor.type = 'video';
          return descriptor;
        }
        return descriptor;
      }

      function clearAnimationBadges() {
        if (!canvas) return;
        canvas.querySelectorAll('.animation-order-badge').forEach((badge) => badge.remove());
      }

      function showAnimationSequencePanel() {
        if (!animationSequenceContainer) return;
        if (isAnimationSequencePanelVisible) return;
        animationSequenceContainer.classList.remove('hidden');
        isAnimationSequencePanelVisible = true;
      }

      function hideAnimationSequencePanel() {
        if (!animationSequenceContainer) return;
        if (!isAnimationSequencePanelVisible) return;
        animationSequenceContainer.classList.add('hidden');
        isAnimationSequencePanelVisible = false;
      }

      function openAnimationSequencePanel(targetId = null) {
        if (animationTabButton && !animationTabButton.classList.contains('active')) {
          animationTabButton.click();
        }
        if (targetId) {
          currentAnimationSelectedElementId = targetId;
        }
        renderAnimationSequenceList();
        if (targetId) {
          const descriptor = describeAnimationTarget(slides[active], targetId);
          if (descriptor.element) {
            handleAnimationSelectionChange(descriptor.element);
          } else {
            const entry = getAnimationEntryByTarget(slides[active], targetId);
            if (entry) {
              animationEffectSelect.value = normalizeAnimationEffect(entry.effect);
              animationDurationInput.value = clampAnimationDuration(entry.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1);
            }
            highlightAnimationListSelection(targetId);
          }
        }
        showAnimationSequencePanel();
        if (animationSequenceList) {
          animationSequenceList.scrollTop = 0;
        }
      }

      function refreshAnimationBadges() {
        clearAnimationBadges();
        const slide = slides[active];
        if (!slide) return;
        pruneSlideAnimations(slide);
        const animations = sortSlideAnimations(slide);
        animations.forEach((animation) => {
          const element = findCanvasElementById(animation.targetId);
          if (!element) return;
          const badge = document.createElement('button');
          badge.type = 'button';
          badge.className = 'animation-order-badge';
          badge.textContent = animation.order;
          badge.dataset.targetId = animation.targetId;
          badge.setAttribute('aria-label', `Animation order ${animation.order}`);
          badge.tabIndex = -1;
          badge.setAttribute('contenteditable', 'false');
          badge.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            openAnimationSequencePanel(animation.targetId);
          });
          element.appendChild(badge);
        });
      }

      function removeAnimationById(slide, animationId) {
        if (!slide || !animationId) return false;
        const animations = ensureSlideAnimations(slide);
        const index = animations.findIndex(anim => anim.id === animationId);
        if (index === -1) return false;
        animations.splice(index, 1);
        sortSlideAnimations(slide);
        return true;
      }

      function removeAnimationByTargetId(slide, targetId) {
        if (!slide || !targetId) return false;
        const animations = ensureSlideAnimations(slide);
        const initialLength = animations.length;
        slide.animations = animations.filter(anim => anim.targetId !== targetId);
        const removed = slide.animations.length !== initialLength;
        if (removed) {
          sortSlideAnimations(slide);
        }
        return removed;
      }

      function renderAnimationSequenceList() {
        if (!animationSequenceList) return;
        const slide = slides[active];
        pruneSlideAnimations(slide);
        const animations = sortSlideAnimations(slide);
        animationSequenceList.innerHTML = '';
        if (!animations.length) {
          const empty = document.createElement('div');
          empty.className = 'animation-sequence-empty';
          empty.textContent = 'No animations assigned yet';
          animationSequenceList.appendChild(empty);
          clearAnimationBadges();
          return;
        }
        animations.forEach((animation) => {
          const item = document.createElement('div');
          item.className = 'animation-sequence-item';
          item.setAttribute('role', 'listitem');
          item.draggable = true;
          item.dataset.animationId = animation.id;
          item.dataset.targetId = animation.targetId;

          const orderBadge = document.createElement('span');
          orderBadge.className = 'animation-item-order';
          orderBadge.textContent = animation.order;
          item.appendChild(orderBadge);

          const infoWrap = document.createElement('div');
          infoWrap.className = 'animation-item-info';
          const descriptor = describeAnimationTarget(slide, animation.targetId);
          const title = document.createElement('span');
          title.className = 'animation-item-title';
          title.textContent = descriptor.label || 'Object';
          infoWrap.appendChild(title);

          const meta = document.createElement('span');
          meta.className = 'animation-item-meta';
          const effectLabel = ANIMATION_EFFECT_LABEL_MAP.get(animation.effect) || animation.effect;
          const durationLabel = `${(animation.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1)}s`;
          meta.textContent = `${effectLabel} â€¢ ${durationLabel}`;
          infoWrap.appendChild(meta);
          item.appendChild(infoWrap);

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'animation-item-remove';
          removeBtn.setAttribute('title', 'Remove animation');
          removeBtn.innerHTML = '<i class="fas fa-times"></i>';
          removeBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (removeAnimationById(slide, animation.id)) {
              capture();
              saveEditorState('remove_animation');
              renderAnimationSequenceList();
              if (currentAnimationSelectedElementId === animation.targetId) {
                currentAnimationSelectedElementId = null;
              }
              showNotification('Removed animation');
            }
          });
          item.appendChild(removeBtn);

          item.addEventListener('click', () => {
            highlightAnimationListSelection(animation.targetId);
            focusAnimationTarget(animation.targetId);
          });

          item.addEventListener('dragstart', (event) => {
            animationDragState.sourceId = animation.id;
            animationDragState.targetId = null;
            item.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', animation.id);
          });
          item.addEventListener('dragenter', (event) => {
            if (!animationDragState.sourceId || animationDragState.sourceId === animation.id) return;
            event.preventDefault();
            item.classList.add('drop-target');
            animationDragState.targetId = animation.id;
          });
          item.addEventListener('dragover', (event) => {
            if (!animationDragState.sourceId || animationDragState.sourceId === animation.id) return;
            event.preventDefault();
            animationDragState.targetId = animation.id;
          });
          item.addEventListener('dragleave', () => {
            item.classList.remove('drop-target');
            animationDragState.targetId = null;
          });
          item.addEventListener('drop', (event) => {
            event.preventDefault();
            item.classList.remove('drop-target');
            const sourceId = animationDragState.sourceId;
            const targetId = animation.id;
            animationDragState = { sourceId: null, targetId: null };
            if (!sourceId || sourceId === targetId) return;
            ensureSlideAnimations(slide);
            const ordered = sortSlideAnimations(slide);
            const sourceIndex = ordered.findIndex(anim => anim.id === sourceId);
            const targetRect = item.getBoundingClientRect();
            const dropAfter = event.clientY > targetRect.top + targetRect.height / 2;
            if (sourceIndex === -1) return;
            const [moved] = ordered.splice(sourceIndex, 1);
            let insertionIndex = ordered.findIndex(anim => anim.id === targetId);
            if (insertionIndex === -1) {
              ordered.push(moved);
            } else {
              if (dropAfter) {
                insertionIndex += 1;
              }
              if (insertionIndex < 0) insertionIndex = 0;
              if (insertionIndex > ordered.length) insertionIndex = ordered.length;
              ordered.splice(insertionIndex, 0, moved);
            }
            ordered.forEach((anim, idx) => {
              anim.order = idx + 1;
            });
            renderAnimationSequenceList();
            capture();
            saveEditorState('reorder_animation');
          });
          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            animationDragState = { sourceId: null, targetId: null };
          });

          if (currentAnimationSelectedElementId && animation.targetId === currentAnimationSelectedElementId) {
            item.classList.add('selected');
          }

          animationSequenceList.appendChild(item);
        });
        highlightAnimationListSelection(currentAnimationSelectedElementId);
        refreshAnimationBadges();
      }

      function getAnimationIdPrefixForElement(element) {
        if (!element) return 'element';
        if (element === titleBox) return 'title';
        if (element === textBox) return 'body';
        if (element.classList.contains('additional-text-box')) return 'textbox';
        if (element.classList.contains('shape-element')) return 'shape';
        if (element.classList.contains('chart-element')) return 'chart';
        if (element.classList.contains('image-element')) return 'image';
        if (element.classList.contains('video-element')) return 'video';
        if (element.classList.contains('table-element')) return 'table';
        return 'element';
      }

      function highlightAnimationListSelection(targetId) {
        if (!animationSequenceList) return;
        currentAnimationSelectedElementId = targetId || null;
        Array.from(animationSequenceList.children).forEach((child) => {
          if (!(child instanceof HTMLElement)) return;
          if (!child.classList.contains('animation-sequence-item')) return;
          child.classList.toggle('selected', !!targetId && child.dataset.targetId === targetId);
        });
      }

      function focusAnimationTarget(targetId) {
        if (!targetId) return;
        const descriptor = describeAnimationTarget(slides[active], targetId);
        const element = descriptor.element || findCanvasElementById(targetId);
        if (!element) {
          if (descriptor.type === 'title' && titleBox) {
            selectTextBox(titleBox);
          } else if (descriptor.type === 'body' && textBox) {
            selectTextBox(textBox);
          }
          return;
        }
        if (element === titleBox || element === textBox || element.classList.contains('additional-text-box')) {
          selectTextBox(element);
          return;
        }
        if (element.classList.contains('shape-element')) {
          selectShape(element);
          return;
        }
        if (element.classList.contains('chart-element')) {
          selectChart(element);
          return;
        }
        if (element.classList.contains('image-element')) {
          selectImage(element);
          return;
        }
        if (element.classList.contains('video-element')) {
          selectVideo(element);
          return;
        }
        if (element.classList.contains('table-element')) {
          selectTableElement(element);
        }
      }

      function handleAnimationSelectionChange(element) {
        if (!animationEffectSelect || !animationDurationInput) return;
        if (!element) {
          highlightAnimationListSelection(null);
          animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
          animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
          return;
        }
        const prefix = getAnimationIdPrefixForElement(element);
        const targetId = ensureElementHasId(element, prefix);
        highlightAnimationListSelection(targetId);
        const slide = slides[active];
        const entry = getAnimationEntryByTarget(slide, targetId);
        if (entry) {
          animationEffectSelect.value = normalizeAnimationEffect(entry.effect);
          animationDurationInput.value = clampAnimationDuration(entry.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1);
        } else {
          animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
          animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
        }
      }

      function syncAnimationControlsWithSlide() {
        renderAnimationSequenceList();
        const context = getSelectedElementContext();
        if (context?.element) {
          handleAnimationSelectionChange(context.element);
          return;
        }
        if (currentAnimationSelectedElementId) {
          const slide = slides[active];
          const entry = getAnimationEntryByTarget(slide, currentAnimationSelectedElementId);
          if (entry) {
            animationEffectSelect.value = normalizeAnimationEffect(entry.effect);
            animationDurationInput.value = clampAnimationDuration(entry.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1);
            highlightAnimationListSelection(currentAnimationSelectedElementId);
            return;
          }
        }
        highlightAnimationListSelection(null);
        animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
        animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
      }

      function assignAnimationToSelectedElement() {
        if (!animationEffectSelect || !animationDurationInput) return;
        const context = getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('Select an object to animate');
          return;
        }
        const slide = slides[active];
        const element = context.element;
        const prefix = getAnimationIdPrefixForElement(element);
        const targetId = ensureElementHasId(element, prefix);
        const effectValue = normalizeAnimationEffect(animationEffectSelect.value);
        const durationValue = clampAnimationDuration(animationDurationInput.value);
        animationDurationInput.value = durationValue.toFixed(1);

        const animations = ensureSlideAnimations(slide);
        let entry = getAnimationEntryByTarget(slide, targetId);
        const isNew = !entry;
        if (!entry) {
          entry = {
            id: generateElementId('anim'),
            targetId,
            effect: effectValue,
            duration: durationValue,
            order: animations.length + 1
          };
          animations.push(entry);
        } else {
          entry.effect = effectValue;
          entry.duration = durationValue;
        }

        sortSlideAnimations(slide);
        highlightAnimationListSelection(targetId);
        renderAnimationSequenceList();
        handleAnimationSelectionChange(element);
        capture();
        saveEditorState(isNew ? 'add_animation' : 'update_animation');
        showNotification(isNew ? 'Added animation' : 'Updated animation');
      }

      function removeAnimationFromSelection() {
        const slide = slides[active];
        if (!slide) return;
        let targetId = null;
        const context = getSelectedElementContext();
        if (context?.element) {
          targetId = ensureElementHasId(context.element, getAnimationIdPrefixForElement(context.element));
        } else if (currentAnimationSelectedElementId) {
          targetId = currentAnimationSelectedElementId;
        }
        if (!targetId) {
          showNotification('Select an animated object to remove');
          return;
        }
        if (!removeAnimationByTargetId(slide, targetId)) {
          showNotification('No animation assigned to remove');
          return;
        }
        renderAnimationSequenceList();
        highlightAnimationListSelection(null);
        if (context?.element) {
          handleAnimationSelectionChange(context.element);
        } else {
          handleAnimationSelectionChange(null);
        }
        capture();
        saveEditorState('remove_animation');
        showNotification('Removed animation');
      }

      function handleElementAnimationRemoval(elementId) {
        if (!elementId) return;
        const slide = slides[active];
        if (!slide) return;
        if (removeAnimationByTargetId(slide, elementId)) {
          if (currentAnimationSelectedElementId === elementId) {
            highlightAnimationListSelection(null);
          }
          renderAnimationSequenceList();
        }
      }
      
      // Template Background Detection and Application
      (function() {
        // Get template from query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const templateParam = urlParams.get('template');
        
        // Also check sessionStorage for backward compatibility
        const templateFromStorage = sessionStorage.getItem('selectedTemplate');
        const templateName = templateParam || templateFromStorage;
        
        if (templateName) {
          // Map template names to CSS classes
          const templateMap = {
            'marketing': 'marketing-template',
            'business': 'business-template',
            'education': 'education-template',
            'project': 'project-template',
            'business-pro': 'business-template',
            'creative-bold': 'marketing-template',
            'corporate-clean': 'business-template'
          };
          
          const templateClass = templateMap[templateName.toLowerCase()];
          
          if (templateClass) {
            // Remove any existing template classes
            canvas.classList.remove('marketing-template', 'business-template', 'education-template', 'project-template');
            
            // Add the new template class
            canvas.classList.add(templateClass);
          }
        }
      })();
      
      // Track selected text box for keyboard deletion
      let selectedTextBox = null;
      
      // Undo/Redo history stack
      let actionHistory = [];
      let redoStack = [];
      const MAX_HISTORY = 50; // Limit history size
      
      // Save current editor state to history
      function saveEditorState(action) {
        const state = {
          action: action,
          timestamp: Date.now(),
          slides: JSON.parse(JSON.stringify(slides)), // Deep copy
          active: active,
          canvasState: {
            titleBoxVisible: titleBox.style.display !== 'none',
            textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
              const coords = getElementCanvasCoordinates(box);
              return {
                element: box,
                html: box.innerHTML,
                style: {
                  top: coords.top,
                  left: coords.left,
                  width: box.offsetWidth,
                  height: box.offsetHeight,
                  fontSize: box.style.fontSize,
                  fontFamily: window.getComputedStyle(box).fontFamily,
                display: box.style.display,
                rotation: parseFloat(box.dataset.rotation || '0') || 0
                }
              };
            }),
            shapes: collectShapesData(),
            charts: collectChartsData(),
            tables: collectTablesData(),
            images: collectImagesData(),
            videos: collectVideosData()
          }
        };
        
        actionHistory.push(state);
        
        // Limit history size
        if (actionHistory.length > MAX_HISTORY) {
          actionHistory.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update undo button state
        updateUndoButton();
      }
      
      // Restore editor state from history
      function restoreEditorState(state) {
        // Restore slides data
        slides.length = 0;
        slides.push(...JSON.parse(JSON.stringify(state.slides)));
        active = state.active;
        
        // Restore title and text box visibility
        if (state.canvasState) {
          titleBox.style.display = state.canvasState.titleBoxVisible ? '' : 'none';
          textBox.style.display = state.canvasState.textBoxVisible ? '' : 'none';
        }
        
        // Restore slide content
        load();
        renderSidebar();
        
        // Restore additional text boxes
        if (state.canvasState && state.canvasState.additionalTextBoxes) {
          // Remove existing additional text boxes
          document.querySelectorAll('.additional-text-box').forEach(box => {
            if (!state.canvasState.additionalTextBoxes.some(saved => saved.element === box)) {
              box.remove();
            }
          });
          
          // Restore saved additional text boxes
          state.canvasState.additionalTextBoxes.forEach(savedBox => {
            let existingBox = null;
            if (savedBox.element && document.contains(savedBox.element)) {
              existingBox = savedBox.element;
            } else {
              // Create new box if it doesn't exist
              existingBox = document.createElement('div');
              existingBox.className = 'text-box additional-text-box';
              existingBox.contentEditable = true;
              existingBox.dataset.placeholder = 'Click to add text';
              canvas.appendChild(existingBox);
              
              // Setup the new box
              createResizeEdges(existingBox);
              makeDraggable(existingBox);
              makeResizable(existingBox);
              setupFontSizeTracking(existingBox);
              setupFontFamilyTracking(existingBox);
              elementFontSizes.set(existingBox, parseFloat(savedBox.style.fontSize) || 16);
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily || DEFAULT_FONT_FAMILY);
              
              // Add selection handler
              existingBox.addEventListener('click', (e) => {
                if (e.target === existingBox || !existingBox.textContent.trim()) {
                  selectTextBox(existingBox);
                }
              });
            }
            
            // Restore content and style
            existingBox.innerHTML = savedBox.html;
            existingBox.style.top = savedBox.style.top + 'px';
            existingBox.style.left = savedBox.style.left + 'px';
            existingBox.style.width = savedBox.style.width + 'px';
            existingBox.style.height = savedBox.style.height + 'px';
            existingBox.style.fontSize = savedBox.style.fontSize;
            if (savedBox.style.fontFamily) {
              existingBox.style.fontFamily = savedBox.style.fontFamily;
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily);
            }
            existingBox.style.display = savedBox.style.display || '';
            const savedRotation = Number.isFinite(savedBox.style.rotation) ? savedBox.style.rotation : 0;
            existingBox.dataset.rotation = String(savedRotation);
            existingBox.style.transform = `rotate(${savedRotation}deg)`;
            const savedMinWidth = Number.isFinite(savedBox.style.minWidth) ? savedBox.style.minWidth : 200;
            const savedMinHeight = Number.isFinite(savedBox.style.minHeight) ? savedBox.style.minHeight : 50;
            existingBox.dataset.minWidth = String(savedMinWidth);
            existingBox.dataset.minHeight = String(savedMinHeight);
          });
        }

        if (state.canvasState && state.canvasState.shapes) {
          document.querySelectorAll('.shape-element').forEach(shapeEl => shapeEl.remove());
          state.canvasState.shapes.forEach(shapeData => instantiateShape(shapeData));
        }
        document.querySelectorAll('.chart-element').forEach(chartEl => chartEl.remove());
        if (state.canvasState && state.canvasState.charts) {
          state.canvasState.charts.forEach(chartData => instantiateChart(chartData));
        }
        if (state.canvasState && state.canvasState.tables) {
          document.querySelectorAll('.table-element').forEach(tableEl => tableEl.remove());
          state.canvasState.tables.forEach(tableData => instantiateTable(tableData));
        }
        document.querySelectorAll('.image-element').forEach(imageEl => imageEl.remove());
        if (state.canvasState && state.canvasState.images) {
          state.canvasState.images.forEach(imageData => instantiateImage(imageData));
        }
        document.querySelectorAll('.video-element').forEach(videoEl => {
          const vid = videoEl.querySelector('video');
          if (vid) vid.pause();
          videoEl.remove();
        });
        if (state.canvasState && state.canvasState.videos) {
          state.canvasState.videos.forEach(videoData => instantiateVideo(videoData));
        }
        
        updateUndoButton();
        updateSlideCanvasMenuState();
      }
      
      // Undo last action
      function undoLastAction() {
        if (actionHistory.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const coords = getElementCanvasCoordinates(box);
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: coords.top,
                    left: coords.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                  display: box.style.display,
                  rotation: parseFloat(box.dataset.rotation || '0') || 0,
                  minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                  minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData(),
            charts: collectChartsData(),
              tables: collectTablesData(),
              images: collectImagesData(),
              videos: collectVideosData()
            }
          };
          
          // Save current state to redo stack
          redoStack.push(currentState);
          
          // Get previous state from history
          const previousState = actionHistory.pop();
          restoreEditorState(previousState);
        }
      }
      
      // Update undo/redo button states
      function updateUndoButton() {
        const backBtn = document.getElementById('btnBack');
        const forwardBtn = document.getElementById('btnForward');
        if (backBtn) {
          backBtn.disabled = actionHistory.length === 0;
          backBtn.style.opacity = actionHistory.length === 0 ? '0.5' : '1';
        }
        if (forwardBtn) {
          forwardBtn.disabled = redoStack.length === 0;
          forwardBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
        }
      }
      
      // Initialize with initial state
      saveEditorState('initial');

      function clearSlideDragIndicators() {
        sidebar.querySelectorAll('.slide-preview.drop-target, .slide-preview.drop-target-before, .slide-preview.drop-target-after').forEach(preview => {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        });
      }

      function handleSlideDragStart(event) {
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        slideDragSourceIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(slideDragSourceIndex)) {
          slideDragSourceIndex = null;
          return;
        }
        item.classList.add('dragging');
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(slideDragSourceIndex));
        }
      }

      function handleSlideDragOver(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const preview = item.querySelector('.slide-preview');
        if (!preview) return;
        clearSlideDragIndicators();
        preview.classList.add('drop-target');
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        if (isAfter) {
          preview.classList.add('drop-target-after');
          preview.classList.remove('drop-target-before');
        } else {
          preview.classList.add('drop-target-before');
          preview.classList.remove('drop-target-after');
        }
        item.dataset.dropPosition = isAfter ? 'after' : 'before';
      }

      function handleSlideDragLeave(event) {
        const item = event.currentTarget;
        if (!item) return;
        const preview = item.querySelector('.slide-preview');
        if (preview) {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        }
        delete item.dataset.dropPosition;
      }

      function finalizeSlideReorder(fromIndex, insertIndex) {
        if (fromIndex === null || insertIndex === null) return;
        if (fromIndex < 0 || fromIndex >= slides.length) return;
        if (insertIndex < 0) insertIndex = 0;
        if (insertIndex > slides.length) insertIndex = slides.length;
        if (insertIndex === fromIndex || insertIndex === fromIndex + 1) return;

        capture();

        const [movedSlide] = slides.splice(fromIndex, 1);
        let adjustedInsertIndex = insertIndex;
        if (insertIndex > fromIndex) {
          adjustedInsertIndex = insertIndex - 1;
        }
        if (adjustedInsertIndex < 0) adjustedInsertIndex = 0;
        slides.splice(adjustedInsertIndex, 0, movedSlide);

        let newActive = active;
        if (fromIndex === active) {
          newActive = adjustedInsertIndex;
        } else {
          if (fromIndex < active) {
            newActive -= 1;
          }
          if (adjustedInsertIndex <= newActive) {
            newActive += 1;
          }
        }
        active = Math.max(0, Math.min(slides.length - 1, newActive));
        load();
        renderSidebar();
        saveEditorState('reorder_slides');
      }

      function handleSlideDrop(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const targetIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(targetIndex)) return;
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        const insertIndex = targetIndex + (isAfter ? 1 : 0);
        clearSlideDragIndicators();
        delete item.dataset.dropPosition;
        finalizeSlideReorder(slideDragSourceIndex, insertIndex);
      }

      function handleSlideDragEnd(event) {
        const item = event.currentTarget;
        if (item) {
          item.classList.remove('dragging');
          delete item.dataset.dropPosition;
        }
        clearSlideDragIndicators();
        slideDragSourceIndex = null;
      }

      function selectEditableText(element) {
        const range = document.createRange();
        range.selectNodeContents(element);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function refreshSidebarSoon() {
        requestAnimationFrame(() => renderSidebar());
      }

      function moveSlideByOffset(index, offset) {
        if (!Number.isInteger(index) || !Number.isInteger(offset)) return;
        const targetIndex = index + offset;
        if (targetIndex < 0 || targetIndex >= slides.length) return;
        finalizeSlideReorder(index, targetIndex + (offset > 0 ? 1 : 0));
      }

      function normalizeTransitionEffect(value) {
        if (typeof value !== 'string') {
          return DEFAULT_TRANSITION;
        }
        const normalized = value.toLowerCase();
        return TRANSITION_VALUE_SET.has(normalized) ? normalized : DEFAULT_TRANSITION;
      }

      function clampTransitionDuration(value) {
        const numeric = Number.parseFloat(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_TRANSITION_DURATION;
        }
        const clamped = Math.min(TRANSITION_DURATION_MAX, Math.max(TRANSITION_DURATION_MIN, numeric));
        return Math.round(clamped * 10) / 10;
      }

      function getSlideTransitionConfig(slide) {
        const effect = normalizeTransitionEffect(slide?.transition);
        const duration = clampTransitionDuration(slide?.transitionDuration);
        return { effect, duration };
      }

      function applyTransitionConfigToSlide(slide, config) {
        if (!slide) {
          return { changed: false, effect: DEFAULT_TRANSITION, duration: DEFAULT_TRANSITION_DURATION };
        }
        const targetEffect = normalizeTransitionEffect(config?.effect ?? slide.transition);
        const targetDuration = clampTransitionDuration(config?.duration ?? slide.transitionDuration);
        const current = getSlideTransitionConfig(slide);
        const changed = current.effect !== targetEffect || current.duration !== targetDuration;
        slide.transition = targetEffect;
        slide.transitionDuration = targetDuration;
        return { changed, effect: targetEffect, duration: targetDuration };
      }

      function applySlideTransitionClass(element, transition, durationSeconds, options = {}) {
        if (!element) return;
        const normalized = normalizeTransitionEffect(transition);
        const duration = clampTransitionDuration(durationSeconds);
        TRANSITION_CLASS_NAMES.forEach(cls => element.classList.remove(cls));
        element.style.removeProperty('--transition-duration');
        const shouldAnimate = options.force === true || isPresenting;
        if (!shouldAnimate || normalized === DEFAULT_TRANSITION) {
          return;
        }
        element.style.setProperty('--transition-duration', `${duration}s`);
        void element.offsetWidth;
        element.classList.add(`transition-effect-${normalized}`);
      }

      function getTransitionLabel(type) {
        const option = TRANSITION_OPTIONS.find(opt => opt.value === normalizeTransitionEffect(type)) || TRANSITION_OPTIONS[0];
        return option.label;
      }

      function getTransitionIconHtml(type) {
        const normalized = normalizeTransitionEffect(type || DEFAULT_TRANSITION);
        switch (normalized) {
          case 'fade':
            return '<i class="fas fa-water"></i>';
          case 'slide-left':
            return '<i class="fas fa-arrow-left"></i>';
          case 'slide-right':
            return '<i class="fas fa-arrow-right"></i>';
          case 'slide-up':
            return '<i class="fas fa-arrow-up"></i>';
          case 'slide-down':
            return '<i class="fas fa-arrow-down"></i>';
          case 'zoom-in':
            return '<i class="fas fa-search-plus"></i>';
          case 'zoom-out':
            return '<i class="fas fa-search-minus"></i>';
          case 'flip':
            return '<i class="fas fa-sync-alt"></i>';
          case 'rotate':
            return '<i class="fas fa-sync"></i>';
          case 'none':
          default:
            return `
              <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="15" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.8"/>
                <rect x="11" y="9" width="10" height="8" rx="1.6" ry="1.6" fill="none" stroke="currentColor" stroke-width="1.6"/>
                <path d="M3 8h15M3 11h7M3 14h7" stroke="currentColor" stroke-width="1.2" />
              </svg>
            `;
        }
      }

      function updateTransitionButtonAppearance(button, slideIndex) {
        if (!button) return;
        const slide = slides[slideIndex];
        const { effect, duration } = getSlideTransitionConfig(slide);
        const iconHtml = getTransitionIconHtml(effect);
        button.innerHTML = `<span class="transition-icon">${iconHtml}</span><span class="transition-caret"><i class="fas fa-caret-down"></i></span>`;
        const targetSlideNumber = slideIndex === slides.length - 1 ? 'End' : `Slide ${slideIndex + 2}`;
        const label = getTransitionLabel(effect);
        const durationLabel = duration.toFixed(1).replace(/\.0$/, '');
        button.title = `Transition (${label}, ${durationLabel}s) â†’ ${targetSlideNumber}`;
        button.setAttribute('aria-label', button.title);
      }

      function syncTransitionControlsWithSlide() {
        if (!transitionEffectSelect || !transitionDurationInput) return;
        const { effect, duration } = getSlideTransitionConfig(slides[active]);
        if (transitionEffectSelect.value !== effect) {
          transitionEffectSelect.value = effect;
        }
        transitionDurationInput.value = duration.toFixed(1);
      }

      function refreshSidebarTransitionButton(index) {
        if (!sidebar) return;
        const button = sidebar.querySelector(`.transition-control-button[data-slide-index="${index}"]`);
        if (button) {
          updateTransitionButtonAppearance(button, index);
        }
      }

      function refreshAllTransitionButtons() {
        if (!sidebar) return;
        sidebar.querySelectorAll('.transition-control-button').forEach((button) => {
          const slideIndex = Number.parseInt(button.getAttribute('data-slide-index') || '', 10);
          if (Number.isInteger(slideIndex)) {
            updateTransitionButtonAppearance(button, slideIndex);
          }
        });
      }

      function updateActiveSlideTransition(effect, duration, { recordHistory = true } = {}) {
        const slide = slides[active];
        if (!slide) return false;
        const normalizedEffect = normalizeTransitionEffect(effect);
        const normalizedDuration = clampTransitionDuration(duration);
        const current = getSlideTransitionConfig(slide);
        const hasChanged = current.effect !== normalizedEffect || current.duration !== normalizedDuration;
        if (!hasChanged) {
          syncTransitionControlsWithSlide();
          return false;
        }
        if (recordHistory) {
          capture();
        }
        applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: normalizedDuration });
        syncTransitionControlsWithSlide();
        refreshSidebarTransitionButton(active);
        refreshSidebarSoon();
        if (recordHistory) {
          saveEditorState('change_transition');
        }
        return true;
      }

      function hideSlideContextMenu() {
        if (!slideContextMenu || !slideContextMenu.classList.contains('show')) {
          slideContextMenuTarget = null;
          slideContextMenuTitle = null;
          slideContextMenuIndex = null;
          return;
        }
        slideContextMenu.classList.remove('show');
        slideContextMenu.style.top = '';
        slideContextMenu.style.left = '';
        slideContextMenuTarget = null;
        slideContextMenuTitle = null;
        slideContextMenuIndex = null;
      }

      function showSlideContextMenu(event, index, titleElement, slideItem) {
        if (!slideContextMenu || !titleElement || !slideItem) return;
        event.preventDefault();
        hideSlideCanvasContextMenu();
        slideContextMenuIndex = index;
        slideContextMenuTitle = titleElement;
        slideContextMenuTarget = slideItem;

        slideContextMenu.classList.add('show');
        const menuRect = slideContextMenu.getBoundingClientRect();
        const padding = 8;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        top = Math.max(padding, top);
        left = Math.max(padding, left);
        slideContextMenu.style.top = `${top}px`;
        slideContextMenu.style.left = `${left}px`;
      }

      function hideSlideTransitionMenu() {
        if (!slideTransitionMenu || !slideTransitionMenu.classList.contains('show')) {
          slideTransitionMenuIndex = null;
          slideTransitionMenuAnchor = null;
          return;
        }
        slideTransitionMenu.classList.remove('show');
        slideTransitionMenu.style.top = '';
        slideTransitionMenu.style.left = '';
        slideTransitionMenuIndex = null;
        slideTransitionMenuAnchor = null;
      }

      function showSlideTransitionMenu(event, index, anchorElement) {
        if (!slideTransitionMenu || !anchorElement) return;
        event.preventDefault();
        event.stopPropagation();
        hideSlideCanvasContextMenu();
        slideTransitionMenuIndex = index;
        slideTransitionMenuAnchor = anchorElement;
        slideTransitionMenu.classList.add('show');
        const buttons = slideTransitionMenu.querySelectorAll('button');
        const currentTransition = normalizeTransitionEffect(slides[index]?.transition);
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.transition === currentTransition);
        });
        const menuRect = slideTransitionMenu.getBoundingClientRect();
        const anchorRect = anchorElement.getBoundingClientRect();
        const padding = 8;
        let top = anchorRect.top + window.scrollY - menuRect.height - 6;
        let left = anchorRect.left + window.scrollX - menuRect.width / 2 + anchorRect.width / 2;
        if (top < padding) {
          top = anchorRect.bottom + window.scrollY + 6;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        if (left < padding) {
          left = padding;
        }
        slideTransitionMenu.style.top = `${top}px`;
        slideTransitionMenu.style.left = `${left}px`;
      }

      if (slideContextRenameBtn) {
        slideContextRenameBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const titleElement = slideContextMenuTitle;
          const slideIndex = slideContextMenuIndex;
          const slideItem = slideContextMenuTarget;
          hideSlideContextMenu();
          if (titleElement && slideItem && Number.isInteger(slideIndex)) {
            startSlideTitleEditing(titleElement, slideIndex, slideItem);
          }
        });
      }

      if (slideTransitionMenu) {
        slideTransitionMenu.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (slideTransitionMenuIndex === null) {
              hideSlideTransitionMenu();
              return;
            }
            const value = btn.dataset.transition || DEFAULT_TRANSITION;
            const slide = slides[slideTransitionMenuIndex];
            hideSlideTransitionMenu();
            if (!slide) return;
            const priorConfig = getSlideTransitionConfig(slide);
            const normalizedEffect = normalizeTransitionEffect(value);
            if (priorConfig.effect === normalizedEffect) {
              return;
            }
            capture();
            applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: priorConfig.duration });
            if (slideTransitionMenuIndex === active) {
              syncTransitionControlsWithSlide();
            }
            if (slideTransitionMenuAnchor) {
              updateTransitionButtonAppearance(slideTransitionMenuAnchor, slideTransitionMenuIndex);
            } else {
              refreshSidebarTransitionButton(slideTransitionMenuIndex);
            }
            saveEditorState('change_transition');
            refreshSidebarSoon();
          });
        });
      }

      document.addEventListener('click', (event) => {
        if (slideContextMenu && slideContextMenu.classList.contains('show') && !slideContextMenu.contains(event.target)) {
          hideSlideContextMenu();
        }
        if (slideTransitionMenu && slideTransitionMenu.classList.contains('show') && !slideTransitionMenu.contains(event.target)) {
          hideSlideTransitionMenu();
        }
      });

      window.addEventListener('resize', hideSlideContextMenu);
      window.addEventListener('scroll', hideSlideContextMenu, true);
      window.addEventListener('resize', hideSlideTransitionMenu);
      window.addEventListener('scroll', hideSlideTransitionMenu, true);

      function startSlideTitleEditing(titleElement, slideIndex, slideItem) {
        if (!titleElement) return;
        const originalTitle = titleElement.textContent.trim();
        titleElement.contentEditable = 'true';
        titleElement.classList.add('editing');
        titleElement.focus({ preventScroll: true });
        selectEditableText(titleElement);
        if (slideItem) {
          slideItem.setAttribute('draggable', 'false');
        }

        function cleanup() {
          titleElement.contentEditable = 'false';
          titleElement.classList.remove('editing');
          if (slideItem) {
            slideItem.setAttribute('draggable', 'true');
          }
          titleElement.removeEventListener('blur', handleBlur);
          titleElement.removeEventListener('keydown', handleKeyDown);
        }

        function applyTitleChange(shouldPersist) {
          const trimmed = titleElement.textContent.trim();
          const fallback = originalTitle || slides[slideIndex].title || `Slide ${slideIndex + 1}`;
          const finalTitle = shouldPersist ? (trimmed || fallback) : fallback;
          cleanup();
          titleElement.textContent = finalTitle;
          if (shouldPersist && finalTitle !== originalTitle) {
            slides[slideIndex].title = finalTitle;
            if (slideIndex === active && titleBox.style.display !== 'none') {
              titleBox.textContent = finalTitle;
            }
            capture();
            saveEditorState('rename_slide');
          }
          refreshSidebarSoon();
        }

        function handleBlur() {
          applyTitleChange(true);
        }

        function handleKeyDown(event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            applyTitleChange(true);
          } else if (event.key === 'Escape') {
            event.preventDefault();
            titleElement.textContent = originalTitle;
            applyTitleChange(false);
          }
        }

        titleElement.addEventListener('blur', handleBlur);
        titleElement.addEventListener('keydown', handleKeyDown);
      }

      function renderSidebar() {
        if (!sidebar) return;
        hideSlideContextMenu();
        hideSlideTransitionMenu();
        hideSlideTransitionMenu();
        const isThumbnailMode = sidebarViewMode === 'thumbnail';
        sidebar.classList.toggle('thumbnail-view', isThumbnailMode);
        sidebar.classList.toggle('list-view', !isThumbnailMode);
        if (isThumbnailMode && (!sidebarThumbnails || sidebarThumbnails.length !== slides.length)) {
          ensureSidebarThumbnails();
        }
        sidebar.innerHTML = '';
        slides.forEach((s, i) => {
          // Create slide-item container
          const slideItem = document.createElement('div');
          slideItem.className = 'slide-item' + (isThumbnailMode ? ' thumbnail' : '');
          slideItem.dataset.index = String(i);
          slideItem.setAttribute('draggable', 'true');
          
        // Create slide preview
        const preview = document.createElement('div');
        preview.className = 'slide-preview' + (i === active ? ' active' : '');
        preview.setAttribute('draggable', 'false');
        if (isThumbnailMode) {
          preview.classList.add('thumbnail');
          const frame = document.createElement('div');
          frame.className = 'slide-thumbnail-frame';
          if (sidebarThumbnails && sidebarThumbnails[i]) {
            const img = document.createElement('img');
            img.src = sidebarThumbnails[i];
            img.alt = s.title ? `Preview of ${s.title}` : `Preview of slide ${i + 1}`;
            frame.appendChild(img);
          } else {
            const placeholder = document.createElement('div');
            placeholder.className = 'slide-thumbnail-placeholder';
            placeholder.textContent = 'Generating previewâ€¦';
            frame.appendChild(placeholder);
          }
          preview.appendChild(frame);
        }

        const titleSpan = document.createElement('span');
        titleSpan.className = 'slide-preview-title';
        titleSpan.textContent = s.title || `Slide ${i + 1}`;
        preview.appendChild(titleSpan);

        preview.addEventListener('click', () => {
          capture();
          active = i;
          load();
          renderSidebar();
        });

        titleSpan.addEventListener('click', (event) => {
          if (titleSpan.isContentEditable) {
            event.stopPropagation();
          }
        });

        titleSpan.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          startSlideTitleEditing(titleSpan, i, slideItem);
        });

        titleSpan.addEventListener('dragstart', (event) => {
          if (titleSpan.isContentEditable) {
            event.preventDefault();
          }
        });
          
          // Create slide action bar container
          const slideActionBar = document.createElement('div');
          slideActionBar.className = 'slide-action-bar';
          
          // New Slide button with icon
          const newSlideBtn = document.createElement('button');
          newSlideBtn.className = 'new-slide';
          newSlideBtn.title = 'New Slide';
          newSlideBtn.innerHTML = '<i class="fas fa-plus"></i>';
          newSlideBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            createNewSlide(i);
          });
          
          // Duplicate button with icon
          const duplicateBtn = document.createElement('button');
          duplicateBtn.className = 'duplicate-slide';
          duplicateBtn.title = 'Duplicate';
          duplicateBtn.innerHTML = '<i class="fas fa-copy"></i>';
          duplicateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            duplicateCurrentSlide(i);
          });

          const moveUpBtn = document.createElement('button');
          moveUpBtn.className = 'move-slide-up';
          moveUpBtn.title = 'Move Up';
          moveUpBtn.innerHTML = '<i class="fas fa-arrow-up"></i>';
          moveUpBtn.disabled = i === 0;
          moveUpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            moveSlideByOffset(i, -1);
          });

          const moveDownBtn = document.createElement('button');
          moveDownBtn.className = 'move-slide-down';
          moveDownBtn.title = 'Move Down';
          moveDownBtn.innerHTML = '<i class="fas fa-arrow-down"></i>';
          moveDownBtn.disabled = i === slides.length - 1;
          moveDownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            moveSlideByOffset(i, 1);
          });
          
          slideActionBar.appendChild(newSlideBtn);
          slideActionBar.appendChild(duplicateBtn);
          slideActionBar.appendChild(moveUpBtn);
        const transitionButton = document.createElement('button');
        transitionButton.type = 'button';
        transitionButton.className = 'transition-control-button';
        transitionButton.setAttribute('data-slide-index', String(i));
        updateTransitionButtonAppearance(transitionButton, i);
        transitionButton.addEventListener('click', (event) => {
          hideSlideContextMenu();
          event.preventDefault();
          event.stopPropagation();
          showSlideTransitionMenu(event, i, transitionButton);
        });
        
        slideActionBar.appendChild(moveDownBtn);
          slideActionBar.appendChild(transitionButton);
        
        slideItem.appendChild(preview);
        slideItem.appendChild(slideActionBar);

        slideItem.addEventListener('dragstart', handleSlideDragStart);
        slideItem.addEventListener('dragenter', (event) => {
          if (slideDragSourceIndex !== null) {
            event.preventDefault();
          }
        });
        slideItem.addEventListener('dragover', handleSlideDragOver);
        slideItem.addEventListener('dragleave', handleSlideDragLeave);
        slideItem.addEventListener('drop', handleSlideDrop);
        slideItem.addEventListener('dragend', handleSlideDragEnd);
        slideItem.addEventListener('contextmenu', (event) => {
          hideSlideTransitionMenu();
          showSlideContextMenu(event, i, titleSpan, slideItem);
        });
          
          sidebar.appendChild(slideItem);

        });
        updateSidebarViewButtons();
      }

      function createResizeEdges(element) {
        // Remove existing edges
        element.querySelectorAll('.resize-edge').forEach(el => el.remove());
        
        const isShapeLike = element.classList && (
          element.classList.contains('shape-element') ||
          element.classList.contains('chart-element') ||
          element.classList.contains('text-box') ||
          element.classList.contains('title-box') ||
          element.classList.contains('additional-text-box') ||
          element.classList.contains('table-element')
        );
        const isImageElement = element.classList && element.classList.contains('image-element');
        const isVideoElement = element.classList && element.classList.contains('video-element');
        let edges;
        if (isImageElement) {
          edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        } else if (isVideoElement) {
          edges = ['bottom-right'];
        } else if (isShapeLike) {
          edges = ['top', 'bottom', 'left', 'right', 'bottom-right'];
        } else {
          edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        }
        edges.forEach(edge => {
          const edgeEl = document.createElement('div');
          edgeEl.className = `resize-edge ${edge}`;
          edgeEl.dataset.edge = edge;
          if (isImageElement) {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          } else if (isVideoElement) {
            edgeEl.classList.add('corner');
          } else if (isShapeLike) {
            edgeEl.classList.add(edge === 'bottom-right' ? 'corner' : 'side');
          } else {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          }
          element.appendChild(edgeEl);
        });
      }

      function load() {
        clearGroupSelection();
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        closeImageCropper();
        const slide = slides[active];
        if (slide && !Array.isArray(slide.animations)) {
          slide.animations = [];
        }
        const backgroundConfig = slide && slide.background ? slide.background : { image: '', size: '', position: '', repeat: '' };
        canvas.style.backgroundImage = backgroundConfig.image || '';
        canvas.style.backgroundSize = backgroundConfig.size || '';
        canvas.style.backgroundPosition = backgroundConfig.position || '';
        canvas.style.backgroundRepeat = backgroundConfig.repeat || '';
        const titleFont = slide.titleFontFamily || DEFAULT_FONT_FAMILY;
        const textFont = slide.textFontFamily || DEFAULT_FONT_FAMILY;
        elementFontFamilies.set(titleBox, titleFont);
        elementFontFamilies.set(textBox, textFont);
        titleBox.style.fontFamily = titleFont;
        textBox.style.fontFamily = textFont;

        const titleBoxData = slide.titleBox || {};
        if (!titleBoxData.id) {
          titleBoxData.id = ensureElementHasId(titleBox, 'title');
        }
        titleBox.dataset.elementId = titleBoxData.id;
        const textBoxData = slide.textBox || {};
        if (!textBoxData.id) {
          textBoxData.id = ensureElementHasId(textBox, 'body');
        }
        textBox.dataset.elementId = textBoxData.id;
        const showTitleBox = titleBoxData.visible !== undefined ? titleBoxData.visible : true;
        if (showTitleBox) {
          titleBox.style.display = '';
          titleBox.textContent = slide.title || '';
          if (slide.titleBox) {
            titleBox.style.top = slide.titleBox.top + 'px';
            titleBox.style.left = slide.titleBox.left + 'px';
            if (slide.titleBox.width) {
              titleBox.style.width = slide.titleBox.width + 'px';
              titleBox.style.right = 'auto';
            }
            if (slide.titleBox.height) {
              titleBox.style.height = slide.titleBox.height + 'px';
            }
            const titleRotation = Number.isFinite(slide.titleBox.rotation) ? slide.titleBox.rotation : 0;
            titleBox.dataset.rotation = String(titleRotation);
            titleBox.style.transform = `rotate(${titleRotation}deg)`;
          }
        } else {
          titleBox.style.display = 'none';
          titleBox.textContent = '';
        }

        const showTextBox = textBoxData.visible !== undefined ? textBoxData.visible : true;
        if (showTextBox) {
          textBox.style.display = '';
          textBox.textContent = slide.content || '';
          if (slide.textBox) {
            textBox.style.top = slide.textBox.top + 'px';
            textBox.style.left = slide.textBox.left + 'px';
            if (slide.textBox.width) {
              textBox.style.width = slide.textBox.width + 'px';
              textBox.style.right = 'auto';
            }
            if (slide.textBox.height) {
              textBox.style.height = slide.textBox.height + 'px';
              textBox.style.bottom = 'auto';
            }
            const textRotation = Number.isFinite(slide.textBox.rotation) ? slide.textBox.rotation : 0;
            textBox.dataset.rotation = String(textRotation);
            textBox.style.transform = `rotate(${textRotation}deg)`;
          }
        } else {
          textBox.style.display = 'none';
          textBox.textContent = '';
        }

        if (!slide.titleBox) {
          titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
        }
        if (!slide.textBox) {
          textBox.dataset.rotation = textBox.dataset.rotation || '0';
        }

        // Create resize edges
        createResizeEdges(titleBox);
        createResizeEdges(textBox);

        document.querySelectorAll('.additional-text-box').forEach(el => el.remove());
        if (!Array.isArray(slide.additionalTextBoxes)) {
          slide.additionalTextBoxes = [];
        }
        slide.additionalTextBoxes.forEach(textBoxData => instantiateAdditionalTextBox(textBoxData));

        document.querySelectorAll('.shape-element').forEach(el => el.remove());
        document.querySelectorAll('.table-element').forEach(el => el.remove());
        document.querySelectorAll('.image-element').forEach(el => el.remove());
        document.querySelectorAll('.video-element').forEach(el => {
          const video = el.querySelector('video');
          if (video) {
            video.pause();
          }
          el.remove();
        });
        selectedShape = null;
        selectedChart = null;
        selectedImage = null;
        selectedVideo = null;
        selectedTable = null;
        hideShapeColorPicker();
        hideRotationHandle();
        document.querySelectorAll('.chart-element').forEach(chartEl => chartEl.remove());
        if (!Array.isArray(slide.charts)) {
          slide.charts = [];
        }
        slide.charts.forEach(chartData => instantiateChart(chartData));
        if (!Array.isArray(slide.shapes)) {
          slide.shapes = [];
        }
        slide.shapes.forEach(shapeData => instantiateShape(shapeData));
        if (!Array.isArray(slide.tables)) {
          slide.tables = [];
        }
        slide.tables.forEach(tableData => instantiateTable(tableData));
        if (!Array.isArray(slide.images)) {
          slide.images = [];
        }
        slide.images.forEach(imageData => instantiateImage(imageData));

        updateFontPickerSelectedFont();
        const transitionConfig = getSlideTransitionConfig(slide);
        applyTransitionConfigToSlide(slide, transitionConfig);
        if (!isPresenting) {
          TRANSITION_CLASS_NAMES.forEach(cls => canvas.classList.remove(cls));
          canvas.style.removeProperty('--transition-duration');
        }
        syncTransitionControlsWithSlide();
        syncAnimationControlsWithSlide();
        renderComments();
      }

      function capture() {
        const slide = slides[active];
        if (!slide) return;
        const titleVisible = titleBox.style.display !== 'none';
        const textVisible = textBox.style.display !== 'none';
        if (titleVisible) {
          slide.title = titleBox.textContent.trim();
        }
        if (textVisible) {
          slide.content = textBox.textContent.trim();
        }
        
        // Save positions and sizes
        const titleElementId = ensureElementHasId(titleBox, 'title');
        const titleCoords = getElementCanvasCoordinates(titleBox);
        slide.titleBox = {
          id: titleElementId,
          top: titleCoords.top,
          left: titleCoords.left,
          width: titleBox.offsetWidth,
          height: titleBox.offsetHeight,
          visible: titleVisible,
          rotation: parseFloat(titleBox.dataset.rotation || '0') || 0
        };
        
        const textElementId = ensureElementHasId(textBox, 'body');
        const textCoords = getElementCanvasCoordinates(textBox);
        slide.textBox = {
          id: textElementId,
          top: textCoords.top,
          left: textCoords.left,
          width: textBox.offsetWidth,
          height: textBox.offsetHeight,
          visible: textVisible,
          rotation: parseFloat(textBox.dataset.rotation || '0') || 0
        };

        slide.titleFontFamily = getCurrentFontFamily(titleBox);
        slide.textFontFamily = getCurrentFontFamily(textBox);
        slide.additionalTextBoxes = collectAdditionalTextBoxesData();
        slide.charts = collectChartsData();
        slide.shapes = collectShapesData();
        slide.tables = collectTablesData();
        slide.images = collectImagesData();
        slide.videos = collectVideosData();
        pruneSlideAnimations(slide);
        invalidateSidebarThumbnails();
      }

      // Drag functionality - only when clicking on empty space
      function makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;
        let dragThreshold = 5;
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        
        element.addEventListener('mousedown', (e) => {
          if (element.classList.contains('table-element') && (e.target.closest('td') || e.target.closest('th'))) {
            return;
          }
          // Don't drag if clicking on resize edge
          if (e.target.classList && e.target.classList.contains('resize-edge')) {
            return;
          }
          
          // Don't drag if clicking on text content
          if (e.target !== element && e.target.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          
          const isEditableBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
          if (isEditableBox) {
            // Only drag if clicking on empty space or border area
            const selection = window.getSelection();
            if (selection.toString().length > 0) {
              return;
            }

            // Check if element is empty or clicking on border
            const isEmpty = !element.textContent.trim() || element.textContent.trim() === element.dataset.placeholder;
            const isBorderClick = e.target === element || (e.target === element && element.contains(e.target));

            if (!isEmpty && !isBorderClick) {
              return; // Allow text editing
            }
          }
          
          startX = e.clientX;
          startY = e.clientY;
          const startCoords = getElementCanvasCoordinates(element);
          initialLeft = startCoords.left;
          initialTop = startCoords.top;
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
        });
        
        document.addEventListener('mousemove', (e) => {
          if (startX === undefined || startY === undefined) return;
          
          const deltaX = Math.abs(e.clientX - startX);
          const deltaY = Math.abs(e.clientY - startY);
          
          if (!isDragging && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            isDragging = true;
            element.classList.add('dragging');
            if (hadEditableAttr || wasContentEditable) {
              element.setAttribute('contenteditable', 'false');
            }
          }
          
          if (!isDragging) return;
          
          const zoom = getCanvasZoom();
          const moveX = (e.clientX - startX) / zoom;
          const moveY = (e.clientY - startY) / zoom;
          
          let newLeft = initialLeft + moveX;
          let newTop = initialTop + moveY;
          
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          capture();
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
              element.setAttribute('contenteditable', 'true');
            }
            capture();
            // Save state for undo after dragging
            saveEditorState('move_element');
          }
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        });
      }
      
      // Resize functionality using edges
      function makeResizable(element) {
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        let resizeEdge = '';
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        let minWidth = 200;
        let minHeight = 50;
        let aspectRatio = 1;
        
        element.addEventListener('mousedown', (e) => {
          if (!e.target.classList.contains('resize-edge')) return;
          
          resizeEdge = e.target.dataset.edge;
          isResizing = true;
          element.classList.add('resizing');
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
          if (hadEditableAttr || wasContentEditable) {
            element.setAttribute('contenteditable', 'false');
          }
          
          startX = e.clientX;
          startY = e.clientY;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
          const startCoords = getElementCanvasCoordinates(element);
          startLeft = startCoords.left;
          startTop = startCoords.top;
          minWidth = parseFloat(element.dataset.minWidth) || 200;
          minHeight = parseFloat(element.dataset.minHeight) || 50;
          aspectRatio = startWidth / startHeight || 1;
        const isShape = element.classList.contains('shape-element');
        const isChart = element.classList.contains('chart-element');
        const isImage = element.classList.contains('image-element');
        const isVideo = element.classList.contains('video-element');
        const isTable = element.classList.contains('table-element');
        const isTextBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        if (isImage && selectedImage !== element) {
          selectImage(element);
        }
        if (isVideo && selectedVideo !== element) {
          selectVideo(element);
        }
        if (isChart && selectedChart !== element) {
          selectChart(element);
        }
        if (isShape || isChart || isTextBox || isTable || isImage || isVideo) {
          activeResizeShape = element;
          updateShapeSizeBadge(element, startWidth, startHeight);
          showShapeSizeBadge();
        }
          
          e.preventDefault();
          e.stopPropagation();
        });
        
        document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const zoom = getCanvasZoom();
        const deltaX = (e.clientX - startX) / zoom;
        const deltaY = (e.clientY - startY) / zoom;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        
        const isShape = element.classList.contains('shape-element');
        const isChart = element.classList.contains('chart-element');
        const isImage = element.classList.contains('image-element');
        const isVideo = element.classList.contains('video-element');
        const isTable = element.classList.contains('table-element');
        const isShapeLike = isShape || isChart || isTable || isImage || isVideo || element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        
        if (isImage || isVideo) {
          const bounds = {
            left: 24,
            top: 24,
            right: canvasWidth - 24,
            bottom: canvasHeight - 24
          };
          const isCornerHandle = ['top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeEdge);
          const storedAspect = parseFloat(element.dataset.aspectRatio || '0');
          const aspect = storedAspect > 0 ? storedAspect : (startWidth / Math.max(startHeight, 0.01));
          
          if (resizeEdge.includes('right')) {
            const maxWidth = bounds.right - startLeft;
            newWidth = Math.max(minWidth, Math.min(startWidth + deltaX, maxWidth));
          }
          if (resizeEdge.includes('left')) {
            const proposedLeft = startLeft + deltaX;
            const maxLeft = startLeft + startWidth - minWidth;
            newLeft = Math.max(bounds.left, Math.min(proposedLeft, maxLeft));
            newWidth = Math.max(minWidth, startWidth + (startLeft - newLeft));
          }
          if (resizeEdge.includes('bottom')) {
            const maxHeight = bounds.bottom - startTop;
            newHeight = Math.max(minHeight, Math.min(startHeight + deltaY, maxHeight));
          }
          if (resizeEdge.includes('top')) {
            const proposedTop = startTop + deltaY;
            const maxTop = startTop + startHeight - minHeight;
            newTop = Math.max(bounds.top, Math.min(proposedTop, maxTop));
            newHeight = Math.max(minHeight, startHeight + (startTop - newTop));
          }
          
          if (!resizeEdge.includes('left') && !resizeEdge.includes('right')) {
            newLeft = startLeft;
          }
          if (!resizeEdge.includes('top') && !resizeEdge.includes('bottom')) {
            newTop = startTop;
          }
          
          if (!isCornerHandle) {
            if (resizeEdge === 'left' || resizeEdge === 'right') {
              newHeight = startHeight;
              newTop = startTop;
            }
            if (resizeEdge === 'top' || resizeEdge === 'bottom') {
              newWidth = startWidth;
              newLeft = startLeft;
            }
          } else {
            const clampedAspect = Math.max(aspect, 0.01);
            const widthDelta = Math.abs(newWidth - startWidth);
            const heightDelta = Math.abs(newHeight - startHeight);
            if (widthDelta >= heightDelta) {
              newHeight = newWidth / clampedAspect;
              if (resizeEdge.includes('top')) {
                newTop = startTop + (startHeight - newHeight);
              }
            } else {
              newWidth = newHeight * clampedAspect;
              if (resizeEdge.includes('left')) {
                newLeft = startLeft + (startWidth - newWidth);
              }
            }
            
            if (newLeft < bounds.left) {
              const overflow = bounds.left - newLeft;
              newLeft = bounds.left;
              newWidth = Math.max(minWidth, newWidth - overflow);
            }
            if (newTop < bounds.top) {
              const overflow = bounds.top - newTop;
              newTop = bounds.top;
              newHeight = Math.max(minHeight, newHeight - overflow);
            }
            if (newLeft + newWidth > bounds.right) {
              const overflow = (newLeft + newWidth) - bounds.right;
              if (resizeEdge.includes('left')) {
                newLeft = Math.max(bounds.left, newLeft - overflow);
              } else {
                newWidth = Math.max(minWidth, newWidth - overflow);
              }
            }
            if (newTop + newHeight > bounds.bottom) {
              const overflow = (newTop + newHeight) - bounds.bottom;
              if (resizeEdge.includes('top')) {
                newTop = Math.max(bounds.top, newTop - overflow);
              } else {
                newHeight = Math.max(minHeight, newHeight - overflow);
              }
            }
          }
          
          newWidth = Math.max(minWidth, Math.min(newWidth, bounds.right - newLeft));
          newHeight = Math.max(minHeight, Math.min(newHeight, bounds.bottom - newTop));
          
          element.style.width = `${newWidth}px`;
          element.style.height = `${newHeight}px`;
          element.style.left = `${newLeft}px`;
          element.style.top = `${newTop}px`;
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          element.dataset.aspectRatio = String(newWidth / Math.max(newHeight, 0.01));
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else if (isShapeLike) {
          const minScale = Math.max(minWidth / startWidth, minHeight / startHeight);
          const bounds = {
            left: 24,
            top: 24,
            right: canvasWidth - 24,
            bottom: canvasHeight - 24
          };
          
          if (resizeEdge === 'bottom-right') {
            const centerX = startLeft + startWidth / 2;
            const centerY = startTop + startHeight / 2;
            let widthCandidate = Math.max(minWidth, startWidth + deltaX);
            let heightCandidate = Math.max(minHeight, startHeight + deltaY);
            let scale = Math.max(widthCandidate / startWidth, heightCandidate / startHeight);
            scale = Math.max(scale, minScale);
            newWidth = startWidth * scale;
            newHeight = startHeight * scale;
            newLeft = centerX - newWidth / 2;
            newTop = centerY - newHeight / 2;
          } else if (resizeEdge === 'left') {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(bounds.left, startLeft + deltaX);
            if (newLeft === bounds.left) {
              newWidth = startLeft + startWidth - bounds.left;
            }
          } else if (resizeEdge === 'right') {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, bounds.right - startLeft);
          } else if (resizeEdge === 'top') {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(bounds.top, startTop + deltaY);
            if (newTop === bounds.top) {
              newHeight = startTop + startHeight - bounds.top;
            }
          } else if (resizeEdge === 'bottom') {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, bounds.bottom - startTop);
          }
          
          newWidth = Math.max(newWidth, minWidth);
          newHeight = Math.max(newHeight, minHeight);
          if (resizeEdge === 'bottom-right') {
            if (newLeft < bounds.left) newLeft = bounds.left;
            if (newTop < bounds.top) newTop = bounds.top;
            if (newLeft + newWidth > bounds.right) newLeft = bounds.right - newWidth;
            if (newTop + newHeight > bounds.bottom) newTop = bounds.bottom - newHeight;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else {
          if (resizeEdge.includes('right')) {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, canvasWidth - newLeft - 48);
          }
          if (resizeEdge.includes('left')) {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(24, startLeft + deltaX);
            if (newLeft === 24) newWidth = startLeft + startWidth - 24;
          }
          if (resizeEdge.includes('bottom')) {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, canvasHeight - newTop - 48);
          }
          if (resizeEdge.includes('top')) {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(24, startTop + deltaY);
            if (newTop === 24) newHeight = startTop + startHeight - 24;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
        }
          
        capture();
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        });
        
        document.addEventListener('mouseup', () => {
          if (isResizing) {
            isResizing = false;
            element.classList.remove('resizing');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
              element.setAttribute('contenteditable', 'true');
            }
            resizeEdge = '';
            capture();
            // Save state for undo after resizing
            saveEditorState('resize_element');
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        if (shapeSizeBadge.classList.contains('visible')) {
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        });
      }
      
      // Make boxes draggable and resizable
      makeDraggable(titleBox);
      makeDraggable(textBox);
      makeResizable(titleBox);
      makeResizable(textBox);
      
      // Initialize resize edges
      createResizeEdges(titleBox);
      createResizeEdges(textBox);
      
      // Add selection handlers for title and text boxes
      titleBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === titleBox || !titleBox.textContent.trim()) {
          selectTextBox(titleBox);
        }
      });
      
      textBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === textBox || !textBox.textContent.trim()) {
          selectTextBox(textBox);
        }
      });

      // Toolbar interactions per Editor.json
      function getActiveElement() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
        return document.activeElement === titleBox ? titleBox : textBox;
      }

      function addTextBoxAtCanvasPosition(canvasX, canvasY) {
        if (!canvas) return null;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const defaultWidth = 150;
        const defaultHeight = 40;
        const margin = 24;
        const clampPosition = (value, elementSize, canvasSize) => {
          const maxWithMargin = canvasSize - elementSize - margin;
          if (maxWithMargin <= margin) {
            return Math.max(0, Math.min(value, canvasSize - elementSize));
          }
          return Math.max(margin, Math.min(value, maxWithMargin));
        };
        let left = canvasX - defaultWidth / 2;
        let top = canvasY - defaultHeight / 2;
        left = clampPosition(left, defaultWidth, canvasWidth);
        top = clampPosition(top, defaultHeight, canvasHeight);
        const newTextBox = createAdditionalTextBox({
          top,
          left,
          width: defaultWidth,
          height: defaultHeight,
          fontSize: '16px',
          fontFamily: DEFAULT_FONT_FAMILY,
          color: '#000000'
        });
        if (!newTextBox) return null;
        lastCanvasInsertPosition = {
          x: left + defaultWidth / 2,
          y: top + defaultHeight / 2
        };
        selectTextBox(newTextBox);
        requestAnimationFrame(() => {
          if (!document.contains(newTextBox)) {
            return;
          }
          try {
            newTextBox.focus({ preventScroll: true });
          } catch (error) {
            newTextBox.focus();
          }
          const selection = window.getSelection();
          if (!selection) return;
          const range = document.createRange();
          range.selectNodeContents(newTextBox);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        });
        capture();
        saveEditorState('add_textbox');
        return newTextBox;
      }

      // Add Text Box functionality
      function addTextBox() {
        if (!canvas) return;
        addTextBoxAtCanvasPosition(canvas.clientWidth / 2, canvas.clientHeight / 2);
      }
      
      // Function to select/deselect text boxes
      function selectTextBox(element) {
        // Can select any text box or title box
        if (!element || (!element.classList.contains('text-box') && element.id !== 'titleBox')) {
          return;
        }
        clearGroupSelection();
        clearShapeSelection();
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        
        // Deselect all other boxes
        document.querySelectorAll('.text-box.selected, .title-box.selected').forEach(box => {
          box.classList.remove('selected');
        });
        
        // Select this box
        element.classList.add('selected');
        createResizeEdges(element);
        selectedTextBox = element;
        handleAnimationSelectionChange(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        
        // Deselect when clicking elsewhere
        setTimeout(() => {
          document.addEventListener('click', function deselectHandler(e) {
            if (!element.contains(e.target) && e.target !== element) {
              element.classList.remove('selected');
              selectedTextBox = null;
              if (rotationTarget === element) {
                hideRotationHandle();
              }
              handleAnimationSelectionChange(null);
              document.removeEventListener('click', deselectHandler);
            }
          }, { once: true });
        }, 150);
      }
      
      // Function to delete text box
      function deleteTextBox(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        const elementId = element.dataset ? element.dataset.elementId : null;
        if (elementId) {
          handleElementAnimationRemoval(elementId);
        }
        
        // Handle title box deletion - hide it instead of removing
        if (element.id === 'titleBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          capture();
          updateElementContextMenuState();
          return;
        }
        
        // Handle main text box deletion - hide it instead of removing
        if (element.id === 'textBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = titleBox;
            updateFontSizeInput();
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          capture();
          updateElementContextMenuState();
          return;
        }
        
        // Handle additional text boxes - remove completely
        if (element.classList.contains('additional-text-box')) {
          // Remove from font size tracking
          elementFontSizes.delete(element);
          // Remove selection
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          // Remove from DOM
          element.remove();
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = textBox;
            updateFontSizeInput();
          }
          capture();
          updateElementContextMenuState();
        }
      }
      
      // Global keyboard listener for Delete/Backspace and Undo
      document.addEventListener('keydown', (e) => {
        if (!isPresenting && slideTransitionMenu && slideTransitionMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideTransitionMenu();
          return;
        }
        if (!isPresenting && slideContextMenu && slideContextMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideContextMenu();
          return;
        }
        if (!isPresenting && saveAsModal && saveAsModal.classList.contains('show') && e.key === 'Escape') {
          hideSaveAsModal();
        }
        if (!isPresenting && saveAsMenu && saveAsMenu.classList.contains('show') && e.key === 'Escape') {
          hideSaveAsMenu();
          return;
        }
        if (isPresenting) {
          if (e.key === 'Escape') {
            e.preventDefault();
            exitPresentation();
            return;
          }
          if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            goToNextSlide();
            return;
          }
          if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            e.preventDefault();
            goToPreviousSlide();
            return;
          }
          return;
        }
        const selection = window.getSelection();
        const editingTableCell = isEditingTableCell();
        const selectedContext = getSelectedElementContext();
        const selectedElement = selectedContext ? selectedContext.element : null;
        const hasSelectionRange = selection && selection.rangeCount > 0;
        const activeRange = hasSelectionRange ? selection.getRangeAt(0) : null;
        const hasNonCollapsedSelection = activeRange ? !activeRange.collapsed : false;
        const rangeContainer = activeRange ? activeRange.commonAncestorContainer : null;
        const selectionWithinSelectedElement = Boolean(
          selectedElement &&
          rangeContainer &&
          selectedElement.contains(rangeContainer)
        );
        const editableShortcutTarget = isEditableShortcutTarget(e.target);
        const editingSelectedElement = editableShortcutTarget && selectionWithinSelectedElement;

        if (!editingTableCell && (e.metaKey || e.ctrlKey)) {
          const key = typeof e.key === 'string' ? e.key.toLowerCase() : '';
          let handledShortcut = false;

          const allowElementCopyCut = selectedElement && (!editingSelectedElement || !hasNonCollapsedSelection);
          if (allowElementCopyCut && !e.shiftKey && !e.altKey) {
            if (key === 'c') {
              handledShortcut = copySelectedElements(selectedElement);
            } else if (key === 'x') {
              handledShortcut = cutSelectedElements(selectedElement);
            }
          }

          const allowElementPaste = !editableShortcutTarget || (selectedElement && !selectionWithinSelectedElement);
          if (allowElementPaste && !e.shiftKey && !e.altKey && key === 'v') {
            handledShortcut = pasteElementsFromClipboard({
              referenceElement: selectedElement || null
            }) || handledShortcut;
          }

          if (handledShortcut) {
            e.preventDefault();
            return;
          }
        }

        // Undo keyboard shortcut (Cmd+Z on Mac, Ctrl+Z on Windows)
        if (!editingTableCell && (e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undoLastAction();
          return;
        }
        
        // Redo keyboard shortcut (Cmd+Shift+Z on Mac, Ctrl+Shift+Z on Windows)
        if (!editingTableCell && (e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          redoLastAction();
          return;
        }
        
        // Only handle Delete/Backspace if a text box is selected
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
          // Check if user is typing (cursor is inside the text box)
          const isTyping = selection.rangeCount > 0 && 
                          selection.getRangeAt(0).startOffset !== selection.getRangeAt(0).endOffset;
          
          // Only delete if not typing (no text selection) or if box is empty
          const isEmpty = !selectedTextBox.textContent.trim();
          const hasTextSelection = selection.toString().length > 0;
          
          if (!hasTextSelection || isEmpty) {
            e.preventDefault();
            e.stopPropagation();
            deleteTextBox(selectedTextBox);
            saveEditorState('delete_textbox');
          }
        }

        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedShape) {
          e.preventDefault();
          e.stopPropagation();
          deleteShape(selectedShape);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedChart) {
          e.preventDefault();
          e.stopPropagation();
          deleteChart(selectedChart);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedImage) {
          e.preventDefault();
          e.stopPropagation();
          deleteImage(selectedImage);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedVideo) {
          e.preventDefault();
          e.stopPropagation();
          deleteVideo(selectedVideo);
        }
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTable) {
          // Check if any table cells are selected
          const selectedCells = getTableSelectedCells(selectedTable);
          if (selectedCells && selectedCells.length > 0) {
            // Check if user is actively editing text within a selected cell
            const activeElement = document.activeElement;
            const isActivelyEditing = activeElement && 
                                     activeElement.isContentEditable && 
                                     activeElement.closest('.table-element') &&
                                     selectedCells.includes(activeElement);
            
            if (isActivelyEditing) {
              // Check if there's text selection or if cell is empty
              const selection = window.getSelection();
              const hasTextSelection = selection && selection.toString().length > 0;
              const isEmpty = !activeElement.textContent.trim();
              
              // Only clear cell if no text is selected or cell is empty
              if (!hasTextSelection || isEmpty) {
                e.preventDefault();
                e.stopPropagation();
                selectedCells.forEach((cell) => {
                  cell.textContent = '';
                  if (document.activeElement === cell) {
                    cell.blur();
                  }
                });
                clearTableSelection(selectedTable);
                capture();
                saveEditorState('delete_table_cell');
                return;
              }
              // Otherwise, allow normal text editing (don't prevent default)
            } else {
              // Cell is selected but not being edited - clear it
              e.preventDefault();
              e.stopPropagation();
              selectedCells.forEach((cell) => {
                cell.textContent = '';
                if (document.activeElement === cell) {
                  cell.blur();
                }
              });
              clearTableSelection(selectedTable);
              capture();
              saveEditorState('delete_table_cell');
              return;
            }
          }
          // If no cells selected and not editing, delete the entire table
          if (!editingTableCell) {
            e.preventDefault();
            e.stopPropagation();
            deleteTable(selectedTable);
          }
        }
      });
      
      // Back (Undo) button click handler
      document.getElementById('btnBack').addEventListener('click', () => {
        undoLastAction();
      });
      
      // Forward (Redo) button click handler
      document.getElementById('btnForward').addEventListener('click', () => {
        redoLastAction();
      });
      
      // Redo functionality
      function redoLastAction() {
        if (redoStack.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const coords = getElementCanvasCoordinates(box);
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: coords.top,
                    left: coords.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                    display: box.style.display,
                    rotation: parseFloat(box.dataset.rotation || '0') || 0,
                    minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                    minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData(),
            charts: collectChartsData(),
              tables: collectTablesData(),
              images: collectImagesData(),
              videos: collectVideosData()
            }
          };
          
          // Save current state to undo stack
          actionHistory.push(currentState);
          
          // Get next state from redo stack
          const nextState = redoStack.pop();
          restoreEditorState(nextState);
        }
      }
      
      const initializeToolbarTabs = () => {
        const toolbar = document.getElementById('toolbar');
        if (!toolbar) return;

        const tabButtons = Array.from(toolbar.querySelectorAll('[data-tab-target]'));
        const panels = Array.from(toolbar.querySelectorAll('[data-tab-panel]'));

        if (!tabButtons.length || !panels.length) {
          return;
        }

        const activateTab = (targetName) => {
          const fallback = tabButtons[0]?.dataset.tabTarget;
          const tabToActivate = targetName || fallback || null;

          if (!tabToActivate) {
            return;
          }

          tabButtons.forEach((button) => {
            const isActive = button.dataset.tabTarget === tabToActivate;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-selected', String(isActive));
            button.setAttribute('tabindex', isActive ? '0' : '-1');
          });

          panels.forEach((panel) => {
            const isActive = panel.dataset.tabPanel === tabToActivate;
            panel.classList.toggle('active', isActive);
            if (isActive) {
              panel.removeAttribute('hidden');
            } else {
              panel.setAttribute('hidden', '');
            }
            panel.setAttribute('aria-hidden', String(!isActive));
          });
          if (typeof hideAnimationSequencePanel === 'function' && tabToActivate !== 'animations') {
            hideAnimationSequencePanel();
          }
        };

        const focusTabByOffset = (currentButton, offset) => {
          if (!tabButtons.length) return;
          const currentIndex = tabButtons.indexOf(currentButton);
          if (currentIndex === -1) return;
          const nextIndex = (currentIndex + offset + tabButtons.length) % tabButtons.length;
          const nextButton = tabButtons[nextIndex];
          if (!nextButton) return;
          nextButton.focus();
          activateTab(nextButton.dataset.tabTarget);
        };

        tabButtons.forEach((button) => {
          button.addEventListener('click', () => {
            activateTab(button.dataset.tabTarget);
          });

          button.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
              event.preventDefault();
              focusTabByOffset(button, 1);
              return;
            }

            if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
              event.preventDefault();
              focusTabByOffset(button, -1);
              return;
            }

            if (event.key === 'Home') {
              event.preventDefault();
              const firstTab = tabButtons[0];
              if (firstTab) {
                firstTab.focus();
                activateTab(firstTab.dataset.tabTarget);
              }
              return;
            }

            if (event.key === 'End') {
              event.preventDefault();
              const lastTab = tabButtons[tabButtons.length - 1];
              if (lastTab) {
                lastTab.focus();
                activateTab(lastTab.dataset.tabTarget);
              }
            }
          });
        });

        activateTab('home');
      };

      initializeToolbarTabs();
      initializeSpellCheckControls();

      if (insertNewSlideButton) {
        insertNewSlideButton.addEventListener('click', (event) => {
          event.preventDefault();
          createNewSlide(active);
        });
      }

      if (transitionEffectSelect) {
        transitionEffectSelect.addEventListener('change', () => {
          const durationValue = transitionDurationInput
            ? clampTransitionDuration(transitionDurationInput.value)
            : DEFAULT_TRANSITION_DURATION;
          if (transitionDurationInput) {
            transitionDurationInput.value = durationValue.toFixed(1);
          }
          updateActiveSlideTransition(transitionEffectSelect.value, durationValue, { recordHistory: true });
        });
      }

      if (transitionDurationInput) {
        const commitDurationChange = () => {
          const durationValue = clampTransitionDuration(transitionDurationInput.value);
          transitionDurationInput.value = durationValue.toFixed(1);
          const effectValue = transitionEffectSelect ? transitionEffectSelect.value : slides[active]?.transition;
          updateActiveSlideTransition(effectValue, durationValue, { recordHistory: true });
        };
        transitionDurationInput.addEventListener('change', commitDurationChange);
        transitionDurationInput.addEventListener('blur', commitDurationChange);
      }

      if (applyTransitionAllButton) {
        applyTransitionAllButton.addEventListener('click', () => {
          const effectValue = transitionEffectSelect ? transitionEffectSelect.value : DEFAULT_TRANSITION;
          const durationValue = transitionDurationInput
            ? clampTransitionDuration(transitionDurationInput.value)
            : DEFAULT_TRANSITION_DURATION;
          if (transitionDurationInput) {
            transitionDurationInput.value = durationValue.toFixed(1);
          }
          const normalizedEffect = normalizeTransitionEffect(effectValue);
          const hasChanges = slides.some((slide) => {
            const config = getSlideTransitionConfig(slide);
            return config.effect !== normalizedEffect || config.duration !== durationValue;
          });
          if (!hasChanges) {
            showNotification('All slides already use this transition');
            return;
          }
          capture();
          slides.forEach((slide) => applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: durationValue }));
          saveEditorState('change_transition_all');
          refreshAllTransitionButtons();
          syncTransitionControlsWithSlide();
          refreshSidebarSoon();
          showNotification('Applied transition to all slides');
        });
      }

      if (assignAnimationButton) {
        assignAnimationButton.addEventListener('click', (event) => {
          event.preventDefault();
          assignAnimationToSelectedElement();
        });
      }

      if (removeAnimationButton) {
        removeAnimationButton.addEventListener('click', (event) => {
          event.preventDefault();
          removeAnimationFromSelection();
        });
      }

      if (animationSequenceCloseButton) {
        animationSequenceCloseButton.addEventListener('click', (event) => {
          event.preventDefault();
          hideAnimationSequencePanel();
        });
      }

      // Formatting tools
      document.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const action = btn.getAttribute('data-action');
          
          // Handle addTextBox action
          if (action === 'addTextBox') {
            addTextBox();
            return;
          }
          if (action === 'present') {
            startPresentation();
            return;
          }
          
          const activeEl = getActiveElement();
          
          // Focus on the active element if needed
          if (activeEl === titleBox || activeEl === textBox || titleBox.contains(activeEl) || textBox.contains(activeEl)) {
            if (titleBox.contains(activeEl) || activeEl === titleBox) {
              titleBox.focus();
            } else {
              textBox.focus();
            }
          }

          // Execute command
          if (action === 'bold') document.execCommand('bold', false);
          else if (action === 'italic') document.execCommand('italic', false);
          else if (action === 'underline') document.execCommand('underline', false);
          else if (action === 'strikeThrough') document.execCommand('strikeThrough', false);
          else if (action === 'superscript') document.execCommand('superscript', false);
          else if (action === 'subscript') document.execCommand('subscript', false);
          else if (action === 'justifyLeft') document.execCommand('justifyLeft', false);
          else if (action === 'justifyCenter') document.execCommand('justifyCenter', false);
          else if (action === 'justifyRight') document.execCommand('justifyRight', false);
          else if (action === 'justifyFull') document.execCommand('justifyFull', false);
          else if (action === 'insertUnorderedList') document.execCommand('insertUnorderedList', false);
          else if (action === 'insertOrderedList') document.execCommand('insertOrderedList', false);
        });
      });

      // Store font sizes for elements
      let titleFontSize = 28;
      let textFontSize = 16;
      let elementFontSizes = new Map(); // Store font sizes for dynamically created elements
      let elementFontFamilies = new Map();
      let currentActiveElement = textBox;

      // Initialize default font sizes
      titleBox.style.fontSize = titleFontSize + 'px';
      textBox.style.fontSize = textFontSize + 'px';
      elementFontSizes.set(titleBox, titleFontSize);
      elementFontSizes.set(textBox, textFontSize);
      titleBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      textBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      elementFontFamilies.set(titleBox, DEFAULT_FONT_FAMILY);
      elementFontFamilies.set(textBox, DEFAULT_FONT_FAMILY);

      // Function to get current font size from an element
      function getCurrentFontSize(element) {
        if (elementFontSizes.has(element)) {
          return elementFontSizes.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseFloat(computedStyle.fontSize);
        return Math.round(fontSize);
      }

      function getCurrentFontFamily(element) {
        if (!element) return DEFAULT_FONT_FAMILY;
        if (elementFontFamilies.has(element)) {
          return elementFontFamilies.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        return computedStyle.fontFamily || DEFAULT_FONT_FAMILY;
      }

      // Function to apply font size to an element
      function applyFontSize(element, size) {
        const selection = window.getSelection();
        
        // If there's selected text in the element, apply font size to selection
        if (selection.rangeCount > 0 && !selection.isCollapsed && 
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = size + 'px';
          
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
          } catch (e) {
            document.execCommand("fontSize", false, "7");
            setTimeout(() => {
              const fonts = element.getElementsByTagName("font");
              for (let i = fonts.length - 1; i >= 0; i--) {
                if (fonts[i].size === "7") {
                  const newSpan = document.createElement('span');
                  newSpan.style.fontSize = size + 'px';
                  newSpan.innerHTML = fonts[i].innerHTML;
                  fonts[i].parentNode.replaceChild(newSpan, fonts[i]);
                }
              }
            }, 10);
          }
        } else {
          // No selection - apply font size to the entire element
          element.style.fontSize = size + 'px';
          
          // Wrap existing text nodes in spans to preserve formatting
          const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
          const textNodes = [];
          let node;
          while (node = walker.nextNode()) {
            const parent = node.parentElement;
            if (!parent || !parent.style.fontSize) {
              textNodes.push(node);
            }
          }
          
          textNodes.forEach(textNode => {
            if (textNode.textContent.trim()) {
              const span = document.createElement('span');
              span.style.fontSize = size + 'px';
              span.textContent = textNode.textContent;
              textNode.parentNode.replaceChild(span, textNode);
            }
          });
        }
        
        // Store the font size for this element
        elementFontSizes.set(element, size);
      }

      function applyFontFamily(element, family) {
        const selection = window.getSelection();
        const normalizedFamily = family || DEFAULT_FONT_FAMILY;

        if (selection.rangeCount > 0 && !selection.isCollapsed &&
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          document.execCommand('fontName', false, normalizedFamily);
        } else {
          element.style.fontFamily = normalizedFamily;
        }

        elementFontFamilies.set(element, normalizedFamily);
      }

      // Update font size input when focus changes
      function updateFontSizeInput() {
        const fontSizeInput = document.getElementById('fontSize');
        if (currentActiveElement) {
          const currentSize = getCurrentFontSize(currentActiveElement);
          fontSizeInput.value = currentSize;
        }
      }

      function updateFontPickerSelectedFont() {
        if (!fontPickerButton || !fontPickerLabel) return;
        const fontFamily = getCurrentFontFamily(currentActiveElement);
        const normalized = normalizeFontStack(fontFamily);
        const name = fontStackToName.get(normalized) || extractPrimaryFontName(fontFamily);
        fontPickerButton.style.fontFamily = fontFamily;
        fontPickerLabel.style.fontFamily = fontFamily;
        fontPickerLabel.textContent = name;
        fontPickerButton.setAttribute('title', `Font Family: ${name}`);
        fontPickerButton.setAttribute('aria-label', `Font Family: ${name}`);
        setActiveFontOption(fontFamily);
      }

      // Track focus changes for any contenteditable element
      function setupFontSizeTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
        });
        
        // Initialize font size if not set
        if (!elementFontSizes.has(element)) {
          const currentSize = parseFloat(window.getComputedStyle(element).fontSize) || 16;
          elementFontSizes.set(element, Math.round(currentSize));
        }
      }

      function setupFontFamilyTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          if (!elementFontFamilies.has(element)) {
            elementFontFamilies.set(element, getCurrentFontFamily(element));
          }
          updateFontPickerSelectedFont();
        });

        if (!elementFontFamilies.has(element)) {
          elementFontFamilies.set(element, getCurrentFontFamily(element));
        }
      }

      function applyFontFamilyToCurrent(fontFamily) {
        if (!currentActiveElement) {
          currentActiveElement = textBox;
        }
        applyFontFamily(currentActiveElement, fontFamily);
        updateFontPickerSelectedFont();
        capture();
        saveEditorState('change_font_family');
      }

      // Track focus changes for existing elements
      setupFontSizeTracking(titleBox);
      setupFontSizeTracking(textBox);
      setupFontFamilyTracking(titleBox);
      setupFontFamilyTracking(textBox);

      // Also check on selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          
          // Find which contenteditable element contains the selection
          let activeEl = null;
          if (titleBox.contains(anchorNode) || anchorNode === titleBox) {
            activeEl = titleBox;
          } else if (textBox.contains(anchorNode) || anchorNode === textBox) {
            activeEl = textBox;
          } else {
            // Check additional text boxes
            const allTextBoxes = document.querySelectorAll('.additional-text-box, .text-box');
            allTextBoxes.forEach(box => {
              if (box.contains(anchorNode) || anchorNode === box) {
                activeEl = box;
              }
            });
          }
          
          if (activeEl && currentActiveElement !== activeEl) {
            currentActiveElement = activeEl;
            updateFontSizeInput();
            updateFontPickerSelectedFont();
          }
        }
      });

      // Font size input change handler
      const fontSizeInput = document.getElementById('fontSize');
      fontSizeInput.addEventListener('change', (e) => {
        const size = parseInt(e.target.value);
        if (!isNaN(size) && size >= 8 && size <= 72 && currentActiveElement) {
          applyFontSize(currentActiveElement, size);
          
          // Update stored sizes for title and main text box
          if (currentActiveElement === titleBox) {
            titleFontSize = size;
          } else if (currentActiveElement === textBox) {
            textFontSize = size;
          }
        }
      });
      
      // Validate input on blur
      fontSizeInput.addEventListener('blur', (e) => {
        if (!currentActiveElement) return;
        
        const size = parseInt(e.target.value);
        const currentSize = getCurrentFontSize(currentActiveElement);
        
        if (isNaN(size) || size < 8) {
          e.target.value = currentSize;
        } else if (size > 72) {
          e.target.value = 72;
          applyFontSize(currentActiveElement, 72);
          
          // Update stored sizes
          if (currentActiveElement === titleBox) {
            titleFontSize = 72;
          } else if (currentActiveElement === textBox) {
            textFontSize = 72;
          }
        }
      });

      // Initialize the input value
      updateFontSizeInput();
      updateFontPickerSelectedFont();

      function attachColorInputHandlers() {
        const fontColorInput = document.getElementById('fontColor');
        const highlightColorInput = document.getElementById('highlightColor');

        if (!fontColorInput || !highlightColorInput) {
          requestAnimationFrame(attachColorInputHandlers);
          return;
        }

        if (!fontColorInput.dataset.bound) {
          fontColorInput.addEventListener('change', (e) => {
            document.execCommand('foreColor', false, e.target.value);
          });
          fontColorInput.dataset.bound = 'true';
        }

        if (!highlightColorInput.dataset.bound) {
          highlightColorInput.addEventListener('change', (e) => {
            document.execCommand('backColor', false, e.target.value);
          });
          highlightColorInput.dataset.bound = 'true';
        }
      }
      attachColorInputHandlers();

      document.addEventListener('apply-text-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#000000';
        document.execCommand('foreColor', false, color);
      });

      document.addEventListener('apply-bg-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#ffff00';
        const targetTable = selectedTable && getTableSelectedCells(selectedTable).length
          ? selectedTable
          : null;
        if (targetTable) {
          const cells = getTableSelectedCells(targetTable);
          if (cells.length) {
            const normalized = normalizeColorHex(color);
            cells.forEach((cell) => {
              cell.style.backgroundColor = normalized;
            });
            capture();
            saveEditorState('color_table_cells');
            return;
          }
        }
        document.execCommand('backColor', false, color);
      });

      // Save function per Editor.json and auth_system.json
      function savePresentation() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        if (!currentUser) {
          if (isGuest) {
            alert('Please sign in to save presentations. Guests can only view and edit.');
            return;
          }
          alert('Please log in to save presentations.');
          window.location.href = './templates.html';
          return;
        }

        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.textContent.trim() || "";
        
        // Save to user-specific key per auth_system.json
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        saved.push({
          title: title,
          date: new Date().toISOString().split("T")[0],
          content: content
        });
        
        localStorage.setItem(userKey, JSON.stringify(saved));
        
        // Show notification animation
        showNotification('Presentation saved!');
      }

      // Topbar button actions per slides.json
      document.getElementById('btnDel').addEventListener('click', () => {
        deleteSlide(active);
      });

      document.getElementById('btnReset').addEventListener('click', () => {
        if (confirm('Reset all slides? This cannot be undone.')) {
          saveEditorState('reset_slides');
          const resetSlide = createEmptySlide();
          resetSlide.transition = DEFAULT_TRANSITION;
          resetSlide.transitionDuration = DEFAULT_TRANSITION_DURATION;
          slides.splice(0, slides.length, resetSlide);
          active = 0;
          load();
          renderSidebar();
          updateSlideCanvasMenuState();
        }
      });

      document.getElementById('btnSave').addEventListener('click', savePresentation);

      document.getElementById('btnHome').addEventListener('click', () => {
        capture();
        window.location.href = './templates.html';
      });

      // Hover button functions per Editor.json slidePreview
      function createNewSlide(index) {
        capture();
        saveEditorState('create_slide');
        const newSlide = createEmptySlide();
        newSlide.transition = DEFAULT_TRANSITION;
        newSlide.transitionDuration = DEFAULT_TRANSITION_DURATION;
        slides.splice(index + 1, 0, newSlide);
        active = index + 1;
        load();
        renderSidebar();
        updateSlideCanvasMenuState();
      }

      function duplicateCurrentSlide(index) {
        capture();
        saveEditorState('duplicate_slide');
        const s = slides[index];
        const duplicatedAnimations = Array.isArray(s.animations)
          ? sortSlideAnimations(s).map((anim, idx) => ({
              id: generateElementId('anim'),
              targetId: anim.targetId,
              effect: normalizeAnimationEffect(anim.effect),
              duration: clampAnimationDuration(anim.duration ?? DEFAULT_ANIMATION_DURATION),
              order: idx + 1
            }))
          : [];
        slides.splice(index + 1, 0, { 
          title: s.title ? `${s.title} copy` : '',
          content: s.content,
          titleBox: s.titleBox ? {...s.titleBox} : { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
          textBox: s.textBox ? {...s.textBox} : { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
          titleFontFamily: s.titleFontFamily || DEFAULT_FONT_STACK,
          textFontFamily: s.textFontFamily || DEFAULT_FONT_STACK,
          shapes: s.shapes ? JSON.parse(JSON.stringify(s.shapes)) : [],
          additionalTextBoxes: s.additionalTextBoxes ? JSON.parse(JSON.stringify(s.additionalTextBoxes)) : [],
        tables: s.tables ? JSON.parse(JSON.stringify(s.tables)) : [],
        images: s.images ? JSON.parse(JSON.stringify(s.images)) : [],
        videos: s.videos ? JSON.parse(JSON.stringify(s.videos)) : [],
        comments: s.comments ? JSON.parse(JSON.stringify(s.comments)) : [],
        animations: duplicatedAnimations,
        transition: normalizeTransitionEffect(s.transition),
        transitionDuration: clampTransitionDuration(s.transitionDuration),
        background: s.background ? { ...s.background } : { image: '', size: '', position: '', repeat: '' }
        });
        active = index + 1;
        load();
        renderSidebar();
        updateSlideCanvasMenuState();
      }

      // Auto-save on input with debounce for undo
      let textEditTimeout;
      function saveTextEditState() {
        clearTimeout(textEditTimeout);
        textEditTimeout = setTimeout(() => {
          saveEditorState('edit_text');
        }, 1000); // Save state 1 second after typing stops
      }
      
      titleBox.addEventListener('input', () => {
        if (titleBox.style.display === 'none') return;
        slides[active].title = titleBox.textContent.trim();
        renderSidebar();
        saveTextEditState();
      });
      textBox.addEventListener('input', () => {
        if (textBox.style.display === 'none') return;
        slides[active].content = textBox.textContent.trim();
        saveTextEditState();
      });
      
      // Also track input on additional text boxes
      document.addEventListener('input', (e) => {
        if (e.target.classList && e.target.classList.contains('additional-text-box')) {
          saveTextEditState();
        }
      });

      // Check if loading a saved presentation from Recent section
      const loadPres = sessionStorage.getItem('loadPresentation');
      if (loadPres) {
        try {
          const pres = JSON.parse(loadPres);
          // Set the title and content from saved presentation
          slides[0].title = pres.title || slides[0].title || '';
          slides[0].content = pres.content || '';
          sessionStorage.removeItem('loadPresentation'); // Clear after loading
        } catch (e) {
          console.error('Error loading presentation:', e);
        }
      }

      // Load and apply saved background color from settings
      const savedBg = localStorage.getItem('siteBackgroundColor');
      if (savedBg) {
        if (savedBg === '#000000') {
          document.body.classList.add('dark-theme');
          document.body.style.background = '';
          document.body.style.color = '';
        } else if (savedBg === '#ffffff') {
          document.body.classList.add('light-mode');
          document.body.style.background = '';
          document.body.style.color = '';
        } else {
          document.body.style.background = savedBg;
        }
      }

      // Listen for background color updates from settings page
      window.addEventListener('message', (e) => {
        if (e.data.type === 'updateBackground') {
          const color = e.data.color;
          document.body.classList.remove('dark-theme', 'light-mode');
          
          if (color === '#000000') {
            document.body.classList.add('dark-theme');
            document.body.style.background = '';
            document.body.style.color = '';
          } else if (color === '#ffffff') {
            document.body.classList.add('light-mode');
            document.body.style.background = '';
            document.body.style.color = '';
          } else {
            document.body.style.background = color;
            if (color !== '#0b3d2e') {
              document.body.style.color = '#e8f5e9';
            }
          }
        }
      });

      // Init
      renderSidebar();
      load();
      updateSlideCanvasMenuState();
      updateElementContextMenuState();

    </script>
  </body>
  </html>
