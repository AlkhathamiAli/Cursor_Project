<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SlideMaker â€¢ Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;600&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Source+Sans+Pro:wght@400;600&family=Nunito:wght@400;600&family=Raleway:wght@400;600&family=Oswald:wght@400;600&family=Fira+Sans:wght@400;600&family=Fira+Code:wght@400;500&family=IBM+Plex+Mono:wght@400;600&family=Cabin:wght@400;600&family=Pacifico&family=Dancing+Script:wght@400;600&family=Great+Vibes&family=Bebas+Neue&family=Raleway+Dots&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="./assets/theme.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNa5lGdQDzFv1NNpJBWlAbIYW/W2PASi6DPd7OJbRRqtD9h5pz50jdK5Zk90un0nLBKBPXn1HULICwhf66A86A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-/PHX0JrB9c4ZzG3eHn2sFTNK1VNHYsYAGdivgLPgAvFp8ZUBKbjsggq09uXBJgp7wa9u0edPFpKnz03Wx/ju0RduCMsZ/H6GfPmw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" integrity="sha512-4R7n2sFTNK1VNHYsYAGdivgLPgAvFp8ZUBKbjsggq09uXBJgp7wa9u0edPFpKnz03Wx/ju0RduCMsZ/H6GfPmw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pptxgenjs/3.12.0/pptxgen.bundle.min.js" integrity="sha512-F8+aoCA8DmF5asJQHKqGmMwakyfeG5edDx9yv7zhtfQczr6gs3qK1D7w+l0kcRAg1WoljzWEGngZFV3nC8slVQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="./style.css">
    <style>
      :root {
        --bg: #ffffff;
        --panel: #f9fafb;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --accent: #1a73e8;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

      .topbar .toolbar-pill { min-width: 48px; }
      .topbar .toolbar-spacer { flex: 1; }

      .editor-topbar {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .editor-main {
        display: flex;
        flex-direction: column;
        gap: 24px;
        box-sizing: border-box;
      }
      .slide-item { 
        position: relative; 
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.3s ease;
      }
      .slide-item.dragging {
        opacity: 0.6;
        transform: scale(0.98);
      }
      .slide-preview { 
        background: rgba(255, 255, 255, 0.05); 
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px; 
        padding: 10px 14px; 
        cursor:pointer; 
        transition: all 0.3s ease; 
        color: #e8f5e9; 
        width: 100%;
      }
      .slide-preview:hover { background: rgba(255, 255, 255, 0.1); }
      .slide-preview.active { outline:2px solid #2ecc71; background: rgba(46, 204, 113, 0.2); }
      .slide-preview.drop-target {
        border-color: rgba(46, 213, 115, 0.65);
        background: rgba(46, 213, 115, 0.15);
      }
      .slide-preview.drop-target-before {
        box-shadow: inset 0 3px 0 rgba(46, 213, 115, 0.85);
      }
      .slide-preview.drop-target-after {
        box-shadow: inset 0 -3px 0 rgba(46, 213, 115, 0.85);
      }
      .transition-control-button {
        background: rgba(20, 60, 45, 0.9);
        border: 1px solid rgba(46, 213, 115, 0.35);
        color: #bbf7d0;
        font-size: 14px;
        border-radius: 8px;
        padding: 6px 8px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 40px;
        justify-content: center;
      }
      .transition-control-button .transition-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-icon i {
        font-size: 12px;
      }
      .transition-control-button .transition-icon svg {
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-caret {
        font-size: 10px;
        opacity: 0.75;
        margin-left: 0;
      }
      .transition-control-button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #22c55e;
        transform: translateY(-1px);
      }
      .transition-control-button.disabled,
      .transition-control-button:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none;
      }
      .transition-control-button.disabled:hover,
      .transition-control-button:disabled:hover {
        background: rgba(20, 60, 45, 0.9);
        color: #bbf7d0;
      }
      .transition-select {
        min-width: 150px;
      }
      .transition-select option {
        color: #111827;
      }
      .slide-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 140px;
        padding: 6px 0;
        background: rgba(8, 45, 30, 0.95);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        z-index: 5000;
      }
      .slide-context-menu.show {
        display: flex;
      }
      .slide-context-menu button {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 14px;
        text-align: left;
        padding: 10px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .slide-context-menu button:hover {
        background: rgba(46, 213, 115, 0.2);
        transform: translateX(2px);
      }
      .slide-context-menu button.active {
        background: rgba(46, 213, 115, 0.25);
        color: #22c55e;
      }
      .slide-action-bar { 
        margin-top: 6px;
        display: flex;
        justify-content: center;
        gap: 8px;
        background: rgba(10, 60, 40, 0.9);
        border-radius: 8px;
        padding: 6px 0;
        height: 0;
        overflow: hidden;
        opacity: 0;
        transform: scaleY(0);
        transform-origin: top;
        transition: all 0.3s ease-in-out;
        width: 100%;
      }
      .slide-item:hover .slide-action-bar {
        height: auto;
        opacity: 1;
        transform: scaleY(1);
        margin-bottom: 10px;
      }
      .slide-action-bar button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-size: 17px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 36px;
      }
      .slide-action-bar button:hover {
        background: rgba(46, 213, 115, 0.25);
        color: #2ed573;
        transform: scale(1.1);
      }
      .slide-action-bar button i {
        font-size: 16px;
      }
      .slide-preview-title {
        display: block;
        font-weight: 600;
        font-size: 14px;
        letter-spacing: 0.3px;
      }
      .slide-preview-title.editing {
        background: rgba(46, 213, 115, 0.16);
        outline: 2px solid rgba(46, 213, 115, 0.7);
        border-radius: 6px;
        padding: 2px 6px;
        color: #e8f5e9;
      }

      /* Dark metallic gradient background */
      body.dark-theme {
        background: linear-gradient(135deg, #0b0b0b 0%, #0d0d0d 40%, #000000 100%) !important;
        background-attachment: fixed;
        background-repeat: no-repeat;
        background-size: cover;
        color: #eaeaea;
        position: relative;
      }

      body.dark-theme::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.05), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }

      body.dark-theme > * {
        position: relative;
        z-index: 1;
      }

      /* Light mode background with frosted glass effect */
      body.light-mode {
        background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,240,240,0.8)) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #1a1a1a;
        transition: all 0.3s ease-in-out;
        position: relative;
      }

      body.light-mode > * {
        position: relative;
        z-index: 1;
      }

      /* Card or container glass effect in light mode */
      body.light-mode .editor {
        background: rgba(255, 255, 255, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
      }

      /* Navigation and text colors in light mode */
      body.light-mode .tool,
      body.light-mode .tool-select,
      body.light-mode .slide-preview {
        color: #1a1a1a !important;
      }

      body.light-mode .slide-preview {
        background: rgba(255, 255, 255, 0.4);
        border-color: rgba(0, 0, 0, 0.15);
      }

      body.light-mode .tool-select::placeholder {
        color: #666 !important;
      }

      body.light-mode .title-box,
      body.light-mode .text-box {
        color: #000000 !important;
      }

      body.light-mode .topbar {
        color: #1a1a1a !important;
      }

      .editor { display:grid; grid-template-rows: auto 1fr; background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border-radius:12px; box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2); }
      .toolbar { 
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        background: rgba(5, 60, 35, 0.95);
        padding: 10px 20px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        flex-wrap: wrap;
      }
      .tool { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        font-weight: 600;
        font-size: 15px;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        min-width: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.22s ease, box-shadow 0.3s ease, background 0.3s ease, border-color 0.3s ease;
      }
      .tool.present-button {
        margin-left: 12px;
        padding: 8px 16px;
        gap: 0;
        font-size: 15px;
        border: 2px solid rgba(255, 255, 255, 0.65);
        background: transparent;
        color: #f8fafc;
        min-width: 52px;
      }
      .tool.present-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.85);
        transform: translateY(-1px);
      }
      .tool.present-button svg {
        width: 18px;
        height: 18px;
        display: block;
      }
      .tool:hover,
      .tool:focus-visible { 
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px) scale(1.03);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      }
      .canvas {
        opacity: 0;
        transform: translateY(24px);
        animation: canvasReveal 0.9s ease forwards;
        animation-delay: 0.15s;
      }
      .canvas.exporting {
        pointer-events: none;
      }
      .canvas.exporting .resize-edge {
        display: none !important;
      }
      .canvas.exporting .title-box,
      .canvas.exporting .text-box,
      .canvas.exporting .additional-text-box {
        border-color: transparent !important;
        box-shadow: none !important;
      }

      .export-modal {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(0, 20, 15, 0.68);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        align-items: center;
        justify-content: center;
        z-index: 4500;
      }
      .export-modal.show {
        display: flex;
      }
      .export-dialog {
        background: rgba(3, 32, 23, 0.95);
        border: 1px solid rgba(0, 222, 168, 0.2);
        border-radius: 18px;
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
        width: min(440px, 92vw);
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 18px;
        color: #e8f5e9;
      }
    .export-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .export-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .export-field label {
      font-size: 0.9rem;
      font-weight: 600;
      color: rgba(200, 240, 225, 0.86);
    }
    .export-field input {
      background: rgba(3, 45, 30, 0.82);
      border: 1px solid rgba(0, 222, 168, 0.25);
      border-radius: 12px;
      padding: 12px;
      color: #e8f5e9;
      font-size: 1rem;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }
    .export-field input:focus {
      outline: none;
      border-color: rgba(0, 222, 168, 0.55);
      box-shadow: 0 0 0 2px rgba(0, 222, 168, 0.25);
    }
      .export-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .export-header h2 {
        margin: 0;
        font-size: 1.25rem;
      }
      .export-close {
        border: none;
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.3s ease;
      }
      .export-close:hover {
        background: rgba(0, 200, 120, 0.35);
        transform: scale(1.05);
      }
      .export-options {
        display: grid;
        gap: 12px;
      }
      .export-option {
      position: relative;
        display: flex;
        align-items: flex-start;
        gap: 14px;
        border: 1px solid rgba(0, 255, 170, 0.2);
        background: rgba(4, 60, 40, 0.55);
        border-radius: 14px;
        padding: 14px 16px;
        cursor: pointer;
        text-align: left;
        transition: transform 0.2s ease, box-shadow 0.3s ease, border 0.3s ease, background 0.3s ease;
        color: inherit;
        font: inherit;
      }
    .export-option-input {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(0, 222, 168, 0.55);
      margin-top: 4px;
      position: relative;
      cursor: pointer;
      flex-shrink: 0;
    }
    .export-option-input::after {
      content: '';
      position: absolute;
      inset: 3px;
      border-radius: 50%;
      background: rgba(0, 222, 168, 0.85);
      transform: scale(0);
      transition: transform 0.2s ease;
    }
    .export-option-input:checked::after {
      transform: scale(1);
    }
    .export-option:hover,
    .export-option:focus-within {
        transform: translateY(-2px);
        border-color: rgba(0, 222, 168, 0.55);
        background: rgba(5, 85, 54, 0.8);
        box-shadow: 0 14px 38px rgba(0, 222, 168, 0.25);
      }
    .export-option.active {
      border-color: rgba(0, 222, 168, 0.65);
      background: rgba(5, 90, 56, 0.92);
      box-shadow: 0 16px 38px rgba(0, 222, 168, 0.35);
    }
    .export-option-details {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
      .export-option-label {
        font-weight: 600;
        font-size: 1rem;
      }
      .export-option-note {
        color: rgba(200, 240, 225, 0.7);
        font-size: 0.85rem;
      }
      .export-option-kicker {
        font-weight: 600;
        font-size: 0.9rem;
        color: rgba(0, 222, 168, 0.85);
        min-width: 44px;
      }
      .export-footer {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      @keyframes canvasReveal {
        0% { opacity: 0; transform: translateY(24px); }
        100% { opacity: 1; transform: translateY(0); }
      }
      .tool.active { 
        background: #1c7c54;
        color: #fff;
        border-color: #2ed573;
      }
      .tool i {
        font-size: 14px;
      }
      .tool svg {
        width: 18px;
        height: 18px;
      }
      .font-picker-button {
        position: relative;
        min-width: 140px;
        padding: 8px 16px;
        justify-content: center;
      }
      .font-picker-label {
        font-size: 15px;
        font-weight: 600;
        line-height: 1.2;
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .color-controls {
        display: flex;
        gap: 8px;
      }
      .color-tool-button {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
        padding: 8px 12px;
      }
      .color-tool-button .color-bar {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 26px;
        height: 4px;
        border-radius: 999px;
        background: currentColor;
        border: 1px solid rgba(255, 255, 255, 0.3);
        pointer-events: none;
      }
      .font-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 220px;
        gap: 4px;
      }
      .font-dropdown.show {
        display: flex;
      }
      .font-option {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        text-align: left;
        transition: all 0.2s ease;
        font-size: 15px;
      }
      .font-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .font-option.active {
        background: #1c7c54;
        border-color: #2ed573;
        color: #fff;
      }
      .shape-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
      }
      .shape-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 240px;
        gap: 6px;
      }
      .shape-dropdown.show {
        display: flex;
      }
      .shape-option {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .shape-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .shape-option svg {
        width: 36px;
        height: 36px;
      }
      .shape-option-preview {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .shape-option-label {
        font-size: 15px;
        font-weight: 600;
      }
      .shape-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        color: #e8f5e9;
        user-select: none;
        transform-origin: center center;
      }
      .shape-element svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .text-box,
      .title-box,
      .additional-text-box {
        transform-origin: center center;
      }
      .shape-element.selected {
        outline: 2px solid #1a73e8;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .shape-element .resize-edge,
      .text-box .resize-edge,
      .title-box .resize-edge,
      .additional-text-box .resize-edge {
        position: absolute;
        border-radius: 50%;
        border: 2px solid rgba(14, 165, 233, 0.9);
        background: rgba(230, 249, 255, 0.98);
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
        opacity: 0;
        transform: translate(-50%, -50%);
        transition: opacity 0.15s ease;
      }
      .shape-element.selected .resize-edge,
      .text-box.selected .resize-edge,
      .title-box.selected .resize-edge,
      .additional-text-box.selected .resize-edge {
        opacity: 1;
      }
      .shape-element .resize-edge.side,
      .text-box .resize-edge.side,
      .title-box .resize-edge.side,
      .additional-text-box .resize-edge.side {
        width: 14px;
        height: 14px;
        background: rgba(219, 246, 255, 0.9);
      }
      .shape-element .resize-edge.corner,
      .text-box .resize-edge.corner,
      .title-box .resize-edge.corner,
      .additional-text-box .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-element .resize-edge.top,
      .text-box .resize-edge.top,
      .title-box .resize-edge.top,
      .additional-text-box .resize-edge.top {
        top: -12px;
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.bottom,
      .text-box .resize-edge.bottom,
      .title-box .resize-edge.bottom,
      .additional-text-box .resize-edge.bottom {
        top: calc(100% + 12px);
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.left,
      .text-box .resize-edge.left,
      .title-box .resize-edge.left,
      .additional-text-box .resize-edge.left {
        left: -12px;
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.right,
      .text-box .resize-edge.right,
      .title-box .resize-edge.right,
      .additional-text-box .resize-edge.right {
        left: calc(100% + 12px);
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.top-left,
      .text-box .resize-edge.top-left,
      .title-box .resize-edge.top-left,
      .additional-text-box .resize-edge.top-left {
        top: -16px;
        left: -16px;
        cursor: nwse-resize;
      }
      .shape-element .resize-edge.top-right,
      .text-box .resize-edge.top-right,
      .title-box .resize-edge.top-right,
      .additional-text-box .resize-edge.top-right {
        top: -16px;
        left: calc(100% + 16px);
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-left,
      .text-box .resize-edge.bottom-left,
      .title-box .resize-edge.bottom-left,
      .additional-text-box .resize-edge.bottom-left {
        top: calc(100% + 16px);
        left: -16px;
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-right,
      .text-box .resize-edge.bottom-right,
      .title-box .resize-edge.bottom-right,
      .additional-text-box .resize-edge.bottom-right {
        top: calc(100% + 18px);
        left: calc(100% + 18px);
        cursor: nwse-resize;
        background: linear-gradient(135deg, rgba(59,130,246,0.95), rgba(129,230,217,0.95));
        border-color: rgba(56, 189, 248, 0.85);
      }
      .shape-color-picker {
        position: fixed;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(4, 44, 28, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 6px;
        gap: 8px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        transform: translateY(8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 4100;
      }
      .shape-color-picker.visible {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .shape-rotation-handle {
        position: fixed;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: rgba(4, 44, 28, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transform: translateY(8px) scale(0.95);
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-rotation-handle.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0) scale(1);
      }
      .shape-rotation-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 2px solid rgba(59, 130, 246, 0.4);
        background: rgba(14, 116, 144, 0.2);
        color: #bae6fd;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }
      .shape-rotation-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.25);
      }
      .shape-rotation-button:active {
        cursor: grabbing;
        background: rgba(59, 130, 246, 0.35);
      }
      .shape-rotation-button i {
        pointer-events: none;
        font-size: 14px;
      }
      .shape-rotation-angle {
        font-size: 13px;
        font-weight: 600;
        color: #c4e3ff;
        letter-spacing: 0.4px;
        pointer-events: none;
      }
      .shape-size-badge {
        position: fixed;
        padding: 6px 12px;
        background: rgba(4, 44, 28, 0.95);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        color: #d1fae5;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.4px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.28);
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-size-badge.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .shape-color-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.12);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #0f172a;
        font-size: 16px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      .shape-color-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      }
      .shape-color-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      .tool-select { 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e8f5e9;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        font-weight: 600;
      }
      .tool-select::placeholder {
        color: rgba(232, 245, 233, 0.6);
      }
      .tool-select:hover {
        background: rgba(255, 255, 255, 0.25);
      }
      .tool-color { 
        width: 40px; 
        height: 36px; 
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px; 
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .tool-color:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
      }
      .color-picker-button {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(50%);
        white-space: nowrap;
        border: 0;
      }
      .canvas-wrap { display:grid; place-items:center; padding:24px; overflow:auto; }
      .canvas { width:min(92vw, 960px); aspect-ratio:16/9; background:#ffffff; border-radius:10px; box-shadow: 0 0 25px rgba(0, 0, 0, 0.25); padding:24px; position: relative; background-size: cover; background-position: center; background-repeat: no-repeat; transition: background 0.6s ease-in-out; }
      @keyframes slideFade {
        from { opacity: 0; transform: scale(0.98); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes slideSlide {
        from { opacity: 0; transform: translateX(35px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes slideZoom {
        from { opacity: 0; transform: scale(0.9); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes slideFlip {
        from { opacity: 0; transform: rotateX(45deg); transform-origin: center; }
        to { opacity: 1; transform: rotateX(0deg); transform-origin: center; }
      }
      @keyframes slideRotate {
        from { opacity: 0; transform: rotate(-12deg) scale(0.9); }
        to { opacity: 1; transform: rotate(0deg) scale(1); }
      }
      @keyframes slidePush {
        from { opacity: 0; transform: translateX(80px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes slideWipe {
        from { opacity: 0; clip-path: inset(0 100% 0 0); }
        to { opacity: 1; clip-path: inset(0 0 0 0); }
      }
      @keyframes slideSpin {
        from { opacity: 0; transform: rotateZ(-360deg) scale(0.8); }
        to { opacity: 1; transform: rotateZ(0deg) scale(1); }
      }
      @keyframes slideDissolve {
        0% { opacity: 0; filter: blur(18px); }
        50% { opacity: 0.5; filter: blur(8px); }
        100% { opacity: 1; filter: blur(0); }
      }
      @keyframes slideCube {
        from { opacity: 0; transform: perspective(1000px) rotateY(-65deg) translateX(-60px); transform-origin: left center; }
        to { opacity: 1; transform: perspective(1000px) rotateY(0deg) translateX(0); transform-origin: left center; }
      }
      @keyframes slideBounce {
        0% { opacity: 0; transform: translateY(60px) scale(0.95); }
        60% { opacity: 1; transform: translateY(-12px) scale(1.01); }
        85% { transform: translateY(6px) scale(0.995); }
        100% { transform: translateY(0) scale(1); }
      }
      @keyframes slideSwirl {
        from { opacity: 0; transform: rotate(18deg) scale(0.85); filter: saturate(0.6); }
        to { opacity: 1; transform: rotate(0deg) scale(1); filter: saturate(1); }
      }
      .presentation-stage .presentation-slide.transition-effect-fade { animation: slideFade 0.45s ease; }
      .presentation-stage .presentation-slide.transition-effect-slide { animation: slideSlide 0.5s ease; }
      .presentation-stage .presentation-slide.transition-effect-zoom { animation: slideZoom 0.5s ease; }
      .presentation-stage .presentation-slide.transition-effect-flip { animation: slideFlip 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-rotate { animation: slideRotate 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-push { animation: slidePush 0.55s ease; }
      .presentation-stage .presentation-slide.transition-effect-wipe { animation: slideWipe 0.55s ease; }
      .presentation-stage .presentation-slide.transition-effect-spin { animation: slideSpin 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-dissolve { animation: slideDissolve 0.6s ease; }
      .presentation-stage .presentation-slide.transition-effect-cube { animation: slideCube 0.65s ease; }
      .presentation-stage .presentation-slide.transition-effect-bounce { animation: slideBounce 0.65s ease; }
      .presentation-stage .presentation-slide.transition-effect-swirl { animation: slideSwirl 0.65s ease; }
      
      .presentation-overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: #000;
        z-index: 9999;
        color: #f9fafb;
      }
      .presentation-overlay.visible {
        display: block;
      }
      .presentation-stage {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #111;
      }
      .presentation-stage .presentation-slide {
        width: 100%;
        height: 100%;
        position: absolute;
        inset: 0;
        background: #fff;
        overflow: hidden;
      }
      .presentation-stage .title-box,
      .presentation-stage .text-box,
      .presentation-stage .additional-text-box {
        border: none !important;
        box-shadow: none !important;
        outline: none !important;
        cursor: default !important;
        user-select: none;
      }
      .presentation-stage .title-box::before,
      .presentation-stage .text-box::before,
      .presentation-stage .additional-text-box::before {
        display: none !important;
        content: none !important;
      }
      .presentation-stage .shape-element {
        outline: none !important;
        box-shadow: none !important;
        cursor: default !important;
      }
      .presentation-stage .resize-edge {
        display: none !important;
      }
      .presentation-overlay .presentation-meta {
        position: absolute;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 16px;
        font-size: 14px;
        letter-spacing: 0.4px;
        background: rgba(15, 23, 42, 0.5);
        padding: 10px 18px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay .presentation-meta span {
        display: flex;
        align-items: center;
        gap: 8px;
        text-transform: uppercase;
        font-weight: 600;
      }
      .presentation-overlay .presentation-counter {
        position: absolute;
        bottom: 32px;
        right: 40px;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.6px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay.show-controls .presentation-meta,
      .presentation-overlay.show-controls .presentation-counter {
        opacity: 1;
        pointer-events: auto;
      }
      body.presenting {
        overflow: hidden;
      }
      body.presenting .editor-topbar,
      body.presenting .editor-main,
      body.presenting .sidebar {
        visibility: hidden;
      }
      body.presenting .presentation-overlay {
        visibility: visible;
      }

      /* Template Background Styles */
      .canvas.marketing-template {
        background-image: url('./CURSOR-Project/Background/B1.avif');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.marketing-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.business-template {
        background-image: url('./CURSOR-Project/Background/business-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.business-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.education-template {
        background-image: url('./CURSOR-Project/Background/education-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.education-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.project-template {
        background-image: url('./CURSOR-Project/Background/project-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.project-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      /* Ensure content is above overlay */
      .canvas .title-box,
      .canvas .text-box {
        position: relative;
        z-index: 1;
      }
      
      .title-box,
      .text-box,
      .additional-text-box {
        background: transparent;
        border: 1px dashed transparent;
        border-radius: 14px;
        padding: 12px 16px;
        outline: none;
        color: #0f172a;
        white-space: pre-wrap;
        word-break: break-word;
        writing-mode: horizontal-tb;
        line-height: 1.45;
        display: block;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
      }
      
      /* Title box per Editor.json */
      .title-box {
        font-size: 28px;
        font-weight: 700;
        min-height: 50px;
        min-width: 200px;
        position: absolute;
        top: 24px;
        left: 24px;
        width: calc(100% - 48px);
      }
      .title-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .title-box:focus,
      .title-box.selected {
        border-color: rgba(0, 200, 120, 0.65);
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 3px rgba(0, 200, 120, 0.18);
      }
      .title-box:hover:not(.selected):not(:focus) {
        border-color: rgba(0, 200, 120, 0.35);
      }
      .title-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .title-box.resizing {
        user-select: none;
      }
      
      /* Resize edges for title box */
      .title-box .resize-edge {
        position: absolute;
        background: transparent;
        z-index: 10;
      }
      .title-box .resize-edge.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.left { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.right { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.corner { width: 15px; height: 15px; }
      .title-box .resize-edge.top-left { top: -5px; left: -5px; cursor: nw-resize; }
      .title-box .resize-edge.top-right { top: -5px; right: -5px; cursor: ne-resize; }
      .title-box .resize-edge.bottom-left { bottom: -5px; left: -5px; cursor: sw-resize; }
      .title-box .resize-edge.bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }

      /* Text box per Editor.json */
      .text-box {
        font-size: 16px;
        min-height: 250px;
        min-width: 200px;
        overflow: visible;
        position: absolute;
        top: 100px;
        left: 24px;
        width: calc(100% - 48px);
        bottom: 24px;
      }
      .text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .additional-text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .text-box:focus,
      .text-box.selected,
      .additional-text-box:focus,
      .additional-text-box.selected {
        border-color: rgba(0, 200, 120, 0.65);
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 3px rgba(0, 200, 120, 0.18);
      }
      .text-box:hover:not(.selected):not(:focus),
      .additional-text-box:hover:not(.selected):not(:focus) {
        border-color: rgba(0, 200, 120, 0.28);
      }
      
      /* Selected state for text boxes and title box */
      .title-box.selected,
      .text-box.selected,
      .additional-text-box.selected {
        cursor: text;
      }
      
      .text-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .text-box.resizing {
        user-select: none;
      }
      

      /* Save notification */
      .save-notification {
        position: fixed;
        top: 70px;
        right: 20px;
        background: #10b981;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity .3s, transform .3s;
        z-index: 1000;
        pointer-events: none;
      }
      .save-notification.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body class="page-container shell-layout editor-shell">
    <aside class="sidebar" id="sidebar"></aside>

    <header class="topbar editor-topbar">
      <button type="button" class="toolbar-pill" data-variant="blue" data-tooltip="Undo (Cmd+Z / Ctrl+Z)" id="btnBack" data-action="back" aria-label="Undo">
        <i class="fas fa-arrow-left"></i>
      </button>
      <button type="button" class="toolbar-pill" data-variant="blue" data-tooltip="Redo (Cmd+Shift+Z / Ctrl+Shift+Z)" id="btnForward" data-action="forward" aria-label="Redo">
        <i class="fas fa-arrow-right"></i>
      </button>
      <button type="button" class="toolbar-pill" data-variant="red" data-tooltip="Delete Slide" id="btnDel" data-action="delete_slide" aria-label="Delete Slide">
        <i class="fas fa-trash"></i>
      </button>
      <button type="button" class="toolbar-pill" data-variant="neutral" data-tooltip="Reset Slides" id="btnReset" data-action="reset_slides" aria-label="Reset Slides">
        <i class="fas fa-rotate-right"></i>
      </button>
      <button type="button" class="toolbar-pill" data-variant="green" data-tooltip="Save Presentation" id="btnSave" data-action="save_presentation" aria-label="Save Presentation">
        <i class="fas fa-save"></i>
      </button>
      <button type="button" class="toolbar-pill" data-variant="emerald" data-tooltip="Save As File" id="btnSaveAs" data-action="save_as_file" aria-label="Save As File">
        <i class="fas fa-folder-open"></i>
      </button>
      <div class="toolbar-spacer"></div>
      <button type="button" class="toolbar-pill" data-variant="emerald" data-tooltip="Return Home" id="btnHome" data-action="go_home" aria-label="Return Home">
        <i class="fas fa-home"></i>
      </button>
    </header>

    <main class="editor-main">
      <section class="editor">
          <div class="toolbar" id="toolbar">
            <button class="tool" data-action="bold" title="Bold"><i class="fas fa-bold"></i></button>
            <button class="tool" data-action="italic" title="Italic"><i class="fas fa-italic"></i></button>
            <button class="tool" data-action="underline" title="Underline"><i class="fas fa-underline"></i></button>
            <button class="tool" data-action="strikeThrough" title="Strikethrough"><i class="fas fa-strikethrough"></i></button>
            <button class="tool" data-action="subscript" title="Subscript"><i class="fas fa-subscript"></i></button>
            <button class="tool" data-action="superscript" title="Superscript"><i class="fas fa-superscript"></i></button>
            <input type="number" class="tool-select" id="fontSize" title="Font Size" min="8" max="72" step="2" value="16" style="width: 80px; color: #e8f5e9;">
            <button type="button" class="tool font-picker-button" id="fontPickerButton" title="Font Family" aria-haspopup="true" aria-expanded="false">
              <span class="font-picker-label" id="fontPickerLabel">Aa</span>
            </button>
            <div id="colorControlsRoot" class="color-controls"></div>
            <button type="button" class="tool shape-picker-button" id="shapePickerButton" title="Insert Shape" aria-haspopup="true" aria-expanded="false">
              <i class="fas fa-shapes"></i>
            </button>
            <button class="tool" data-action="justifyLeft" title="Align Left"><i class="fas fa-align-left"></i></button>
            <button class="tool" data-action="justifyCenter" title="Align Center"><i class="fas fa-align-center"></i></button>
            <button class="tool" data-action="justifyRight" title="Align Right"><i class="fas fa-align-right"></i></button>
            <button class="tool" data-action="justifyFull" title="Justify"><i class="fas fa-align-justify"></i></button>
            <button class="tool" data-action="insertUnorderedList" title="Bullet List"><i class="fas fa-list-ul"></i></button>
            <button class="tool" data-action="insertOrderedList" title="Numbered List"><i class="fas fa-list-ol"></i></button>
            <button class="tool" data-action="addTextBox" title="Add Text Box"><i class="fas fa-text-width"></i> Text Box</button>
            <button class="tool present-button" data-action="present" title="Present Slideshow" aria-label="Present">
              <svg class="present-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 4l12 8-12 8z" fill="currentColor"></path>
              </svg>
            </button>
          </div>
          <div class="canvas-wrap">
            <div class="canvas" id="canvas">
              <div class="title-box" contenteditable="true" id="titleBox" data-placeholder="Click to add title"></div>
              <div class="text-box" contenteditable="true" id="textBox" data-placeholder="Click to add text"></div>
            </div>
          </div>
        </section>
    </main>

    <div class="save-notification" id="saveNotification">Presentation saved!</div>
    <div class="export-modal" id="exportModal" aria-hidden="true">
      <div class="export-dialog" role="dialog" aria-modal="true" aria-labelledby="exportDialogTitle">
        <div class="export-header">
          <h2 id="exportDialogTitle">Export Presentation</h2>
          <button type="button" class="export-close" id="exportClose" aria-label="Close export dialog">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="export-body">
          <div class="export-field">
            <label for="exportFileName">File name</label>
            <input type="text" id="exportFileName" maxlength="80" autocomplete="off" placeholder="presentation-name">
          </div>
          <div class="export-options" id="exportOptions"></div>
        </div>
        <div class="export-footer">
          <button type="button" class="toolbar-pill" data-variant="neutral" id="exportCancel">
            <span class="label">Cancel</span>
          </button>
          <button type="button" class="toolbar-pill" data-variant="green" id="exportConfirm" disabled>
            <span class="label">Save</span>
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      import React, { useEffect, useRef, useState } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { PaintBucket } from 'https://esm.sh/lucide-react@0.312.0?deps=react@18.2.0';

      const { createElement, Fragment } = React;

      const TextIcon = (props) => createElement(
        'svg',
        Object.assign({
          width: 18,
          height: 18,
          viewBox: '0 0 24 24',
          fill: 'none',
          stroke: 'currentColor',
          strokeWidth: 2,
          strokeLinecap: 'round',
          strokeLinejoin: 'round'
        }, props),
        createElement('path', { d: 'M5 20h14' }),
        createElement('path', { d: 'M12 4l5 12' }),
        createElement('path', { d: 'M12 4L7 16' }),
        createElement('line', { x1: 10.5, y1: 12, x2: 13.5, y2: 12 })
      );

      const DEFAULT_TEXT_COLOR = '#000000';
      const DEFAULT_BG_COLOR = '#ffff00';

      const ColorControls = ({ textColorHandler, bgColorHandler }) => {
        const [textColor, setTextColor] = useState(DEFAULT_TEXT_COLOR);
        const [bgColor, setBgColor] = useState(DEFAULT_BG_COLOR);
        const textInputRef = useRef(null);
        const bgInputRef = useRef(null);

        useEffect(() => {
          if (textInputRef.current) {
            setTextColor(textInputRef.current.value || DEFAULT_TEXT_COLOR);
          }
          if (bgInputRef.current) {
            setBgColor(bgInputRef.current.value || DEFAULT_BG_COLOR);
          }
        }, []);

        const handleTextColorChange = (event) => {
          const color = event.target.value;
          setTextColor(color);
          if (typeof textColorHandler === 'function') {
            textColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-text-color', { detail: { color } }));
          }
        };

        const handleBgColorChange = (event) => {
          const color = event.target.value;
          setBgColor(color);
          if (typeof bgColorHandler === 'function') {
            bgColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-bg-color', { detail: { color } }));
          }
        };

        const triggerTextPicker = () => {
          if (textInputRef.current) {
            textInputRef.current.click();
          }
        };

        const triggerBgPicker = () => {
          if (bgInputRef.current) {
            bgInputRef.current.click();
          }
        };

        return createElement(
          Fragment,
          null,
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerTextPicker,
              title: 'Font Color',
              'aria-label': 'Font Color'
            },
            createElement(TextIcon, { className: 'color-tool-icon' }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: textColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'fontColor',
            ref: textInputRef,
            defaultValue: DEFAULT_TEXT_COLOR,
            className: 'visually-hidden',
            onChange: handleTextColorChange
          }),
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerBgPicker,
              title: 'Text Box Background Color',
              'aria-label': 'Text Box Background Color'
            },
            createElement(PaintBucket, { size: 18 }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: bgColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'highlightColor',
            ref: bgInputRef,
            defaultValue: DEFAULT_BG_COLOR,
            className: 'visually-hidden',
            onChange: handleBgColorChange
          })
        );
      };

      const rootElement = document.getElementById('colorControlsRoot');
      if (rootElement) {
        const handlers = window.slideEditorColorHandlers || {};
        createRoot(rootElement).render(createElement(ColorControls, {
          textColorHandler: handlers.onTextColor,
          bgColorHandler: handlers.onBackgroundColor
        }));
      }
    </script>

    <script>
      // Route Protection - Check authentication on page load
      (function() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        // If not authenticated and not a guest, redirect to welcome page
        if (!currentUser && !isGuest) {
          window.location.href = './index.html';
          return;
        }
      })();
      
      const DEFAULT_FONT_STACK = 'Inter, system-ui, -apple-system, "Segoe UI", sans-serif';

      // Model per Editor.json: starting with one slide titled "Title"
      const slides = [{ 
        title: '', 
        content: '',
        titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
        textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
        titleFontFamily: DEFAULT_FONT_STACK,
        textFontFamily: DEFAULT_FONT_STACK,
        shapes: [],
        additionalTextBoxes: [],
        transition: 'none'
      }];
      let active = 0;
      let slideDragSourceIndex = null;

      const sidebar = document.getElementById('sidebar');
      const titleBox = document.getElementById('titleBox');
      const textBox = document.getElementById('textBox');
      const saveNotification = document.getElementById('saveNotification');
      const exportModal = document.getElementById('exportModal');
      const exportOptionsContainer = document.getElementById('exportOptions');
      const exportCloseBtn = document.getElementById('exportClose');
      const exportCancelBtn = document.getElementById('exportCancel');
      const exportFileNameInput = document.getElementById('exportFileName');
      const exportConfirmBtn = document.getElementById('exportConfirm');
      const canvas = document.getElementById('canvas');
      const fontPickerButton = document.getElementById('fontPickerButton');
      const fontPickerLabel = document.getElementById('fontPickerLabel');
      const shapePickerButton = document.getElementById('shapePickerButton');
      const DEFAULT_FONT_FAMILY = window.getComputedStyle(textBox).fontFamily || DEFAULT_FONT_STACK;
      titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
      textBox.dataset.rotation = textBox.dataset.rotation || '0';
      titleBox.style.transform = `rotate(${parseFloat(titleBox.dataset.rotation || '0')}deg)`;
      textBox.style.transform = `rotate(${parseFloat(textBox.dataset.rotation || '0')}deg)`;
      titleBox.dataset.minWidth = titleBox.dataset.minWidth || '200';
      titleBox.dataset.minHeight = titleBox.dataset.minHeight || '50';
      textBox.dataset.minWidth = textBox.dataset.minWidth || '200';
      textBox.dataset.minHeight = textBox.dataset.minHeight || '50';
      titleBox.style.display = 'none';
      textBox.style.display = 'none';
      let toastTimeout;
      let selectedExportFormat = null;
      let exportModalPreviousFocus = null;
      const EXPORT_FORMATS = [
        { id: 'pdf', label: 'PDF Document', note: 'High-quality printable slides.' },
        { id: 'pptx', label: 'PowerPoint (PPTX)', note: 'Open and edit in Microsoft PowerPoint.' },
        { id: 'png', label: 'PNG Images (ZIP)', note: 'Export each slide as a transparent image.' },
        { id: 'jpg', label: 'JPG Images (ZIP)', note: 'Export each slide as a photo-friendly image.' },
        { id: 'html', label: 'Interactive HTML', note: 'Share as a standalone web page.' },
        { id: 'json', label: 'Editor JSON', note: 'Backup for reloading into SlideMaker.' }
      ];
      const EXPORT_LABEL_MAP = EXPORT_FORMATS.reduce((map, fmt) => {
        map[fmt.id] = fmt.label;
        return map;
      }, {});

      function showToast(message, duration = 2400) {
        clearTimeout(toastTimeout);
        saveNotification.textContent = message;
        saveNotification.classList.add('show');
        if (duration !== null) {
          toastTimeout = setTimeout(() => {
            saveNotification.classList.remove('show');
          }, duration);
        }
      }

      function hideToast() {
        clearTimeout(toastTimeout);
        saveNotification.classList.remove('show');
      }

      function sanitizeFileName(value) {
        return (value || 'presentation')
          .replace(/[^a-z0-9\-_]+/gi, '-')
          .replace(/-{2,}/g, '-')
          .replace(/^-|-$/g, '')
          .toLowerCase() || 'presentation';
      }

      function getExportBaseName() {
        const primaryTitle = slides.find(slide => slide.title && slide.title.trim());
        return sanitizeFileName(primaryTitle ? primaryTitle.title : 'Aramco-slide');
      }

      function triggerDownloadFromBlob(blob, fileName) {
        console.log('Triggering downloadâ€¦', fileName);
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        console.log('Download successful.', fileName);
      }

      function renderExportOptions() {
        exportOptionsContainer.innerHTML = '';
        selectedExportFormat = null;
        exportConfirmBtn.disabled = true;
        EXPORT_FORMATS.forEach(format => {
          const option = document.createElement('label');
          option.className = 'export-option';

          const input = document.createElement('input');
          input.type = 'radio';
          input.name = 'exportFormat';
          input.value = format.id;
          input.className = 'export-option-input';

          const kicker = document.createElement('span');
          kicker.className = 'export-option-kicker';
          kicker.textContent = format.id.toUpperCase();

          const details = document.createElement('div');
          details.className = 'export-option-details';
          const labelSpan = document.createElement('span');
          labelSpan.className = 'export-option-label';
          labelSpan.textContent = format.label;
          const noteSpan = document.createElement('span');
          noteSpan.className = 'export-option-note';
          noteSpan.textContent = format.note;
          details.append(labelSpan, noteSpan);

          input.addEventListener('change', () => {
            document.querySelectorAll('.export-option.active').forEach(active => active.classList.remove('active'));
            option.classList.add('active');
            selectedExportFormat = input.value;
            exportConfirmBtn.disabled = false;
          });

          option.append(input, kicker, details);
          exportOptionsContainer.appendChild(option);
        });
      }

      function handleExportKeydown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          closeExportModal();
        }
        if (event.key === 'Tab') {
          const focusable = Array.from(exportModal.querySelectorAll('button, input[type="radio"]'));
          if (focusable.length === 0) return;
          const first = focusable[0];
          const last = focusable[focusable.length - 1];
          if (event.shiftKey && document.activeElement === first) {
            event.preventDefault();
            last.focus();
          } else if (!event.shiftKey && document.activeElement === last) {
            event.preventDefault();
            first.focus();
          }
        }
      }

      function openExportModal() {
        renderExportOptions();
        const defaultName = getExportBaseName();
        exportFileNameInput.value = defaultName;
        exportFileNameInput.focus();
        exportFileNameInput.select();
        exportModalPreviousFocus = document.activeElement;
        exportModal.classList.add('show');
        exportModal.setAttribute('aria-hidden', 'false');
        document.addEventListener('keydown', handleExportKeydown);
      }

      function closeExportModal() {
        exportModal.classList.remove('show');
        exportModal.setAttribute('aria-hidden', 'true');
        document.removeEventListener('keydown', handleExportKeydown);
        document.querySelectorAll('.export-option.active').forEach(active => active.classList.remove('active'));
        exportConfirmBtn.disabled = true;
        selectedExportFormat = null;
        if (exportModalPreviousFocus && typeof exportModalPreviousFocus.focus === 'function') {
          exportModalPreviousFocus.focus();
        }
      }

      exportModal.addEventListener('click', (event) => {
        if (event.target === exportModal) {
          closeExportModal();
        }
      });
      exportCloseBtn.addEventListener('click', closeExportModal);
      exportCancelBtn.addEventListener('click', closeExportModal);
      exportConfirmBtn.addEventListener('click', handleExportConfirm);
      exportFileNameInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !exportConfirmBtn.disabled) {
          event.preventDefault();
          handleExportConfirm();
        }
      });

      async function handleExportConfirm() {
        if (!selectedExportFormat) return;
        const rawName = exportFileNameInput.value.trim();
        const safeName = sanitizeFileName(rawName) || getExportBaseName();
        closeExportModal();
        await exportPresentation(selectedExportFormat, safeName);
      }

      function escapeHtml(value) {
        return (value || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      async function waitForRenderCycles(cycles = 2) {
        while (cycles-- > 0) {
          await new Promise(resolve => requestAnimationFrame(() => resolve()));
        }
      }

      async function captureCanvasSnapshot(imageType = 'png') {
        await waitForRenderCycles(2);
        if (typeof clearShapeSelection === 'function') {
          clearShapeSelection();
        }
        if (typeof hideRotationHandle === 'function') {
          hideRotationHandle();
        }
        if (typeof hideShapeColorPicker === 'function') {
          hideShapeColorPicker();
        }
        document.querySelectorAll('.title-box.selected, .text-box.selected, .additional-text-box.selected').forEach(el => el.classList.remove('selected'));
        canvas.classList.add('exporting');
        await waitForRenderCycles(1);
        const backgroundColor = imageType === 'png' ? null : '#ffffff';
        const renderedCanvas = await html2canvas(canvas, {
          backgroundColor,
          scale: 2,
          logging: false,
          useCORS: true
        });
        canvas.classList.remove('exporting');
        const mime = imageType === 'jpg' ? 'image/jpeg' : 'image/png';
        const dataUrl = renderedCanvas.toDataURL(mime, 0.92);
        return {
          dataUrl,
          width: renderedCanvas.width,
          height: renderedCanvas.height
        };
      }

      function generateStandaloneHTMLDocument(baseName) {
        const slidesJSON = JSON.stringify(slides).replace(/<\/script>/gi, '<\\/script>');
        const lines = [
          "<!doctype html>",
          "<html lang=\"en\">",
          "<head>",
          "  <meta charset=\"utf-8\">",
          "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">",
          `  <title>${escapeHtml(baseName)} â€“ Slide Export</title>`,
          "  <style>",
          "    body { font-family: 'Poppins', Arial, sans-serif; margin: 0; padding: 40px; background: #01231a; color: #e8f5e9; }",
          "    .deck { display: grid; gap: 32px; max-width: 960px; margin: 0 auto; }",
          "    .slide { background: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 18px; padding: 32px; box-shadow: 0 20px 50px rgba(0,0,0,0.35); }",
          "    .slide h2 { margin: 0 0 16px; font-size: 1.8rem; color: #9ef6c7; }",
          "    .slide-content { line-height: 1.6; white-space: pre-wrap; }",
          "    .slide-content p { margin: 8px 0; }",
          "  </style>",
          "</head>",
          "<body>",
          "  <main class=\"deck\" id=\"deck\"></main>",
          "  <script>",
          `    const slides = ${slidesJSON};`,
          "    const deck = document.getElementById('deck');",
          "    const toText = (html) => {",
          "      const temp = document.createElement('div');",
          "      temp.innerHTML = html || '';",
          "      return temp.textContent || temp.innerText || '';",
          "    };",
          "    slides.forEach((slide, index) => {",
          "      const section = document.createElement('section');",
          "      section.className = 'slide';",
          "      const title = document.createElement('h2');",
          "      title.textContent = slide.title && slide.title.trim() ? slide.title.trim() : 'Slide ' + (index + 1);",
          "      section.appendChild(title);",
          "      const content = document.createElement('div');",
          "      content.className = 'slide-content';",
          "      const text = slide.content ? slide.content : '';",
          "      content.textContent = toText(text);",
          "      section.appendChild(content);",
          "      deck.appendChild(section);",
          "    });",
          "  <\\/script>",
          "</body>",
          "</html>"
        ];
        return lines.join('\\n');
      }

      async function exportAsPDF(baseName) {
        if (!window.html2canvas || !window.jspdf) {
          throw new Error('PDF export libraries are not available.');
        }
        console.log('Generating file blobâ€¦ (PDF)');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
        const originalActive = active;
        const originalScroll = sidebar.scrollTop;
        for (let index = 0; index < slides.length; index += 1) {
          active = index;
          load();
          renderSidebar();
          sidebar.scrollTop = originalScroll;
          const snapshot = await captureCanvasSnapshot('png');
          if (index > 0) {
            pdf.addPage();
          }
          const pageWidth = pdf.internal.pageSize.getWidth() - 60;
          const ratio = snapshot.height === 0 ? 1 : snapshot.width / snapshot.height;
          const imageHeight = pageWidth / ratio;
          const maxHeight = pdf.internal.pageSize.getHeight() - 60;
          const heightToUse = Math.min(imageHeight, maxHeight);
          const widthToUse = heightToUse * ratio;
          pdf.addImage(snapshot.dataUrl, 'PNG', 30, 30, widthToUse, heightToUse);
        }
        active = originalActive;
        load();
        renderSidebar();
        sidebar.scrollTop = originalScroll;
        const fileName = `${baseName}.pdf`;
        const pdfBlob = pdf.output('blob');
        triggerDownloadFromBlob(pdfBlob, fileName);
        return fileName;
      }

      async function exportAsPPTX(baseName) {
        if (!window.PptxGenJS) {
          throw new Error('PPTX export library is not available.');
        }
        console.log('Generating file blobâ€¦ (PPTX)');
        const pptx = new window.PptxGenJS();
        slides.forEach((slide, index) => {
          const pptSlide = pptx.addSlide();
          const titleText = slide.title && slide.title.trim() ? slide.title.trim() : `Slide ${index + 1}`;
          pptSlide.addText(titleText, {
            x: 0.6,
            y: 0.5,
            fontSize: 26,
            bold: true,
            color: '2dd4bf'
          });
          const rawContent = slide.content || '';
          const temp = document.createElement('div');
          temp.innerHTML = rawContent;
          const bodyText = temp.textContent || temp.innerText || '';
          if (bodyText.trim()) {
            pptSlide.addText(bodyText.trim(), {
              x: 0.6,
              y: 1.25,
              w: 8.4,
              h: 4.5,
              fontSize: 18,
              color: '173f35',
              lineSpacing: 28
            });
          }
        });
        const fileName = `${baseName}.pptx`;
        const pptxBlob = await pptx.write('blob');
        triggerDownloadFromBlob(pptxBlob, fileName);
        return fileName;
      }

      async function exportSlidesAsImages(baseName, type) {
        if (!window.html2canvas || !window.JSZip) {
          throw new Error('Image export libraries are not available.');
        }
        console.log(`Generating file blobâ€¦ (${type.toUpperCase()} ZIP)`);
        const zip = new JSZip();
        const originalActive = active;
        const originalScroll = sidebar.scrollTop;
        for (let index = 0; index < slides.length; index += 1) {
          active = index;
          load();
          renderSidebar();
          sidebar.scrollTop = originalScroll;
          const snapshot = await captureCanvasSnapshot(type);
          const fileName = `slide-${String(index + 1).padStart(2, '0')}.${type}`;
          zip.file(fileName, snapshot.dataUrl.split(',')[1], { base64: true });
        }
        active = originalActive;
        load();
        renderSidebar();
        sidebar.scrollTop = originalScroll;
        const blob = await zip.generateAsync({ type: 'blob' });
        const zipName = `${baseName}-${type.toUpperCase()}-slides.zip`;
        triggerDownloadFromBlob(blob, zipName);
        return zipName;
      }

      function exportAsHTML(baseName) {
        console.log('Generating file blobâ€¦ (HTML)');
        const htmlDocument = generateStandaloneHTMLDocument(baseName);
        const blob = new Blob([htmlDocument], { type: 'text/html;charset=utf-8' });
        const fileName = `${baseName}.html`;
        triggerDownloadFromBlob(blob, fileName);
        return fileName;
      }

      function exportAsJSON(baseName) {
        console.log('Generating file blobâ€¦ (JSON)');
        const payload = {
          generatedAt: new Date().toISOString(),
          activeSlide: active,
          slides: slides
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const fileName = `${baseName}.json`;
        triggerDownloadFromBlob(blob, fileName);
        return fileName;
      }

      async function exportPresentation(format, customBaseName) {
        const label = EXPORT_LABEL_MAP[format] || format.toUpperCase();
        showToast(`Preparing ${label}â€¦`, null);
        try {
          const baseName = sanitizeFileName(customBaseName || getExportBaseName());
          let exportedFileName = '';
          if (format === 'pdf') {
            exportedFileName = await exportAsPDF(baseName);
          } else if (format === 'pptx') {
            exportedFileName = await exportAsPPTX(baseName);
          } else if (format === 'png') {
            exportedFileName = await exportSlidesAsImages(baseName, 'png');
          } else if (format === 'jpg') {
            exportedFileName = await exportSlidesAsImages(baseName, 'jpg');
          } else if (format === 'html') {
            exportedFileName = exportAsHTML(baseName);
          } else if (format === 'json') {
            exportedFileName = exportAsJSON(baseName);
          } else {
            throw new Error('Unsupported format selected.');
          }
          hideToast();
          showToast('âœ… File saved successfully to your Downloads folder.', 3000);
        } catch (error) {
          console.error('Export failed:', error);
          hideToast();
          alert(`Export failed: ${error.message || error}`);
        }
      }

      const FONT_OPTIONS = [
        { name: 'Inter', stack: DEFAULT_FONT_STACK },
        { name: 'System UI', stack: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif' },
        { name: 'Roboto', stack: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Open Sans', stack: '"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Lato', stack: 'Lato, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Montserrat', stack: 'Montserrat, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Poppins', stack: 'Poppins, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Source Sans Pro', stack: '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Nunito', stack: 'Nunito, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway', stack: 'Raleway, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Oswald', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Cabin', stack: 'Cabin, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Fira Sans', stack: '"Fira Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Arial', stack: 'Arial, Helvetica, sans-serif' },
        { name: 'Verdana', stack: 'Verdana, Geneva, sans-serif' },
        { name: 'Tahoma', stack: 'Tahoma, Geneva, sans-serif' },
        { name: 'Trebuchet MS', stack: '"Trebuchet MS", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Helvetica Neue', stack: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Times New Roman', stack: '"Times New Roman", Times, serif' },
        { name: 'Georgia', stack: 'Georgia, serif' },
        { name: 'Garamond', stack: 'Garamond, Baskerville, "Times New Roman", serif' },
        { name: 'Merriweather', stack: 'Merriweather, Georgia, serif' },
        { name: 'Playfair Display', stack: '"Playfair Display", Georgia, serif' },
        { name: 'Cambria', stack: 'Cambria, Georgia, serif' },
        { name: 'Palatino', stack: '"Palatino Linotype", "Book Antiqua", Palatino, serif' },
        { name: 'Courier New', stack: '"Courier New", Courier, monospace' },
        { name: 'IBM Plex Mono', stack: '"IBM Plex Mono", "Courier New", Courier, monospace' },
        { name: 'Consolas', stack: 'Consolas, "Liberation Mono", Courier, monospace' },
        { name: 'Fira Code', stack: '"Fira Code", "Fira Mono", "DejaVu Sans Mono", monospace' },
        { name: 'Lucida Console', stack: '"Lucida Console", Monaco, monospace' },
        { name: 'Brush Script', stack: '"Brush Script MT", cursive' },
        { name: 'Pacifico', stack: 'Pacifico, "Brush Script MT", cursive' },
        { name: 'Dancing Script', stack: '"Dancing Script", "Brush Script MT", cursive' },
        { name: 'Great Vibes', stack: '"Great Vibes", "Brush Script MT", cursive' },
        { name: 'Oswald Condensed', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Bebas Neue', stack: '"Bebas Neue", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway Dots', stack: '"Raleway Dots", "Helvetica Neue", Helvetica, Arial, sans-serif' }
      ];

      const fontDropdown = document.createElement('div');
      fontDropdown.id = 'fontDropdown';
      fontDropdown.className = 'font-dropdown';
      document.body.appendChild(fontDropdown);

      const fontOptionButtons = new Map();
      const fontStackToName = new Map();
      const fontNameToStack = new Map();

      const shapeDropdown = document.createElement('div');
      shapeDropdown.id = 'shapeDropdown';
      shapeDropdown.className = 'shape-dropdown';
      document.body.appendChild(shapeDropdown);
      const shapeOptionButtons = new Map();

      const COLOR_CANVAS = document.createElement('canvas');
      COLOR_CANVAS.width = COLOR_CANVAS.height = 1;
      const COLOR_CTX = COLOR_CANVAS.getContext('2d');
      function normalizeColorHex(color) {
        if (!color) return '#ffffff';
        try {
          COLOR_CTX.fillStyle = '#000000';
          COLOR_CTX.fillStyle = color;
          return COLOR_CTX.fillStyle;
        } catch (err) {
          return '#ffffff';
        }
      }

      const SHAPE_OPTIONS = [
        {
          id: 'rectangle',
          name: 'Rectangle',
          viewBox: '0 0 100 70',
          svg: '<rect x="6" y="10" width="88" height="50" rx="10" ry="10"></rect>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#9ae6b4'
        },
        {
          id: 'square',
          name: 'Square',
          viewBox: '0 0 100 100',
          svg: '<rect x="12" y="12" width="76" height="76" rx="12" ry="12"></rect>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#a5b4fc'
        },
        {
          id: 'circle',
          name: 'Circle',
          viewBox: '0 0 100 100',
          svg: '<circle cx="50" cy="50" r="38"></circle>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#fbb6ce'
        },
        {
          id: 'triangle',
          name: 'Triangle',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 12 L90 78 H10 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#f6ad55'
        },
        {
          id: 'star',
          name: 'Star',
          viewBox: '0 0 100 100',
          svg: '<path d="M50 6 L61 36 H92 L66 54 L76 84 L50 66 L24 84 L34 54 L8 36 H39 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 160,
          minWidth: 80,
          minHeight: 80,
          defaultColor: '#fcd34d'
        },
        {
          id: 'arrow-right',
          name: 'Arrow',
          viewBox: '0 0 120 70',
          svg: '<path d="M16 28 H70 V14 L104 35 L70 56 V42 H16 Z"></path>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#4ade80'
        },
        {
          id: 'line',
          name: 'Line',
          viewBox: '0 0 100 40',
          svg: '<line x1="8" y1="32" x2="92" y2="8" stroke-linecap="round" fill="none"></line>',
          defaultWidth: 220,
          defaultHeight: 60,
          minWidth: 80,
          minHeight: 30,
          defaultColor: '#63b3ed',
          strokeWidth: 8
        },
        {
          id: 'pentagon',
          name: 'Pentagon',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 8 L90 36 L74 80 H26 L10 36 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 70,
          defaultColor: '#f472b6'
        }
      ];

      const SHAPE_OPTION_MAP = new Map(SHAPE_OPTIONS.map(shape => [shape.id, shape]));

      function normalizeFontStack(value) {
        if (!value) return '';
        return value.replace(/"/g, "'").split(',').map(part => part.replace(/['"]/g, '').trim().toLowerCase()).join(',');
      }

      FONT_OPTIONS.forEach(font => {
        const normalized = normalizeFontStack(font.stack);
        fontStackToName.set(normalized, font.name);
        fontNameToStack.set(font.name.toLowerCase(), font.stack);
      });

      function renderFontOptions() {
        fontDropdown.innerHTML = '';
        fontOptionButtons.clear();
        FONT_OPTIONS.forEach(font => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'font-option';
          option.textContent = font.name;
          option.style.fontFamily = font.stack;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            applyFontFamilyToCurrent(font.stack);
            hideFontDropdown();
          });
          fontDropdown.appendChild(option);
          fontOptionButtons.set(normalizeFontStack(font.stack), option);
        });
      }

      function renderShapeOptions() {
        shapeDropdown.innerHTML = '';
        shapeOptionButtons.clear();
        SHAPE_OPTIONS.forEach(shape => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'shape-option';
          option.innerHTML = `
            <div class="shape-option-preview">${renderShapeSvg(shape)}</div>
            <span class="shape-option-label">${shape.name}</span>
          `;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            insertShape(shape.id);
            hideShapeDropdown();
          });
          shapeDropdown.appendChild(option);
          shapeOptionButtons.set(shape.id, option);
        });
      }

      renderShapeOptions();

      renderFontOptions();

      const shapeColorPicker = document.createElement('div');
      shapeColorPicker.id = 'shapeColorPicker';
      shapeColorPicker.className = 'shape-color-picker';
      shapeColorPicker.innerHTML = `
        <button type="button" id="shapeColorButton" class="shape-color-button" title="Shape Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="shapeColorInput" class="shape-color-input" value="#e8f5e9" aria-label="Shape Fill Color Picker">
      `;
      document.body.appendChild(shapeColorPicker);
      const shapeColorButton = document.getElementById('shapeColorButton');
      const shapeColorInput = document.getElementById('shapeColorInput');
      const shapeSizeBadge = document.createElement('div');
      shapeSizeBadge.id = 'shapeSizeBadge';
      shapeSizeBadge.className = 'shape-size-badge';
      document.body.appendChild(shapeSizeBadge);

      const slideContextMenu = document.createElement('div');
      slideContextMenu.id = 'slideContextMenu';
      slideContextMenu.className = 'slide-context-menu';
      slideContextMenu.innerHTML = `
        <button type="button" data-action="rename-slide">
          <i class="fas fa-pen"></i>
          <span>Rename</span>
        </button>
      `;
      document.body.appendChild(slideContextMenu);
      const slideContextRenameBtn = slideContextMenu.querySelector('[data-action="rename-slide"]');

      const slideTransitionMenu = document.createElement('div');
      slideTransitionMenu.id = 'slideTransitionMenu';
      slideTransitionMenu.className = 'slide-context-menu';
      slideTransitionMenu.innerHTML = '';
      document.body.appendChild(slideTransitionMenu);

      const presentationOverlay = document.createElement('div');
      presentationOverlay.id = 'presentationOverlay';
      presentationOverlay.className = 'presentation-overlay';
      presentationOverlay.setAttribute('tabindex', '-1');
      presentationOverlay.innerHTML = `
        <div class="presentation-stage" tabindex="-1"></div>
        <div class="presentation-meta">
          <span><i class="fas fa-arrow-left"></i> Prev</span>
          <span>Esc to Exit</span>
          <span>Next <i class="fas fa-arrow-right"></i></span>
        </div>
        <div class="presentation-counter"></div>
      `;
      document.body.appendChild(presentationOverlay);
      const presentationStage = presentationOverlay.querySelector('.presentation-stage');
      const presentationCounterEl = presentationOverlay.querySelector('.presentation-counter');
      let isPresenting = false;
      let presentationIndex = 0;
      let presentationReturnIndex = 0;
      let presentationControlsTimeout = null;
      const PRESENTATION_CONTROLS_AUTOHIDE_DELAY = 4000;
      let presentationControlsLocked = false;
      let slideContextMenuTarget = null;
      let slideContextMenuTitle = null;
      let slideContextMenuIndex = null;
      const TRANSITION_OPTIONS = Object.freeze([
        { value: 'none', label: 'No Transition' },
        { value: 'fade', label: 'Fade' },
        { value: 'slide', label: 'Slide' },
        { value: 'zoom', label: 'Zoom' },
        { value: 'flip', label: 'Flip' },
        { value: 'rotate', label: 'Rotate' },
        { value: 'push', label: 'Push' },
        { value: 'wipe', label: 'Wipe' },
        { value: 'spin', label: 'Spin' },
        { value: 'dissolve', label: 'Dissolve' },
        { value: 'cube', label: 'Cube' },
        { value: 'bounce', label: 'Bounce' },
        { value: 'swirl', label: 'Swirl' }
      ]);
      const DEFAULT_TRANSITION = 'none';
      const TRANSITION_CLASS_NAMES = TRANSITION_OPTIONS
        .filter(opt => opt.value !== 'none')
        .map(opt => `transition-effect-${opt.value}`);
      let slideTransitionMenuIndex = null;
      let slideTransitionMenuAnchor = null;

      function renderSlideTransitionMenuOptions() {
        if (!slideTransitionMenu) return;
        slideTransitionMenu.innerHTML = '';
        TRANSITION_OPTIONS.forEach(opt => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.transition = opt.value;
          btn.innerHTML = `${getTransitionIconHtml(opt.value)}<span>${opt.label}</span>`;
          slideTransitionMenu.appendChild(btn);
        });
      }
      renderSlideTransitionMenuOptions();

      function prepareCanvasForPresentation(clone) {
        clone.removeAttribute('id');
        clone.classList.add('presentation-slide');
        clone.style.width = '100%';
        clone.style.height = '100%';
        clone.style.pointerEvents = 'none';
        clone.querySelectorAll('[id]').forEach(el => {
          if (el.id) {
            el.removeAttribute('id');
          }
        });
        clone.querySelectorAll('[contenteditable]').forEach(el => {
          el.removeAttribute('contenteditable');
          el.classList.remove('selected');
          el.removeAttribute('spellcheck');
        });
        clone.querySelectorAll('.resize-edge').forEach(el => el.remove());
        clone.querySelectorAll('[data-placeholder]').forEach(el => el.removeAttribute('data-placeholder'));
        clone.querySelectorAll('.shape-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.title-box, .text-box, .additional-text-box').forEach(el => {
          el.style.border = 'none';
          el.style.boxShadow = 'none';
          el.style.backgroundColor = el.style.backgroundColor || 'transparent';
        });
      }

      function cloneCanvasForPresentation(index) {
        const originalActive = presentationReturnIndex;
        active = index;
        load();
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        applySlideTransitionClass(clone, (slides[index] && slides[index].transition) || DEFAULT_TRANSITION);
        active = originalActive;
        load();
        return clone;
      }

      function updatePresentationCounter() {
        if (presentationCounterEl) {
          presentationCounterEl.textContent = `${presentationIndex + 1} / ${slides.length}`;
        }
      }

      function showPresentationSlide(index) {
        if (index < 0 || index >= slides.length) return;
        presentationIndex = index;
        const clone = cloneCanvasForPresentation(index);
        if (presentationStage) {
          presentationStage.innerHTML = '';
          presentationStage.appendChild(clone);
          applySlideTransitionClass(clone, (slides[index] && slides[index].transition) || DEFAULT_TRANSITION);
        }
        updatePresentationCounter();
      }

      function hidePresentationControls(lock = false) {
        if (!isPresenting) return;
        presentationOverlay.classList.remove('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (lock) {
          presentationControlsLocked = true;
        }
      }

      function showPresentationControls(autoHide = true) {
        if (!isPresenting || presentationControlsLocked) return;
        presentationOverlay.classList.add('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
        }
        if (autoHide) {
          presentationControlsTimeout = setTimeout(() => {
            presentationControlsTimeout = null;
            hidePresentationControls(true);
          }, PRESENTATION_CONTROLS_AUTOHIDE_DELAY);
        } else {
          presentationControlsTimeout = null;
        }
      }

      function startPresentation() {
        if (isPresenting) return;
        capture();
        presentationReturnIndex = active;
        isPresenting = true;
        presentationOverlay.classList.add('visible');
        showPresentationSlide(active);
        document.body.classList.add('presenting');
        presentationControlsLocked = false;
        showPresentationControls(true);
        requestAnimationFrame(() => {
          try {
            presentationOverlay.focus({ preventScroll: true });
          } catch (err) {
            presentationOverlay.focus();
          }
          if (presentationOverlay.requestFullscreen) {
            presentationOverlay.requestFullscreen().catch(() => {});
          }
        });
      }

      function exitPresentation(fromFullscreenChange = false) {
        if (!isPresenting) return;
        isPresenting = false;
        presentationOverlay.classList.remove('visible');
        presentationOverlay.classList.remove('show-controls');
        document.body.classList.remove('presenting');
        presentationControlsLocked = false;
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (presentationStage) {
          presentationStage.innerHTML = '';
        }
        active = presentationReturnIndex;
        load();
        renderSidebar();
        if (!fromFullscreenChange && document.fullscreenElement && document.exitFullscreen) {
          document.exitFullscreen().catch(() => {});
        }
      }

      function goToNextSlide() {
        if (presentationIndex < slides.length - 1) {
          showPresentationSlide(presentationIndex + 1);
        }
      }

      function goToPreviousSlide() {
        if (presentationIndex > 0) {
          showPresentationSlide(presentationIndex - 1);
        }
      }

      presentationOverlay.addEventListener('click', (event) => {
        if (!isPresenting) return;
        if (event.target.closest('.presentation-meta') || event.target.closest('.presentation-counter')) return;
        const stageRect = presentationStage ? presentationStage.getBoundingClientRect() : presentationOverlay.getBoundingClientRect();
        if (!stageRect || stageRect.width === 0) return;
        if (event.clientX > stageRect.left + stageRect.width / 2) {
          goToNextSlide();
        } else {
          goToPreviousSlide();
        }
      });

      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && isPresenting) {
          exitPresentation(true);
        }
      });


      shapeColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      shapeColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        shapeColorInput.click();
      });

      function updateShapeColorButtonAppearance(color) {
        shapeColorButton.style.background = color;
        const shadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
        shapeColorButton.style.boxShadow = shadow;
        const hex = color.replace('#', '');
        const bigint = parseInt(hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        shapeColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
      }

      const SHAPE_PICKER_MARGIN = 12;

      function positionShapeColorPicker(element) {
        if (!element || !shapeColorPicker.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const pickerRect = shapeColorPicker.getBoundingClientRect();
        let top = rect.top - pickerRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - pickerRect.width / 2;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }

        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }

        shapeColorPicker.style.top = `${top}px`;
        shapeColorPicker.style.left = `${left}px`;
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
      }

      function showShapeColorPicker(element) {
        if (!element) return;
        const color = normalizeColorHex(element.dataset.color || window.getComputedStyle(element).color || '#e8f5e9');
        shapeColorInput.value = color;
        updateShapeColorButtonAppearance(color);
        shapeColorPicker.classList.add('visible');
        positionShapeColorPicker(element);
        showRotationHandle(element);
      }

      function hideShapeColorPicker() {
        shapeColorPicker.classList.remove('visible');
        hideRotationHandle();
      }

      shapeColorInput.addEventListener('change', (event) => {
        if (!selectedShape) return;
        const color = normalizeColorHex(event.target.value);
        selectedShape.dataset.color = color;
        selectedShape.style.color = color;
        updateShapeColorButtonAppearance(color);
        positionShapeColorPicker(selectedShape);
        if (rotationTarget === selectedShape) {
          positionRotationHandle(selectedShape);
        }
        capture();
        saveEditorState('change_shape_color');
      });

      const shapeRotationHandle = document.createElement('div');
      shapeRotationHandle.id = 'shapeRotationHandle';
      shapeRotationHandle.className = 'shape-rotation-handle';
      shapeRotationHandle.innerHTML = `
        <button type="button" class="shape-rotation-button" title="Rotate Shape">
          <i class="fas fa-sync-alt"></i>
        </button>
        <span class="shape-rotation-angle">0Â°</span>
      `;
      document.body.appendChild(shapeRotationHandle);
      const shapeRotationButton = shapeRotationHandle.querySelector('.shape-rotation-button');
      const shapeRotationAngle = shapeRotationHandle.querySelector('.shape-rotation-angle');

      let rotationTarget = null;
      let isRotatingTarget = false;
      let rotationStartAngle = 0;
      let rotationInitial = 0;
      let rotationCenter = { x: 0, y: 0 };
      let activeResizeShape = null;
      let shapeResizeAnimating = false;

      function updateRotationAngleLabel(element, angleOverride) {
        if (!element || !shapeRotationAngle) return;
        const angle = angleOverride !== undefined ? angleOverride : (parseFloat(element.dataset.rotation || '0') || 0);
        shapeRotationAngle.textContent = `${Math.round(angle)}Â°`;
      }

      function positionRotationHandle(element) {
        if (!element || !shapeRotationHandle.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const handleRect = shapeRotationHandle.getBoundingClientRect();
        const colorRect = shapeColorPicker.getBoundingClientRect();
        const horizontalOffset = shapeColorPicker.classList.contains('visible')
          ? (colorRect.width / 2 + 28)
          : 70;
        let top = rect.top - handleRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 + horizontalOffset;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + handleRect.width > window.innerWidth - 16) {
          left = window.innerWidth - handleRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + handleRect.height > window.innerHeight - 16) {
          top = window.innerHeight - handleRect.height - 16;
        }

        shapeRotationHandle.style.top = `${top}px`;
        shapeRotationHandle.style.left = `${left}px`;
      }

      function showRotationHandle(element) {
        if (!element) return;
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        const currentRotation = parseFloat(element.dataset.rotation || '0') || 0;
        element.style.transform = `rotate(${currentRotation}deg)`;
        rotationTarget = element;
        updateRotationAngleLabel(element);
        positionRotationHandle(element);
        shapeRotationHandle.classList.add('visible');
      }

      function hideRotationHandle() {
        shapeRotationHandle.classList.remove('visible');
        endRotation(false);
        rotationTarget = null;
      }

      function endRotation(save = true) {
        if (!isRotatingTarget) return;
        isRotatingTarget = false;
        shapeRotationButton.classList.remove('active');
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleRotationMove);
        document.removeEventListener('mouseup', handleRotationUp);
        if (save && rotationTarget) {
          updateRotationAngleLabel(rotationTarget);
          positionRotationHandle(rotationTarget);
          capture();
          saveEditorState('rotate_shape');
        }
      }

      function handleRotationMove(event) {
        if (!isRotatingTarget || !rotationTarget) return;
        const current = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        let delta = (current - rotationStartAngle) * (180 / Math.PI);
        let newRotation = rotationInitial + delta;
        newRotation = ((newRotation % 360) + 360) % 360;
        rotationTarget.dataset.rotation = String(newRotation);
        rotationTarget.style.transform = `rotate(${newRotation}deg)`;
        updateRotationAngleLabel(rotationTarget, newRotation);
        if (rotationTarget.classList.contains('shape-element')) {
          positionShapeColorPicker(rotationTarget);
        }
        positionRotationHandle(rotationTarget);
      }

      function handleRotationUp() {
        endRotation(true);
      }

      shapeRotationButton.addEventListener('mousedown', (event) => {
        if (!rotationTarget) return;
        event.preventDefault();
        event.stopPropagation();
        const rect = rotationTarget.getBoundingClientRect();
        rotationCenter = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        rotationStartAngle = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        rotationInitial = parseFloat(rotationTarget.dataset.rotation || '0') || 0;
        isRotatingTarget = true;
        shapeRotationButton.classList.add('active');
        document.body.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleRotationMove);
        document.addEventListener('mouseup', handleRotationUp);
      });

      shapeRotationHandle.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      function updateShapeSizeBadge(element, width, height) {
        if (!element) return;
        shapeSizeBadge.textContent = `${Math.round(width)} Ã— ${Math.round(height)} px`;
        const rect = element.getBoundingClientRect();
        const badgeRect = shapeSizeBadge.getBoundingClientRect();
        let top = rect.top - badgeRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - badgeRect.width / 2;
        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + badgeRect.width > window.innerWidth - 16) {
          left = window.innerWidth - badgeRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        shapeSizeBadge.style.top = `${top}px`;
        shapeSizeBadge.style.left = `${left}px`;
      }

      function showShapeSizeBadge() {
        if (!shapeSizeBadge.classList.contains('visible')) {
          shapeSizeBadge.classList.add('visible');
        }
      }

      function hideShapeSizeBadge() {
        shapeSizeBadge.classList.remove('visible');
      }

      let isFontDropdownVisible = false;

      function setActiveFontOption(fontFamily) {
        const normalized = normalizeFontStack(fontFamily);
        fontOptionButtons.forEach((button, key) => {
          const isActive = key === normalized;
          button.classList.toggle('active', isActive);
          if (isActive) {
            button.scrollIntoView({ block: 'nearest' });
          }
        });
      }

      function extractPrimaryFontName(fontFamily) {
        if (!fontFamily) return 'Inter';
        const primary = fontFamily.split(',')[0].replace(/['"]/g, '').trim();
        if (!primary) return 'Inter';
        return primary;
      }

      function positionFontDropdown() {
        if (!fontPickerButton) return;
        const rect = fontPickerButton.getBoundingClientRect();
        fontDropdown.style.top = '0px';
        fontDropdown.style.left = '0px';
        fontDropdown.classList.add('show');
        const dropdownRect = fontDropdown.getBoundingClientRect();
        let top = rect.bottom + 8;
        let left = rect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = rect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(rect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        fontDropdown.style.top = `${Math.max(16, top)}px`;
        fontDropdown.style.left = `${left}px`;
      }

      function showFontDropdown() {
        if (!fontPickerButton) return;
        const currentFont = getCurrentFontFamily(currentActiveElement);
        setActiveFontOption(currentFont);
        fontDropdown.classList.add('show');
        positionFontDropdown();
        isFontDropdownVisible = true;
        fontPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideFontDropdown() {
        fontDropdown.classList.remove('show');
        isFontDropdownVisible = false;
        if (fontPickerButton) {
          fontPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleFontDropdown() {
        if (isFontDropdownVisible) {
          hideFontDropdown();
        } else {
          showFontDropdown();
        }
      }

      if (fontPickerButton) {
        fontPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleFontDropdown();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target) || (fontPickerButton && fontPickerButton.contains(event.target))) {
          return;
        }
        hideFontDropdown();
      });

      window.addEventListener('resize', () => {
        if (isFontDropdownVisible) {
          positionFontDropdown();
        }
      });

      window.addEventListener('scroll', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target)) {
          return;
        }
        hideFontDropdown();
      }, true);

      let isShapeDropdownVisible = false;
      let selectedShape = null;

      function positionShapeDropdown() {
        if (!shapePickerButton) return;
        shapeDropdown.style.top = '0px';
        shapeDropdown.style.left = '0px';
        shapeDropdown.classList.add('show');
        const buttonRect = shapePickerButton.getBoundingClientRect();
        const dropdownRect = shapeDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        shapeDropdown.style.top = `${Math.max(16, top)}px`;
        shapeDropdown.style.left = `${left}px`;
      }

      function showShapeDropdown() {
        if (!shapePickerButton) return;
        positionShapeDropdown();
        isShapeDropdownVisible = true;
        shapeDropdown.classList.add('show');
        shapePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideShapeDropdown() {
        shapeDropdown.classList.remove('show');
        isShapeDropdownVisible = false;
        if (shapePickerButton) {
          shapePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleShapeDropdown() {
        if (isShapeDropdownVisible) {
          hideShapeDropdown();
        } else {
          showShapeDropdown();
        }
      }

      if (shapePickerButton) {
        shapePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleShapeDropdown();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isShapeDropdownVisible) return;
        if (shapeDropdown.contains(event.target) || (shapePickerButton && shapePickerButton.contains(event.target))) {
          return;
        }
        hideShapeDropdown();
      });

      window.addEventListener('resize', () => {
        if (isShapeDropdownVisible) {
          positionShapeDropdown();
        }
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
      });

      window.addEventListener('scroll', (event) => {
        if (!isShapeDropdownVisible) return;
        if (shapeDropdown.contains(event.target)) {
          return;
        }
        hideShapeDropdown();
      }, true);

      window.addEventListener('scroll', () => {
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
      }, true);

      function clearShapeSelection() {
        if (selectedShape) {
          selectedShape.classList.remove('selected');
          selectedShape = null;
        }
        hideShapeColorPicker();
        hideShapeSizeBadge();
        hideRotationHandle();
        activeResizeShape = null;
      }

      function selectShape(element) {
        if (!element || !element.classList.contains('shape-element')) return;
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        if (selectedShape && selectedShape !== element) {
          selectedShape.classList.remove('selected');
        }
        selectedShape = element;
        element.classList.add('selected');
        showShapeColorPicker(element);

        setTimeout(() => {
          document.addEventListener('click', function shapeDeselectHandler(e) {
            if (!element.contains(e.target)) {
              if (selectedShape === element) {
                clearShapeSelection();
              }
              document.removeEventListener('click', shapeDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteShape(element) {
        if (!element) return;
        if (selectedShape === element) {
          selectedShape = null;
          hideShapeColorPicker();
          hideRotationHandle();
        }
        element.remove();
        capture();
        saveEditorState('delete_shape');
      }

      function renderShapeSvg(shape) {
        const strokeWidth = typeof shape.strokeWidth === 'number' ? shape.strokeWidth : 0;
        return `
          <svg class="shape-svg" viewBox="${shape.viewBox}" preserveAspectRatio="none">
            <g class="shape-geometry" fill="currentColor" stroke="currentColor"
               stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round">
              ${shape.svg}
            </g>
          </svg>
        `;
      }

      function createShapeElement(shape, options = {}) {
        if (!shape) return null;
        const element = document.createElement('div');
        element.className = 'shape-element';
        element.dataset.shape = shape.id;
        const minWidth = options.minWidth || shape.minWidth || 60;
        const minHeight = options.minHeight || shape.minHeight || 60;
        element.dataset.minWidth = String(minWidth);
        element.dataset.minHeight = String(minHeight);
        const color = normalizeColorHex(options.color || shape.defaultColor || '#e8f5e9');
        element.dataset.color = color;
        element.style.color = color;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? options.zIndex : 2;

        const parsedWidth = Number(options.width);
        const parsedHeight = Number(options.height);
        const width = Number.isFinite(parsedWidth) && parsedWidth > 0 ? parsedWidth : (shape.defaultWidth || 160);
        const height = Number.isFinite(parsedHeight) && parsedHeight > 0 ? parsedHeight : (shape.defaultHeight || 140);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        const innerWidth = canvas.clientWidth;
        const innerHeight = canvas.clientHeight;
        const defaultLeft = (innerWidth - width) / 2;
        const defaultTop = (innerHeight - height) / 2;
        const parsedLeft = Number(options.left);
        const parsedTop = Number(options.top);
        const left = Number.isFinite(parsedLeft) ? parsedLeft : defaultLeft;
        const top = Number.isFinite(parsedTop) ? parsedTop : defaultTop;

        const clampedLeft = Math.max(24, Math.min(left, innerWidth - width - 24));
        const clampedTop = Math.max(24, Math.min(top, innerHeight - height - 24));

        element.style.left = `${clampedLeft}px`;
        element.style.top = `${clampedTop}px`;
        const rotation = Number.isFinite(Number(options.rotation)) ? Number(options.rotation) : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = renderShapeSvg(shape);
        const svg = element.querySelector('.shape-svg');
        if (svg) {
          svg.style.width = '100%';
          svg.style.height = '100%';
        }

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectShape(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectShape(element);
        });

        if (options.select) {
          selectShape(element);
        }

        return element;
      }

      function instantiateShape(shapeData) {
        if (!shapeData) return;
        const shape = SHAPE_OPTION_MAP.get(shapeData.shapeId) || SHAPE_OPTIONS[0];
        if (!shape) return;
        const element = createShapeElement(shape, {
          left: shapeData.left,
          top: shapeData.top,
          width: shapeData.width,
          height: shapeData.height,
          color: shapeData.color,
          zIndex: shapeData.zIndex,
          minWidth: shapeData.minWidth,
          minHeight: shapeData.minHeight,
          rotation: shapeData.rotation
        });
        if (element && shapeData.color) {
          const normalizedColor = normalizeColorHex(shapeData.color);
          element.dataset.color = normalizedColor;
          element.style.color = normalizedColor;
        }
      }

      function insertShape(shapeId) {
        const shape = SHAPE_OPTION_MAP.get(shapeId);
        if (!shape) return;
        const element = createShapeElement(shape, { select: true });
        if (element) {
          capture();
          saveEditorState('add_shape');
        }
      }

      function collectAdditionalTextBoxesData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
          const rect = box.getBoundingClientRect();
          const computed = window.getComputedStyle(box);
          return {
            html: box.innerHTML,
            top: parseFloat(box.style.top) || rect.top - canvasRect.top,
            left: parseFloat(box.style.left) || rect.left - canvasRect.left,
            width: box.offsetWidth,
            height: box.offsetHeight,
            fontSize: box.style.fontSize || computed.fontSize,
            fontFamily: computed.fontFamily,
            display: box.style.display || '',
            rotation: parseFloat(box.dataset.rotation || '0') || 0,
            minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
            minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50),
            backgroundColor: box.style.backgroundColor || '',
            color: box.style.color || '',
            zIndex: box.style.zIndex ? parseInt(box.style.zIndex, 10) : undefined
          };
        });
      }

      function createAdditionalTextBox(baseOptions = {}) {
        const newTextBox = document.createElement('div');
        newTextBox.className = 'text-box additional-text-box';
        newTextBox.contentEditable = true;
        newTextBox.dataset.placeholder = 'Click to add text';
        newTextBox.style.position = 'absolute';
        newTextBox.style.top = (baseOptions.top !== undefined ? baseOptions.top : (canvas.clientHeight / 2 - 100)) + 'px';
        newTextBox.style.left = (baseOptions.left !== undefined ? baseOptions.left : (canvas.clientWidth / 2 - 150)) + 'px';
        newTextBox.style.width = (baseOptions.width !== undefined ? baseOptions.width : 300) + 'px';
        newTextBox.style.height = (baseOptions.height !== undefined ? baseOptions.height : 200) + 'px';
        const minWidthValue = baseOptions.minWidth !== undefined ? baseOptions.minWidth : 200;
        const minHeightValue = baseOptions.minHeight !== undefined ? baseOptions.minHeight : 50;
        newTextBox.style.minWidth = minWidthValue + 'px';
        newTextBox.style.minHeight = minHeightValue + 'px';
        newTextBox.dataset.minWidth = String(minWidthValue);
        newTextBox.dataset.minHeight = String(minHeightValue);
        newTextBox.style.border = baseOptions.border || '';
        newTextBox.style.padding = baseOptions.padding || '';
        newTextBox.style.outline = 'none';
        newTextBox.style.overflow = 'visible';
        newTextBox.style.color = baseOptions.color || '#0f172a';
        newTextBox.style.backgroundColor = (baseOptions.backgroundColor !== undefined) ? baseOptions.backgroundColor : 'transparent';
        newTextBox.style.whiteSpace = 'pre-wrap';
        newTextBox.style.wordBreak = 'break-word';
        newTextBox.style.writingMode = 'horizontal-tb';
        newTextBox.style.lineHeight = baseOptions.lineHeight || '1.45';
        newTextBox.style.fontSize = baseOptions.fontSize || '16px';
        newTextBox.style.fontFamily = baseOptions.fontFamily || DEFAULT_FONT_FAMILY;
        newTextBox.style.display = baseOptions.display || '';
        const rotation = Number.isFinite(baseOptions.rotation) ? baseOptions.rotation : 0;
        newTextBox.dataset.rotation = String(rotation);
        newTextBox.style.transform = `rotate(${rotation}deg)`;
        if (baseOptions.zIndex !== undefined) {
          newTextBox.style.zIndex = String(baseOptions.zIndex);
        }
        if (baseOptions.html) {
          newTextBox.innerHTML = baseOptions.html;
        }
        const placeholder = newTextBox.dataset.placeholder;
        newTextBox.addEventListener('focus', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        newTextBox.addEventListener('blur', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        canvas.appendChild(newTextBox);
        createResizeEdges(newTextBox);
        makeDraggable(newTextBox);
        makeResizable(newTextBox);
        setupFontSizeTracking(newTextBox);
        setupFontFamilyTracking(newTextBox);
        elementFontSizes.set(newTextBox, parseFloat(newTextBox.style.fontSize) || 16);
        elementFontFamilies.set(newTextBox, newTextBox.style.fontFamily || DEFAULT_FONT_FAMILY);
        newTextBox.addEventListener('click', (e) => {
          if (e.target === newTextBox || !newTextBox.textContent.trim()) {
            selectTextBox(newTextBox);
          }
        });
        return newTextBox;
      }

      function instantiateAdditionalTextBox(boxData) {
        if (!boxData) return;
        createAdditionalTextBox(boxData);
      }

      function collectShapesData() {
        const canvasRect = canvas.getBoundingClientRect();
        return Array.from(document.querySelectorAll('.shape-element')).map(el => {
          const rect = el.getBoundingClientRect();
          const leftStyle = parseFloat(el.style.left);
          const topStyle = parseFloat(el.style.top);
          return {
            shapeId: el.dataset.shape,
            left: Number.isFinite(leftStyle) ? leftStyle : rect.left - canvasRect.left,
            top: Number.isFinite(topStyle) ? topStyle : rect.top - canvasRect.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            color: normalizeColorHex(el.dataset.color || el.style.color || '#e8f5e9'),
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined,
            minWidth: el.dataset.minWidth ? parseFloat(el.dataset.minWidth) : undefined,
            minHeight: el.dataset.minHeight ? parseFloat(el.dataset.minHeight) : undefined,
            rotation: parseFloat(el.dataset.rotation || '0') || 0
          };
        });
      }
      
      // Template Background Detection and Application
      (function() {
        // Get template from query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const templateParam = urlParams.get('template');
        
        // Also check sessionStorage for backward compatibility
        const templateFromStorage = sessionStorage.getItem('selectedTemplate');
        const templateName = templateParam || templateFromStorage;
        
        if (templateName) {
          // Map template names to CSS classes
          const templateMap = {
            'marketing': 'marketing-template',
            'business': 'business-template',
            'education': 'education-template',
            'project': 'project-template',
            'business-pro': 'business-template',
            'creative-bold': 'marketing-template',
            'corporate-clean': 'business-template'
          };
          
          const templateClass = templateMap[templateName.toLowerCase()];
          
          if (templateClass) {
            // Remove any existing template classes
            canvas.classList.remove('marketing-template', 'business-template', 'education-template', 'project-template');
            
            // Add the new template class
            canvas.classList.add(templateClass);
          }
        }
      })();
      
      // Track selected text box for keyboard deletion
      let selectedTextBox = null;
      
      // Undo/Redo history stack
      let actionHistory = [];
      let redoStack = [];
      const MAX_HISTORY = 50; // Limit history size
      
      // Save current editor state to history
      function saveEditorState(action) {
        const state = {
          action: action,
          timestamp: Date.now(),
          slides: JSON.parse(JSON.stringify(slides)), // Deep copy
          active: active,
          canvasState: {
            titleBoxVisible: titleBox.style.display !== 'none',
            textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
              const rect = box.getBoundingClientRect();
              const canvasRect = canvas.getBoundingClientRect();
              return {
                element: box,
                html: box.innerHTML,
                style: {
                  top: rect.top - canvasRect.top,
                  left: rect.left - canvasRect.left,
                  width: box.offsetWidth,
                  height: box.offsetHeight,
                  fontSize: box.style.fontSize,
                  fontFamily: window.getComputedStyle(box).fontFamily,
                display: box.style.display,
                rotation: parseFloat(box.dataset.rotation || '0') || 0
                }
              };
            }),
            shapes: collectShapesData()
          }
        };
        
        actionHistory.push(state);
        
        // Limit history size
        if (actionHistory.length > MAX_HISTORY) {
          actionHistory.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update undo button state
        updateUndoButton();
      }
      
      // Restore editor state from history
      function restoreEditorState(state) {
        // Restore slides data
        slides.length = 0;
        slides.push(...JSON.parse(JSON.stringify(state.slides)));
        active = state.active;
        
        // Restore title and text box visibility
        if (state.canvasState) {
          titleBox.style.display = state.canvasState.titleBoxVisible ? '' : 'none';
          textBox.style.display = state.canvasState.textBoxVisible ? '' : 'none';
        }
        
        // Restore slide content
        load();
        renderSidebar();
        
        // Restore additional text boxes
        if (state.canvasState && state.canvasState.additionalTextBoxes) {
          // Remove existing additional text boxes
          document.querySelectorAll('.additional-text-box').forEach(box => {
            if (!state.canvasState.additionalTextBoxes.some(saved => saved.element === box)) {
              box.remove();
            }
          });
          
          // Restore saved additional text boxes
          state.canvasState.additionalTextBoxes.forEach(savedBox => {
            let existingBox = null;
            if (savedBox.element && document.contains(savedBox.element)) {
              existingBox = savedBox.element;
            } else {
              // Create new box if it doesn't exist
              existingBox = document.createElement('div');
              existingBox.className = 'text-box additional-text-box';
              existingBox.contentEditable = true;
              existingBox.dataset.placeholder = 'Click to add text';
              canvas.appendChild(existingBox);
              
              // Setup the new box
              createResizeEdges(existingBox);
              makeDraggable(existingBox);
              makeResizable(existingBox);
              setupFontSizeTracking(existingBox);
              setupFontFamilyTracking(existingBox);
              elementFontSizes.set(existingBox, parseFloat(savedBox.style.fontSize) || 16);
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily || DEFAULT_FONT_FAMILY);
              
              // Add selection handler
              existingBox.addEventListener('click', (e) => {
                if (e.target === existingBox || !existingBox.textContent.trim()) {
                  selectTextBox(existingBox);
                }
              });
            }
            
            // Restore content and style
            existingBox.innerHTML = savedBox.html;
            existingBox.style.top = savedBox.style.top + 'px';
            existingBox.style.left = savedBox.style.left + 'px';
            existingBox.style.width = savedBox.style.width + 'px';
            existingBox.style.height = savedBox.style.height + 'px';
            existingBox.style.fontSize = savedBox.style.fontSize;
            if (savedBox.style.fontFamily) {
              existingBox.style.fontFamily = savedBox.style.fontFamily;
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily);
            }
            existingBox.style.display = savedBox.style.display || '';
            const savedRotation = Number.isFinite(savedBox.style.rotation) ? savedBox.style.rotation : 0;
            existingBox.dataset.rotation = String(savedRotation);
            existingBox.style.transform = `rotate(${savedRotation}deg)`;
            const savedMinWidth = Number.isFinite(savedBox.style.minWidth) ? savedBox.style.minWidth : 200;
            const savedMinHeight = Number.isFinite(savedBox.style.minHeight) ? savedBox.style.minHeight : 50;
            existingBox.dataset.minWidth = String(savedMinWidth);
            existingBox.dataset.minHeight = String(savedMinHeight);
          });
        }

        if (state.canvasState && state.canvasState.shapes) {
          document.querySelectorAll('.shape-element').forEach(shapeEl => shapeEl.remove());
          state.canvasState.shapes.forEach(shapeData => instantiateShape(shapeData));
        }
        
        updateUndoButton();
      }
      
      // Undo last action
      function undoLastAction() {
        if (actionHistory.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const rect = box.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: rect.top - canvasRect.top,
                    left: rect.left - canvasRect.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                  display: box.style.display,
                  rotation: parseFloat(box.dataset.rotation || '0') || 0,
                  minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                  minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData()
            }
          };
          
          // Save current state to redo stack
          redoStack.push(currentState);
          
          // Get previous state from history
          const previousState = actionHistory.pop();
          restoreEditorState(previousState);
        }
      }
      
      // Update undo/redo button states
      function updateUndoButton() {
        const backBtn = document.getElementById('btnBack');
        const forwardBtn = document.getElementById('btnForward');
        if (backBtn) {
          backBtn.disabled = actionHistory.length === 0;
          backBtn.style.opacity = actionHistory.length === 0 ? '0.5' : '1';
        }
        if (forwardBtn) {
          forwardBtn.disabled = redoStack.length === 0;
          forwardBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
        }
      }
      
      // Initialize with initial state
      saveEditorState('initial');

      function clearSlideDragIndicators() {
        sidebar.querySelectorAll('.slide-preview.drop-target, .slide-preview.drop-target-before, .slide-preview.drop-target-after').forEach(preview => {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        });
      }

      function handleSlideDragStart(event) {
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        slideDragSourceIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(slideDragSourceIndex)) {
          slideDragSourceIndex = null;
          return;
        }
        item.classList.add('dragging');
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(slideDragSourceIndex));
        }
      }

      function handleSlideDragOver(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const preview = item.querySelector('.slide-preview');
        if (!preview) return;
        clearSlideDragIndicators();
        preview.classList.add('drop-target');
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        if (isAfter) {
          preview.classList.add('drop-target-after');
          preview.classList.remove('drop-target-before');
        } else {
          preview.classList.add('drop-target-before');
          preview.classList.remove('drop-target-after');
        }
        item.dataset.dropPosition = isAfter ? 'after' : 'before';
      }

      function handleSlideDragLeave(event) {
        const item = event.currentTarget;
        if (!item) return;
        const preview = item.querySelector('.slide-preview');
        if (preview) {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        }
        delete item.dataset.dropPosition;
      }

      function finalizeSlideReorder(fromIndex, insertIndex) {
        if (fromIndex === null || insertIndex === null) return;
        if (fromIndex < 0 || fromIndex >= slides.length) return;
        if (insertIndex < 0) insertIndex = 0;
        if (insertIndex > slides.length) insertIndex = slides.length;
        if (insertIndex === fromIndex || insertIndex === fromIndex + 1) return;

        capture();

        const [movedSlide] = slides.splice(fromIndex, 1);
        let adjustedInsertIndex = insertIndex;
        if (insertIndex > fromIndex) {
          adjustedInsertIndex = insertIndex - 1;
        }
        if (adjustedInsertIndex < 0) adjustedInsertIndex = 0;
        slides.splice(adjustedInsertIndex, 0, movedSlide);

        let newActive = active;
        if (fromIndex === active) {
          newActive = adjustedInsertIndex;
        } else {
          if (fromIndex < active) {
            newActive -= 1;
          }
          if (adjustedInsertIndex <= newActive) {
            newActive += 1;
          }
        }
        active = Math.max(0, Math.min(slides.length - 1, newActive));
        load();
        renderSidebar();
        saveEditorState('reorder_slides');
      }

      function handleSlideDrop(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const targetIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(targetIndex)) return;
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        const insertIndex = targetIndex + (isAfter ? 1 : 0);
        clearSlideDragIndicators();
        delete item.dataset.dropPosition;
        finalizeSlideReorder(slideDragSourceIndex, insertIndex);
      }

      function handleSlideDragEnd(event) {
        const item = event.currentTarget;
        if (item) {
          item.classList.remove('dragging');
          delete item.dataset.dropPosition;
        }
        clearSlideDragIndicators();
        slideDragSourceIndex = null;
      }

      function selectEditableText(element) {
        const range = document.createRange();
        range.selectNodeContents(element);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function refreshSidebarSoon() {
        requestAnimationFrame(() => renderSidebar());
      }

      function moveSlideByOffset(index, offset) {
        if (!Number.isInteger(index) || !Number.isInteger(offset)) return;
        const targetIndex = index + offset;
        if (targetIndex < 0 || targetIndex >= slides.length) return;
        finalizeSlideReorder(index, targetIndex + (offset > 0 ? 1 : 0));
      }

      function applySlideTransitionClass(element, transition) {
        if (!element) return;
        const normalized = typeof transition === 'string' ? transition : DEFAULT_TRANSITION;
        TRANSITION_CLASS_NAMES.forEach(cls => element.classList.remove(cls));
        void element.offsetWidth;
        if (!isPresenting) return;
        if (normalized && normalized !== 'none') {
          element.classList.add(`transition-effect-${normalized}`);
        }
      }

      function getTransitionLabel(type) {
        const option = TRANSITION_OPTIONS.find(opt => opt.value === type) || TRANSITION_OPTIONS[0];
        return option.label;
      }

      function getTransitionIconHtml(type) {
        const normalized = (type || DEFAULT_TRANSITION);
        switch (normalized) {
          case 'fade':
            return '<i class="fas fa-water"></i>';
          case 'slide':
            return '<i class="fas fa-arrow-right"></i>';
          case 'zoom':
            return '<i class="fas fa-search-plus"></i>';
          case 'flip':
            return '<i class="fas fa-sync-alt"></i>';
          case 'rotate':
            return '<i class="fas fa-sync"></i>';
          case 'push':
            return '<i class="fas fa-long-arrow-alt-right"></i>';
          case 'wipe':
            return '<i class="fas fa-align-left"></i>';
          case 'spin':
            return '<i class="fas fa-circle-notch"></i>';
          case 'dissolve':
            return '<i class="fas fa-braille"></i>';
          case 'cube':
            return '<i class="fas fa-dice-d6"></i>';
          case 'bounce':
            return '<i class="fas fa-arrow-down"></i>';
          case 'swirl':
            return '<i class="fas fa-asterisk"></i>';
          case 'none':
          default:
            return `
              <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="15" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.8"/>
                <rect x="11" y="9" width="10" height="8" rx="1.6" ry="1.6" fill="none" stroke="currentColor" stroke-width="1.6"/>
                <path d="M3 8h15M3 11h7M3 14h7" stroke="currentColor" stroke-width="1.2" />
              </svg>
            `;
        }
      }

      function updateTransitionButtonAppearance(button, slideIndex) {
        if (!button) return;
        const slide = slides[slideIndex];
        const transitionValue = slide ? (slide.transition || DEFAULT_TRANSITION) : DEFAULT_TRANSITION;
        const iconHtml = getTransitionIconHtml(transitionValue);
        button.innerHTML = `<span class="transition-icon">${iconHtml}</span><span class="transition-caret"><i class="fas fa-caret-down"></i></span>`;
        const targetSlideNumber = slideIndex === slides.length - 1 ? 'End' : `Slide ${slideIndex + 2}`;
        const label = getTransitionLabel(transitionValue);
        button.title = `Transition (${label}) â†’ ${targetSlideNumber}`;
        button.setAttribute('aria-label', button.title);
      }

      function hideSlideContextMenu() {
        if (!slideContextMenu || !slideContextMenu.classList.contains('show')) {
          slideContextMenuTarget = null;
          slideContextMenuTitle = null;
          slideContextMenuIndex = null;
          return;
        }
        slideContextMenu.classList.remove('show');
        slideContextMenu.style.top = '';
        slideContextMenu.style.left = '';
        slideContextMenuTarget = null;
        slideContextMenuTitle = null;
        slideContextMenuIndex = null;
      }

      function showSlideContextMenu(event, index, titleElement, slideItem) {
        if (!slideContextMenu || !titleElement || !slideItem) return;
        event.preventDefault();
        slideContextMenuIndex = index;
        slideContextMenuTitle = titleElement;
        slideContextMenuTarget = slideItem;

        slideContextMenu.classList.add('show');
        const menuRect = slideContextMenu.getBoundingClientRect();
        const padding = 8;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        top = Math.max(padding, top);
        left = Math.max(padding, left);
        slideContextMenu.style.top = `${top}px`;
        slideContextMenu.style.left = `${left}px`;
      }

      function hideSlideTransitionMenu() {
        if (!slideTransitionMenu || !slideTransitionMenu.classList.contains('show')) {
          slideTransitionMenuIndex = null;
          slideTransitionMenuAnchor = null;
          return;
        }
        slideTransitionMenu.classList.remove('show');
        slideTransitionMenu.style.top = '';
        slideTransitionMenu.style.left = '';
        slideTransitionMenuIndex = null;
        slideTransitionMenuAnchor = null;
      }

      function showSlideTransitionMenu(event, index, anchorElement) {
        if (!slideTransitionMenu || !anchorElement) return;
        event.preventDefault();
        event.stopPropagation();
        slideTransitionMenuIndex = index;
        slideTransitionMenuAnchor = anchorElement;
        slideTransitionMenu.classList.add('show');
        const buttons = slideTransitionMenu.querySelectorAll('button');
        const currentTransition = (slides[index] && slides[index].transition) || DEFAULT_TRANSITION;
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.transition === currentTransition);
        });
        const menuRect = slideTransitionMenu.getBoundingClientRect();
        const anchorRect = anchorElement.getBoundingClientRect();
        const padding = 8;
        let top = anchorRect.top + window.scrollY - menuRect.height - 6;
        let left = anchorRect.left + window.scrollX - menuRect.width / 2 + anchorRect.width / 2;
        if (top < padding) {
          top = anchorRect.bottom + window.scrollY + 6;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        if (left < padding) {
          left = padding;
        }
        slideTransitionMenu.style.top = `${top}px`;
        slideTransitionMenu.style.left = `${left}px`;
      }

      if (slideContextRenameBtn) {
        slideContextRenameBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const titleElement = slideContextMenuTitle;
          const slideIndex = slideContextMenuIndex;
          const slideItem = slideContextMenuTarget;
          hideSlideContextMenu();
          if (titleElement && slideItem && Number.isInteger(slideIndex)) {
            startSlideTitleEditing(titleElement, slideIndex, slideItem);
          }
        });
      }

      if (slideTransitionMenu) {
        slideTransitionMenu.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (slideTransitionMenuIndex === null) {
              hideSlideTransitionMenu();
              return;
            }
            const value = btn.dataset.transition || DEFAULT_TRANSITION;
            const slide = slides[slideTransitionMenuIndex];
            hideSlideTransitionMenu();
            if (!slide) return;
            slide.transition = value;
            capture();
            slide.transition = value;
            if (slideTransitionMenuIndex === active) {
              applySlideTransitionClass(canvas, value);
            }
            if (slideTransitionMenuAnchor) {
              updateTransitionButtonAppearance(slideTransitionMenuAnchor, slideTransitionMenuIndex);
            }
            saveEditorState('change_transition');
            refreshSidebarSoon();
          });
        });
      }

      document.addEventListener('click', (event) => {
        if (slideContextMenu && slideContextMenu.classList.contains('show') && !slideContextMenu.contains(event.target)) {
          hideSlideContextMenu();
        }
        if (slideTransitionMenu && slideTransitionMenu.classList.contains('show') && !slideTransitionMenu.contains(event.target)) {
          hideSlideTransitionMenu();
        }
      });

      window.addEventListener('resize', hideSlideContextMenu);
      window.addEventListener('scroll', hideSlideContextMenu, true);
      window.addEventListener('resize', hideSlideTransitionMenu);
      window.addEventListener('scroll', hideSlideTransitionMenu, true);

      function startSlideTitleEditing(titleElement, slideIndex, slideItem) {
        if (!titleElement) return;
        const originalTitle = titleElement.textContent.trim();
        titleElement.contentEditable = 'true';
        titleElement.classList.add('editing');
        titleElement.focus({ preventScroll: true });
        selectEditableText(titleElement);
        if (slideItem) {
          slideItem.setAttribute('draggable', 'false');
        }

        function cleanup() {
          titleElement.contentEditable = 'false';
          titleElement.classList.remove('editing');
          if (slideItem) {
            slideItem.setAttribute('draggable', 'true');
          }
          titleElement.removeEventListener('blur', handleBlur);
          titleElement.removeEventListener('keydown', handleKeyDown);
        }

        function applyTitleChange(shouldPersist) {
          const trimmed = titleElement.textContent.trim();
          const fallback = originalTitle || slides[slideIndex].title || `Slide ${slideIndex + 1}`;
          const finalTitle = shouldPersist ? (trimmed || fallback) : fallback;
          cleanup();
          titleElement.textContent = finalTitle;
          if (shouldPersist && finalTitle !== originalTitle) {
            slides[slideIndex].title = finalTitle;
            if (slideIndex === active && titleBox.style.display !== 'none') {
              titleBox.textContent = finalTitle;
            }
            capture();
            saveEditorState('rename_slide');
          }
          refreshSidebarSoon();
        }

        function handleBlur() {
          applyTitleChange(true);
        }

        function handleKeyDown(event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            applyTitleChange(true);
          } else if (event.key === 'Escape') {
            event.preventDefault();
            titleElement.textContent = originalTitle;
            applyTitleChange(false);
          }
        }

        titleElement.addEventListener('blur', handleBlur);
        titleElement.addEventListener('keydown', handleKeyDown);
      }

      function renderSidebar() {
        hideSlideContextMenu();
        hideSlideTransitionMenu();
        hideSlideTransitionMenu();
        sidebar.innerHTML = '';
        slides.forEach((s, i) => {
          // Create slide-item container
          const slideItem = document.createElement('div');
          slideItem.className = 'slide-item';
          slideItem.dataset.index = String(i);
          slideItem.setAttribute('draggable', 'true');
          
          // Create slide preview
          const el = document.createElement('div');
          el.className = 'slide-preview' + (i === active ? ' active' : '');
        el.setAttribute('draggable', 'false');

        const titleSpan = document.createElement('span');
        titleSpan.className = 'slide-preview-title';
        titleSpan.textContent = s.title || `Slide ${i + 1}`;
        el.appendChild(titleSpan);

          el.addEventListener('click', () => {
            capture();
            active = i;
            load();
            renderSidebar();
          });

        titleSpan.addEventListener('click', (event) => {
          if (titleSpan.isContentEditable) {
            event.stopPropagation();
          }
        });

        titleSpan.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          startSlideTitleEditing(titleSpan, i, slideItem);
        });

        titleSpan.addEventListener('dragstart', (event) => {
          if (titleSpan.isContentEditable) {
            event.preventDefault();
          }
        });
          
          // Create slide action bar container
          const slideActionBar = document.createElement('div');
          slideActionBar.className = 'slide-action-bar';
          
          // New Slide button with icon
          const newSlideBtn = document.createElement('button');
          newSlideBtn.className = 'new-slide';
          newSlideBtn.title = 'New Slide';
          newSlideBtn.innerHTML = '<i class="fas fa-plus"></i>';
          newSlideBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            createNewSlide(i);
          });
          
          // Duplicate button with icon
          const duplicateBtn = document.createElement('button');
          duplicateBtn.className = 'duplicate-slide';
          duplicateBtn.title = 'Duplicate';
          duplicateBtn.innerHTML = '<i class="fas fa-copy"></i>';
          duplicateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            duplicateCurrentSlide(i);
          });

          const moveUpBtn = document.createElement('button');
          moveUpBtn.className = 'move-slide-up';
          moveUpBtn.title = 'Move Up';
          moveUpBtn.innerHTML = '<i class="fas fa-arrow-up"></i>';
          moveUpBtn.disabled = i === 0;
          moveUpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            moveSlideByOffset(i, -1);
          });

          const moveDownBtn = document.createElement('button');
          moveDownBtn.className = 'move-slide-down';
          moveDownBtn.title = 'Move Down';
          moveDownBtn.innerHTML = '<i class="fas fa-arrow-down"></i>';
          moveDownBtn.disabled = i === slides.length - 1;
          moveDownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            moveSlideByOffset(i, 1);
          });
          
          slideActionBar.appendChild(newSlideBtn);
          slideActionBar.appendChild(duplicateBtn);
          slideActionBar.appendChild(moveUpBtn);
        const transitionButton = document.createElement('button');
        transitionButton.type = 'button';
        transitionButton.className = 'transition-control-button';
        transitionButton.setAttribute('data-slide-index', String(i));
        updateTransitionButtonAppearance(transitionButton, i);
        transitionButton.addEventListener('click', (event) => {
          hideSlideContextMenu();
          event.preventDefault();
          event.stopPropagation();
          showSlideTransitionMenu(event, i, transitionButton);
        });
        
        slideActionBar.appendChild(moveDownBtn);
        slideActionBar.appendChild(transitionButton);
          
          slideItem.appendChild(el);
          slideItem.appendChild(slideActionBar);

        slideItem.addEventListener('dragstart', handleSlideDragStart);
        slideItem.addEventListener('dragenter', (event) => {
          if (slideDragSourceIndex !== null) {
            event.preventDefault();
          }
        });
        slideItem.addEventListener('dragover', handleSlideDragOver);
        slideItem.addEventListener('dragleave', handleSlideDragLeave);
        slideItem.addEventListener('drop', handleSlideDrop);
        slideItem.addEventListener('dragend', handleSlideDragEnd);
        slideItem.addEventListener('contextmenu', (event) => {
          hideSlideTransitionMenu();
          showSlideContextMenu(event, i, titleSpan, slideItem);
        });
          
          sidebar.appendChild(slideItem);

        });
      }

      function createResizeEdges(element) {
        // Remove existing edges
        element.querySelectorAll('.resize-edge').forEach(el => el.remove());
        
        const isShapeLike = element.classList && (
          element.classList.contains('shape-element') ||
          element.classList.contains('text-box') ||
          element.classList.contains('title-box') ||
          element.classList.contains('additional-text-box')
        );
        const edges = isShapeLike
          ? ['top', 'bottom', 'left', 'right', 'bottom-right']
          : ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        edges.forEach(edge => {
          const edgeEl = document.createElement('div');
          edgeEl.className = `resize-edge ${edge}`;
          edgeEl.dataset.edge = edge;
          if (isShapeLike) {
            edgeEl.classList.add(edge === 'bottom-right' ? 'corner' : 'side');
          } else {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          }
          element.appendChild(edgeEl);
        });
      }

      function load() {
        const slide = slides[active];
        const titleFont = slide.titleFontFamily || DEFAULT_FONT_FAMILY;
        const textFont = slide.textFontFamily || DEFAULT_FONT_FAMILY;
        elementFontFamilies.set(titleBox, titleFont);
        elementFontFamilies.set(textBox, textFont);
        titleBox.style.fontFamily = titleFont;
        textBox.style.fontFamily = textFont;

        const titleBoxData = slide.titleBox || {};
        const textBoxData = slide.textBox || {};
        const showTitleBox = titleBoxData.visible !== undefined ? titleBoxData.visible : true;
        if (showTitleBox) {
          titleBox.style.display = '';
          titleBox.textContent = slide.title || '';
        if (slide.titleBox) {
          titleBox.style.top = slide.titleBox.top + 'px';
          titleBox.style.left = slide.titleBox.left + 'px';
          if (slide.titleBox.width) {
            titleBox.style.width = slide.titleBox.width + 'px';
            titleBox.style.right = 'auto';
          }
          if (slide.titleBox.height) {
            titleBox.style.height = slide.titleBox.height + 'px';
          }
            const titleRotation = Number.isFinite(slide.titleBox.rotation) ? slide.titleBox.rotation : 0;
            titleBox.dataset.rotation = String(titleRotation);
            titleBox.style.transform = `rotate(${titleRotation}deg)`;
          }
        } else {
          titleBox.style.display = 'none';
          titleBox.textContent = '';
        }

        const showTextBox = textBoxData.visible !== undefined ? textBoxData.visible : true;
        if (showTextBox) {
          textBox.style.display = '';
          textBox.textContent = slide.content || '';
        if (slide.textBox) {
          textBox.style.top = slide.textBox.top + 'px';
          textBox.style.left = slide.textBox.left + 'px';
          if (slide.textBox.width) {
            textBox.style.width = slide.textBox.width + 'px';
            textBox.style.right = 'auto';
          }
          if (slide.textBox.height) {
            textBox.style.height = slide.textBox.height + 'px';
            textBox.style.bottom = 'auto';
          }
            const textRotation = Number.isFinite(slide.textBox.rotation) ? slide.textBox.rotation : 0;
            textBox.dataset.rotation = String(textRotation);
            textBox.style.transform = `rotate(${textRotation}deg)`;
          }
        } else {
          textBox.style.display = 'none';
          textBox.textContent = '';
        }

        if (!slide.titleBox) {
          titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
        }
        if (!slide.textBox) {
          textBox.dataset.rotation = textBox.dataset.rotation || '0';
        }
        
        // Create resize edges
        createResizeEdges(titleBox);
        createResizeEdges(textBox);

        document.querySelectorAll('.additional-text-box').forEach(el => el.remove());
        if (!Array.isArray(slide.additionalTextBoxes)) {
          slide.additionalTextBoxes = [];
        }
        slide.additionalTextBoxes.forEach(textBoxData => instantiateAdditionalTextBox(textBoxData));

        document.querySelectorAll('.shape-element').forEach(el => el.remove());
        selectedShape = null;
        hideShapeColorPicker();
        hideRotationHandle();
        if (!Array.isArray(slide.shapes)) {
          slide.shapes = [];
        }
        slide.shapes.forEach(shapeData => instantiateShape(shapeData));

        updateFontPickerSelectedFont();
        const transitionValue = slide.transition || DEFAULT_TRANSITION;
        slide.transition = transitionValue;
        if (!isPresenting) {
          TRANSITION_CLASS_NAMES.forEach(cls => canvas.classList.remove(cls));
        }
      }

      function capture() {
        const slide = slides[active];
        if (!slide) return;
        const titleVisible = titleBox.style.display !== 'none';
        const textVisible = textBox.style.display !== 'none';
        if (titleVisible) {
          slide.title = titleBox.textContent.trim();
        }
        if (textVisible) {
          slide.content = textBox.textContent.trim();
        }
        
        // Save positions and sizes
        const titleRect = titleBox.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        slide.titleBox = {
          top: titleRect.top - canvasRect.top,
          left: titleRect.left - canvasRect.left,
          width: titleBox.offsetWidth,
          height: titleBox.offsetHeight,
          visible: titleVisible,
          rotation: parseFloat(titleBox.dataset.rotation || '0') || 0
        };
        
        const textRect = textBox.getBoundingClientRect();
        slide.textBox = {
          top: textRect.top - canvasRect.top,
          left: textRect.left - canvasRect.left,
          width: textBox.offsetWidth,
          height: textBox.offsetHeight,
          visible: textVisible,
          rotation: parseFloat(textBox.dataset.rotation || '0') || 0
        };

        slide.titleFontFamily = getCurrentFontFamily(titleBox);
        slide.textFontFamily = getCurrentFontFamily(textBox);
        slide.additionalTextBoxes = collectAdditionalTextBoxesData();
        slide.shapes = collectShapesData();
      }

      // Drag functionality - only when clicking on empty space
      function makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;
        let dragThreshold = 5;
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        
        element.addEventListener('mousedown', (e) => {
          // Don't drag if clicking on resize edge
          if (e.target.classList && e.target.classList.contains('resize-edge')) {
            return;
          }
          
          // Don't drag if clicking on text content
          if (e.target !== element && e.target.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          
          // Only drag if clicking on empty space or border area
          const selection = window.getSelection();
          if (selection.toString().length > 0) {
            return;
          }
          
          // Check if element is empty or clicking on border
          const isEmpty = !element.textContent.trim() || element.textContent.trim() === element.dataset.placeholder;
          const isBorderClick = e.target === element || (e.target === element && element.contains(e.target));
          
          if (!isEmpty && !isBorderClick) {
            return; // Allow text editing
          }
          
          const rect = element.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          startX = e.clientX;
          startY = e.clientY;
          initialLeft = rect.left - canvasRect.left;
          initialTop = rect.top - canvasRect.top;
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
        });
        
        document.addEventListener('mousemove', (e) => {
          if (startX === undefined || startY === undefined) return;
          
          const deltaX = Math.abs(e.clientX - startX);
          const deltaY = Math.abs(e.clientY - startY);
          
          if (!isDragging && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            isDragging = true;
            element.classList.add('dragging');
            if (hadEditableAttr || wasContentEditable) {
            element.setAttribute('contenteditable', 'false');
            }
          }
          
          if (!isDragging) return;
          
          const canvasRect = canvas.getBoundingClientRect();
          const moveX = e.clientX - startX;
          const moveY = e.clientY - startY;
          
          let newLeft = initialLeft + moveX;
          let newTop = initialTop + moveY;
          
          const maxLeft = canvasRect.width - element.offsetWidth - 48;
          const maxTop = canvasRect.height - element.offsetHeight - 48;
          
          newLeft = Math.max(24, Math.min(newLeft, maxLeft));
          newTop = Math.max(24, Math.min(newTop, maxTop));
          
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          capture();
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
            element.setAttribute('contenteditable', 'true');
            }
            capture();
            // Save state for undo after dragging
            saveEditorState('move_element');
          }
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        });
      }
      
      // Resize functionality using edges
      function makeResizable(element) {
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        let resizeEdge = '';
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        let minWidth = 200;
        let minHeight = 50;
        let aspectRatio = 1;
        
        element.addEventListener('mousedown', (e) => {
          if (!e.target.classList.contains('resize-edge')) return;
          
          resizeEdge = e.target.dataset.edge;
          isResizing = true;
          element.classList.add('resizing');
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
          if (hadEditableAttr || wasContentEditable) {
          element.setAttribute('contenteditable', 'false');
          }
          
          const rect = element.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          startX = e.clientX;
          startY = e.clientY;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
          startLeft = rect.left - canvasRect.left;
          startTop = rect.top - canvasRect.top;
          minWidth = parseFloat(element.dataset.minWidth) || 200;
          minHeight = parseFloat(element.dataset.minHeight) || 50;
          aspectRatio = startWidth / startHeight || 1;
        const isShape = element.classList.contains('shape-element');
        const isTextBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        if (isShape || isTextBox) {
          activeResizeShape = element;
          updateShapeSizeBadge(element, startWidth, startHeight);
          showShapeSizeBadge();
        }
          
          e.preventDefault();
          e.stopPropagation();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isResizing) return;
          
          const canvasRect = canvas.getBoundingClientRect();
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
        const isShape = element.classList.contains('shape-element');
        const isShapeLike = isShape || element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
          let newWidth = startWidth;
          let newHeight = startHeight;
          let newLeft = startLeft;
          let newTop = startTop;
          
        if (isShapeLike) {
          const minScale = Math.max(minWidth / startWidth, minHeight / startHeight);
          const bounds = {
            left: 24,
            top: 24,
            right: canvasRect.width - 24,
            bottom: canvasRect.height - 24
          };
          
          if (resizeEdge === 'bottom-right') {
            const centerX = startLeft + startWidth / 2;
            const centerY = startTop + startHeight / 2;
            let widthCandidate = Math.max(minWidth, startWidth + deltaX);
            let heightCandidate = Math.max(minHeight, startHeight + deltaY);
            let scale = Math.max(widthCandidate / startWidth, heightCandidate / startHeight);
            scale = Math.max(scale, minScale);
            newWidth = startWidth * scale;
            newHeight = startHeight * scale;
            newLeft = centerX - newWidth / 2;
            newTop = centerY - newHeight / 2;
          } else if (resizeEdge === 'left') {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(bounds.left, startLeft + deltaX);
            if (newLeft === bounds.left) {
              newWidth = startLeft + startWidth - bounds.left;
            }
          } else if (resizeEdge === 'right') {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, bounds.right - startLeft);
          } else if (resizeEdge === 'top') {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(bounds.top, startTop + deltaY);
            if (newTop === bounds.top) {
              newHeight = startTop + startHeight - bounds.top;
            }
          } else if (resizeEdge === 'bottom') {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, bounds.bottom - startTop);
          }
          
          newWidth = Math.max(newWidth, minWidth);
          newHeight = Math.max(newHeight, minHeight);
          if (resizeEdge === 'bottom-right') {
            if (newLeft < bounds.left) newLeft = bounds.left;
            if (newTop < bounds.top) newTop = bounds.top;
            if (newLeft + newWidth > bounds.right) newLeft = bounds.right - newWidth;
            if (newTop + newHeight > bounds.bottom) newTop = bounds.bottom - newHeight;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else {
          if (resizeEdge.includes('right')) {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, canvasRect.width - newLeft - 48);
          }
          if (resizeEdge.includes('left')) {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(24, startLeft + deltaX);
            if (newLeft === 24) newWidth = startLeft + startWidth - 24;
          }
          if (resizeEdge.includes('bottom')) {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, canvasRect.height - newTop - 48);
          }
          if (resizeEdge.includes('top')) {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(24, startTop + deltaY);
            if (newTop === 24) newHeight = startTop + startHeight - 24;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
        }
          
          capture();
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        });
        
        document.addEventListener('mouseup', () => {
          if (isResizing) {
            isResizing = false;
            element.classList.remove('resizing');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
            element.setAttribute('contenteditable', 'true');
            }
            resizeEdge = '';
            capture();
            // Save state for undo after resizing
            saveEditorState('resize_element');
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        if (shapeSizeBadge.classList.contains('visible')) {
          hideShapeSizeBadge();
          activeResizeShape = null;
          }
        });
      }
      
      // Make boxes draggable and resizable
      makeDraggable(titleBox);
      makeDraggable(textBox);
      makeResizable(titleBox);
      makeResizable(textBox);
      
      // Initialize resize edges
      createResizeEdges(titleBox);
      createResizeEdges(textBox);
      
      // Add selection handlers for title and text boxes
      titleBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === titleBox || !titleBox.textContent.trim()) {
          selectTextBox(titleBox);
        }
      });
      
      textBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === textBox || !textBox.textContent.trim()) {
          selectTextBox(textBox);
        }
      });

      // Toolbar interactions per Editor.json
      function getActiveElement() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
        return document.activeElement === titleBox ? titleBox : textBox;
      }

      // Add Text Box functionality
      function addTextBox() {
        const canvasRect = canvas.getBoundingClientRect();
        const centerX = canvasRect.width / 2 - 150;
        const centerY = canvasRect.height / 2 - 100;
        const newTextBox = createAdditionalTextBox({
          top: centerY,
          left: centerX,
          width: 300,
          height: 200,
          fontSize: '16px',
          fontFamily: DEFAULT_FONT_FAMILY,
          backgroundColor: '#fff',
          color: '#000000'
        });
        if (!newTextBox) return;
            selectTextBox(newTextBox);
        setTimeout(() => {
          if (document.contains(newTextBox)) {
          newTextBox.focus();
          }
        }, 60);
        capture();
        saveEditorState('add_textbox');
      }
      
      // Function to select/deselect text boxes
      function selectTextBox(element) {
        // Can select any text box or title box
        if (!element || (!element.classList.contains('text-box') && element.id !== 'titleBox')) {
          return;
        }
        clearShapeSelection();
        
        // Deselect all other boxes
        document.querySelectorAll('.text-box.selected, .title-box.selected').forEach(box => {
          box.classList.remove('selected');
        });
        
        // Select this box
        element.classList.add('selected');
        createResizeEdges(element);
        selectedTextBox = element;
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        
        // Deselect when clicking elsewhere
        setTimeout(() => {
          document.addEventListener('click', function deselectHandler(e) {
            if (!element.contains(e.target) && e.target !== element) {
              element.classList.remove('selected');
              selectedTextBox = null;
              if (rotationTarget === element) {
                hideRotationHandle();
              }
              document.removeEventListener('click', deselectHandler);
            }
          }, { once: true });
        }, 150);
      }
      
      // Function to delete text box
      function deleteTextBox(element) {
        if (!element) return;
        
        // Handle title box deletion - hide it instead of removing
        if (element.id === 'titleBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          capture();
          return;
        }
        
        // Handle main text box deletion - hide it instead of removing
        if (element.id === 'textBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = titleBox;
            updateFontSizeInput();
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          capture();
          return;
        }
        
        // Handle additional text boxes - remove completely
        if (element.classList.contains('additional-text-box')) {
          // Remove from font size tracking
          elementFontSizes.delete(element);
          // Remove selection
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          // Remove from DOM
          element.remove();
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = textBox;
            updateFontSizeInput();
          }
          capture();
        }
      }
      
      // Global keyboard listener for Delete/Backspace and Undo
      document.addEventListener('keydown', (e) => {
        if (!isPresenting && slideTransitionMenu && slideTransitionMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideTransitionMenu();
          return;
        }
        if (!isPresenting && slideContextMenu && slideContextMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideContextMenu();
          return;
        }
        if (isPresenting) {
          if (e.key === 'Escape') {
            e.preventDefault();
            exitPresentation();
            return;
          }
          if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') {
            e.preventDefault();
            goToNextSlide();
            return;
          }
          if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            e.preventDefault();
            goToPreviousSlide();
            return;
          }
          return;
        }
        // Undo keyboard shortcut (Cmd+Z on Mac, Ctrl+Z on Windows)
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undoLastAction();
          return;
        }
        
        // Redo keyboard shortcut (Cmd+Shift+Z on Mac, Ctrl+Shift+Z on Windows)
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          redoLastAction();
          return;
        }
        
        // Only handle Delete/Backspace if a text box is selected
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
          const selection = window.getSelection();
          const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
          const caretInside = !!(range && selectedTextBox.contains(range.commonAncestorContainer));
          const hasSelection = selection && selection.toString().length > 0;
          const textContent = (selectedTextBox.textContent || '').replace(/\u200B/g, '');
          const isEmpty = !textContent.trim();
          
          if (!caretInside || (caretInside && !hasSelection && isEmpty)) {
            e.preventDefault();
            e.stopPropagation();
            deleteTextBox(selectedTextBox);
            saveEditorState('delete_textbox');
          }
        }

        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedShape) {
          e.preventDefault();
          e.stopPropagation();
          deleteShape(selectedShape);
        }
      });
      
      // Back (Undo) button click handler
      document.getElementById('btnBack').addEventListener('click', () => {
        undoLastAction();
      });
      
      // Forward (Redo) button click handler
      document.getElementById('btnForward').addEventListener('click', () => {
        redoLastAction();
      });
      
      // Redo functionality
      function redoLastAction() {
        if (redoStack.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const rect = box.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: rect.top - canvasRect.top,
                    left: rect.left - canvasRect.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                    display: box.style.display,
                    rotation: parseFloat(box.dataset.rotation || '0') || 0,
                    minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                    minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
            }),
            shapes: collectShapesData()
            }
          };
          
          // Save current state to undo stack
          actionHistory.push(currentState);
          
          // Get next state from redo stack
          const nextState = redoStack.pop();
          restoreEditorState(nextState);
        }
      }
      
      // Formatting tools
      document.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const action = btn.getAttribute('data-action');
          
          // Handle addTextBox action
          if (action === 'addTextBox') {
            addTextBox();
            return;
          }
          if (action === 'present') {
            startPresentation();
            return;
          }
          
          const activeEl = getActiveElement();
          
          // Focus on the active element if needed
          if (activeEl === titleBox || activeEl === textBox || titleBox.contains(activeEl) || textBox.contains(activeEl)) {
            if (titleBox.contains(activeEl) || activeEl === titleBox) {
              titleBox.focus();
            } else {
              textBox.focus();
            }
          }

          // Execute command
          if (action === 'bold') document.execCommand('bold', false);
          else if (action === 'italic') document.execCommand('italic', false);
          else if (action === 'underline') document.execCommand('underline', false);
          else if (action === 'strikeThrough') document.execCommand('strikeThrough', false);
          else if (action === 'superscript') document.execCommand('superscript', false);
          else if (action === 'subscript') document.execCommand('subscript', false);
          else if (action === 'justifyLeft') document.execCommand('justifyLeft', false);
          else if (action === 'justifyCenter') document.execCommand('justifyCenter', false);
          else if (action === 'justifyRight') document.execCommand('justifyRight', false);
          else if (action === 'justifyFull') document.execCommand('justifyFull', false);
          else if (action === 'insertUnorderedList') document.execCommand('insertUnorderedList', false);
          else if (action === 'insertOrderedList') document.execCommand('insertOrderedList', false);
        });
      });

      // Store font sizes for elements
      let titleFontSize = 28;
      let textFontSize = 16;
      let elementFontSizes = new Map(); // Store font sizes for dynamically created elements
      let elementFontFamilies = new Map();
      let currentActiveElement = textBox;

      // Initialize default font sizes
      titleBox.style.fontSize = titleFontSize + 'px';
      textBox.style.fontSize = textFontSize + 'px';
      elementFontSizes.set(titleBox, titleFontSize);
      elementFontSizes.set(textBox, textFontSize);
      titleBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      textBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      elementFontFamilies.set(titleBox, DEFAULT_FONT_FAMILY);
      elementFontFamilies.set(textBox, DEFAULT_FONT_FAMILY);

      // Function to get current font size from an element
      function getCurrentFontSize(element) {
        if (elementFontSizes.has(element)) {
          return elementFontSizes.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseFloat(computedStyle.fontSize);
        return Math.round(fontSize);
      }

      function getCurrentFontFamily(element) {
        if (!element) return DEFAULT_FONT_FAMILY;
        if (elementFontFamilies.has(element)) {
          return elementFontFamilies.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        return computedStyle.fontFamily || DEFAULT_FONT_FAMILY;
      }

      // Function to apply font size to an element
      function applyFontSize(element, size) {
        const selection = window.getSelection();
        
        // If there's selected text in the element, apply font size to selection
        if (selection.rangeCount > 0 && !selection.isCollapsed && 
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = size + 'px';
          
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
          } catch (e) {
            document.execCommand("fontSize", false, "7");
            setTimeout(() => {
              const fonts = element.getElementsByTagName("font");
              for (let i = fonts.length - 1; i >= 0; i--) {
                if (fonts[i].size === "7") {
                  const newSpan = document.createElement('span');
                  newSpan.style.fontSize = size + 'px';
                  newSpan.innerHTML = fonts[i].innerHTML;
                  fonts[i].parentNode.replaceChild(newSpan, fonts[i]);
                }
              }
            }, 10);
          }
        } else {
          // No selection - apply font size to the entire element
          element.style.fontSize = size + 'px';
          
          // Wrap existing text nodes in spans to preserve formatting
          const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
          const textNodes = [];
          let node;
          while (node = walker.nextNode()) {
            const parent = node.parentElement;
            if (!parent || !parent.style.fontSize) {
              textNodes.push(node);
            }
          }
          
          textNodes.forEach(textNode => {
            if (textNode.textContent.trim()) {
              const span = document.createElement('span');
              span.style.fontSize = size + 'px';
              span.textContent = textNode.textContent;
              textNode.parentNode.replaceChild(span, textNode);
            }
          });
        }
        
        // Store the font size for this element
        elementFontSizes.set(element, size);
      }

      function applyFontFamily(element, family) {
        const selection = window.getSelection();
        const normalizedFamily = family || DEFAULT_FONT_FAMILY;

        if (selection.rangeCount > 0 && !selection.isCollapsed &&
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          document.execCommand('fontName', false, normalizedFamily);
        } else {
          element.style.fontFamily = normalizedFamily;
        }

        elementFontFamilies.set(element, normalizedFamily);
      }

      // Update font size input when focus changes
      function updateFontSizeInput() {
        const fontSizeInput = document.getElementById('fontSize');
        if (currentActiveElement) {
          const currentSize = getCurrentFontSize(currentActiveElement);
          fontSizeInput.value = currentSize;
        }
      }

      function updateFontPickerSelectedFont() {
        if (!fontPickerButton || !fontPickerLabel) return;
        const fontFamily = getCurrentFontFamily(currentActiveElement);
        const normalized = normalizeFontStack(fontFamily);
        const name = fontStackToName.get(normalized) || extractPrimaryFontName(fontFamily);
        fontPickerButton.style.fontFamily = fontFamily;
        fontPickerLabel.style.fontFamily = fontFamily;
        fontPickerLabel.textContent = name;
        fontPickerButton.setAttribute('title', `Font Family: ${name}`);
        fontPickerButton.setAttribute('aria-label', `Font Family: ${name}`);
        setActiveFontOption(fontFamily);
      }

      // Track focus changes for any contenteditable element
      function setupFontSizeTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
        });
        
        // Initialize font size if not set
        if (!elementFontSizes.has(element)) {
          const currentSize = parseFloat(window.getComputedStyle(element).fontSize) || 16;
          elementFontSizes.set(element, Math.round(currentSize));
        }
      }

      function setupFontFamilyTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          if (!elementFontFamilies.has(element)) {
            elementFontFamilies.set(element, getCurrentFontFamily(element));
          }
          updateFontPickerSelectedFont();
        });

        if (!elementFontFamilies.has(element)) {
          elementFontFamilies.set(element, getCurrentFontFamily(element));
        }
      }

      function applyFontFamilyToCurrent(fontFamily) {
        if (!currentActiveElement) {
          currentActiveElement = textBox;
        }
        applyFontFamily(currentActiveElement, fontFamily);
        updateFontPickerSelectedFont();
        capture();
        saveEditorState('change_font_family');
      }

      // Track focus changes for existing elements
      setupFontSizeTracking(titleBox);
      setupFontSizeTracking(textBox);
      setupFontFamilyTracking(titleBox);
      setupFontFamilyTracking(textBox);

      // Also check on selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          
          // Find which contenteditable element contains the selection
          let activeEl = null;
          if (titleBox.contains(anchorNode) || anchorNode === titleBox) {
            activeEl = titleBox;
          } else if (textBox.contains(anchorNode) || anchorNode === textBox) {
            activeEl = textBox;
          } else {
            // Check additional text boxes
            const allTextBoxes = document.querySelectorAll('.additional-text-box, .text-box');
            allTextBoxes.forEach(box => {
              if (box.contains(anchorNode) || anchorNode === box) {
                activeEl = box;
              }
            });
          }
          
          if (activeEl && currentActiveElement !== activeEl) {
            currentActiveElement = activeEl;
            updateFontSizeInput();
            updateFontPickerSelectedFont();
          }
        }
      });

      // Font size input change handler
      const fontSizeInput = document.getElementById('fontSize');
      fontSizeInput.addEventListener('change', (e) => {
        const size = parseInt(e.target.value);
        if (!isNaN(size) && size >= 8 && size <= 72 && currentActiveElement) {
          applyFontSize(currentActiveElement, size);
          
          // Update stored sizes for title and main text box
          if (currentActiveElement === titleBox) {
            titleFontSize = size;
          } else if (currentActiveElement === textBox) {
            textFontSize = size;
          }
        }
      });
      
      // Validate input on blur
      fontSizeInput.addEventListener('blur', (e) => {
        if (!currentActiveElement) return;
        
        const size = parseInt(e.target.value);
        const currentSize = getCurrentFontSize(currentActiveElement);
        
        if (isNaN(size) || size < 8) {
          e.target.value = currentSize;
        } else if (size > 72) {
          e.target.value = 72;
          applyFontSize(currentActiveElement, 72);
          
          // Update stored sizes
          if (currentActiveElement === titleBox) {
            titleFontSize = 72;
          } else if (currentActiveElement === textBox) {
            textFontSize = 72;
          }
        }
      });

      // Initialize the input value
      updateFontSizeInput();
      updateFontPickerSelectedFont();

      function attachColorInputHandlers() {
        const fontColorInput = document.getElementById('fontColor');
        const highlightColorInput = document.getElementById('highlightColor');

        if (!fontColorInput || !highlightColorInput) {
          requestAnimationFrame(attachColorInputHandlers);
          return;
        }

        if (!fontColorInput.dataset.bound) {
          fontColorInput.addEventListener('change', (e) => {
        document.execCommand('foreColor', false, e.target.value);
      });
          fontColorInput.dataset.bound = 'true';
        }

        if (!highlightColorInput.dataset.bound) {
          highlightColorInput.addEventListener('change', (e) => {
        document.execCommand('backColor', false, e.target.value);
          });
          highlightColorInput.dataset.bound = 'true';
        }
      }
      attachColorInputHandlers();

      document.addEventListener('apply-text-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#000000';
        document.execCommand('foreColor', false, color);
      });

      document.addEventListener('apply-bg-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#ffff00';
        document.execCommand('backColor', false, color);
      });

      // Save function per Editor.json and auth_system.json
      function savePresentation() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        if (!currentUser) {
          if (isGuest) {
            alert('Please sign in to save presentations. Guests can only view and edit.');
            return;
          }
          alert('Please log in to save presentations.');
          window.location.href = './Home.html';
          return;
        }

        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.textContent.trim() || "";
        
        // Save to user-specific key per auth_system.json
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        saved.push({
          title: title,
          date: new Date().toISOString().split("T")[0],
          content: content
        });
        
        localStorage.setItem(userKey, JSON.stringify(saved));

        showToast('Presentation saved!');
      }

      // Topbar button actions per slides.json
      document.getElementById('btnDel').addEventListener('click', () => {
        if (slides.length <= 1) return;
        saveEditorState('delete_slide');
        slides.splice(active, 1);
        active = Math.max(0, active - 1);
        load();
        renderSidebar();
      });

      document.getElementById('btnReset').addEventListener('click', () => {
        if (confirm('Reset all slides? This cannot be undone.')) {
          saveEditorState('reset_slides');
          slides.splice(0, slides.length, { 
            title: '', 
            content: '',
            titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
            textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
            titleFontFamily: DEFAULT_FONT_STACK,
            textFontFamily: DEFAULT_FONT_STACK,
            shapes: [],
            additionalTextBoxes: [],
            transition: DEFAULT_TRANSITION
          });
          active = 0;
          load();
          renderSidebar();
        }
      });

      document.getElementById('btnSave').addEventListener('click', savePresentation);
      document.getElementById('btnSaveAs').addEventListener('click', () => {
        capture();
        openExportModal();
      });

      document.getElementById('btnHome').addEventListener('click', () => {
        capture();
        window.location.href = './Home.html';
      });

      // Hover button functions per Editor.json slidePreview
      function createNewSlide(index) {
        capture();
        saveEditorState('create_slide');
        slides.splice(index + 1, 0, { 
          title: '', 
          content: '',
          titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
          textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
          titleFontFamily: DEFAULT_FONT_STACK,
          textFontFamily: DEFAULT_FONT_STACK,
          shapes: [],
          additionalTextBoxes: [],
          transition: DEFAULT_TRANSITION
        });
        active = index + 1;
        load();
        renderSidebar();
      }

      function duplicateCurrentSlide(index) {
        capture();
        saveEditorState('duplicate_slide');
        const s = slides[index];
        slides.splice(index + 1, 0, { 
          title: s.title ? `${s.title} copy` : '',
          content: s.content,
          titleBox: s.titleBox ? {...s.titleBox} : { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
          textBox: s.textBox ? {...s.textBox} : { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
          titleFontFamily: s.titleFontFamily || DEFAULT_FONT_STACK,
          textFontFamily: s.textFontFamily || DEFAULT_FONT_STACK,
          shapes: s.shapes ? JSON.parse(JSON.stringify(s.shapes)) : [],
          additionalTextBoxes: s.additionalTextBoxes ? JSON.parse(JSON.stringify(s.additionalTextBoxes)) : [],
          transition: s.transition || DEFAULT_TRANSITION
        });
        active = index + 1;
        load();
        renderSidebar();
      }

      // Auto-save on input with debounce for undo
      let textEditTimeout;
      function saveTextEditState() {
        clearTimeout(textEditTimeout);
        textEditTimeout = setTimeout(() => {
          saveEditorState('edit_text');
        }, 1000); // Save state 1 second after typing stops
      }
      
      titleBox.addEventListener('input', () => {
        if (titleBox.style.display === 'none') return;
        slides[active].title = titleBox.textContent.trim();
        renderSidebar();
        saveTextEditState();
      });
      textBox.addEventListener('input', () => {
        if (textBox.style.display === 'none') return;
        slides[active].content = textBox.textContent.trim();
        saveTextEditState();
      });
      
      // Also track input on additional text boxes
      document.addEventListener('input', (e) => {
        if (e.target.classList && e.target.classList.contains('additional-text-box')) {
          saveTextEditState();
        }
      });

      // Check if loading a saved presentation from Recent section
      const loadPres = sessionStorage.getItem('loadPresentation');
      if (loadPres) {
        try {
          const pres = JSON.parse(loadPres);
          // Set the title and content from saved presentation
          slides[0].title = pres.title || slides[0].title || '';
          slides[0].content = pres.content || '';
          sessionStorage.removeItem('loadPresentation'); // Clear after loading
        } catch (e) {
          console.error('Error loading presentation:', e);
        }
      }

      // Load and apply saved background color from settings
      const savedBg = localStorage.getItem('siteBackgroundColor');
      if (savedBg) {
        if (savedBg === '#000000') {
          document.body.classList.add('dark-theme');
          document.body.style.background = '';
          document.body.style.color = '';
        } else if (savedBg === '#ffffff') {
          document.body.classList.add('light-mode');
          document.body.style.background = '';
          document.body.style.color = '';
        } else {
          document.body.style.background = savedBg;
        }
      }

      // Listen for background color updates from settings page
      window.addEventListener('message', (e) => {
        if (e.data.type === 'updateBackground') {
          const color = e.data.color;
          document.body.classList.remove('dark-theme', 'light-mode');
          
          if (color === '#000000') {
            document.body.classList.add('dark-theme');
            document.body.style.background = '';
            document.body.style.color = '';
          } else if (color === '#ffffff') {
            document.body.classList.add('light-mode');
            document.body.style.background = '';
            document.body.style.color = '';
          } else {
            document.body.style.background = color;
            if (color !== '#0b3d2e') {
              document.body.style.color = '#e8f5e9';
            }
          }
        }
      });

      // Init
      renderSidebar();
      load();

    </script>
  </body>
  </html>
