<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SlideMaker â€¢ Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;600&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Source+Sans+Pro:wght@400;600&family=Nunito:wght@400;600&family=Raleway:wght@400;600&family=Oswald:wght@400;600&family=Fira+Sans:wght@400;600&family=Fira+Code:wght@400;500&family=IBM+Plex+Mono:wght@400;600&family=Cabin:wght@400;600&family=Pacifico&family=Dancing+Script:wght@400;600&family=Great+Vibes&family=Bebas+Neue&family=Raleway+Dots&family=Antic&family=Amaranth:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="./Training/editor.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pptxgenjs/3.12.0/pptxgen.bundle.min.js" integrity="sha512-F8+aoCA8DmF5asJQHKqGmMwakyfeG5edDx9yv7zhtfQczr6gs3qK1D7w+l0kcRAg1WoljzWEGngZFV3nC8slVQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      // Fallback loader for PptxGenJS if primary CDN fails
      window.addEventListener('load', function() {
        setTimeout(function() {
          if (typeof window.PptxGenJS === 'undefined') {
            console.warn('PptxGenJS not loaded from primary CDN, trying fallback...');
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js';
            script.crossOrigin = 'anonymous';
            document.head.appendChild(script);
          }
        }, 2000);
      });
    </script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script defer src="./sidebar-thumbnails.js"></script>
    <style>
      :root {
        --bg: #ffffff;
        --panel: #f9fafb;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;
        --accent: #1a73e8;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background:
          linear-gradient(113deg, #0d4f41 0%, #0b5449 22%, #0a5a57 38%, #0a5f63 52%, #0a6370 65%, #0a5f7a 78%, #0a5382 88%, #0a4b85 100%);
        color: #f1fbff;
      }

      .layout { display: grid; grid-template-rows: 56px 1fr; height: 100%; }
      .topbar {
        display:flex;
        align-items:center;
        gap:10px;
        padding: 8px 12px;
        background: linear-gradient(120deg, rgba(21, 86, 115, 0.82) 0%, rgba(19, 116, 101, 0.84) 100%);
        backdrop-filter: blur(14px);
        border-bottom:1px solid rgba(104, 196, 255, 0.3);
        position: relative;
        z-index: 9000;
        box-shadow: 0 18px 34px rgba(10, 42, 60, 0.46);
      }
      .topbar .btn {
        border:1px solid rgba(125, 211, 252, 0.45);
        background: linear-gradient(135deg, rgba(26, 102, 128, 0.75) 0%, rgba(24, 130, 113, 0.8) 100%);
        border-radius:10px;
        padding:8px 14px;
        font-weight:700;
        color:#e7fbff;
        cursor:pointer;
        transition: all .2s ease;
      }
      .topbar .btn:hover {
        background: linear-gradient(135deg, rgba(30, 126, 154, 0.92) 0%, rgba(26, 140, 120, 0.94) 100%);
        transform: translateY(-1px);
      }
      .toolbar-btn { display: flex; align-items: center; justify-content: center; gap: 6px; min-width: 40px; padding: 8px 12px; }
      .toolbar-btn i { font-size: 16px; }
      .topbar .btn.blue {
        background: linear-gradient(135deg, #23c4ff 0%, #3ce5c5 55%, #63c7ff 100%);
        border-color: rgba(35, 197, 255, 0.85);
        color:#08314a;
      }
      .topbar .btn.gray {
        background: rgba(71, 85, 105, 0.35);
        border-color: rgba(148, 163, 184, 0.35);
        color:#e2e8f0;
      }
      .topbar .btn.red {
        background: rgba(248, 113, 113, 0.26);
        border-color: rgba(248, 113, 113, 0.5);
        color:#ffe1e1;
      }
      .topbar .btn.light {
        background: rgba(236, 254, 255, 0.26);
        border-color: rgba(165, 243, 252, 0.42);
        color:#f4fdff;
      }
      .topbar .btn.green {
        background: linear-gradient(135deg, #22d8b8 0%, #3be9f4 45%, #62ccff 100%);
        border-color: rgba(26, 173, 158, 0.68);
        color:#083542;
      }
      .topbar .btn.emerald {
        background: linear-gradient(135deg, #3ae7f8 0%, #1cc9a9 50%, #2cb8ff 100%);
        border-color: rgba(82, 209, 255, 0.72);
        color:#063046;
      }
      body.light-mode .toolbar .btn {
        background: linear-gradient(135deg, rgba(247, 249, 254, 0.95) 0%, rgba(230, 236, 244, 0.92) 100%);
        border: 1px solid rgba(203, 213, 225, 0.82);
        color: #1f2937;
        box-shadow: 0 10px 20px rgba(148, 163, 184, 0.18);
        transition: filter 0.2s ease, transform 0.2s ease;
      }
      body.light-mode .toolbar .btn svg,
      body.light-mode .toolbar .btn i {
        color: currentColor;
        opacity: 0.85;
      }
      body.light-mode .toolbar .btn:hover {
        filter: brightness(0.97);
      }
      body.light-mode .toolbar .btn.light {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.98) 0%, rgba(232, 235, 240, 0.94) 100%);
        color: #1f2937;
      }
      body.light-mode .toolbar .btn.red {
        background: linear-gradient(135deg, rgba(254, 226, 226, 0.96) 0%, rgba(252, 165, 165, 0.9) 100%);
        border-color: rgba(248, 113, 113, 0.4);
        color: #7f1d1d;
        box-shadow: 0 10px 20px rgba(248, 113, 113, 0.2);
      }
      body.light-mode .toolbar .btn.green {
        background: linear-gradient(135deg, rgba(209, 250, 229, 0.96) 0%, rgba(167, 243, 208, 0.9) 100%);
        border-color: rgba(34, 197, 94, 0.35);
        color: #065f46;
      }
      body.light-mode .toolbar .btn.blue {
        background: linear-gradient(135deg, rgba(219, 234, 254, 0.96) 0%, rgba(191, 219, 254, 0.9) 100%);
        border-color: rgba(59, 130, 246, 0.4);
        color: #1d4ed8;
      }
      body.light-mode .toolbar .btn.emerald {
        background: linear-gradient(135deg, rgba(204, 251, 241, 0.96) 0%, rgba(167, 243, 208, 0.9) 100%);
        border-color: rgba(45, 212, 191, 0.35);
        color: #047857;
      }
      body.light-mode .toolbar .btn.red i,
      body.light-mode .toolbar .btn.red svg,
      body.light-mode .toolbar .btn.light i,
      body.light-mode .toolbar .btn.light svg {
        color: #475569;
        opacity: 0.95;
      }
      
      /* Guide System Styles */
      .guide-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.4);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .guide-popup {
        position: relative;
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.98) 0%, rgba(226, 232, 240, 0.94) 100%);
        border: 2px solid rgba(59, 130, 246, 0.4);
        border-radius: 16px;
        padding: 24px;
        min-width: 320px;
        max-width: 400px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        animation: guideFadeIn 0.3s ease;
      }
      
      @keyframes guideFadeIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      
      .guide-skip-btn {
        position: absolute;
        top: 12px;
        right: 12px;
        background: transparent;
        border: none;
        color: #6b7280;
        font-size: 18px;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 6px;
        transition: all 0.2s ease;
      }
      
      .guide-skip-btn:hover {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
      }
      
      .guide-progress {
        position: absolute;
        top: 12px;
        left: 12px;
        font-size: 12px;
        font-weight: 600;
        color: #3b82f6;
        background: rgba(59, 130, 246, 0.1);
        padding: 4px 10px;
        border-radius: 12px;
      }
      
      .guide-content {
        margin-top: 32px;
        margin-bottom: 20px;
      }
      
      .guide-title {
        font-size: 20px;
        font-weight: 700;
        color: #1f2937;
        margin: 0 0 12px 0;
      }
      
      .guide-description {
        font-size: 14px;
        color: #4b5563;
        line-height: 1.6;
        margin: 0;
      }
      
      .guide-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 20px;
      }
      
      .guide-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
      }
      
      .guide-btn-next {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
      }
      
      .guide-btn-next:hover {
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }
      
      .guide-highlight {
        position: absolute;
        border: 3px solid #3b82f6;
        border-radius: 8px;
        pointer-events: none;
        z-index: 9999;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.4), 0 0 20px rgba(59, 130, 246, 0.6);
        animation: guidePulse 2s ease-in-out infinite;
      }
      
      @keyframes guidePulse {
        0%, 100% {
          box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.4), 0 0 20px rgba(59, 130, 246, 0.6);
        }
        50% {
          box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.4), 0 0 30px rgba(59, 130, 246, 0.8);
        }
      }
      
      body.light-mode .guide-popup {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(249, 250, 251, 0.94) 100%);
        border-color: rgba(59, 130, 246, 0.5);
      }
      
      /* Welcome Popup for Guide Button */
      .guide-welcome-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.4);
        z-index: 10000;
        display: flex;
        align-items: flex-start;
        justify-content: flex-end;
        padding: 80px 20px 20px 20px;
        animation: welcomeFadeIn 0.4s ease;
        pointer-events: auto;
      }
      
      .guide-welcome-popup {
        pointer-events: auto;
      }
      
      .guide-welcome-close {
        pointer-events: auto;
        z-index: 10002;
      }
      
      @keyframes welcomeFadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .guide-welcome-popup {
        position: fixed;
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.98) 0%, rgba(226, 232, 240, 0.94) 100%);
        border: 2px solid rgba(59, 130, 246, 0.5);
        border-radius: 16px;
        padding: 24px;
        max-width: 360px;
        width: auto;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        animation: welcomeSlideIn 0.5s ease;
        text-align: center;
      }
      
      @keyframes welcomeSlideIn {
        from {
          opacity: 0;
          transform: translateY(-10px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      
      .guide-welcome-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: transparent;
        border: none;
        color: #6b7280;
        font-size: 22px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: all 0.2s ease;
      }
      
      .guide-welcome-close:hover {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
      }
      
      .guide-welcome-icon {
        font-size: 56px;
        margin-bottom: 16px;
        animation: iconPulse 2s ease-in-out infinite;
      }
      
      @keyframes iconPulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.15); }
      }
      
      .guide-welcome-title {
        font-size: 24px;
        font-weight: 700;
        color: #1f2937;
        margin: 0 0 12px 0;
      }
      
      .guide-welcome-text {
        font-size: 15px;
        color: #4b5563;
        line-height: 1.6;
        margin: 0;
      }
      
      /* Button Highlight Animation */
      .guide-button-highlight-wrapper {
        position: fixed;
        z-index: 9999;
        pointer-events: none;
      }
      
      .guide-button-pulse-ring {
        position: absolute;
        border: 5px solid #3b82f6;
        border-radius: 12px;
        animation: buttonPulse 2s ease-in-out infinite;
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.9), 0 0 0 0 rgba(59, 130, 246, 0.7), 0 0 25px rgba(59, 130, 246, 0.6);
      }
      
      @keyframes buttonPulse {
        0% {
          transform: scale(1);
          opacity: 1;
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.9), 0 0 0 0 rgba(59, 130, 246, 0.7), 0 0 25px rgba(59, 130, 246, 0.6);
        }
        50% {
          transform: scale(1.12);
          opacity: 0.95;
          box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.4), 0 0 0 16px rgba(59, 130, 246, 0.2), 0 0 35px rgba(59, 130, 246, 0.8);
        }
        100% {
          transform: scale(1);
          opacity: 1;
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.9), 0 0 0 0 rgba(59, 130, 246, 0.7), 0 0 25px rgba(59, 130, 246, 0.6);
        }
      }
      
      .guide-arrow-indicator {
        position: absolute;
        font-size: 40px;
        filter: drop-shadow(0 2px 8px rgba(59, 130, 246, 0.6));
        animation: arrowBounce 1.5s ease-in-out infinite;
      }
      
      @keyframes arrowBounce {
        0%, 100% {
          transform: translateY(0);
          opacity: 0.9;
        }
        50% {
          transform: translateY(10px);
          opacity: 1;
        }
      }
      
      /* Make the guide button lighter than other buttons when highlighted */
      #guideButton.guide-highlighted {
        position: relative;
        z-index: 10001 !important;
        transform: scale(1.05);
        transition: all 0.3s ease;
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.6), 0 4px 12px rgba(59, 130, 246, 0.4) !important;
        filter: brightness(1.3) !important;
        opacity: 1 !important;
      }
      
      #guideButton.guide-highlighted i {
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2)) !important;
      }
      body.light-mode .topbar .btn {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.98) 0%, rgba(226, 232, 240, 0.94) 100%);
        border: 1px solid rgba(148, 163, 184, 0.6);
        color: #1f2937;
        box-shadow: 0 10px 24px rgba(148, 163, 184, 0.22);
        transition: filter 0.2s ease, transform 0.2s ease;
      }
      body.light-mode .topbar .btn:hover {
        filter: brightness(0.97);
        transform: translateY(-1px);
      }
      body.light-mode .topbar .btn svg,
      body.light-mode .topbar .btn i {
        color: currentColor;
        opacity: 0.9;
      }
      body.light-mode .topbar .btn.light {
        background: linear-gradient(135deg, rgba(236, 252, 255, 0.98) 0%, rgba(207, 250, 254, 0.94) 100%);
        border-color: rgba(94, 234, 212, 0.5);
        color: #0f172a;
      }
      body.light-mode .topbar .btn.red {
        background: linear-gradient(135deg, rgba(254, 202, 202, 0.96) 0%, rgba(248, 113, 113, 0.92) 100%);
        border-color: rgba(248, 113, 113, 0.55);
        color: #ffffff;
      }
      body.light-mode .topbar .btn.red:hover {
        filter: brightness(0.95);
      }
      body.light-mode .topbar .btn.green {
        background: linear-gradient(135deg, rgba(187, 247, 208, 0.96) 0%, rgba(110, 231, 183, 0.9) 100%);
        border-color: rgba(34, 197, 94, 0.45);
        color: #065f46;
      }
      body.light-mode .topbar .btn.blue {
        background: linear-gradient(135deg, rgba(191, 219, 254, 0.96) 0%, rgba(147, 197, 253, 0.92) 100%);
        border-color: rgba(59, 130, 246, 0.45);
        color: #1d4ed8;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnBack,
      body:not(.light-mode):not(.dark-theme) .topbar #btnForward,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSave,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSaveAs,
      body:not(.light-mode):not(.dark-theme) .topbar #btnHome {
        background: linear-gradient(135deg, rgba(35, 196, 255, 0.85) 0%, rgba(60, 229, 197, 0.88) 50%, rgba(99, 199, 255, 0.85) 100%);
        border-color: rgba(35, 197, 255, 0.65);
        color: #08314a;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnBack i,
      body:not(.light-mode):not(.dark-theme) .topbar #btnForward i,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSave i,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSaveAs i,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSaveAs .caret i,
      body:not(.light-mode):not(.dark-theme) .topbar #btnHome i {
        color: #08314a;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnDel {
        background: rgba(220, 100, 100, 0.4);
        border-color: rgba(220, 100, 100, 0.6);
        color: #ffe1e1;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnDel i {
        color: #ffe1e1;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnReset {
        background: rgba(236, 254, 255, 0.35);
        border-color: rgba(165, 243, 252, 0.5);
        color: #f4fdff;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnReset i {
        color: #f4fdff;
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnBack:hover,
      body:not(.light-mode):not(.dark-theme) .topbar #btnForward:hover,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSave:hover,
      body:not(.light-mode):not(.dark-theme) .topbar #btnSaveAs:hover,
      body:not(.light-mode):not(.dark-theme) .topbar #btnHome:hover {
        background: linear-gradient(135deg, rgba(45, 210, 255, 0.95) 0%, rgba(70, 239, 207, 0.95) 50%, rgba(109, 209, 255, 0.95) 100%);
        transform: translateY(-1px);
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnDel:hover {
        background: rgba(230, 110, 110, 0.5);
        transform: translateY(-1px);
      }
      body:not(.light-mode):not(.dark-theme) .topbar #btnReset:hover {
        background: rgba(246, 254, 255, 0.45);
        transform: translateY(-1px);
      }
      body.light-mode .topbar .btn.emerald {
        background: linear-gradient(135deg, rgba(204, 251, 241, 0.96) 0%, rgba(167, 243, 208, 0.92) 100%);
        border-color: rgba(45, 212, 191, 0.45);
        color: #047857;
      }
      .save-as-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        z-index: 11000;
      }
      .save-as-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .save-as-toggle .caret {
        font-size: 11px;
        opacity: 0.75;
        margin-left: 2px;
      }
      .save-as-menu {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        background: linear-gradient(150deg, rgba(27, 94, 121, 0.9) 0%, rgba(22, 126, 110, 0.94) 100%);
        border: 1px solid rgba(99, 210, 255, 0.38);
        border-radius: 12px;
        box-shadow: 0 20px 44px rgba(12, 54, 70, 0.52);
        padding: 8px 0;
        min-width: 220px;
        display: flex;
        flex-direction: column;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 12000;
      }
      .save-as-menu.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .save-as-option {
        background: transparent;
        border: none;
        color: #e0f2ff;
        font-size: 14px;
        font-weight: 600;
        text-align: left;
        padding: 10px 18px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .save-as-option:hover {
        background: linear-gradient(135deg, rgba(82, 217, 255, 0.24), rgba(72, 222, 182, 0.24));
        color: #4bd0ff;
        transform: translateX(4px);
      }
      .save-as-option .option-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        font-size: 16px;
      }
      .save-as-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 13000;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        background: rgba(3, 19, 32, 0.65);
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
      .save-as-modal.show {
        display: flex !important;
        opacity: 1;
        visibility: visible;
      }
      .save-as-modal-content {
        width: min(90vw, 420px);
        max-width: 420px;
        background: linear-gradient(150deg, rgba(28, 100, 130, 0.88) 0%, rgba(24, 132, 116, 0.92) 100%);
        border: 1px solid rgba(105, 214, 255, 0.38);
        border-radius: 20px;
        box-shadow: 0 30px 56px rgba(14, 56, 76, 0.56);
        padding: 24px;
        color: #eafcff;
        position: relative;
        margin: auto;
        transform: scale(0.96);
        transition: transform 0.2s ease;
      }
      .save-as-modal.show .save-as-modal-content {
        transform: scale(1);
      }
      .save-as-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(96, 165, 250, 0.25);
      }
      .save-as-modal-title {
        font-size: 20px;
        font-weight: 700;
        color: #f0f9ff;
        margin: 0;
      }
      .save-as-modal-close {
        background: transparent;
        border: none;
        color: #94a3b8;
        font-size: 24px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }
      .save-as-modal-close:hover {
        background: rgba(56, 189, 248, 0.18);
        color: #38bdf8;
      }
      .save-as-form-group {
        margin-bottom: 18px;
        display: block;
      }
      .save-as-form-group:last-of-type {
        margin-bottom: 0;
      }
      .save-as-form-label {
        display: block;
        margin-bottom: 8px;
        color: rgba(191, 219, 254, 0.88);
        font-weight: 600;
        font-size: 14px;
      }
      .save-as-form-select,
      .save-as-form-input {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(8, 32, 51, 0.72);
        color: #f0f9ff;
        font-size: 14px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
        display: block;
        min-height: 44px;
      }
      .save-as-form-select option {
        background: rgba(8, 32, 51, 0.95);
        color: #e0f2ff;
        padding: 8px;
      }
      .save-as-form-select:focus,
      .save-as-form-input:focus {
        outline: none;
        border-color: rgba(56, 189, 248, 0.6);
        background: rgba(9, 37, 60, 0.85);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
      }
      .save-as-form-select {
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2338bdf8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        background-size: 12px 12px;
        padding-right: 42px;
        display: block;
        width: 100%;
      }
      .save-as-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 24px;
        padding-top: 20px;
        border-top: 1px solid rgba(96, 165, 250, 0.25);
      }
      .save-as-modal-btn {
        border: none;
        border-radius: 12px;
        padding: 10px 20px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .save-as-modal-btn-cancel {
        background: rgba(71, 85, 105, 0.38);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.38);
      }
      .save-as-modal-btn-cancel:hover {
        background: rgba(99, 102, 241, 0.22);
        transform: translateY(-1px);
      }
      .save-as-modal-btn-save {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.95) 0%, rgba(45, 212, 191, 0.95) 100%);
        color: #04111f;
        border: 1px solid rgba(56, 189, 248, 0.5);
        box-shadow: 0 12px 28px rgba(14, 165, 233, 0.35);
      }
      .save-as-modal-btn-save:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 1) 0%, rgba(45, 212, 191, 1) 100%);
        transform: translateY(-1px);
      }
      .save-as-modal-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .section-name-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 13000;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        background: rgba(3, 19, 32, 0.65);
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
      .section-name-modal.show {
        display: flex !important;
        opacity: 1;
        visibility: visible;
      }
      .section-name-modal-content {
        width: min(90vw, 420px);
        max-width: 420px;
        background: linear-gradient(150deg, rgba(28, 100, 130, 0.88) 0%, rgba(24, 132, 116, 0.92) 100%);
        border: 1px solid rgba(105, 214, 255, 0.38);
        border-radius: 20px;
        box-shadow: 0 30px 56px rgba(14, 56, 76, 0.56);
        padding: 28px;
        color: #eafcff;
        position: relative;
        margin: auto;
        transform: scale(0.96);
        transition: transform 0.2s ease;
      }
      .section-name-modal.show .section-name-modal-content {
        transform: scale(1);
      }
      .section-name-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(96, 165, 250, 0.25);
      }
      .section-name-modal-title {
        font-size: 22px;
        font-weight: 700;
        color: #f0f9ff;
        margin: 0;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .section-name-modal-title i {
        font-size: 20px;
        color: rgba(56, 189, 248, 0.9);
      }
      .section-name-modal-close {
        background: transparent;
        border: none;
        color: #94a3b8;
        font-size: 24px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }
      .section-name-modal-close:hover {
        background: rgba(56, 189, 248, 0.18);
        color: #38bdf8;
      }
      .section-name-form-group {
        margin-bottom: 20px;
        display: block;
      }
      .section-name-form-label {
        display: block;
        margin-bottom: 10px;
        color: rgba(191, 219, 254, 0.95);
        font-weight: 600;
        font-size: 15px;
      }
      .section-name-form-input {
        width: 100%;
        padding: 14px 18px;
        border-radius: 12px;
        border: 2px solid rgba(96, 165, 250, 0.35);
        background: rgba(8, 32, 51, 0.75);
        color: #f0f9ff;
        font-size: 15px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
        display: block;
        min-height: 48px;
      }
      .section-name-form-input:focus {
        outline: none;
        border-color: rgba(56, 189, 248, 0.7);
        background: rgba(9, 37, 60, 0.9);
        box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.2);
      }
      .section-name-form-input::placeholder {
        color: rgba(148, 163, 184, 0.6);
      }
      .section-name-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 28px;
        padding-top: 20px;
        border-top: 1px solid rgba(96, 165, 250, 0.25);
      }
      .section-name-modal-btn {
        border: none;
        border-radius: 12px;
        padding: 12px 24px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
        min-width: 100px;
      }
      .section-name-modal-btn-cancel {
        background: rgba(71, 85, 105, 0.38);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.38);
      }
      .section-name-modal-btn-cancel:hover {
        background: rgba(99, 102, 241, 0.22);
        transform: translateY(-1px);
      }
      .section-name-modal-btn-submit {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.95) 0%, rgba(45, 212, 191, 0.95) 100%);
        color: #04111f;
        border: 1px solid rgba(56, 189, 248, 0.5);
        box-shadow: 0 12px 28px rgba(14, 165, 233, 0.35);
      }
      .section-name-modal-btn-submit:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 1) 0%, rgba(45, 212, 191, 1) 100%);
        transform: translateY(-1px);
      }
      .section-name-modal-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .delete-section-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 13000;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        background: rgba(3, 19, 32, 0.65);
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
      .delete-section-modal.show {
        display: flex !important;
        opacity: 1;
        visibility: visible;
      }
      .delete-section-modal-content {
        width: min(90vw, 420px);
        max-width: 420px;
        background: linear-gradient(150deg, rgba(28, 100, 130, 0.88) 0%, rgba(24, 132, 116, 0.92) 100%);
        border: 1px solid rgba(105, 214, 255, 0.38);
        border-radius: 20px;
        box-shadow: 0 30px 56px rgba(14, 56, 76, 0.56);
        padding: 28px;
        color: #eafcff;
        position: relative;
        margin: auto;
        transform: scale(0.96);
        transition: transform 0.2s ease;
      }
      .delete-section-modal.show .delete-section-modal-content {
        transform: scale(1);
      }
      .delete-section-modal-message {
        font-size: 16px;
        color: #f0f9ff;
        margin: 0 0 28px 0;
        line-height: 1.5;
        text-align: center;
      }
      .delete-section-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }
      .delete-section-modal-btn {
        border: none;
        border-radius: 12px;
        padding: 12px 24px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
        min-width: 100px;
      }
      .delete-section-modal-btn-cancel {
        background: rgba(71, 85, 105, 0.38);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.38);
      }
      .delete-section-modal-btn-cancel:hover {
        background: rgba(99, 102, 241, 0.22);
        transform: translateY(-1px);
      }
      .delete-section-modal-btn-confirm {
        background: linear-gradient(135deg, rgba(248, 113, 113, 0.85) 0%, rgba(239, 68, 68, 0.9) 100%);
        color: #ffffff;
        border: 1px solid rgba(248, 113, 113, 0.5);
        box-shadow: 0 12px 28px rgba(239, 68, 68, 0.35);
      }
      .delete-section-modal-btn-confirm:hover {
        background: linear-gradient(135deg, rgba(248, 113, 113, 0.95) 0%, rgba(239, 68, 68, 1) 100%);
        transform: translateY(-1px);
      }

      .ai-designer-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 13000;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        background: rgba(3, 19, 32, 0.65);
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
      .ai-designer-modal.show {
        display: flex !important;
        opacity: 1;
        visibility: visible;
      }
      .ai-designer-modal-content {
        width: min(90vw, 600px);
        max-width: 600px;
        max-height: 90vh;
        background: linear-gradient(150deg, rgba(28, 100, 130, 0.88) 0%, rgba(24, 132, 116, 0.92) 100%);
        border: 1px solid rgba(105, 214, 255, 0.38);
        border-radius: 20px;
        box-shadow: 0 30px 56px rgba(14, 56, 76, 0.56);
        padding: 24px;
        color: #eafcff;
        position: relative;
        margin: auto;
        transform: scale(0.96);
        transition: transform 0.2s ease;
        overflow-y: auto;
      }
      .ai-designer-modal.show .ai-designer-modal-content {
        transform: scale(1);
      }
      .ai-designer-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(96, 165, 250, 0.25);
      }
      .ai-designer-modal-title {
        font-size: 20px;
        font-weight: 700;
        color: #f0f9ff;
        margin: 0;
      }
      .ai-designer-modal-close {
        background: transparent;
        border: none;
        color: #94a3b8;
        font-size: 24px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }
      .ai-designer-modal-close:hover {
        background: rgba(56, 189, 248, 0.18);
        color: #38bdf8;
      }
      .ai-designer-form-group {
        margin-bottom: 18px;
        display: block;
      }
      .ai-designer-form-group:last-of-type {
        margin-bottom: 0;
      }
      .ai-designer-form-label {
        display: block;
        margin-bottom: 8px;
        color: rgba(191, 219, 254, 0.88);
        font-weight: 600;
        font-size: 14px;
      }
      .ai-designer-form-textarea,
      .ai-designer-form-select {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(8, 32, 51, 0.72);
        color: #f0f9ff;
        font-size: 14px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
        display: block;
        min-height: 44px;
      }
      .ai-designer-form-textarea {
        min-height: 100px;
        resize: vertical;
      }
      .ai-designer-form-select option {
        background: rgba(8, 32, 51, 0.95);
        color: #e0f2ff;
        padding: 8px;
      }
      .ai-designer-form-textarea:focus,
      .ai-designer-form-select:focus {
        outline: none;
        border-color: rgba(56, 189, 248, 0.6);
        background: rgba(9, 37, 60, 0.85);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
      }
      .ai-designer-form-select {
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2338bdf8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        background-size: 12px 12px;
        padding-right: 42px;
      }
      .ai-designer-preview {
        margin-top: 18px;
        padding: 16px;
        background: rgba(8, 32, 51, 0.5);
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.25);
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }
      .ai-designer-preview img {
        max-width: 100%;
        max-height: 400px;
        border-radius: 8px;
        display: block;
      }
      .ai-designer-preview-placeholder {
        color: rgba(191, 219, 254, 0.6);
        text-align: center;
        font-size: 14px;
      }
      .ai-designer-preview-loading {
        color: rgba(56, 189, 248, 0.8);
        text-align: center;
        font-size: 14px;
      }
      .ai-designer-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 24px;
        padding-top: 20px;
        border-top: 1px solid rgba(96, 165, 250, 0.25);
      }
      .ai-designer-modal-btn {
        border: none;
        border-radius: 12px;
        padding: 10px 20px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .ai-designer-modal-btn-cancel {
        background: rgba(71, 85, 105, 0.38);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.38);
      }
      .ai-designer-modal-btn-cancel:hover {
        background: rgba(99, 102, 241, 0.22);
        transform: translateY(-1px);
      }
      .ai-designer-modal-btn-generate {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.95) 0%, rgba(45, 212, 191, 0.95) 100%);
        color: #04111f;
        border: 1px solid rgba(56, 189, 248, 0.5);
        box-shadow: 0 12px 28px rgba(14, 165, 233, 0.35);
      }
      .ai-designer-modal-btn-generate:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 1) 0%, rgba(45, 212, 191, 1) 100%);
        transform: translateY(-1px);
      }
      .ai-designer-modal-btn-insert {
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(16, 185, 129, 0.95) 100%);
        color: #04111f;
        border: 1px solid rgba(34, 197, 94, 0.5);
        box-shadow: 0 12px 28px rgba(5, 150, 105, 0.35);
      }
      .ai-designer-modal-btn-insert:hover {
        background: linear-gradient(135deg, rgba(34, 197, 94, 1) 0%, rgba(16, 185, 129, 1) 100%);
        transform: translateY(-1px);
      }
      .ai-designer-modal-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }
      .ai-designer-status {
        margin-top: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 13px;
        color: rgba(191, 219, 254, 0.9);
        background: rgba(8, 32, 51, 0.5);
        border: 1px solid rgba(96, 165, 250, 0.25);
      }
      .ai-designer-status.error {
        color: #fca5a5;
        background: rgba(127, 29, 29, 0.3);
        border-color: rgba(239, 68, 68, 0.4);
      }
      .ai-designer-status.success {
        color: #86efac;
        background: rgba(20, 83, 45, 0.3);
        border-color: rgba(34, 197, 94, 0.4);
      }

      .ai-presentation-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 13000;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        background: rgba(3, 19, 32, 0.65);
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }
      .ai-presentation-modal.show {
        display: flex !important;
        opacity: 1;
        visibility: visible;
      }
      .ai-presentation-modal-content {
        width: min(90vw, 700px);
        max-width: 700px;
        max-height: 90vh;
        background: linear-gradient(150deg, rgba(28, 100, 130, 0.88) 0%, rgba(24, 132, 116, 0.92) 100%);
        border: 1px solid rgba(105, 214, 255, 0.38);
        border-radius: 20px;
        box-shadow: 0 30px 56px rgba(14, 56, 76, 0.56);
        padding: 24px;
        color: #eafcff;
        position: relative;
        margin: auto;
        transform: scale(0.96);
        transition: transform 0.2s ease;
        overflow-y: auto;
      }
      .ai-presentation-modal.show .ai-presentation-modal-content {
        transform: scale(1);
      }
      .ai-presentation-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(96, 165, 250, 0.25);
      }
      .ai-presentation-modal-title {
        font-size: 20px;
        font-weight: 700;
        color: #f0f9ff;
        margin: 0;
      }
      .ai-presentation-modal-close {
        background: transparent;
        border: none;
        color: #94a3b8;
        font-size: 24px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }
      .ai-presentation-modal-close:hover {
        background: rgba(56, 189, 248, 0.18);
        color: #38bdf8;
      }
      .ai-presentation-form-group {
        margin-bottom: 18px;
        display: block;
      }
      .ai-presentation-form-group:last-of-type {
        margin-bottom: 0;
      }
      .ai-presentation-form-label {
        display: block;
        margin-bottom: 8px;
        color: rgba(191, 219, 254, 0.88);
        font-weight: 600;
        font-size: 14px;
      }
      .ai-presentation-form-textarea,
      .ai-presentation-form-input,
      .ai-presentation-form-select {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(8, 32, 51, 0.72);
        color: #f0f9ff;
        font-size: 14px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
        display: block;
        min-height: 44px;
      }
      .ai-presentation-form-textarea {
        min-height: 120px;
        resize: vertical;
      }
      .ai-presentation-form-select option {
        background: rgba(8, 32, 51, 0.95);
        color: #e0f2ff;
        padding: 8px;
      }
      .ai-presentation-form-textarea:focus,
      .ai-presentation-form-input:focus,
      .ai-presentation-form-select:focus {
        outline: none;
        border-color: rgba(56, 189, 248, 0.6);
        background: rgba(9, 37, 60, 0.85);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
      }
      .ai-presentation-form-select {
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2338bdf8' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        background-size: 12px 12px;
        padding-right: 42px;
      }
      .ai-presentation-progress {
        margin-top: 18px;
        padding: 16px;
        background: rgba(8, 32, 51, 0.5);
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.25);
        display: none;
      }
      .ai-presentation-progress.show {
        display: block;
      }
      .ai-presentation-progress-bar {
        width: 100%;
        height: 8px;
        background: rgba(8, 32, 51, 0.8);
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 12px;
      }
      .ai-presentation-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, rgba(56, 189, 248, 0.9) 0%, rgba(45, 212, 191, 0.9) 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }
      .ai-presentation-progress-text {
        color: rgba(191, 219, 254, 0.9);
        font-size: 13px;
        text-align: center;
      }
      .ai-presentation-modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 24px;
        padding-top: 20px;
        border-top: 1px solid rgba(96, 165, 250, 0.25);
      }
      .ai-presentation-modal-btn {
        border: none;
        border-radius: 12px;
        padding: 10px 20px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .ai-presentation-modal-btn-cancel {
        background: rgba(71, 85, 105, 0.38);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.38);
      }
      .ai-presentation-modal-btn-cancel:hover {
        background: rgba(99, 102, 241, 0.22);
        transform: translateY(-1px);
      }
      .ai-presentation-modal-btn-generate {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.95) 0%, rgba(45, 212, 191, 0.95) 100%);
        color: #04111f;
        border: 1px solid rgba(56, 189, 248, 0.5);
        box-shadow: 0 12px 28px rgba(14, 165, 233, 0.35);
      }
      .ai-presentation-modal-btn-generate:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 1) 0%, rgba(45, 212, 191, 1) 100%);
        transform: translateY(-1px);
      }
      .ai-presentation-modal-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }
      .ai-presentation-status {
        margin-top: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 13px;
        color: rgba(191, 219, 254, 0.9);
        background: rgba(8, 32, 51, 0.5);
        border: 1px solid rgba(96, 165, 250, 0.25);
        display: none;
      }
      .ai-presentation-status.error {
        color: #fca5a5;
        background: rgba(127, 29, 29, 0.3);
        border-color: rgba(239, 68, 68, 0.4);
      }
      .ai-presentation-status.success {
        color: #86efac;
        background: rgba(20, 83, 45, 0.3);
        border-color: rgba(34, 197, 94, 0.4);
      }

      .main { 
        display:grid; 
        grid-template-columns: var(--sidebar-width, 260px) 1fr; 
        gap: 12px; 
        padding: 12px; 
        min-height:0;
        transition: grid-template-columns 0.2s ease-out;
      }
      .main.show-translator {
        grid-template-columns: var(--sidebar-width, 260px) 1fr var(--translator-width, 280px);
      }
      .sidebar { 
        background: linear-gradient(145deg, rgba(9, 44, 60, 0.88) 0%, rgba(8, 63, 53, 0.9) 100%);
        backdrop-filter: blur(14px);
        border-right: 1px solid rgba(96, 165, 250, 0.25);
        border-radius:14px;
        padding:12px;
        padding-bottom: 60px; 
        overflow-y: auto; 
        overflow-x: hidden; 
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 20px 42px rgba(5, 24, 36, 0.5);
        position: relative;
        width: var(--sidebar-width, 260px);
        min-width: 180px;
        max-width: 600px;
        z-index: 1;
        box-sizing: border-box;
        transition: width 0.2s ease-out;
      }
      .sidebar-view-toggle {
        margin-top: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
  transform: translateY(-6px);
      }
      .sidebar-view-button {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 12px;
        border: 1px solid rgba(96, 165, 250, 0.32);
        background: rgba(8, 32, 51, 0.72);
        color: #e0f2ff;
        font-weight: 600;
        padding: 6px 16px;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .sidebar-view-button:hover {
        background: rgba(56, 189, 248, 0.18);
        transform: translateY(-1px);
        color: #f0f9ff;
      }
      .sidebar-view-button.active {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.28) 0%, rgba(45, 212, 191, 0.28) 100%);
        color: #ffffff;
        box-shadow: 0 12px 26px rgba(14, 165, 233, 0.35);
      }
      .sidebar.list-view .slide-preview-title {
        font-size: 14px;
        font-weight: 600;
      }
      .sidebar.thumbnail-view {
        gap: 14px;
      }
      .sidebar.thumbnail-view .slide-item {
        align-items: stretch;
        margin-bottom: 4px;
      }
      .sidebar.thumbnail-view .slide-preview {
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        width: 100%;
      }
      .slide-thumbnail-frame {
        position: relative;
        width: 100%;
        max-width: 100%;
        padding-top: 56.25%;
        border-radius: 12px;
        overflow: hidden;
        background: rgba(45, 55, 72, 0.88);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: inset 0 0 0 1px rgba(99, 102, 241, 0.18);
        box-sizing: border-box;
      }
      .slide-thumbnail-frame img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .slide-thumbnail-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 12px;
        color: rgba(226, 232, 240, 0.7);
        background: rgba(45, 55, 72, 0.75);
      }
      .sidebar.thumbnail-view .slide-preview-title {
        display: block;
        margin-top: 8px;
        font-size: 13px;
        font-weight: 600;
        color: #e0f2ff;
        text-align: center;
      }
      .sidebar.thumbnail-view .slide-preview.active .slide-thumbnail-frame {
        border-color: rgba(96, 165, 250, 0.85);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35);
      }
      .slide-item { 
        position: relative; 
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        transition: all 0.3s ease;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        cursor: grab;
      }
      .slide-item:hover {
        cursor: grab;
      }
      .slide-item:active {
        cursor: grabbing;
      }
      .slide-item.dragging {
        opacity: 0.6;
        transform: scale(0.98);
        cursor: grabbing;
      }
      /* SortableJS classes */
      .sortable-ghost {
        opacity: 0.4;
        background: rgba(56, 189, 248, 0.1);
        border: 2px dashed rgba(56, 189, 248, 0.5);
      }
      .sortable-drag {
        opacity: 0.8;
        transform: rotate(2deg);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      }
      .sortable-chosen {
        cursor: grabbing;
      }
      .section-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        margin: 12px 0 8px 0;
        background: linear-gradient(140deg, rgba(15, 65, 80, 0.85) 0%, rgba(12, 80, 70, 0.87) 100%);
        border: 1px solid rgba(56, 189, 248, 0.4);
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        color: #e0f2ff;
        font-weight: 600;
        font-size: 14px;
        user-select: none;
      }
      .section-header:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.25), rgba(34, 197, 94, 0.23));
        border-color: rgba(56, 189, 248, 0.55);
      }
      .section-header .section-chevron {
        transition: transform 0.3s ease;
        font-size: 12px;
        color: rgba(224, 242, 255, 0.8);
      }
      .section-header.collapsed .section-chevron {
        transform: rotate(-90deg);
      }
      .section-header .section-name {
        flex: 1;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .section-header .section-actions {
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .section-header:hover .section-actions {
        opacity: 1;
      }
      .section-header .section-action-btn {
        background: transparent;
        border: none;
        color: rgba(224, 242, 255, 0.7);
        cursor: pointer;
        padding: 4px 6px;
        border-radius: 4px;
        font-size: 12px;
        transition: all 0.2s ease;
      }
      .section-header .section-action-btn:hover {
        background: rgba(56, 189, 248, 0.2);
        color: #e0f2ff;
      }
      .section-slides {
        margin-left: 12px;
        transition: all 0.3s ease;
        overflow: hidden;
      }
      .section-header.drop-target,
      .section-slides.drop-target {
        border-color: rgba(59, 130, 246, 0.8);
        background: linear-gradient(140deg, rgba(15, 65, 80, 0.95) 0%, rgba(12, 80, 70, 0.97) 100%);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
      }
      .section-header.collapsed + .section-slides {
        max-height: 0;
        margin-top: 0;
        margin-bottom: 0;
        opacity: 0;
      }
      .section-slides .slide-item {
        margin-left: 0;
      }
      .standalone-slides-sortable {
        display: contents;
      }
      .slide-context-menu button[disabled] {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
      }
      .slide-context-menu button[disabled] .menu-icon,
      .slide-context-menu button[disabled] span:not(.menu-shortcut),
      .slide-context-menu button[disabled] .menu-shortcut {
        color: rgba(148, 163, 184, 0.5);
      }
      .slide-preview { 
        background: linear-gradient(140deg, rgba(12, 57, 72, 0.82) 0%, rgba(10, 72, 62, 0.84) 100%);
        border: 1px solid rgba(56, 189, 248, 0.32);
        border-radius: 12px;
        padding: 10px 14px; 
        cursor: pointer; 
        transition: all 0.3s ease; 
        color: #e0f2ff;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        box-shadow: 0 14px 28px rgba(5, 24, 36, 0.38);
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      .slide-preview:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.22), rgba(34, 197, 94, 0.22));
        border-color: rgba(56, 189, 248, 0.45);
      }
      .slide-preview.active {
        outline:2px solid rgba(56, 189, 248, 0.75);
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.28), rgba(34, 197, 94, 0.26));
      }
      .slide-preview.drop-target {
        border-color: rgba(56, 189, 248, 0.6);
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.24), rgba(34, 197, 94, 0.22));
      }
      .slide-preview.drop-target-before {
        box-shadow: inset 0 3px 0 rgba(56, 189, 248, 0.85);
      }
      .slide-preview.drop-target-after {
        box-shadow: inset 0 -3px 0 rgba(56, 189, 248, 0.85);
      }
      .transition-control-button {
        background: linear-gradient(140deg, rgba(11, 51, 66, 0.88) 0%, rgba(9, 71, 59, 0.9) 100%);
        border: 1px solid rgba(56, 189, 248, 0.35);
        color: #e0f2ff;
        font-size: 14px;
        border-radius: 10px;
        padding: 6px 8px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 42px;
        justify-content: center;
      }
      .transition-control-button .transition-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-icon i {
        font-size: 12px;
      }
      .transition-control-button .transition-icon svg {
        width: 16px;
        height: 16px;
      }
      .transition-control-button .transition-caret {
        font-size: 10px;
        opacity: 0.75;
        margin-left: 0;
      }
      .transition-control-button:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.24), rgba(34, 197, 94, 0.24));
        color: #f0f9ff;
        transform: translateY(-1px);
      }
      .transition-control-button.disabled,
      .transition-control-button:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none;
      }
      .transition-control-button.disabled:hover,
      .transition-control-button:disabled:hover {
        background: linear-gradient(140deg, rgba(11, 51, 66, 0.85) 0%, rgba(9, 71, 59, 0.87) 100%);
        color: #94a3b8;
      }
      .transition-select {
        min-width: 150px;
      }
      .transition-select option {
        color: #111827;
      }
      .slide-context-menu,
      .section-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 160px;
        padding: 8px 0;
        background: rgba(9, 35, 56, 0.95);
        border: 1px solid rgba(96, 165, 250, 0.35);
        border-radius: 12px;
        box-shadow: 0 20px 44px rgba(5, 20, 36, 0.5);
        z-index: 5000;
      }
      .section-context-menu {
        min-width: 200px;
      }
      .slide-context-menu.show,
      .section-context-menu.show {
        display: flex;
      }
      .slide-context-menu .menu-divider,
      .section-context-menu .menu-divider {
        height: 1px;
        background: rgba(56, 189, 248, 0.2);
        margin: 4px 0;
        border: none;
      }
      .slide-context-menu .menu-shortcut,
      .section-context-menu .menu-shortcut {
        margin-left: auto;
        font-size: 11px;
        color: rgba(224, 242, 255, 0.6);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }
      .slide-context-menu button,
      .section-context-menu button {
        background: transparent;
        border: none;
        color: #e0f2ff;
        font-size: 14px;
        text-align: left;
        padding: 10px 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .slide-context-menu button .menu-icon,
      .section-context-menu button .menu-icon {
        width: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .slide-context-menu button span:not(.menu-icon):not(.menu-shortcut),
      .section-context-menu button span:not(.menu-icon):not(.menu-shortcut) {
        flex: 1;
      }
      .slide-context-menu button:hover,
      .section-context-menu button:hover {
        background: rgba(56, 189, 248, 0.22);
        transform: translateX(3px);
        color: #38bdf8;
      }
      .slide-context-menu button.active,
      .section-context-menu button.active {
        background: rgba(56, 189, 248, 0.28);
        color: #0f172a;
      }
      .slide-context-menu button[disabled],
      .section-context-menu button[disabled] {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
      }
      .image-context-menu,
      .slide-canvas-context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 200px;
        padding: 8px 0;
        background: linear-gradient(150deg, rgba(9, 46, 63, 0.95) 0%, rgba(8, 70, 58, 0.97) 100%);
        border: 1px solid rgba(56, 189, 248, 0.35);
        border-radius: 12px;
        box-shadow: 0 24px 50px rgba(5, 24, 36, 0.58);
        z-index: 6000;
        opacity: 0;
        transform: translateY(-6px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }
      .image-context-menu.show,
      .slide-canvas-context-menu.show {
        display: flex;
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .image-context-menu button,
      .slide-canvas-context-menu button {
        background: transparent;
        border: none;
        color: #e0f2ff;
        font-size: 14px;
        text-align: left;
        padding: 10px 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }
      .image-context-menu button:hover:not([disabled]),
      .slide-canvas-context-menu button:hover:not([disabled]) {
        background: rgba(56, 189, 248, 0.22);
        color: #38bdf8;
        transform: translateX(3px);
      }
      .spell-suggestion-label {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(191, 219, 254, 0.65);
        padding: 6px 18px 4px;
      }
      .image-context-menu button[data-role="spell-suggestion"] {
        display: flex;
        gap: 12px;
        justify-content: space-between;
        align-items: center;
      }
      .image-context-menu button[data-role="spell-suggestion"] .spell-suggestion-hint {
        font-size: 11px;
        opacity: 0.6;
      }
      .image-context-menu button[data-role="spell-suggestion"][disabled] {
        opacity: 0.65;
        cursor: default;
        transform: none;
      }
      .image-context-menu button[disabled],
      .slide-canvas-context-menu button[disabled] {
        opacity: 0.55;
        cursor: default;
        transform: none;
      }
      .image-context-menu .menu-icon,
      .slide-canvas-context-menu .menu-icon {
        width: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        opacity: 0.8;
      }
      .slide-preview-title {
        display: block;
        font-weight: 600;
        font-size: 14px;
        letter-spacing: 0.3px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        max-width: 100%;
      }
      .slide-preview-title.editing {
        background: rgba(56, 189, 248, 0.18);
        outline: 2px solid rgba(56, 189, 248, 0.6);
        border-radius: 6px;
        padding: 2px 6px;
        color: #f0f9ff;
      }

      body:not(.light-mode):not(.dark-theme) .shape-dropdown,
      body:not(.light-mode):not(.dark-theme) .chart-dropdown,
      body:not(.light-mode):not(.dark-theme) .logo-dropdown,
      body:not(.light-mode):not(.dark-theme) .font-dropdown {
        background: linear-gradient(150deg, rgba(9, 46, 63, 0.95) 0%, rgba(8, 70, 58, 0.97) 100%);
        border: 1px solid rgba(56, 189, 248, 0.35);
        box-shadow: 0 26px 48px rgba(5, 24, 36, 0.58);
        color: #e0f2ff;
        backdrop-filter: blur(18px);
      }
      body:not(.light-mode):not(.dark-theme) .shape-option,
      body:not(.light-mode):not(.dark-theme) .chart-option,
      body:not(.light-mode):not(.dark-theme) .font-option {
        color: #e0f2ff;
        background: transparent;
        border-radius: 10px;
        transition: background 0.2s ease, color 0.2s ease;
      }
      body:not(.light-mode):not(.dark-theme) .shape-option:hover,
      body:not(.light-mode):not(.dark-theme) .chart-option:hover,
      body:not(.light-mode):not(.dark-theme) .font-option:hover {
        background: rgba(56, 189, 248, 0.22);
        color: #38bdf8;
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel {
        background: linear-gradient(150deg, rgba(9, 46, 63, 0.94) 0%, rgba(8, 70, 58, 0.96) 100%);
        border: 1px solid rgba(56, 189, 248, 0.35);
        box-shadow: 0 26px 48px rgba(5, 24, 36, 0.58);
        color: #e0f2ff;
        border-radius: 16px;
        backdrop-filter: blur(18px);
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel h4 {
        color: #f0f9ff;
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel label {
        color: rgba(191, 219, 254, 0.8);
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel input {
        background: rgba(13, 52, 78, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.32);
        color: #e0f2ff;
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel input:focus {
        border-color: rgba(56, 189, 248, 0.6);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
        outline: none;
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel button {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.95) 0%, rgba(45, 212, 191, 0.95) 100%);
        color: #04111f;
        border: none;
        box-shadow: 0 14px 30px rgba(14, 165, 233, 0.35);
      }
      body:not(.light-mode):not(.dark-theme) .table-insert-panel button:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 1) 0%, rgba(45, 212, 191, 1) 100%);
      }

      body.dark-theme {
        background: linear-gradient(135deg, #2d333b 0%, #252b33 45%, #1f242b 100%) !important;
        background-attachment: fixed;
        background-repeat: no-repeat;
        background-size: cover;
        color: #eaeaea;
        position: relative;
      }

      body.dark-theme::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.04), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }

      body.dark-theme > * {
        position: relative;
        z-index: 1;
      }
body.dark-theme > .shape-dropdown,
body.dark-theme > .chart-dropdown,
body.dark-theme > .logo-dropdown,
body.dark-theme > .font-dropdown,
body.dark-theme > #tableInsertPanel,
body.dark-theme > .save-as-modal,
body.dark-theme > .save-as-modal.show,
body.dark-theme > .transition-preview-overlay,
body.dark-theme > .presentation-overlay,
body.dark-theme > .image-context-menu,
body.dark-theme > .slide-canvas-context-menu {
  position: fixed;
      }

      body.dark-theme > #chartDataEditor {
        position: fixed;
        z-index: 4500;
      }

      /* Light mode background with frosted glass effect */
      body.light-mode {
        background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(240,240,240,0.8)) !important;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #1a1a1a;
        transition: all 0.3s ease-in-out;
        position: relative;
      }

      /* Card or container glass effect in light mode */
      body.light-mode .editor {
        background: rgba(255, 255, 255, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
      }

      body.light-mode .sidebar {
        background: rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-right: none;
        box-shadow: 0 10px 24px rgba(148, 163, 184, 0.15);
      }

      body.light-mode .topbar {
        background: rgba(255, 255, 255, 0.4);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }
      body.light-mode .canvas-wrap {
        background: rgba(255, 255, 255, 0.6);
        border-radius: 16px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 10px 30px rgba(148, 163, 184, 0.2);
      }
      body.light-mode .toolbar {
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid rgba(209, 213, 219, 0.55);
        box-shadow: 0 18px 35px rgba(148, 163, 184, 0.3);
        backdrop-filter: blur(18px);
        -webkit-backdrop-filter: blur(18px);
        position: relative;
        z-index: 20;
      }
      body.light-mode .toolbar-tabs {
        background: rgba(255, 255, 255, 0.88);
        border: 1px solid rgba(203, 213, 225, 0.7);
        box-shadow: 0 14px 32px rgba(148, 163, 184, 0.22);
        gap: 10px;
      }
      body.light-mode .toolbar-tab {
        color: #475569;
      }
      body.light-mode .toolbar-tab:hover {
        background: rgba(59, 130, 246, 0.12);
        color: #1d4ed8;
      }
      body.light-mode .toolbar-tab.active {
        background: rgba(59, 130, 246, 0.18);
        color: #1d4ed8;
        box-shadow: none;
      }
      body.light-mode .toolbar-tab::after {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.95), rgba(14, 165, 233, 0.9));
      }
      body.light-mode .toolbar-tab:focus-visible {
        box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.6);
      }
      body.light-mode .toolbar-panel .group-title {
        color: #1f2937;
      }
      body.light-mode .toolbar-panel .tool-divider {
        background: rgba(148, 163, 184, 0.35);
      }
      body.light-mode .tool-select,
      body.light-mode .tool {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(203, 213, 225, 0.85);
        color: #1f2937;
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.12);
      }
      body.light-mode .tool-select:hover,
      body.light-mode .tool:hover {
        background: rgba(226, 232, 240, 0.95);
      }
      body.light-mode .tool.active {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.95) 0%, rgba(14, 165, 233, 0.95) 100%);
        border-color: rgba(96, 165, 250, 0.9);
        color: #f8fafc;
        box-shadow: 0 10px 24px rgba(37, 99, 235, 0.3);
      }
      body.light-mode .color-controls .color-bar {
        border-color: rgba(148, 163, 184, 0.4);
      }
      body.light-mode .sidebar-view-button {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(203, 213, 225, 0.85);
        color: #1f2937;
        box-shadow: 0 8px 18px rgba(148, 163, 184, 0.22);
      }
      body.light-mode .sidebar-view-button:hover {
        background: rgba(226, 232, 240, 0.95);
      }
      body.light-mode .sidebar-view-button.active {
        background: linear-gradient(130deg, rgba(59, 130, 246, 0.95) 0%, rgba(16, 185, 129, 0.92) 100%);
        border-color: rgba(96, 165, 250, 0.9);
        color: #f8fafc;
        box-shadow: 0 16px 32px rgba(37, 99, 235, 0.35);
      }

      /* Navigation and text colors in light mode */
      body.light-mode .tool,
      body.light-mode .tool-select,
      body.light-mode .slide-preview {
        color: #1a1a1a !important;
      }

      body.light-mode .slide-preview {
        background: rgba(255, 255, 255, 0.4);
        border-color: rgba(0, 0, 0, 0.15);
      }

      body.light-mode .tool-select::placeholder {
        color: #666 !important;
      }

      body.light-mode .title-box,
      body.light-mode .text-box {
        color: #000000 !important;
      }

      body.light-mode .topbar {
        color: #1a1a1a !important;
      }
      body.light-mode .comments-panel {
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(209, 213, 219, 0.75);
        color: #1f2937;
        box-shadow: 0 22px 40px rgba(148, 163, 184, 0.25);
      }
      body.light-mode .comments-header,
      body.light-mode .comment-meta,
      body.light-mode .comment-empty {
        color: #1f2937;
      }
      body.light-mode .comment-item {
        background: rgba(248, 250, 252, 0.9);
        border: 1px solid rgba(209, 213, 219, 0.65);
      }
      body.light-mode .comment-delete {
        color: #dc2626;
      }
      body.light-mode .comment-delete:hover {
        color: #b91c1c;
      }
      body.light-mode .comment-input {
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(209, 213, 219, 0.8);
        color: #1f2937;
      }
      body.light-mode .comment-input::placeholder {
        color: rgba(71, 85, 105, 0.7);
      }
      body.light-mode .comment-submit {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.95) 0%, rgba(14, 165, 233, 0.95) 100%);
        color: #f8fafc;
        box-shadow: 0 14px 26px rgba(59, 130, 246, 0.28);
      }
      body.light-mode .font-picker-button,
      body.light-mode .font-picker-label {
        color: #0f172a;
      }
      body.light-mode .save-as-modal-content {
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid rgba(203, 213, 225, 0.6);
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
        color: #0f172a;
      }
      body.light-mode .save-as-modal {
        background: rgba(15, 23, 42, 0.25);
      }
      body.light-mode .save-as-modal-title {
        color: #0f172a;
      }
      body.light-mode .save-as-modal-close {
        color: #64748b;
      }
      body.light-mode .save-as-modal-close:hover {
        background: rgba(59, 130, 246, 0.16);
        color: #1d4ed8;
      }
      body.light-mode .save-as-form-label {
        color: rgba(30, 41, 59, 0.75);
      }
      body.light-mode .save-as-form-select,
      body.light-mode .save-as-form-input {
        border: 1px solid rgba(203, 213, 225, 0.75);
        background: rgba(248, 250, 252, 0.96);
        color: #0f172a;
      }
      body.light-mode .save-as-form-select option {
        background: #ffffff;
        color: #0f172a;
      }
      body.light-mode .save-as-form-select:focus,
      body.light-mode .save-as-form-input:focus {
        border-color: rgba(59, 130, 246, 0.65);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
      }
      body.light-mode .save-as-form-select {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%233b82f6' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        background-size: 12px 12px;
      }
      body.light-mode .save-as-modal-actions {
        border-top: 1px solid rgba(203, 213, 225, 0.55);
      }
      body.light-mode .save-as-modal-btn-cancel {
        background: rgba(226, 232, 240, 0.85);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .save-as-modal-btn-cancel:hover {
        background: rgba(209, 213, 219, 0.9);
      }
      body.light-mode .save-as-modal-btn-save {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 14px 28px rgba(59, 130, 246, 0.25);
      }
      body.light-mode .save-as-modal-btn-save:hover {
        background: linear-gradient(135deg, rgba(37, 99, 235, 1) 0%, rgba(59, 130, 246, 1) 100%);
      }
      body.light-mode .section-name-modal-content {
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid rgba(203, 213, 225, 0.6);
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
        color: #0f172a;
      }
      body.light-mode .section-name-modal {
        background: rgba(15, 23, 42, 0.25);
      }
      body.light-mode .section-name-modal-title {
        color: #0f172a;
      }
      body.light-mode .section-name-modal-close {
        color: #64748b;
      }
      body.light-mode .section-name-modal-close:hover {
        background: rgba(59, 130, 246, 0.16);
        color: #1d4ed8;
      }
      body.light-mode .section-name-form-label {
        color: rgba(30, 41, 59, 0.75);
      }
      body.light-mode .section-name-form-input {
        border: 1px solid rgba(203, 213, 225, 0.75);
        background: rgba(248, 250, 252, 0.96);
        color: #0f172a;
      }
      body.light-mode .section-name-form-input:focus {
        border-color: rgba(59, 130, 246, 0.65);
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.15);
        background: rgba(255, 255, 255, 1);
      }
      body.light-mode .section-name-modal-actions {
        border-top: 1px solid rgba(203, 213, 225, 0.55);
      }
      body.light-mode .section-name-modal-btn-cancel {
        background: rgba(226, 232, 240, 0.85);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .section-name-modal-btn-cancel:hover {
        background: rgba(209, 213, 219, 0.9);
      }
      body.light-mode .section-name-modal-btn-submit {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 12px 28px rgba(59, 130, 246, 0.25);
      }
      body.light-mode .section-name-modal-btn-submit:hover {
        background: linear-gradient(135deg, rgba(37, 99, 235, 1) 0%, rgba(59, 130, 246, 1) 100%);
      }
      body.light-mode .delete-section-modal-content {
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid rgba(203, 213, 225, 0.6);
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
        color: #0f172a;
      }
      body.light-mode .delete-section-modal {
        background: rgba(15, 23, 42, 0.25);
      }
      body.light-mode .delete-section-modal-message {
        color: #0f172a;
      }
      body.light-mode .delete-section-modal-btn-cancel {
        background: rgba(226, 232, 240, 0.85);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .delete-section-modal-btn-cancel:hover {
        background: rgba(209, 213, 219, 0.9);
      }
      body.light-mode .delete-section-modal-btn-confirm {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.95) 100%);
        color: #ffffff;
        border: 1px solid rgba(239, 68, 68, 0.5);
        box-shadow: 0 12px 28px rgba(239, 68, 68, 0.25);
      }
      body.light-mode .delete-section-modal-btn-confirm:hover {
        background: linear-gradient(135deg, rgba(239, 68, 68, 1) 0%, rgba(220, 38, 38, 1) 100%);
      }
      body.light-mode .ai-designer-modal-content {
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid rgba(203, 213, 225, 0.6);
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
        color: #0f172a;
      }
      body.light-mode .ai-designer-modal {
        background: rgba(15, 23, 42, 0.25);
      }
      body.light-mode .ai-designer-modal-title {
        color: #0f172a;
      }
      body.light-mode .ai-designer-modal-close {
        color: #64748b;
      }
      body.light-mode .ai-designer-modal-close:hover {
        background: rgba(59, 130, 246, 0.16);
        color: #1d4ed8;
      }
      body.light-mode .ai-designer-form-label {
        color: rgba(30, 41, 59, 0.75);
      }
      body.light-mode .ai-designer-form-textarea,
      body.light-mode .ai-designer-form-select {
        border: 1px solid rgba(203, 213, 225, 0.75);
        background: rgba(248, 250, 252, 0.96);
        color: #0f172a;
      }
      body.light-mode .ai-designer-form-select option {
        background: #ffffff;
        color: #0f172a;
      }
      body.light-mode .ai-designer-form-textarea:focus,
      body.light-mode .ai-designer-form-select:focus {
        border-color: rgba(59, 130, 246, 0.65);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        background: rgba(255, 255, 255, 1);
      }
      body.light-mode .ai-designer-preview {
        background: rgba(248, 250, 252, 0.8);
        border: 1px solid rgba(203, 213, 225, 0.6);
      }
      body.light-mode .ai-designer-preview-placeholder {
        color: rgba(100, 116, 139, 0.7);
      }
      body.light-mode .ai-designer-preview-loading {
        color: rgba(37, 99, 235, 0.8);
      }
      body.light-mode .ai-designer-modal-actions {
        border-top: 1px solid rgba(203, 213, 225, 0.55);
      }
      body.light-mode .ai-designer-modal-btn-cancel {
        background: rgba(226, 232, 240, 0.85);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .ai-designer-modal-btn-cancel:hover {
        background: rgba(209, 213, 219, 0.9);
      }
      body.light-mode .ai-designer-modal-btn-generate {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 14px 28px rgba(59, 130, 246, 0.25);
      }
      body.light-mode .ai-designer-modal-btn-generate:hover {
        background: linear-gradient(135deg, rgba(37, 99, 235, 1) 0%, rgba(59, 130, 246, 1) 100%);
      }
      body.light-mode .ai-designer-modal-btn-insert {
        background: linear-gradient(135deg, rgba(5, 150, 105, 0.95) 0%, rgba(16, 185, 129, 0.95) 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 14px 28px rgba(5, 150, 105, 0.25);
      }
      body.light-mode .ai-designer-modal-btn-insert:hover {
        background: linear-gradient(135deg, rgba(5, 150, 105, 1) 0%, rgba(16, 185, 129, 1) 100%);
      }
      body.light-mode .ai-designer-status {
        background: rgba(248, 250, 252, 0.8);
        border: 1px solid rgba(203, 213, 225, 0.6);
        color: rgba(30, 41, 59, 0.9);
      }
      body.light-mode .ai-designer-status.error {
        color: #dc2626;
        background: rgba(254, 226, 226, 0.8);
        border-color: rgba(239, 68, 68, 0.5);
      }
      body.light-mode .ai-designer-status.success {
        color: #059669;
        background: rgba(209, 250, 229, 0.8);
        border-color: rgba(34, 197, 94, 0.5);
      }
      body.light-mode .ai-presentation-modal-content {
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid rgba(203, 213, 225, 0.6);
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
        color: #0f172a;
      }
      body.light-mode .ai-presentation-modal {
        background: rgba(15, 23, 42, 0.25);
      }
      body.light-mode .ai-presentation-modal-title {
        color: #0f172a;
      }
      body.light-mode .ai-presentation-modal-close {
        color: #64748b;
      }
      body.light-mode .ai-presentation-modal-close:hover {
        background: rgba(59, 130, 246, 0.16);
        color: #1d4ed8;
      }
      body.light-mode .ai-presentation-form-label {
        color: rgba(30, 41, 59, 0.75);
      }
      body.light-mode .ai-presentation-form-textarea,
      body.light-mode .ai-presentation-form-input,
      body.light-mode .ai-presentation-form-select {
        border: 1px solid rgba(203, 213, 225, 0.75);
        background: rgba(248, 250, 252, 0.96);
        color: #0f172a;
      }
      body.light-mode .ai-presentation-form-select option {
        background: #ffffff;
        color: #0f172a;
      }
      body.light-mode .ai-presentation-form-textarea:focus,
      body.light-mode .ai-presentation-form-input:focus,
      body.light-mode .ai-presentation-form-select:focus {
        border-color: rgba(59, 130, 246, 0.65);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        background: rgba(255, 255, 255, 1);
      }
      body.light-mode .ai-presentation-progress {
        background: rgba(248, 250, 252, 0.8);
        border: 1px solid rgba(203, 213, 225, 0.6);
      }
      body.light-mode .ai-presentation-progress-bar {
        background: rgba(226, 232, 240, 0.8);
      }
      body.light-mode .ai-presentation-progress-text {
        color: rgba(30, 41, 59, 0.9);
      }
      body.light-mode .ai-presentation-modal-actions {
        border-top: 1px solid rgba(203, 213, 225, 0.55);
      }
      body.light-mode .ai-presentation-modal-btn-cancel {
        background: rgba(226, 232, 240, 0.85);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .ai-presentation-modal-btn-cancel:hover {
        background: rgba(209, 213, 219, 0.9);
      }
      body.light-mode .ai-presentation-modal-btn-generate {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 14px 28px rgba(59, 130, 246, 0.25);
      }
      body.light-mode .ai-presentation-modal-btn-generate:hover {
        background: linear-gradient(135deg, rgba(37, 99, 235, 1) 0%, rgba(59, 130, 246, 1) 100%);
      }
      body.light-mode .ai-presentation-status {
        background: rgba(248, 250, 252, 0.8);
        border: 1px solid rgba(203, 213, 225, 0.6);
        color: rgba(30, 41, 59, 0.9);
      }
      body.light-mode .ai-presentation-status.error {
        color: #dc2626;
        background: rgba(254, 226, 226, 0.8);
        border-color: rgba(239, 68, 68, 0.5);
      }
      body.light-mode .ai-presentation-status.success {
        color: #059669;
        background: rgba(209, 250, 229, 0.8);
        border-color: rgba(34, 197, 94, 0.5);
      }
      body.light-mode .font-dropdown,
      body.light-mode .shape-dropdown,
      body.light-mode .chart-dropdown,
      body.light-mode .logo-dropdown,
      body.light-mode .icon-dropdown,
      body.light-mode .table-insert-panel {
        background: rgba(255, 255, 255, 0.96);
        border: 1px solid rgba(203, 213, 225, 0.7);
        box-shadow: 0 18px 42px rgba(148, 163, 184, 0.25);
        color: #0f172a;
      }
      body.light-mode .font-dropdown::-webkit-scrollbar,
      body.light-mode .shape-dropdown::-webkit-scrollbar,
      body.light-mode .chart-dropdown::-webkit-scrollbar {
        width: 8px;
      }
      body.light-mode .font-dropdown::-webkit-scrollbar-thumb,
      body.light-mode .shape-dropdown::-webkit-scrollbar-thumb,
      body.light-mode .chart-dropdown::-webkit-scrollbar-thumb {
        background: rgba(148, 163, 184, 0.5);
        border-radius: 999px;
      }
      body.light-mode .font-dropdown::-webkit-scrollbar-thumb:hover,
      body.light-mode .shape-dropdown::-webkit-scrollbar-thumb:hover,
      body.light-mode .chart-dropdown::-webkit-scrollbar-thumb:hover {
        background: rgba(100, 116, 139, 0.7);
      }
      body.light-mode .font-option {
        background: rgba(248, 250, 252, 0.96);
        border: 1px solid rgba(203, 213, 225, 0.7);
        color: #0f172a;
      }
      body.light-mode .font-option:hover {
        background: rgba(226, 232, 240, 0.95);
      }
      body.light-mode .font-option.active {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.92) 0%, rgba(14, 165, 233, 0.92) 100%);
        color: #f8fafc;
        border-color: rgba(96, 165, 250, 0.9);
      }
      body.light-mode .shape-option,
      body.light-mode .chart-option {
        background: rgba(248, 250, 252, 0.96);
        border: 1px solid rgba(203, 213, 225, 0.7);
        color: #0f172a;
      }
      body.light-mode .shape-option:hover,
      body.light-mode .chart-option:hover {
        background: rgba(226, 232, 240, 0.95);
      }
      body.light-mode .shape-option-label,
      body.light-mode .chart-option-label {
        color: #0f172a;
      }
      body.light-mode .icon-option {
        background: rgba(248, 250, 252, 0.96);
        border: 1px solid rgba(203, 213, 225, 0.7);
        color: #0f172a;
      }
      body.light-mode .icon-option:hover {
        background: rgba(226, 232, 240, 0.95);
        border-color: rgba(59, 130, 246, 0.5);
      }
      body.light-mode .icon-option svg {
        color: #0f172a;
      }
      body.light-mode .icon-option-label {
        color: rgba(30, 41, 59, 0.75);
      }
      body.light-mode .icon-folder-option {
        background: rgba(248, 250, 252, 0.96);
        border: 1px solid rgba(203, 213, 225, 0.7);
        color: #0f172a;
      }
      body.light-mode .icon-folder-option:hover {
        background: rgba(226, 232, 240, 0.95);
        border-color: rgba(59, 130, 246, 0.5);
      }
      body.light-mode .icon-back-button {
        background: rgba(248, 250, 252, 0.96);
        border: 1px solid rgba(203, 213, 225, 0.7);
        color: #0f172a;
      }
      body.light-mode .icon-back-button:hover {
        background: rgba(226, 232, 240, 0.95);
        border-color: rgba(59, 130, 246, 0.5);
      }
      body.light-mode .icon-search input {
        background: rgba(248, 250, 252, 0.95);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .icon-search input::placeholder {
        color: rgba(100, 116, 139, 0.6);
      }
      body.light-mode .icon-search input:focus {
        border-color: rgba(59, 130, 246, 0.5);
        background: rgba(255, 255, 255, 0.98);
      }
      body.light-mode .icon-view-header {
        border-bottom-color: rgba(203, 213, 225, 0.5);
      }
      body.light-mode .chart-option-preview .chart-mini {
        background: rgba(59, 130, 246, 0.12);
      }
      body.light-mode .table-insert-panel h4 {
        color: #0f172a;
      }
      body.light-mode .table-insert-panel label {
        color: rgba(30, 41, 59, 0.75);
      }
      body.light-mode .table-insert-panel input {
        background: rgba(248, 250, 252, 0.95);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #0f172a;
      }
      body.light-mode .table-insert-panel button {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.92) 0%, rgba(14, 165, 233, 0.92) 100%);
        color: #f8fafc;
        border: none;
        box-shadow: 0 12px 26px rgba(59, 130, 246, 0.25);
      }
      body.light-mode .transition-select-wrapper,
      body.light-mode .animation-select-wrapper,
      body.light-mode .transition-select-wrapper .tool-select,
      body.light-mode .animation-select-wrapper .tool-select {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(203, 213, 225, 0.75);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }
      body.light-mode .transition-label,
      body.light-mode .animation-label {
        color: rgba(15, 23, 42, 0.75);
      }
      body.light-mode .transition-select,
      body.light-mode .animation-select {
        color: #0f172a;
      }
      body.light-mode .transition-select-wrapper:hover,
      body.light-mode .animation-select-wrapper:hover {
        background: rgba(226, 232, 240, 0.95);
        border-color: rgba(148, 163, 184, 0.75);
      }
      body.light-mode .transition-apply-button,
      body.light-mode .transition-apply-all-button,
      body.light-mode .animation-assign-button,
      body.light-mode .animation-remove-button {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(203, 213, 225, 0.75);
        color: #0f172a;
        box-shadow: 0 10px 24px rgba(148, 163, 184, 0.18);
      }
      body.light-mode .transition-apply-button:hover,
      body.light-mode .transition-apply-all-button:hover,
      body.light-mode .animation-assign-button:hover,
      body.light-mode .animation-remove-button:hover {
        background: rgba(226, 232, 240, 0.95);
      }
      body.light-mode .transition-duration-suffix,
      body.light-mode .animation-duration-suffix {
        color: rgba(31, 41, 55, 0.7);
      }
      body.light-mode .transition-select-icon,
      body.light-mode .transition-select-caret {
        color: rgba(37, 99, 235, 0.85);
      }
      body.light-mode .translator-panel {
        background: rgba(255, 255, 255, 0.96);
        border-left: 1px solid rgba(203, 213, 225, 0.7);
        color: #0f172a;
        box-shadow: 0 10px 30px rgba(148, 163, 184, 0.2);
      }
      body.light-mode .translator-label {
        color: rgba(30, 41, 59, 0.65);
      }
      body.light-mode .translator-textarea {
        background: rgba(248, 250, 252, 0.95);
        border: 1px solid rgba(203, 213, 225, 0.75);
        color: #0f172a;
      }
      body.light-mode .translator-textarea[readonly] {
        background: rgba(226, 232, 240, 0.8);
        color: rgba(30, 41, 59, 0.7);
      }
      body.light-mode .translator-select {
        border: 1px solid rgba(203, 213, 225, 0.75);
        background: rgba(248, 250, 252, 0.95);
        color: #0f172a;
      }
      body.light-mode .translator-select:hover {
        background: rgba(226, 232, 240, 0.95);
        border-color: rgba(148, 163, 184, 0.75);
      }
      body.light-mode .translator-select:focus {
        outline: 2px solid rgba(59, 130, 246, 0.6);
        outline-offset: 2px;
      }
      body.light-mode .zoom-display {
        color: #1f2937;
      }
      body.light-mode .translator-select option {
        background: #ffffff;
        color: #0f172a;
      }
      body.light-mode .image-context-menu,
      body.light-mode .slide-canvas-context-menu {
        background: rgba(255, 255, 255, 0.97);
        border: 1px solid rgba(203, 213, 225, 0.7);
        box-shadow: 0 18px 40px rgba(148, 163, 184, 0.25);
        color: #0f172a;
      }
      body.light-mode .image-context-menu button,
      body.light-mode .slide-canvas-context-menu button {
        color: #0f172a;
      }
      body.light-mode .image-context-menu button:hover:not([disabled]),
      body.light-mode .slide-canvas-context-menu button:hover:not([disabled]) {
        background: rgba(59, 130, 246, 0.15);
        color: #1d4ed8;
      }
      body.light-mode .image-context-menu .menu-icon,
      body.light-mode .slide-canvas-context-menu .menu-icon {
        opacity: 0.7;
        color: #1f2937;
      }
      body.dark-theme {
        background: radial-gradient(circle at 20% 20%, rgba(148, 163, 184, 0.12), transparent 55%), linear-gradient(135deg, #2f343d 0%, #262b33 100%) !important;
        color: #e2e8f0;
      }
      body.dark-theme .editor {
        background: linear-gradient(135deg, rgba(58, 64, 74, 0.88) 0%, rgba(32, 37, 44, 0.82) 100%);
        border: 1px solid rgba(148, 163, 184, 0.25);
        box-shadow: 0 24px 48px rgba(23, 29, 36, 0.6);
      }
      body.dark-theme .sidebar {
        background: linear-gradient(135deg, rgba(58, 64, 74, 0.78) 0%, rgba(32, 37, 44, 0.7) 100%);
        border-right: 1px solid rgba(148, 163, 184, 0.25);
        color: #e2e8f0;
      }
      body.dark-theme .topbar {
        background: linear-gradient(135deg, rgba(58, 64, 74, 0.76) 0%, rgba(32, 37, 44, 0.68) 100%);
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      }
      body.dark-theme .toolbar {
        background: linear-gradient(135deg, rgba(58, 64, 74, 0.82) 0%, rgba(32, 37, 44, 0.74) 100%);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 24px 45px rgba(23, 29, 36, 0.6);
      }
      body.dark-theme .toolbar-tabs {
        background: linear-gradient(135deg, rgba(66, 72, 82, 0.9) 0%, rgba(38, 43, 50, 0.84) 100%);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: inset 0 1px 0 rgba(148, 163, 184, 0.15), 0 18px 45px rgba(23, 29, 36, 0.55);
      }
      body.dark-theme .toolbar-tab {
        color: rgba(203, 213, 225, 0.75);
      }
      body.dark-theme .toolbar-tab:hover {
        background: rgba(59, 130, 246, 0.2);
        color: rgba(226, 232, 240, 0.95);
      }
      body.dark-theme .toolbar-tab.active {
        background: rgba(59, 130, 246, 0.28);
        color: #ffffff;
      }
      body.dark-theme .toolbar-tab::after {
        background: linear-gradient(135deg, rgba(96, 165, 250, 1), rgba(56, 189, 248, 1));
      }
      body.dark-theme .toolbar-tab:focus-visible {
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.45);
      }
      body.dark-theme .tool,
      body.dark-theme .tool-select {
        background: linear-gradient(135deg, rgba(68, 74, 84, 0.92) 0%, rgba(40, 45, 53, 0.88) 100%);
        border: 1px solid rgba(148, 163, 184, 0.4);
        color: #e2e8f0;
        box-shadow: 0 12px 30px rgba(23, 29, 36, 0.55);
      }
      body.dark-theme .tool:hover,
      body.dark-theme .tool-select:hover {
        background: linear-gradient(135deg, rgba(76, 82, 92, 0.95) 0%, rgba(46, 51, 59, 0.92) 100%);
      }
      body.dark-theme .tool.active {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.85) 0%, rgba(129, 140, 248, 0.85) 100%);
        border-color: rgba(96, 165, 250, 0.65);
        box-shadow: 0 16px 34px rgba(59, 130, 246, 0.45);
      }
      body.dark-theme .transition-select-wrapper,
      body.dark-theme .animation-select-wrapper {
        background: linear-gradient(135deg, rgba(68, 74, 84, 0.92) 0%, rgba(40, 45, 53, 0.88) 100%);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: inset 0 1px 0 rgba(209, 213, 219, 0.15);
      }
      body.dark-theme .transition-label,
      body.dark-theme .animation-label {
        color: rgba(226, 232, 240, 0.75);
      }
      body.dark-theme .transition-select,
      body.dark-theme .animation-select {
        color: #e2e8f0;
      }
      body.dark-theme .transition-select-icon,
      body.dark-theme .transition-select-caret {
        color: rgba(209, 213, 219, 0.7);
      }
      body.dark-theme .transition-apply-button,
      body.dark-theme .transition-apply-all-button,
      body.dark-theme .animation-assign-button,
      body.dark-theme .animation-remove-button {
        background: rgba(44, 49, 58, 0.88);
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: #e2e8f0;
      }
      body.dark-theme .transition-apply-button:hover,
      body.dark-theme .transition-apply-all-button:hover,
      body.dark-theme .transition-apply-all-button:hover,
      body.dark-theme .animation-assign-button:hover,
      body.dark-theme .animation-remove-button:hover {
        background: rgba(58, 63, 73, 0.92);
      }
      body.dark-theme .font-dropdown,
      body.dark-theme .shape-dropdown,
      body.dark-theme .chart-dropdown,
      body.dark-theme .table-insert-panel,
      body.dark-theme .save-as-modal-content,
      body.dark-theme .translator-panel,
      body.dark-theme .image-context-menu,
      body.dark-theme .slide-canvas-context-menu {
        background: linear-gradient(135deg, rgba(68, 74, 84, 0.95) 0%, rgba(40, 45, 53, 0.92) 100%);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 26px 52px rgba(23, 29, 36, 0.6);
        color: #e2e8f0;
      }
      body.dark-theme .save-as-modal {
        background: rgba(36, 42, 51, 0.65);
      }
      body.dark-theme .save-as-modal-title,
      body.dark-theme .save-as-form-label {
        color: rgba(226, 232, 240, 0.9);
      }
      body.dark-theme .save-as-form-select,
      body.dark-theme .save-as-form-input,
      body.dark-theme .translator-textarea,
      body.dark-theme .translator-select {
        background: rgba(50, 56, 66, 0.88);
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: #e2e8f0;
      }
      body.dark-theme .translator-select option,
      body.dark-theme .save-as-form-select option {
        background: rgba(36, 42, 51, 0.95);
        color: #e2e8f0;
      }
      body.dark-theme .save-as-modal-btn-cancel {
        background: rgba(50, 56, 66, 0.88);
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: #e2e8f0;
      }
      body.dark-theme .save-as-modal-btn-save {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
        color: #ffffff;
        border: none;
        box-shadow: 0 16px 34px rgba(37, 99, 235, 0.45);
      }
      body.dark-theme .shape-option,
      body.dark-theme .chart-option {
        background: rgba(50, 56, 66, 0.88);
        border: 1px solid rgba(148, 163, 184, 0.3);
        color: #e2e8f0;
      }
      body.dark-theme .shape-option:hover,
      body.dark-theme .chart-option:hover {
        background: rgba(72, 80, 92, 0.9);
      }
      body.dark-theme .zoom-display {
        color: rgba(226, 232, 240, 0.9);
      }
      body.dark-theme .comments-panel {
        background: linear-gradient(135deg, rgba(66, 72, 82, 0.92) 0%, rgba(40, 45, 53, 0.9) 100%);
        border: 1px solid rgba(148, 163, 184, 0.3);
        color: #e2e8f0;
      }
      body.dark-theme .comments-header,
      body.dark-theme .comment-meta,
      body.dark-theme .comment-empty {
        color: rgba(226, 232, 240, 0.85);
      }
body.dark-theme .comment-item {
  background: linear-gradient(135deg, rgba(76, 82, 92, 0.92) 0%, rgba(46, 51, 59, 0.9) 100%);
  border: 1px solid rgba(148, 163, 184, 0.25);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.15);
}
body.dark-theme .comment-input {
  background: linear-gradient(135deg, rgba(68, 74, 84, 0.88) 0%, rgba(40, 45, 53, 0.85) 100%);
  border: 1px solid rgba(148, 163, 184, 0.25);
  color: #e2e8f0;
}
body.dark-theme .comment-input::placeholder {
  color: rgba(148, 163, 184, 0.7);
}
body.dark-theme .comment-delete {
  color: #fca5a5;
}
body.dark-theme .comment-delete:hover {
  color: #f87171;
}
body.dark-theme .comment-submit {
  background: linear-gradient(135deg, rgba(37, 99, 235, 0.95) 0%, rgba(14, 165, 233, 0.95) 100%);
  color: #ffffff;
  box-shadow: 0 12px 26px rgba(37, 99, 235, 0.3);
}
body.dark-theme .comment-submit:hover {
  transform: translateY(-1px);
}

body.dark-theme .slide-preview {
  background: rgba(48, 54, 64, 0.88);
  border: 1px solid rgba(148, 163, 184, 0.3);
  box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.15);
  color: #e2e8f0;
}
body.dark-theme .slide-preview:hover {
  background: rgba(62, 68, 78, 0.9);
}
body.dark-theme .slide-preview.active {
  outline: 2px solid rgba(203, 213, 225, 0.8);
  background: rgba(72, 78, 88, 0.9);
}
body.dark-theme .slide-preview.drop-target {
  background: rgba(82, 88, 96, 0.85);
}
body.dark-theme .slide-preview.drop-target::after {
  background: rgba(203, 213, 225, 0.9);
}
body.dark-theme .slide-preview-title {
  color: #e2e8f0;
}
body.dark-theme .slide-preview-title.editing {
  background: rgba(50, 56, 66, 0.9);
  border: 1px solid rgba(148, 163, 184, 0.3);
  color: #ffffff;
}
body.dark-theme .slide-thumbnail-frame {
  background: rgba(45, 55, 72, 0.88);
  border: 1px solid rgba(96, 165, 250, 0.35);
  box-shadow: inset 0 0 0 1px rgba(99, 102, 241, 0.2);
}
body.dark-theme .slide-thumbnail-placeholder {
  background: rgba(45, 55, 72, 0.75);
  color: rgba(226, 232, 240, 0.65);
}
body.dark-theme .sidebar.thumbnail-view .slide-preview-title {
  color: rgba(226, 232, 240, 0.85);
}
      body.dark-theme .section-name-modal-content {
        background: linear-gradient(150deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.98) 100%);
        border: 1px solid rgba(71, 85, 105, 0.5);
        box-shadow: 0 30px 56px rgba(0, 0, 0, 0.6);
        color: #e2e8f0;
      }
      body.dark-theme .section-name-modal {
        background: rgba(0, 0, 0, 0.75);
      }
      body.dark-theme .section-name-modal-title {
        color: #e2e8f0;
      }
      body.dark-theme .section-name-modal-close {
        color: #94a3b8;
      }
      body.dark-theme .section-name-modal-close:hover {
        background: rgba(59, 130, 246, 0.2);
        color: #60a5fa;
      }
      body.dark-theme .section-name-form-label {
        color: rgba(226, 232, 240, 0.85);
      }
      body.dark-theme .section-name-form-input {
        border: 1px solid rgba(71, 85, 105, 0.5);
        background: rgba(30, 41, 59, 0.6);
        color: #e2e8f0;
      }
      body.dark-theme .section-name-form-input:focus {
        border-color: rgba(59, 130, 246, 0.6);
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        background: rgba(30, 41, 59, 0.8);
      }
      body.dark-theme .section-name-modal-actions {
        border-top: 1px solid rgba(71, 85, 105, 0.4);
      }
      body.dark-theme .section-name-modal-btn-cancel {
        background: rgba(51, 65, 85, 0.6);
        border: 1px solid rgba(71, 85, 105, 0.5);
        color: #cbd5e1;
      }
      body.dark-theme .section-name-modal-btn-cancel:hover {
        background: rgba(71, 85, 105, 0.7);
      }
      body.dark-theme .section-name-modal-btn-submit {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.9) 0%, rgba(99, 102, 241, 0.9) 100%);
        color: #ffffff;
        border: 1px solid rgba(59, 130, 246, 0.4);
        box-shadow: 0 12px 28px rgba(59, 130, 246, 0.3);
      }
      body.dark-theme .section-name-modal-btn-submit:hover {
        background: linear-gradient(135deg, rgba(59, 130, 246, 1) 0%, rgba(99, 102, 241, 1) 100%);
}
      body.dark-theme .save-as-modal-btn-save:hover,
      body.dark-theme .transition-select-wrapper:hover,
      body.dark-theme .animation-select-wrapper:hover,
      body.dark-theme .tool:hover,
      body.dark-theme .translator-select:hover {
        border-color: rgba(148, 163, 184, 0.45);
      }
      body.light-mode .translator-panel {
        background: rgba(255, 255, 255, 0.88);
        border: 1px solid rgba(209, 213, 219, 0.7);
        color: #1f2937;
        box-shadow: 0 14px 24px rgba(148, 163, 184, 0.22);
      }
      body.light-mode .translator-label {
        color: rgba(15, 23, 42, 0.65);
      }
      body.light-mode .translator-textarea {
        background: rgba(248, 250, 252, 0.95);
        border: 1px solid rgba(203, 213, 225, 0.8);
        color: #1f2937;
      }
      body.light-mode .translator-textarea[readonly] {
        background: rgba(226, 232, 240, 0.7);
        color: rgba(30, 41, 59, 0.7);
      }

      .editor {
        display:grid;
        grid-template-rows: auto 1fr;
        background: linear-gradient(140deg, rgba(10, 45, 60, 0.82) 0%, rgba(8, 65, 55, 0.84) 100%);
        backdrop-filter: blur(18px);
        border-radius:14px;
        border:1px solid rgba(56, 189, 248, 0.28);
        box-shadow: 0 28px 48px rgba(5, 24, 36, 0.58);
        min-width: 0;
        transition: all 0.2s ease-out;
      }
      .toolbar { 
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        gap: 12px;
        background: linear-gradient(145deg, rgba(9, 49, 63, 0.9) 0%, rgba(8, 72, 59, 0.92) 100%);
        padding: 12px 22px;
        border-radius: 16px;
        box-shadow: 0 24px 52px rgba(5, 24, 36, 0.56);
        backdrop-filter: blur(18px);
        position: relative;
        z-index: 20;
        min-width: 0;
        width: 100%;
        max-width: 100%;
        transition: all 0.2s ease-out;
        box-sizing: border-box;
        overflow: hidden;
      }
      .toolbar,
      .toolbar * {
        pointer-events: auto;
      }
      .toolbar-tabs {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px;
        border-radius: 999px;
        background: linear-gradient(135deg, rgba(11, 52, 71, 0.9) 0%, rgba(9, 74, 59, 0.92) 100%);
        box-shadow: inset 0 1px 0 rgba(148, 163, 184, 0.14), 0 20px 38px rgba(5, 22, 36, 0.48);
        position: relative;
        flex-wrap: wrap;
        min-width: 0;
        max-width: 100%;
      }
      .toolbar-tab {
        position: relative;
        background: transparent;
        border: none;
        color: rgba(226, 232, 240, 0.75);
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 13px;
        padding: 12px 24px;
        border-radius: 999px;
        cursor: pointer;
        transition: color 0.2s ease, background 0.2s ease, transform 0.2s ease;
        flex-shrink: 0;
        white-space: nowrap;
        box-sizing: border-box;
      }
      .toolbar-tab::after {
        content: "";
        position: absolute;
        left: 20px;
        right: 20px;
        bottom: 6px;
        height: 3px;
        border-radius: 999px;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.9), rgba(45, 212, 191, 0.9));
        transform: scaleX(0);
        transform-origin: center;
        transition: transform 0.2s ease;
        opacity: 0.9;
      }
      .toolbar-tab:hover {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.22), rgba(34, 197, 94, 0.22));
        color: rgba(240, 249, 255, 0.96);
      }
      .toolbar-tab.active {
        color: #ffffff;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.32), rgba(34, 197, 94, 0.28));
      }
      .toolbar-tab.active::after {
        transform: scaleX(1);
      }
      .toolbar-tab:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.45);
      }
      .toolbar-panels {
        position: relative;
        min-width: 0;
        max-width: 100%;
        overflow: hidden;
      }
      .toolbar-panel { 
        display: none; 
        align-items: center; 
        gap: 12px; 
        flex-wrap: wrap; 
        opacity: 0; 
        transform: translateY(4px); 
        transition: opacity 0.2s ease, transform 0.2s ease; 
        position: relative; 
        z-index: 1;
        min-width: 0;
        max-width: 100%;
        overflow: hidden;
      }
      .toolbar-panel.active { display: flex; opacity: 1; transform: translateY(0); }
      .toolbar-panel[data-tab-panel="view"] { margin-top: 0; }
      .toolbar-panel[data-tab-panel="templates"] { margin-top: 0; }
      .toolbar-panel[hidden] {
        display: none !important;
      }
      .templates-panel {
        display: flex;
        flex-direction: column;
        padding: 8px;
        gap: 8px;
        min-height: 60px;
      }
      .template-categories-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .transition-controls {
        display: flex;
        align-items: flex-end;
        flex-wrap: wrap;
        gap: 12px;
      }
      .transition-field {
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        gap: 4px;
        min-width: 160px;
      }
      .transition-label {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(191, 219, 254, 0.78);
      }
      .transition-field .tool-select {
        width: 100%;
      }
      .transition-select-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        height: 40px;
        padding: 0 12px;
        border-radius: 12px;
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(13, 52, 78, 0.7);
        box-shadow: inset 0 1px 0 rgba(148, 163, 184, 0.18);
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      }
      .transition-select-wrapper:hover {
        background: rgba(56, 189, 248, 0.2);
        border-color: rgba(56, 189, 248, 0.45);
        box-shadow: 0 8px 18px rgba(5, 20, 36, 0.3);
        transform: translateY(-1px);
      }
      .transition-select-wrapper:focus-within {
        border-color: rgba(56, 189, 248, 0.6);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
      }
      .transition-select-icon,
      .transition-select-caret {
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(232, 245, 233, 0.85);
      }
      .transition-select-icon i {
        font-size: 15px;
      }
      .transition-select-caret i {
        font-size: 12px;
      }
      .transition-select {
        flex: 1;
        min-width: 0;
        height: 100%;
        border: none;
        background: transparent;
        color: #e0f2ff;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        appearance: none;
        padding: 0;
        margin: 0;
        line-height: 1;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .transition-select:focus {
        outline: none;
      }
      .transition-duration-control {
        display: flex;
        align-items: center;
        gap: 6px;
        height: 40px;
      }
      .transition-duration-input {
        width: 88px;
        text-align: right;
      }
      .transition-duration-suffix {
        font-size: 13px;
        font-weight: 600;
        color: rgba(191, 219, 254, 0.75);
      }
      .transition-apply-button {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 16px;
        background: rgba(34, 197, 94, 0.15);
        border: 1px solid rgba(34, 197, 94, 0.3);
        border-radius: 6px;
        color: #22c55e;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .transition-apply-button:hover {
        background: rgba(34, 197, 94, 0.25);
        border-color: rgba(34, 197, 94, 0.5);
        transform: translateY(-1px);
      }
      
      .transition-apply-all-button {
        gap: 8px;
        height: 40px;
        padding: 0 16px;
        margin-left: auto;
        flex-shrink: 0;
        align-self: flex-end;
      }
      .animation-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        width: 100%;
      }
      .animation-controls {
        display: flex;
        align-items: flex-end;
        flex-wrap: wrap;
        gap: 12px;
      }
      .animation-field {
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        gap: 4px;
        min-width: 160px;
      }
      .animation-field .animation-label {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(191, 219, 254, 0.78);
      }
      .animation-duration-control {
        display: flex;
        align-items: center;
        gap: 6px;
        height: 40px;
      }
      .animation-duration-control input {
        width: 88px;
        text-align: right;
      }
      .animation-duration-suffix {
        font-size: 13px;
        font-weight: 600;
        color: rgba(191, 219, 254, 0.75);
      }
      .animation-assign-button,
      .animation-remove-button {
        height: 40px;
        padding: 0 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      .animation-sequence-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 100%;
      }
      .animation-sequence-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: rgba(191, 219, 254, 0.9);
        font-weight: 600;
        font-size: 14px;
      }
      .animation-sequence-hint {
        font-size: 12px;
        font-weight: 500;
        color: rgba(148, 163, 184, 0.75);
      }
      .animation-sequence-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 220px;
        overflow-y: auto;
        padding-right: 4px;
      }
      .animation-sequence-empty {
        font-size: 13px;
        color: rgba(148, 163, 184, 0.7);
        font-style: italic;
      }
      .animation-sequence-item {
        display: flex;
        align-items: center;
        gap: 12px;
        background: linear-gradient(140deg, rgba(13, 57, 72, 0.82) 0%, rgba(11, 73, 62, 0.84) 100%);
        border: 1px solid rgba(56, 189, 248, 0.32);
        border-radius: 12px;
        padding: 10px 12px;
        cursor: grab;
        transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      }
      .animation-sequence-item:hover {
        border-color: rgba(56, 189, 248, 0.45);
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.24), rgba(34, 197, 94, 0.24));
        transform: translateY(-1px);
      }
      .animation-sequence-item.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }
      .animation-sequence-item.drop-target {
        border-color: rgba(56, 189, 248, 0.55);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.25);
      }
      .animation-sequence-item.selected {
        border-color: rgba(56, 189, 248, 0.75);
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.3), rgba(34, 197, 94, 0.28));
      }
      .animation-item-order {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 8px;
        background: rgba(56, 189, 248, 0.2);
        color: rgba(191, 219, 254, 0.95);
        font-weight: 700;
        font-size: 13px;
      }
      .animation-item-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex: 1;
        min-width: 0;
      }
      .animation-item-title {
        font-weight: 600;
        font-size: 14px;
        color: rgba(226, 232, 240, 0.95);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .animation-item-meta {
        font-size: 12px;
        color: rgba(148, 163, 184, 0.75);
      }
      .animation-item-remove {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 8px;
        border: 1px solid rgba(239, 68, 68, 0.35);
        color: rgba(248, 113, 113, 0.95);
        background: rgba(127, 29, 29, 0.35);
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .animation-item-remove:hover {
        background: rgba(239, 68, 68, 0.35);
        border-color: rgba(239, 68, 68, 0.55);
        transform: translateY(-1px);
      }
      .animation-sequence-container.hidden {
        display: none;
      }
      .animation-sequence-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .animation-sequence-close {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        background: rgba(13, 52, 78, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.35);
        color: rgba(226, 232, 240, 0.85);
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .animation-sequence-close:hover {
        background: rgba(56, 189, 248, 0.24);
        border-color: rgba(56, 189, 248, 0.45);
        transform: translateY(-1px);
      }
      .animation-order-badge {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: rgba(13, 52, 78, 0.85);
        border: 1px solid rgba(96, 165, 250, 0.35);
        color: rgba(224, 242, 254, 0.95);
        font-size: 11px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        cursor: pointer;
        z-index: 2000;
        box-shadow: 0 6px 12px rgba(5, 20, 36, 0.35);
        transition: background 0.2s ease, transform 0.2s ease;
        user-select: none;
      }
      .animation-order-badge:hover {
        background: rgba(56, 189, 248, 0.3);
        transform: translateY(-1px);
      }
      .presentation-animation-hidden {
        opacity: 0 !important;
        pointer-events: none !important;
      }
      .presentation-animation-effect-fade-in {
        animation: animationFadeIn var(--animation-duration, 0.7s) ease-out forwards;
      }
      .presentation-animation-effect-pop-up {
        animation: animationPopUp var(--animation-duration, 0.7s) cubic-bezier(0.26, 0.72, 0, 1.02) forwards;
      }
      .presentation-animation-effect-slide-in-right {
        animation: animationSlideInRight var(--animation-duration, 0.7s) ease-out forwards;
      }
      .presentation-animation-effect-slide-in-left {
        animation: animationSlideInLeft var(--animation-duration, 0.7s) ease-out forwards;
      }
      .presentation-animation-effect-slide-in-up {
        animation: animationSlideInUp var(--animation-duration, 0.7s) ease-out forwards;
      }
      @keyframes animationFadeIn {
        0% { opacity: 0; }
        100% { opacity: 1; }
      }
      @keyframes animationPopUp {
        0% { opacity: 0; transform: var(--animation-base-transform, none) scale(0.7); }
        60% { opacity: 1; transform: var(--animation-base-transform, none) scale(1.05); }
        100% { opacity: 1; transform: var(--animation-base-transform, none) scale(1); }
      }
      @keyframes animationSlideInRight {
        0% { opacity: 0; transform: var(--animation-base-transform, none) translateX(40px); }
        100% { opacity: 1; transform: var(--animation-base-transform, none); }
      }
      @keyframes animationSlideInLeft {
        0% { opacity: 0; transform: var(--animation-base-transform, none) translateX(-40px); }
        100% { opacity: 1; transform: var(--animation-base-transform, none); }
      }
      @keyframes animationSlideInUp {
        0% { opacity: 0; transform: var(--animation-base-transform, none) translateY(40px); }
        100% { opacity: 1; transform: var(--animation-base-transform, none); }
      }
      .transition-preview-overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(4px);
        z-index: 12050;
        padding: 24px;
      }
      .transition-preview-overlay.show {
        display: flex;
      }
      .transition-preview-stage {
        position: relative;
        width: min(960px, 80vw);
        aspect-ratio: 16 / 9;
        background: rgba(8, 45, 30, 0.88);
        border: 1px solid rgba(46, 213, 115, 0.35);
        border-radius: 16px;
        box-shadow: 0 22px 44px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }
      .transition-preview-stage .presentation-slide {
        width: 100%;
        height: 100%;
      }
      .toolbar-panel .group-title {
        font-weight: 700;
        color: rgba(226, 232, 240, 0.85);
        margin-right: 8px;
      }
      .toolbar-panel .tool-divider {
        width: 1px;
        height: 28px;
        background: rgba(148, 163, 184, 0.28);
        margin: 0 6px;
      }
      .tool[disabled],
      .tool[aria-disabled="true"] {
        opacity: 0.5;
        cursor: default;
        pointer-events: none;
      }
      .tool { 
        background: linear-gradient(140deg, rgba(12, 59, 72, 0.82) 0%, rgba(10, 74, 63, 0.84) 100%);
        border: 1px solid rgba(56, 189, 248, 0.32);
        color: #e0f2ff;
        font-weight: 600;
        font-size: 15px;
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 40px;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        box-sizing: border-box;
        justify-content: center;
        box-shadow: 0 12px 26px rgba(5, 24, 36, 0.38);
      }
      .tool.present-button {
        margin-left: 12px;
        padding: 8px 16px;
        gap: 0;
        font-size: 15px;
        border: 2px solid rgba(56, 189, 248, 0.55);
        background: linear-gradient(135deg, rgba(8, 59, 70, 0.78) 0%, rgba(7, 72, 60, 0.8) 100%);
        color: #e0f2ff;
        min-width: 52px;
      }
      .tool.present-button:hover {
        background: linear-gradient(135deg, rgba(11, 82, 91, 0.9) 0%, rgba(9, 95, 75, 0.92) 100%);
        border-color: rgba(56, 189, 248, 0.75);
        transform: translateY(-1px);
      }
      .tool.present-button svg {
        width: 18px;
        height: 18px;
        display: block;
      }
      .tool:hover { 
        background: linear-gradient(135deg, rgba(14, 104, 118, 0.24) 0%, rgba(12, 117, 91, 0.28) 100%);
        transform: translateY(-2px);
        border-color: rgba(56, 189, 248, 0.48);
      }
      .tool.active { 
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.92) 0%, rgba(34, 197, 94, 0.9) 100%);
        color: #04111f;
        border-color: rgba(56, 189, 248, 0.58);
        box-shadow: 0 18px 36px rgba(14, 165, 233, 0.38);
      }
      .tool i {
        font-size: 14px;
      }
      .tool:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none;
      }
      .tool.spell-check-toggle {
        gap: 10px;
        padding: 8px 20px;
        justify-content: flex-start;
      }
      .tool.spell-check-toggle .tool-label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
      }
      .tool.spell-check-toggle .tool-state {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #38bdf8;
      }
      .tool.spell-check-toggle:not(.active) .tool-state {
        color: #fca5a5;
      }
      .translator-panel {
        position: relative;
        display: flex;
        flex-direction: column;
        background: linear-gradient(150deg, rgba(9, 49, 63, 0.9) 0%, rgba(8, 72, 59, 0.92) 100%);
        border-left: 1px solid rgba(56, 189, 248, 0.32);
        border-radius: 14px;
        padding: 14px;
        gap: 12px;
        width: var(--translator-width, 280px);
        min-width: 180px;
        max-width: 600px;
        color: #e0f2ff;
        box-sizing: border-box;
        transition: width 0.2s ease-out;
        overflow: hidden;
      }
      .translator-panel.hidden {
        display: none;
      }
      
      /* Resizable Panel Styles */
      .panel-resizer {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 6px;
        cursor: col-resize;
        z-index: 1000;
        user-select: none;
        transition: background 0.2s ease, width 0.2s ease;
        pointer-events: auto;
      }
      .panel-resizer:hover {
        background: rgba(56, 189, 248, 0.4);
        width: 8px;
      }
      .panel-resizer:active {
        background: rgba(56, 189, 248, 0.6);
        width: 8px;
      }
      .panel-resizer.resizing {
        background: rgba(56, 189, 248, 0.7);
        width: 8px;
      }
      .sidebar .panel-resizer {
        right: -6px;
        width: 12px;
      }
      .translator-panel .panel-resizer {
        left: -6px;
        width: 12px;
      }
      .panel-resizer::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 2px;
        height: 40px;
        background: rgba(56, 189, 248, 0.5);
        border-radius: 2px;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .panel-resizer:hover::before {
        opacity: 1;
      }
      .panel-resizer:active::before,
      .panel-resizer.resizing::before {
        opacity: 1;
        background: rgba(56, 189, 248, 0.8);
      }
      body.resizing-panel {
        cursor: col-resize !important;
        user-select: none;
      }
      body.resizing-panel * {
        cursor: col-resize !important;
      }
      
      /* Light mode resizer styles */
      body.light-mode .panel-resizer {
        background: transparent;
      }
      body.light-mode .panel-resizer:hover {
        background: rgba(148, 163, 184, 0.25);
      }
      body.light-mode .panel-resizer:active {
        background: rgba(148, 163, 184, 0.4);
      }
      body.light-mode .panel-resizer.resizing {
        background: rgba(148, 163, 184, 0.5);
      }
      body.light-mode .panel-resizer::before {
        background: rgba(148, 163, 184, 0.4);
      }
      body.light-mode .panel-resizer:hover::before {
        opacity: 1;
      }
      body.light-mode .panel-resizer:active::before,
      body.light-mode .panel-resizer.resizing::before {
        background: rgba(148, 163, 184, 0.6);
      }
      
      /* Dark theme resizer styles */
      body.dark-theme .panel-resizer {
        background: transparent;
      }
      body.dark-theme .panel-resizer:hover {
        background: rgba(148, 163, 184, 0.2);
      }
      body.dark-theme .panel-resizer:active {
        background: rgba(148, 163, 184, 0.35);
      }
      body.dark-theme .panel-resizer.resizing {
        background: rgba(148, 163, 184, 0.45);
      }
      body.dark-theme .panel-resizer::before {
        background: rgba(148, 163, 184, 0.35);
      }
      body.dark-theme .panel-resizer:hover::before {
        opacity: 1;
      }
      body.dark-theme .panel-resizer:active::before,
      body.dark-theme .panel-resizer.resizing::before {
        background: rgba(148, 163, 184, 0.55);
      }
      .translator-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .translator-title {
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 0.04em;
      }
      .translator-close {
        background: transparent;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        padding: 4px 6px;
        border-radius: 6px;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .translator-close:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateY(-1px);
      }
      .translator-body {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex: 1;
      }
      .translator-source,
      .translator-result {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .translator-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .translator-label {
        font-size: 11px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        font-weight: 700;
        color: rgba(191, 219, 254, 0.75);
      }
      .translator-textarea {
        min-height: 80px;
        border-radius: 12px;
        border: 1px solid rgba(96, 165, 250, 0.32);
        background: rgba(9, 32, 51, 0.8);
        color: #e0f2ff;
        font-size: 13px;
        line-height: 1.5;
        padding: 10px 12px;
        resize: vertical;
        font-family: inherit;
      }
      .translator-textarea[readonly] {
        background: rgba(9, 37, 60, 0.7);
        color: rgba(191, 219, 254, 0.72);
      }
      .translator-select {
        appearance: none;
        -webkit-appearance: none;
        width: 100%;
        height: 40px;
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.32);
        background: rgba(8, 32, 51, 0.72);
        color: #f0f9ff;
        font-size: 14px;
        font-weight: 600;
        padding: 0 14px;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        cursor: pointer;
      }
      .translator-select:hover {
        background: rgba(56, 189, 248, 0.18);
        border-color: rgba(56, 189, 248, 0.4);
        transform: translateY(-1px);
      }
      .translator-select:focus {
        outline: 2px solid rgba(56, 189, 248, 0.6);
        outline-offset: 2px;
      }
      .translator-select option {
        background: rgba(8, 32, 51, 0.95);
        color: #e0f2ff;
      }
      .translator-actions {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }
      .translator-actions .tool {
        min-width: 80px;
      }
      .translator-status {
        font-size: 12px;
        color: rgba(236, 253, 245, 0.75);
      }
      .tool svg {
        width: 18px;
        height: 18px;
      }
      .new-slide-toolbar-button {
        gap: 8px;
        padding: 8px 16px;
        white-space: nowrap;
      }
      
      .toolbar-btn-with-label {
        gap: 6px;
        padding: 8px 14px;
        min-width: auto;
      }
      
      .toolbar-btn-with-label .tool-label {
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
      }
      .new-slide-button-icon i {
        font-size: 16px;
      }
      .new-slide-button-label {
        font-size: 14px;
        font-weight: 600;
        line-height: 1;
        color: inherit;
      }
      .font-picker-button {
        position: relative;
        min-width: 140px;
        padding: 8px 16px;
        justify-content: center;
      }
      .font-picker-label {
        font-size: 15px;
        font-weight: 600;
        line-height: 1.2;
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .color-controls {
        display: flex;
        gap: 8px;
      }
      .color-tool-button {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 40px;
        padding: 8px 12px;
      }
      .color-tool-button .color-bar {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        width: 26px;
        height: 4px;
        border-radius: 999px;
        background: currentColor;
        border: 1px solid rgba(255, 255, 255, 0.3);
        pointer-events: none;
      }
      .font-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 220px;
        gap: 4px;
      }
      .font-dropdown.show {
        display: flex;
      }
      .font-option {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        text-align: left;
        transition: all 0.2s ease;
        font-size: 15px;
      }
      .font-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .font-option.active {
        background: #1c7c54;
        border-color: #2ed573;
        color: #fff;
      }
      .shape-picker-button,
      .chart-picker-button,
      .icon-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
        gap: 8px;
      }
      .image-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
        gap: 8px;
      }
      .video-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
        gap: 8px;
      }
      .table-picker-button {
        position: relative;
        min-width: 48px;
        padding: 8px 12px;
        gap: 8px;
      }
      .logo-picker-button {
        gap: 8px;
      }
      #dictateButton {
        gap: 8px;
      }
      #backgroundColorButton {
        gap: 8px;
      }
      .shape-dropdown,
      .chart-dropdown,
      .logo-dropdown,
      .icon-dropdown,
      .layout-dropdown {
        position: fixed;
        display: none;
        flex-direction: column;
        background: linear-gradient(135deg, rgba(13, 79, 65, 0.98) 0%, rgba(10, 95, 112, 0.98) 50%, rgba(10, 75, 122, 0.98) 100%);
        backdrop-filter: blur(14px);
        border: 1px solid rgba(104, 196, 255, 0.25);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        padding: 8px;
        max-height: 360px;
        overflow-y: auto;
        z-index: 4000;
        min-width: 240px;
        gap: 6px;
      }
      .shape-dropdown.show,
      .chart-dropdown.show,
      .logo-dropdown.show,
      .icon-dropdown.show,
      .layout-dropdown.show {
        display: flex;
      }
      .icon-dropdown {
        min-width: 400px;
        max-width: 500px;
        max-height: 500px;
      }
      .icon-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 8px;
        padding: 4px;
      }
      .icon-option {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 12px;
        background: rgba(10, 60, 70, 0.5);
        border: 1px solid rgba(104, 196, 255, 0.2);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-height: 70px;
      }
      .icon-option:hover {
        background: rgba(21, 86, 115, 0.7);
        border-color: rgba(104, 196, 255, 0.4);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(56, 189, 248, 0.25);
      }
      .icon-option svg {
        width: 32px;
        height: 32px;
        color: #e7fbff;
      }
      .icon-option-label {
        font-size: 10px;
        color: rgba(231, 251, 255, 0.85);
        margin-top: 4px;
        text-align: center;
        word-break: break-word;
        max-width: 100%;
      }
      .icon-search {
        padding: 8px;
        margin-bottom: 8px;
      }
      .icon-search input {
        width: 100%;
        padding: 8px 12px;
        background: rgba(10, 60, 70, 0.5);
        border: 1px solid rgba(104, 196, 255, 0.2);
        border-radius: 6px;
        color: #e7fbff;
        font-size: 13px;
      }
      .icon-search input::placeholder {
        color: rgba(231, 251, 255, 0.5);
      }
      .icon-search input:focus {
        outline: none;
        border-color: rgba(104, 196, 255, 0.4);
        background: rgba(21, 86, 115, 0.6);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.15);
      }
      .icon-folder-menu {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 8px;
      }
      .icon-folder-option {
        width: 100%;
        border: 0;
        padding: 16px;
        background: rgba(10, 60, 70, 0.5);
        border: 1px solid rgba(104, 196, 255, 0.2);
        border-radius: 8px;
        color: #e7fbff;
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 14px;
        font-weight: 500;
        text-align: left;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .icon-folder-option:hover {
        background: rgba(21, 86, 115, 0.7);
        border-color: rgba(104, 196, 255, 0.4);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(56, 189, 248, 0.25);
      }
      .icon-folder-option i {
        font-size: 20px;
        width: 24px;
        text-align: center;
      }
      .icon-view {
        display: flex;
        flex-direction: column;
      }
      .icon-view-header {
        padding: 8px;
        border-bottom: 1px solid rgba(104, 196, 255, 0.15);
        margin-bottom: 8px;
      }
      .icon-back-button {
        width: 100%;
        border: 0;
        padding: 8px 12px;
        background: rgba(10, 60, 70, 0.5);
        border: 1px solid rgba(104, 196, 255, 0.2);
        border-radius: 6px;
        color: #e7fbff;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .icon-back-button:hover {
        background: rgba(21, 86, 115, 0.7);
        border-color: rgba(104, 196, 255, 0.4);
        box-shadow: 0 2px 8px rgba(56, 189, 248, 0.2);
      }
      .icon-back-button i {
        font-size: 14px;
      }
      .logo-position-option {
        width: 100%;
        border: 0;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.08);
        color: #e0f2ff;
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 13px;
        text-align: left;
        cursor: pointer;
        border-radius: 8px;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .logo-position-option:hover {
        background: rgba(56, 189, 248, 0.25);
        transform: translateX(2px);
      }
      .logo-position-option i {
        width: 20px;
        text-align: center;
      }
      .table-insert-panel {
        position: fixed;
        display: flex;
        flex-direction: column;
        background: rgba(5, 60, 35, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
        padding: 12px;
        gap: 10px;
        z-index: 4100;
        width: 220px;
        color: #e8f5e9;
        transition: opacity 0.2s ease, transform 0.2s ease;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px) scale(0.96);
        pointer-events: none;
      }
      .table-insert-panel.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .table-insert-panel h4 {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 0.3px;
        color: #a7f3d0;
        cursor: grab;
        user-select: none;
      }
      .table-insert-panel.dragging h4 {
        cursor: grabbing;
      }
      .table-insert-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      .table-insert-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .table-insert-field label {
        font-size: 13px;
        font-weight: 600;
        color: rgba(232, 245, 233, 0.75);
      }
      .table-insert-field input {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        padding: 6px 8px;
        color: #e8f5e9;
        font-size: 14px;
        font-weight: 600;
      }
      .table-insert-field input:focus {
        outline: none;
        border-color: rgba(46, 213, 115, 0.6);
        box-shadow: 0 0 0 2px rgba(46, 213, 115, 0.25);
      }
      .table-insert-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .table-insert-actions button {
        background: rgba(46, 213, 115, 0.25);
        border: 1px solid rgba(46, 213, 115, 0.5);
        color: #bbf7d0;
        font-weight: 600;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }
      .table-insert-actions button:hover {
        background: rgba(46, 213, 115, 0.35);
        transform: translateY(-1px);
      }
      .table-element {
        position: absolute;
        background: #ffffff;
        border: 1px solid rgba(148, 232, 203, 0.55);
        border-radius: 8px;
        overflow: visible;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
        cursor: move;
        color: #0f172a;
      }
      .table-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.3);
      }
      .table-drag-handle {
        position: absolute;
        left: 50%;
        bottom: -28px;
        transform: translateX(-50%);
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        background: rgba(4, 44, 28, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.32);
        box-shadow: 0 14px 28px rgba(15, 23, 42, 0.35);
        color: #c4e3ff;
        cursor: grab;
        user-select: none;
        pointer-events: auto;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
        opacity: 0;
        visibility: hidden;
        transform-origin: center;
        transform: translateX(-50%) scale(0.88);
      }
      .table-drag-handle i {
        font-size: 14px;
        pointer-events: none;
      }
      .table-drag-handle:hover {
        transform: translateX(-50%) translateY(-1px);
        background: rgba(4, 44, 28, 0.98);
        border-color: rgba(148, 232, 203, 0.42);
        box-shadow: 0 18px 36px rgba(15, 23, 42, 0.45);
      }
      .table-drag-handle:active {
        cursor: grabbing;
        background: rgba(26, 115, 232, 0.4);
        border-color: rgba(59, 130, 246, 0.55);
        transform: translateX(-50%) scale(0.97);
      }
      .table-element.selected .table-drag-handle {
        border-color: rgba(59, 130, 246, 0.45);
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) scale(1);
      }
      .table-element table {
        width: 100%;
        height: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }
      .table-element td,
      .table-element th {
        border: 1px solid rgba(0, 0, 0, 0.1);
        padding: 8px;
        min-width: 40px;
        min-height: 28px;
        background: #ffffff;
        color: #0f172a;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      .table-element td[contenteditable="true"]:focus,
      .table-element th[contenteditable="true"]:focus {
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
      }
      .table-element .table-cell-selected {
        position: relative;
        background: rgba(59, 130, 246, 0.15) !important;
      }
      .table-element .table-cell-selected::after {
        content: "";
        position: absolute;
        inset: -1px;
        border-radius: 4px;
        border: 2px solid rgba(59, 130, 246, 0.6);
        background: transparent;
        pointer-events: none;
        box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2);
        z-index: 1;
      }
      .table-element td:focus,
      .table-element th:focus {
        outline: none;
        background: rgba(255, 255, 255, 0.95);
      }
      .table-element td,
      .table-element th {
        position: relative;
      }
      .table-element .table-resize-handle {
        position: absolute;
        background: transparent;
        border-radius: 4px;
        z-index: 6;
        opacity: 0;
        transition: opacity 0.18s ease, transform 0.18s ease;
      }
      .table-element .table-resize-handle::after {
        content: '';
        position: absolute;
        inset: 0;
        background: transparent;
        border-radius: inherit;
      }
      .table-element .table-resize-handle.table-resize-col {
        width: 6px;
        top: 0;
        bottom: 0;
        cursor: col-resize;
        transform: translateX(-3px);
      }
      .table-element .table-resize-handle.table-resize-row {
        height: 6px;
        left: 0;
        right: 0;
        cursor: row-resize;
        transform: translateY(-3px);
      }
      .table-element.selected .table-resize-handle,
      .table-element .table-resize-handle.active,
      .table-element:hover .table-resize-handle {
        opacity: 1;
      }
      .table-selection-border-handle {
        position: absolute;
        background: rgba(59, 130, 246, 0.8);
        border-radius: 3px;
        z-index: 10;
        cursor: col-resize;
        pointer-events: auto;
        transition: background 0.2s ease, transform 0.2s ease;
        box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      .table-selection-border-handle:hover {
        background: rgba(59, 130, 246, 1);
        transform: scale(1.1);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5), 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      .table-selection-border-handle.table-selection-border-vertical {
        cursor: col-resize;
        transform: translateX(-3px);
      }
      .table-selection-border-handle.table-selection-border-horizontal {
        cursor: row-resize;
        transform: translateY(-3px);
      }
      .shape-option,
      .chart-option,
      .layout-option {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 8px 12px;
        color: #e8f5e9;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .layout-option {
        flex-direction: column;
        align-items: center;
        min-width: 200px;
      }
      .layout-preview {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 60px;
      }
      .layout-preview-box {
        border: 1px solid rgba(104, 196, 255, 0.4);
        border-radius: 4px;
      }
      .shape-option:hover,
      .chart-option:hover,
      .layout-option:hover {
        background: rgba(255, 255, 255, 0.18);
        transform: translateY(-1px);
      }
      .shape-option svg {
        width: 36px;
        height: 36px;
      }
      .shape-option-preview {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .shape-option-label,
      .chart-option-label {
        font-size: 15px;
        font-weight: 600;
      }
      .chart-option-preview {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chart-option-preview .chart-mini {
        width: 100%;
        height: 100%;
        border-radius: 10px;
        background: rgba(26, 115, 232, 0.18);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }
      .chart-option-preview .chart-mini.bar::before,
      .chart-option-preview .chart-mini.bar::after {
        content: '';
        position: absolute;
        bottom: 6px;
        width: 8px;
        background: rgba(37, 204, 247, 0.9);
        border-radius: 4px 4px 0 0;
      }
      .chart-option-preview .chart-mini.bar::before {
        left: 10px;
        height: 16px;
        background: rgba(56, 189, 248, 0.95);
      }
      .chart-option-preview .chart-mini.bar::after {
        right: 10px;
        height: 26px;
        background: rgba(14, 165, 233, 0.95);
      }
      .chart-option-preview .chart-mini.bar span {
        position: absolute;
        left: 18px;
        bottom: 6px;
        width: 8px;
        height: 20px;
        border-radius: 4px 4px 0 0;
        background: rgba(6, 182, 212, 0.95);
      }
      .chart-option-preview .chart-mini.line {
        position: relative;
        background: transparent;
      }
      .chart-option-preview .chart-mini.line::before {
        content: '';
        position: absolute;
        inset: 10px 8px 12px 8px;
        border: 2px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
      }
      .chart-option-preview .chart-mini.line span {
        position: absolute;
        left: 8px;
        right: 8px;
        top: 50%;
        height: 2px;
        background: linear-gradient(90deg, #38bdf8, #a855f7);
        transform: rotate(-12deg);
        border-radius: 999px;
      }
      .chart-option-preview .chart-mini.pie {
        border-radius: 50%;
        background: conic-gradient(#60a5fa 0deg 140deg, #34d399 140deg 260deg, #fbbf24 260deg 360deg);
        position: relative;
      }
      .chart-option-preview .chart-mini.pie.chart-mini--donut::after {
        content: '';
        position: absolute;
        inset: 22%;
        background: rgba(12, 25, 25, 0.06);
        border-radius: 50%;
        box-shadow: inset 0 2px 4px rgba(15, 23, 42, 0.18);
      }
      .chart-option-preview .chart-mini.pie.chart-mini--gradient {
        position: relative;
      }
      .chart-option-preview .chart-mini.pie.chart-mini--gradient::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: radial-gradient(circle at 50% 25%, rgba(255, 255, 255, 0.45) 0%, rgba(255, 255, 255, 0.15) 35%, rgba(0, 0, 0, 0.15) 100%);
        pointer-events: none;
      }
      .chart-element {
        background: transparent;
        border-radius: 12px;
        border: 2px solid transparent;
        box-shadow: none;
        cursor: move;
        flex-direction: column;
        padding: 16px;
        gap: 12px;
        color: #0f172a;
      }
      .chart-element:hover,
      .chart-element.selected,
      .chart-element.resizing {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .chart-element .chart-title {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.3px;
        color: #1e293b;
      }
      .chart-element .chart-visual {
        flex: 1;
        width: 100%;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 10px;
      }
      .chart-element .chart-bars {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 14px;
        width: 100%;
        height: 100%;
        padding: 12px 0 4px;
        box-sizing: border-box;
      }
      .chart-element .chart-bar {
        width: 32px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
        transition: transform 0.18s ease;
      }
      .chart-element .chart-bar:hover {
        transform: translateY(-4px);
      }
      .chart-element .chart-bars--rounded .chart-bar {
        box-shadow: 0 10px 22px rgba(59, 130, 246, 0.22);
      }
      .chart-element .chart-bars--gradient .chart-bar {
        box-shadow: 0 12px 24px rgba(14, 165, 233, 0.25);
      }
      .chart-element .chart-bar-wrapper {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        height: 100%;
      }
      .chart-element .chart-bar-value {
        position: absolute;
        bottom: 100%;
        transform: translateY(-6px);
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        pointer-events: none;
        white-space: nowrap;
      }
      .chart-element .chart-pie {
        width: 140px;
        height: 140px;
        border-radius: 50%;
        background: conic-gradient(#60a5fa 0deg 150deg, #34d399 150deg 270deg, #fbbf24 270deg 360deg);
        box-shadow: 0 10px 24px rgba(59, 130, 246, 0.35);
        position: relative;
        overflow: hidden;
      }
      .chart-element .chart-pie::after {
        content: '';
        display: none;
      }
      .chart-element .chart-pie.chart-pie--donut::after {
        display: block;
        position: absolute;
        inset: 18%;
        background: #fff;
        border-radius: 50%;
        box-shadow: inset 0 6px 18px rgba(15, 23, 42, 0.12);
      }
      .chart-element .chart-pie.chart-pie--gradient {
        box-shadow: 0 10px 24px rgba(59, 130, 246, 0.35);
      }
      .chart-element .chart-pie-wrapper {
        position: relative;
        width: 140px;
        height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chart-element .chart-pie-labels {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .chart-element .chart-pie-label {
        position: absolute;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        white-space: nowrap;
      }
      .chart-element .chart-line-wrapper {
        position: relative;
        width: 240px;
        height: 140px;
      }
      .chart-element .chart-line-svg {
        width: 240px;
        height: 140px;
      }
      .chart-element .chart-line-path {
        fill: none;
        stroke-width: 3;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .chart-element .chart-line-path.line-smooth {
        stroke-linejoin: round;
      }
      .chart-element .chart-line-path.line-dotted {
        stroke-dasharray: 6 6;
      }
      .chart-element .chart-line-point {
        stroke: #ffffff;
        stroke-width: 2;
      }
      .chart-element .chart-line-value {
        position: absolute;
        transform: translate(-50%, -120%);
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        pointer-events: none;
        white-space: nowrap;
      }
      .chart-element .chart-line-axis {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .chart-element .chart-line-axis-label {
        position: absolute;
        bottom: 0;
        transform: translate(-50%, 110%);
        font-size: 12px;
        font-weight: 600;
        color: #4b5563;
        white-space: nowrap;
      }
      .chart-element .chart-legend {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .chart-element .chart-legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: #334155;
        font-weight: 600;
      }
      .chart-element .chart-legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }
      .chart-data-editor {
        position: fixed;
        top: 120px;
        right: 36px;
        width: 300px;
        max-height: 80vh;
        background: #ffffff;
        border-radius: 14px;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.22);
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 16px;
        display: none;
        z-index: 4500;
        font-size: 13px;
        color: #0f172a;
        cursor: default;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .chart-data-editor::-webkit-scrollbar {
        width: 8px;
      }
      .chart-data-editor::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
        border-radius: 4px;
      }
      .chart-data-editor::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.2);
        border-radius: 4px;
      }
      .chart-data-editor::-webkit-scrollbar-thumb:hover {
        background: rgba(15, 23, 42, 0.3);
      }
      .chart-data-editor.visible {
        display: block;
      }
      .chart-data-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        cursor: move;
      }
      .chart-data-title {
        font-size: 15px;
        font-weight: 700;
        color: #1f2937;
        letter-spacing: 0.2px;
      }
      .chart-data-close {
        border: none;
        background: rgba(15, 23, 42, 0.06);
        color: #1f2937;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .chart-data-close:hover {
        background: rgba(26, 115, 232, 0.12);
        transform: translateY(-1px);
      }
      .chart-data-subtitle {
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.2px;
        text-transform: uppercase;
        margin-bottom: 12px;
      }
      .chart-data-title-input-wrapper {
        margin-bottom: 12px;
      }
      .chart-data-title-label {
        display: block;
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.35px;
        text-transform: uppercase;
        margin-bottom: 6px;
      }
      .chart-data-title-input {
        width: 100%;
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 8px;
        padding: 8px 10px;
        font-size: 13px;
        font-weight: 600;
        color: #0f172a;
        background: rgba(248, 250, 252, 0.9);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        box-sizing: border-box;
      }
      .chart-data-title-input::placeholder {
        color: rgba(15, 23, 42, 0.35);
      }
      .chart-data-title-input:focus {
        outline: none;
        border-color: rgba(26, 115, 232, 0.4);
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.25);
        background: #ffffff;
      }
      .chart-data-variant {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      .chart-data-variant-label {
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.35px;
        text-transform: uppercase;
      }
      .chart-data-variant-options {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .chart-data-variant-button {
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: rgba(240, 249, 255, 0.85);
        color: #1f2937;
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .chart-data-variant-button:hover {
        background: rgba(59, 130, 246, 0.12);
        border-color: rgba(59, 130, 246, 0.35);
        color: #1d4ed8;
      }
      .chart-data-variant-button.active {
        background: rgba(59, 130, 246, 0.16);
        border-color: rgba(59, 130, 246, 0.55);
        color: #1d4ed8;
        box-shadow: 0 4px 10px rgba(59, 130, 246, 0.15);
      }
      .chart-data-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 12px;
      }
      .chart-data-toggle-label {
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.55);
        letter-spacing: 0.35px;
      }
      .chart-data-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
      }
      .chart-data-toggle.hidden {
        display: none;
      }
      .chart-element .chart-bars {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 14px;
        width: 100%;
        height: 100%;
        padding: 12px 0 4px;
        box-sizing: border-box;
      }
      .chart-element .chart-bar {
        width: 32px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
        transition: transform 0.18s ease;
      }
      .chart-element .chart-bar:hover {
        transform: translateY(-4px);
      }
      .chart-element .chart-bars--rounded .chart-bar {
        box-shadow: 0 10px 22px rgba(59, 130, 246, 0.22);
      }
      .chart-element .chart-bars--gradient .chart-bar {
        box-shadow: 0 12px 24px rgba(14, 165, 233, 0.25);
      }
      .chart-element .chart-bar-wrapper {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        height: 100%;
      }
      .chart-element .chart-bar-value {
        position: absolute;
        bottom: 100%;
        transform: translateY(-6px);
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        pointer-events: none;
        white-space: nowrap;
      }
      .chart-element .chart-pie-wrapper {
        position: relative;
        width: 140px;
        height: 140px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .chart-element .chart-pie-labels {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .chart-element .chart-pie-label {
        position: absolute;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        font-weight: 700;
        color: #1f2937;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.16);
        white-space: nowrap;
      }
      .chart-data-table-wrapper {
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(248, 250, 252, 0.9);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65);
        margin-bottom: 14px;
        max-height: 400px;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .chart-data-table-wrapper::-webkit-scrollbar {
        width: 8px;
      }
      .chart-data-table-wrapper::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
        border-radius: 4px;
      }
      .chart-data-table-wrapper::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.2);
        border-radius: 4px;
      }
      .chart-data-table-wrapper::-webkit-scrollbar-thumb:hover {
        background: rgba(15, 23, 42, 0.3);
      }
      .chart-data-table {
        width: 100%;
        border-collapse: collapse;
      }
      .chart-data-table thead {
        background: rgba(15, 118, 110, 0.08);
      }
      .chart-data-table th {
        text-align: left;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.55);
        padding: 8px 10px;
      }
      .chart-data-table th:nth-child(3) {
        text-align: center;
      }
      .chart-data-table td {
        padding: 8px 10px;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
        background: rgba(255, 255, 255, 0.85);
      }
      .chart-data-table td:nth-child(3) {
        text-align: center;
      }
      .chart-data-input {
        width: 100%;
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 13px;
        font-weight: 600;
        color: #0f172a;
        background: rgba(248, 250, 252, 0.9);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .chart-data-input::placeholder {
        color: rgba(15, 23, 42, 0.35);
      }
      .chart-data-input:focus {
        outline: none;
        border-color: rgba(26, 115, 232, 0.4);
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.25);
        background: #ffffff;
      }
      .chart-data-color-input {
        width: 42px;
        height: 32px;
        border: 1px solid rgba(15, 23, 42, 0.18);
        border-radius: 8px;
        padding: 0;
        background: #ffffff;
        cursor: pointer;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }
      .chart-data-color-input::-webkit-color-swatch {
        border: none;
        border-radius: 6px;
      }
      .chart-data-color-input::-webkit-color-swatch-wrapper {
        padding: 4px;
        border-radius: 6px;
      }
      .chart-data-color-input:focus {
        outline: none;
        border-color: rgba(26, 115, 232, 0.4);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      .chart-data-table td:nth-child(3) .chart-data-color-input {
        margin: 0 auto;
      }
      .chart-data-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .chart-data-actions button {
        flex: 1;
        background: rgba(46, 213, 115, 0.16);
        border: 1px solid rgba(46, 213, 115, 0.35);
        color: #065f46;
        font-weight: 700;
        font-size: 13px;
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
      }
      .chart-data-actions button:hover:not(:disabled) {
        background: rgba(46, 213, 115, 0.26);
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(16, 185, 129, 0.25);
      }
      .chart-data-actions button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .chart-data-line-editor {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .chart-data-line-editor.hidden {
        display: none;
      }
      .chart-line-series-section,
      .chart-line-points-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .chart-line-series-header,
      .chart-line-points-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .chart-line-series-title,
      .chart-line-points-title {
        font-size: 13px;
        font-weight: 700;
        color: #0f172a;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .chart-line-series-header button,
      .chart-line-points-actions button {
        background: rgba(59, 130, 246, 0.12);
        border: 1px solid rgba(59, 130, 246, 0.28);
        color: #1d4ed8;
        font-weight: 700;
        font-size: 12px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
      }
      .chart-line-series-header button:hover,
      .chart-line-points-actions button:hover {
        background: rgba(59, 130, 246, 0.18);
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(37, 99, 235, 0.18);
      }
      .chart-line-points-actions {
        display: flex;
        gap: 8px;
      }
      .chart-line-series-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 200px;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .chart-line-series-list::-webkit-scrollbar {
        width: 8px;
      }
      .chart-line-series-list::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
        border-radius: 4px;
      }
      .chart-line-series-list::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.2);
        border-radius: 4px;
      }
      .chart-line-series-list::-webkit-scrollbar-thumb:hover {
        background: rgba(15, 23, 42, 0.3);
      }
      .chart-line-series-item {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px;
        align-items: center;
      }
      .chart-line-series-remove {
        background: rgba(239, 68, 68, 0.12);
        border: 1px solid rgba(239, 68, 68, 0.28);
        color: #b91c1c;
        font-weight: 700;
        font-size: 12px;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
      }
      .chart-line-series-remove:hover {
        background: rgba(239, 68, 68, 0.18);
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(220, 38, 38, 0.18);
      }
      .chart-line-values-table-wrapper {
        overflow-x: auto;
        max-height: 300px;
        overflow-y: auto;
      }
      .chart-line-values-table-wrapper::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .chart-line-values-table-wrapper::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.05);
        border-radius: 4px;
      }
      .chart-line-values-table-wrapper::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.2);
        border-radius: 4px;
      }
      .chart-line-values-table-wrapper::-webkit-scrollbar-thumb:hover {
        background: rgba(15, 23, 42, 0.3);
      }
      .chart-line-values-table th,
      .chart-line-values-table td {
        white-space: nowrap;
      }
      .chart-line-point-label {
        width: 140px;
      }
      .canvas-marquee {
        position: absolute;
        border: 1px dashed rgba(37, 99, 235, 0.65);
        background: rgba(59, 130, 246, 0.16);
        pointer-events: none;
        z-index: 2000;
      }
      .group-selection-frame {
        position: absolute;
        border: 1px solid rgba(37, 99, 235, 0.8);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.65);
        pointer-events: auto;
        background: rgba(59, 130, 246, 0.05);
        z-index: 1999;
      }
      .group-selection-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        border-radius: 4px;
        border: 2px solid #fff;
        background: rgba(37, 99, 235, 0.9);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.65);
        pointer-events: auto;
      }
      .group-selection-handle[data-handle="top-left"] {
        top: -7px;
        left: -7px;
        cursor: nwse-resize;
      }
      .group-selection-handle[data-handle="top-right"] {
        top: -7px;
        right: -7px;
        cursor: nesw-resize;
      }
      .group-selection-handle[data-handle="bottom-left"] {
        bottom: -7px;
        left: -7px;
        cursor: nesw-resize;
      }
      .group-selection-handle[data-handle="bottom-right"] {
        bottom: -7px;
        right: -7px;
        cursor: nwse-resize;
      }
      .group-selection-handle[data-handle="top"] {
        top: -7px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }
      .group-selection-handle[data-handle="bottom"] {
        bottom: -7px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }
      .group-selection-handle[data-handle="left"] {
        left: -7px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
      .group-selection-handle[data-handle="right"] {
        right: -7px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
      .group-selected {
        outline: 2px solid rgba(37, 99, 235, 0.35);
      }
      .chart-data-empty {
        text-align: center;
        font-size: 12px;
        font-weight: 600;
        color: rgba(15, 23, 42, 0.45);
        padding: 12px 0;
      }
      .shape-element,
      .chart-element,
      .icon-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        color: #e8f5e9;
        user-select: none;
        transform-origin: center center;
        cursor: move;
        border: none;
        outline: none;
      }
      .icon-element.dragging {
        border: none;
        outline: none;
      }
      .shape-element svg,
      .chart-element svg,
      .icon-element svg {
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }
      .image-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        cursor: move;
        transform-origin: center center;
        border: 2px solid transparent;
        border-radius: 8px;
        transition: border-color 0.15s ease;
      }
      .image-element img {
        width: 100%;
        height: 100%;
        object-fit: fill;
        border-radius: inherit;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.3);
        pointer-events: none;
      }
      /* Remove shadows and borders from logo images for seamless background blending */
      .image-element[data-is-logo="true"] img {
        box-shadow: none;
      }
      .image-element[data-is-logo="true"] {
        border: none;
        box-shadow: none;
      }
      .image-element[data-is-logo="true"]:hover,
      .image-element[data-is-logo="true"].resizing,
      .image-element[data-is-logo="true"].selected {
        border: 2px solid rgba(26, 115, 232, 0.85);
      }
      .image-element:hover,
      .image-element.resizing,
      .image-element.selected {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .image-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .image-element[data-is-logo="true"].selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        border: 2px solid rgba(26, 115, 232, 0.85);
      }
      .video-element {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        cursor: move;
        transform-origin: center center;
        border: 2px solid transparent;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.45);
        transition: border-color 0.15s ease;
      }
      .video-element video {
        width: 100%;
        height: 100%;
        border-radius: inherit;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.3);
        background: #000;
        position: relative;
        z-index: 1;
      }
      .video-element.selected video,
      .video-element.resizing video {
        pointer-events: none;
      }
      .video-element:hover,
      .video-element.resizing,
      .video-element.selected {
        border-color: rgba(26, 115, 232, 0.85);
      }
      .video-element.selected {
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .text-box,
      .title-box,
      .additional-text-box {
        transform-origin: center center;
      }
      .shape-element.selected,
      .chart-element.selected,
      .icon-element.selected {
        outline: 2px solid #1a73e8;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .shape-element .resize-edge,
      .chart-element .resize-edge,
      .image-element .resize-edge,
      .icon-element .resize-edge,
      .text-box .resize-edge,
      .title-box .resize-edge,
      .additional-text-box .resize-edge {
        position: absolute;
        border-radius: 50%;
        border: 2px solid rgba(14, 165, 233, 0.9);
        background: rgba(230, 249, 255, 0.98);
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
        opacity: 0;
        transform: translate(-50%, -50%);
        transition: opacity 0.15s ease;
      }
      .shape-element.selected .resize-edge,
      .chart-element.selected .resize-edge,
      .image-element.selected .resize-edge,
      .video-element.selected .resize-edge,
      .icon-element.selected .resize-edge,
      .text-box.selected .resize-edge,
      .title-box.selected .resize-edge,
      .additional-text-box.selected .resize-edge {
        opacity: 1;
      }
      .icon-element.resizing .resize-edge {
        opacity: 1;
      }
      .image-element:hover .resize-edge,
      .image-element.resizing .resize-edge {
        opacity: 1;
      }
      .video-element:hover .resize-edge,
      .video-element.resizing .resize-edge {
        opacity: 1;
      }
      .shape-element .resize-edge.side,
      .chart-element .resize-edge.side,
      .image-element .resize-edge.side,
      .icon-element .resize-edge.side,
      .video-element .resize-edge.side,
      .text-box .resize-edge.side,
      .title-box .resize-edge.side,
      .additional-text-box .resize-edge.side {
        width: 14px;
        height: 14px;
        background: rgba(219, 246, 255, 0.9);
      }
      .shape-element .resize-edge.corner,
      .chart-element .resize-edge.corner,
      .image-element .resize-edge.corner,
      .icon-element .resize-edge.corner,
      .video-element .resize-edge.corner,
      .text-box .resize-edge.corner,
      .title-box .resize-edge.corner,
      .additional-text-box .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-element .resize-edge.top,
      .chart-element .resize-edge.top,
      .image-element .resize-edge.top,
      .icon-element .resize-edge.top,
      .video-element .resize-edge.top,
      .text-box .resize-edge.top,
      .title-box .resize-edge.top,
      .additional-text-box .resize-edge.top {
        top: -12px;
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.bottom,
      .chart-element .resize-edge.bottom,
      .image-element .resize-edge.bottom,
      .icon-element .resize-edge.bottom,
      .video-element .resize-edge.bottom,
      .text-box .resize-edge.bottom,
      .title-box .resize-edge.bottom,
      .additional-text-box .resize-edge.bottom {
        top: calc(100% + 12px);
        left: 50%;
        cursor: ns-resize;
      }
      .shape-element .resize-edge.left,
      .chart-element .resize-edge.left,
      .image-element .resize-edge.left,
      .icon-element .resize-edge.left,
      .video-element .resize-edge.left,
      .text-box .resize-edge.left,
      .title-box .resize-edge.left,
      .additional-text-box .resize-edge.left {
        left: -12px;
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.right,
      .chart-element .resize-edge.right,
      .image-element .resize-edge.right,
      .icon-element .resize-edge.right,
      .video-element .resize-edge.right,
      .text-box .resize-edge.right,
      .title-box .resize-edge.right,
      .additional-text-box .resize-edge.right {
        left: calc(100% + 12px);
        top: 50%;
        cursor: ew-resize;
      }
      .shape-element .resize-edge.top-left,
      .chart-element .resize-edge.top-left,
      .image-element .resize-edge.top-left,
      .icon-element .resize-edge.top-left,
      .video-element .resize-edge.top-left,
      .text-box .resize-edge.top-left,
      .title-box .resize-edge.top-left,
      .additional-text-box .resize-edge.top-left {
        top: -16px;
        left: -16px;
        cursor: nwse-resize;
      }
      .shape-element .resize-edge.top-right,
      .chart-element .resize-edge.top-right,
      .image-element .resize-edge.top-right,
      .icon-element .resize-edge.top-right,
      .video-element .resize-edge.top-right,
      .text-box .resize-edge.top-right,
      .title-box .resize-edge.top-right,
      .additional-text-box .resize-edge.top-right {
        top: -16px;
        left: calc(100% + 16px);
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-left,
      .chart-element .resize-edge.bottom-left,
      .image-element .resize-edge.bottom-left,
      .icon-element .resize-edge.bottom-left,
      .video-element .resize-edge.bottom-left,
      .text-box .resize-edge.bottom-left,
      .title-box .resize-edge.bottom-left,
      .additional-text-box .resize-edge.bottom-left {
        top: calc(100% + 16px);
        left: -16px;
        cursor: nesw-resize;
      }
      .shape-element .resize-edge.bottom-right,
      .chart-element .resize-edge.bottom-right,
      .image-element .resize-edge.bottom-right,
      .icon-element .resize-edge.bottom-right,
      .video-element .resize-edge.bottom-right,
      .text-box .resize-edge.bottom-right,
      .title-box .resize-edge.bottom-right,
      .additional-text-box .resize-edge.bottom-right {
        top: calc(100% + 18px);
        left: calc(100% + 18px);
        cursor: nwse-resize;
        background: linear-gradient(135deg, rgba(59,130,246,0.95), rgba(129,230,217,0.95));
        border-color: rgba(56, 189, 248, 0.85);
      }
      .video-element .resize-edge.bottom-right {
        top: calc(100% + 14px);
        left: calc(100% + 14px);
      }
      .image-element .resize-edge {
        background: rgba(219, 246, 255, 0.95);
        border-color: rgba(59, 130, 246, 0.75);
      }
      .image-element .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .video-element .resize-edge {
        background: rgba(219, 246, 255, 0.95);
        border-color: rgba(59, 130, 246, 0.75);
        z-index: 2;
      }
      .video-element .resize-edge.corner {
        width: 16px;
        height: 16px;
      }
      .shape-color-picker {
        position: fixed;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(4, 44, 28, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 6px;
        gap: 8px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        transform: translateY(8px) scale(0.96);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 4100;
      }
      .shape-color-picker.visible {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .shape-rotation-handle {
        position: fixed;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: rgba(4, 44, 28, 0.92);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transform: translateY(8px) scale(0.95);
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-rotation-handle.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0) scale(1);
      }
      .shape-rotation-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 2px solid rgba(59, 130, 246, 0.4);
        background: rgba(14, 116, 144, 0.2);
        color: #bae6fd;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }
      .shape-rotation-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.25);
      }
      .shape-rotation-button:active {
        cursor: grabbing;
        background: rgba(59, 130, 246, 0.35);
      }
      .shape-rotation-button i {
        pointer-events: none;
        font-size: 14px;
      }
      .shape-rotation-angle {
        font-size: 13px;
        font-weight: 600;
        color: #c4e3ff;
        letter-spacing: 0.4px;
        pointer-events: none;
      }
      .shape-size-badge {
        position: fixed;
        padding: 6px 12px;
        background: rgba(4, 44, 28, 0.95);
        border: 1px solid rgba(148, 232, 203, 0.25);
        border-radius: 999px;
        color: #d1fae5;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.4px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.28);
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 4100;
      }
      .shape-size-badge.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .image-crop-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.75);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 14000;
        backdrop-filter: blur(6px);
      }
      .image-crop-overlay.visible {
        display: flex;
      }
      .image-crop-dialog {
        width: min(90vw, 720px);
        background: rgba(0, 40, 20, 0.92);
        border: 1px solid rgba(46, 213, 115, 0.45);
        border-radius: 18px;
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.6);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        color: #ecfdf5;
      }
      .image-crop-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        font-weight: 700;
        background: rgba(4, 44, 28, 0.65);
        letter-spacing: 0.3px;
      }
      .image-crop-content {
        position: relative;
        padding: 20px;
        background: rgba(2, 32, 20, 0.65);
      }
      .image-crop-content img {
        max-width: 100%;
        max-height: 60vh;
        display: block;
        margin: 0 auto;
      }
      .image-crop-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        padding: 16px 20px;
        background: rgba(4, 44, 28, 0.65);
      }
      .image-crop-actions button {
        border: none;
        border-radius: 999px;
        padding: 10px 20px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, background 0.15s ease;
      }
      #imageCropCancel {
        background: rgba(255, 255, 255, 0.08);
        color: #ecfdf5;
        border: 1px solid rgba(255, 255, 255, 0.18);
      }
      #imageCropCancel:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-1px);
      }
      #imageCropApply {
        background: rgba(46, 213, 115, 0.2);
        color: #bbf7d0;
        border: 1px solid rgba(46, 213, 115, 0.45);
      }
      #imageCropApply:hover {
        background: rgba(46, 213, 115, 0.35);
        transform: translateY(-1px);
      }
      .image-crop-close {
        background: transparent;
        border: none;
        color: #ecfdf5;
        font-size: 20px;
        cursor: pointer;
        transition: transform 0.15s ease, color 0.15s ease;
      }
      .image-crop-close:hover {
        transform: scale(1.1);
        color: #22c55e;
      }
      @keyframes imageInsertFade {
        from {
          opacity: 0;
          transform: scale(0.94);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      .image-element.image-insert-animation {
        animation: imageInsertFade 0.28s ease-out;
      }
      .shape-color-button {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(13, 52, 78, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #e0f2ff;
        font-size: 16px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
      }
      .shape-color-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 20px rgba(5, 20, 36, 0.35);
        background: rgba(56, 189, 248, 0.2);
      }
      .shape-color-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      .tool-select { 
        background: rgba(13, 52, 78, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.32);
        color: #e0f2ff;
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
      }
      .tool-select::placeholder {
        color: rgba(191, 219, 254, 0.6);
      }
      .tool-select:hover {
        background: rgba(56, 189, 248, 0.2);
        border-color: rgba(56, 189, 248, 0.45);
        transform: translateY(-1px);
      }
      .tool-color { 
        width: 40px; 
        height: 36px; 
        background: rgba(13, 52, 78, 0.72);
        border: 1px solid rgba(96, 165, 250, 0.32);
        border-radius: 10px; 
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .tool-color:hover {
        background: rgba(56, 189, 248, 0.2);
        border-color: rgba(56, 189, 248, 0.45);
        transform: translateY(-2px);
      }
      .color-picker-button {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(50%);
        white-space: nowrap;
        border: 0;
      }
      .canvas-wrap { 
        display:grid; 
        place-items:center; 
        padding:24px; 
        overflow:auto; 
        position:relative;
        min-width: 0;
        transition: all 0.2s ease-out;
      }
      .canvas { 
        width:min(100%, 960px); 
        max-width: 100%;
        aspect-ratio:16/9; 
        background:#ffffff; 
        border-radius:10px; 
        box-shadow: 0 0 25px rgba(0, 0, 0, 0.25); 
        padding:24px; 
        position: relative; 
        background-size: cover; 
        background-position: center; 
        background-repeat: no-repeat; 
        transition: background 0.6s ease-in-out, width 0.2s ease-out, max-width 0.2s ease-out; 
        transform-origin: center center;
        box-sizing: border-box;
      }
      .comments-panel {
        width:min(100%, 960px);
        max-width: 100%;
        margin: 12px auto 24px;
        background: linear-gradient(145deg, rgba(9, 49, 63, 0.9) 0%, rgba(8, 72, 59, 0.92) 100%);
        border: 1px solid rgba(56, 189, 248, 0.32);
        border-radius: 16px;
        box-shadow: 0 26px 44px rgba(5, 24, 36, 0.5);
        padding: 20px 24px;
        color: #e0f2ff;
        display: flex;
        flex-direction: column;
        gap: 16px;
        box-sizing: border-box;
        transition: width 0.2s ease-out, max-width 0.2s ease-out;
      }
      .comments-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .comments-title { font-size: 18px; font-weight: 700; margin: 0; }
      .comments-count { font-size: 14px; font-weight: 600; color: rgba(191, 219, 254, 0.75); }
      .comments-list { display: flex; flex-direction: column; gap: 14px; max-height: 240px; overflow-y: auto; padding-right: 4px; }
      .comments-list::-webkit-scrollbar { width: 6px; }
      .comments-list::-webkit-scrollbar-thumb { background: rgba(56, 189, 248, 0.35); border-radius: 999px; }
      .comment-item {
        background: rgba(13, 52, 78, 0.85);
        border: 1px solid rgba(96, 165, 250, 0.3);
        border-radius: 14px;
        padding: 12px 14px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: inset 0 0 0 1px rgba(99, 102, 241, 0.15);
      }
      .comment-text { font-size: 14px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
      .comment-meta { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: rgba(191, 219, 254, 0.6); }
      .comment-delete { background: transparent; border: none; color: rgba(248, 113, 113, 0.85); font-size: 12px; font-weight: 600; cursor: pointer; transition: color 0.2s ease, transform 0.2s ease; }
      .comment-delete:hover { color: rgba(252, 165, 165, 0.95); transform: translateY(-1px); }
      .comment-empty {
        font-size: 14px;
        color: rgba(191, 219, 254, 0.6);
        text-align: center;
        padding: 20px 12px;
        border: 1px dashed rgba(96, 165, 250, 0.35);
        border-radius: 14px;
      }
      .comment-form { display: flex; flex-direction: column; gap: 10px; }
      .comment-input {
        width: 100%;
        min-height: 72px;
        resize: vertical;
        border-radius: 12px;
        border: 1px solid rgba(96, 165, 250, 0.32);
        background: rgba(8, 32, 51, 0.78);
        color: #e0f2ff;
        padding: 12px 14px;
        font-size: 14px;
        font-family: inherit;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .comment-input::placeholder { color: rgba(191, 219, 254, 0.45); }
      .comment-input:focus { outline: none; border-color: rgba(56, 189, 248, 0.6); box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18); }
      .comment-form-actions { display: flex; align-items: center; justify-content: flex-end; gap: 12px; }
      .comment-submit {
        border: none;
        border-radius: 999px;
        padding: 10px 22px;
        font-weight: 700;
        letter-spacing: 0.3px;
        cursor: pointer;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.95) 0%, rgba(45, 212, 191, 0.95) 100%);
        color: #04111f;
        box-shadow: 0 12px 26px rgba(14, 165, 233, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .comment-submit:hover { transform: translateY(-1px); box-shadow: 0 16px 30px rgba(14, 165, 233, 0.4); }
      .comment-submit:disabled { opacity: 0.6; cursor: not-allowed; transform: none; box-shadow: none; }
      .zoom-controls {
        display:flex;
        align-items:center;
        gap:8px;
        margin-left:12px;
        padding:6px 12px;
        border:1px solid rgba(56, 189, 248, 0.35);
        border-radius:12px;
        background: linear-gradient(135deg, rgba(9, 46, 63, 0.85) 0%, rgba(8, 68, 58, 0.87) 100%);
        box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.2);
      }
      body.light-mode .zoom-controls {
        background: linear-gradient(135deg, rgba(247, 249, 254, 0.96) 0%, rgba(232, 236, 244, 0.92) 100%);
        border: 1px solid rgba(203, 213, 225, 0.82);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.45), 0 12px 28px rgba(148, 163, 184, 0.18);
      }
      body.light-mode .zoom-controls .tool.zoom-button,
      body.light-mode .zoom-controls .tool.zoom-reset-button {
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(203, 213, 225, 0.85);
        color: #1f2937;
        box-shadow: 0 6px 12px rgba(148, 163, 184, 0.18);
      }
      body.light-mode .zoom-controls .tool.zoom-button:hover,
      body.light-mode .zoom-controls .tool.zoom-reset-button:hover {
        background: rgba(226, 232, 240, 0.96);
      }
      body.dark-theme .zoom-controls {
        background: linear-gradient(135deg, rgba(74, 80, 90, 0.95) 0%, rgba(42, 47, 55, 0.9) 100%);
        border: 1px solid rgba(148, 163, 184, 0.3);
        box-shadow: inset 0 0 0 1px rgba(82, 88, 99, 0.25);
      }
      .zoom-display { min-width:60px; text-align:center; font-weight:600; color:#e0f2ff; transition: color 0.2s ease; }
      body.light-mode .zoom-display { color: #1f2937; }
      .tool.zoom-button { min-width:36px; padding:6px 10px; font-size:16px; }
      .tool.zoom-reset-button { padding:6px 12px; font-size:14px; }
      .alignment-guide {
        position: absolute;
        background: rgba(59, 130, 246, 0.85);
        pointer-events: none;
        display: none;
        z-index: 5000;
      }
      .alignment-guide.horizontal {
        height: 2px;
        width: 0;
      }
      .alignment-guide.vertical {
        width: 2px;
        height: 0;
      }
      
      /* Panel Default Size Indicator */
      .panel-default-size-indicator {
        position: fixed;
        background: rgba(234, 179, 8, 0.9);
        pointer-events: none;
        display: none;
        z-index: 5001;
        transform: translateX(-50%);
        box-shadow: 0 0 4px rgba(234, 179, 8, 0.5);
      }
      @keyframes transitionFade {
        from { opacity: 0; transform: scale(0.985); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes transitionSlideLeft {
        from { opacity: 0; transform: translateX(60px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes transitionSlideRight {
        from { opacity: 0; transform: translateX(-60px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes transitionSlideUp {
        from { opacity: 0; transform: translateY(60px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes transitionSlideDown {
        from { opacity: 0; transform: translateY(-60px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes transitionZoomIn {
        from { opacity: 0; transform: scale(0.88); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes transitionZoomOut {
        from { opacity: 0; transform: scale(1.12); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes transitionFlip {
        from { opacity: 0; transform: rotateX(50deg); transform-origin: center; }
        to { opacity: 1; transform: rotateX(0deg); transform-origin: center; }
      }
      @keyframes transitionRotate {
        from { opacity: 0; transform: rotate(-14deg) scale(0.94); }
        to { opacity: 1; transform: rotate(0deg) scale(1); }
      }
      .presentation-stage .presentation-slide.transition-effect-fade { animation: transitionFade var(--transition-duration, 0.7s) ease both; }
      .presentation-stage .presentation-slide.transition-effect-slide-left { animation: transitionSlideLeft var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-slide-right { animation: transitionSlideRight var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-slide-up { animation: transitionSlideUp var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-slide-down { animation: transitionSlideDown var(--transition-duration, 0.7s) ease-out both; }
      .presentation-stage .presentation-slide.transition-effect-zoom-in { animation: transitionZoomIn var(--transition-duration, 0.7s) ease both; }
      .presentation-stage .presentation-slide.transition-effect-zoom-out { animation: transitionZoomOut var(--transition-duration, 0.7s) ease both; }
      .presentation-stage .presentation-slide.transition-effect-flip { animation: transitionFlip var(--transition-duration, 0.7s) ease-in-out both; }
      .presentation-stage .presentation-slide.transition-effect-rotate { animation: transitionRotate var(--transition-duration, 0.7s) ease-in-out both; }
      
      .presentation-overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: #000;
        z-index: 9999;
        color: #f9fafb;
      }
      .presentation-overlay.visible {
        display: block;
      }
      .presentation-stage {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #111;
      }
      .presentation-stage .presentation-slide {
        width: 100%;
        height: 100%;
        position: absolute;
        inset: 0;
        background: #fff;
        overflow: hidden;
      }
      .presentation-stage .title-box,
      .presentation-stage .text-box,
      .presentation-stage .additional-text-box {
        border: none !important;
        box-shadow: none !important;
        outline: none !important;
        cursor: default !important;
        user-select: none;
      }
      .presentation-stage .title-box::before,
      .presentation-stage .text-box::before,
      .presentation-stage .additional-text-box::before {
        display: none !important;
        content: none !important;
      }
      .presentation-stage .shape-element,
      .presentation-stage .icon-element {
        outline: none !important;
        box-shadow: none !important;
        cursor: default !important;
      }
      .presentation-stage .resize-edge {
        display: none !important;
      }
      .presentation-overlay .presentation-meta {
        position: absolute;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 16px;
        font-size: 14px;
        letter-spacing: 0.4px;
        background: rgba(15, 23, 42, 0.5);
        padding: 10px 18px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay .presentation-meta span {
        display: flex;
        align-items: center;
        gap: 8px;
        text-transform: uppercase;
        font-weight: 600;
      }
      .presentation-overlay .presentation-counter {
        position: absolute;
        bottom: 32px;
        right: 40px;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.6px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .presentation-overlay.show-controls .presentation-meta,
      .presentation-overlay.show-controls .presentation-counter {
        opacity: 1;
        pointer-events: auto;
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-controls {
        display: inline-flex;
        align-items: center;
        gap: 12px;
      }
      .presentation-overlay .presentation-meta .presentation-language-group {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-toggle,
      .presentation-overlay .presentation-meta .presentation-translation-toggle {
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.5);
        border-radius: 999px;
        color: #f8fafc;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 14px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-toggle:hover,
      .presentation-overlay .presentation-meta .presentation-translation-toggle:hover {
        background: rgba(59, 130, 246, 0.45);
        border-color: rgba(96, 165, 250, 0.8);
        transform: translateY(-1px);
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-toggle.active,
      .presentation-overlay .presentation-meta .presentation-translation-toggle.active {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.95) 0%, rgba(14, 165, 233, 0.95) 100%);
        border-color: rgba(96, 165, 250, 0.9);
        box-shadow: 0 12px 28px rgba(59, 130, 246, 0.35);
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-toggle:disabled,
      .presentation-overlay .presentation-meta .presentation-translation-toggle:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        transform: none;
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-menu-button,
      .presentation-overlay .presentation-meta .presentation-translation-menu-button {
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.5);
        border-radius: 50%;
        color: #f8fafc;
        width: 38px;
        height: 38px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 0;
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-menu-button:hover,
      .presentation-overlay .presentation-meta .presentation-translation-menu-button:hover {
        background: rgba(59, 130, 246, 0.45);
        border-color: rgba(96, 165, 250, 0.8);
        transform: translateY(-1px);
      }
      .presentation-overlay .presentation-meta .presentation-subtitle-menu-button:disabled,
      .presentation-overlay .presentation-meta .presentation-translation-menu-button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        transform: none;
      }
      .dictation-language-menu {
        position: absolute;
        min-width: 260px;
        max-width: 320px;
        max-height: 340px;
        display: none;
        flex-direction: column;
        border-radius: 14px;
        border: 1px solid rgba(82, 209, 255, 0.45);
        background: rgba(20, 89, 120, 0.92);
        backdrop-filter: blur(18px);
        box-shadow: 0 24px 60px rgba(8, 61, 82, 0.48);
        color: #ecfeff;
        z-index: 12000;
        overflow: hidden;
      }
      .dictation-language-menu.show {
        display: flex;
      }
      .dictation-language-menu .dictation-menu-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 12px 18px;
        border-bottom: 1px solid rgba(148, 236, 255, 0.2);
      }
      .dictation-language-menu .dictation-menu-header span {
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }
      .dictation-language-menu .dictation-menu-close {
        border: 0;
        background: rgba(15, 118, 110, 0.28);
        color: inherit;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .dictation-language-menu .dictation-menu-close:hover,
      .dictation-language-menu .dictation-menu-close:focus {
        background: rgba(45, 212, 191, 0.32);
        transform: scale(1.05);
        outline: none;
      }
      .dictation-language-menu .dictation-menu-search {
        padding: 10px 18px 0;
      }
      .dictation-language-menu .dictation-language-search {
        width: 100%;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid rgba(125, 211, 252, 0.4);
        background: rgba(12, 74, 110, 0.45);
        color: inherit;
        font-size: 13px;
        outline: none;
        transition: border-color 0.2s ease, background 0.2s ease;
      }
      .dictation-language-menu .dictation-language-search::placeholder {
        color: rgba(224, 242, 254, 0.7);
      }
      .dictation-language-menu .dictation-language-search:focus {
        border-color: rgba(56, 189, 248, 0.85);
        background: rgba(8, 126, 164, 0.5);
      }
      .dictation-language-menu .dictation-language-list {
        padding: 10px 0;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }
      .dictation-language-menu .dictation-language-option {
        border: 0;
        background: transparent;
        color: inherit;
        padding: 10px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        text-align: left;
        font-size: 13px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .dictation-language-menu .dictation-language-option .option-label {
        font-weight: 500;
        flex: 1;
      }
      .dictation-language-menu .dictation-language-option .option-code {
        font-size: 11px;
        opacity: 0.75;
        letter-spacing: 0.05em;
      }
      .dictation-language-menu .dictation-language-option:hover,
      .dictation-language-menu .dictation-language-option:focus {
        background: rgba(59, 216, 221, 0.24);
        outline: none;
        transform: translateX(2px);
      }
      .dictation-language-menu .dictation-language-option.active {
        background: rgba(37, 211, 202, 0.32);
        font-weight: 600;
      }
      .dictation-language-menu .dictation-language-empty {
        padding: 24px 18px 18px;
        font-size: 13px;
        color: rgba(224, 242, 254, 0.7);
        display: none;
        text-align: center;
      }
      .dictation-language-menu .dictation-language-empty.show {
        display: block;
      }
      .presentation-subtitle-menu {
        position: absolute;
        min-width: 280px;
        max-width: 340px;
        max-height: 320px;
        overflow: hidden;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.92);
        color: #f8fafc;
        box-shadow: 0 24px 60px rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.35);
        backdrop-filter: blur(18px);
        display: none;
        z-index: 20;
      }
      .presentation-subtitle-menu.show {
        display: flex;
        flex-direction: column;
      }
      .presentation-subtitle-menu .subtitle-menu-header {
        padding: 14px 18px 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .presentation-subtitle-menu .subtitle-menu-header h4 {
        margin: 0;
        font-size: 14px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #cbd5f5;
      }
      .presentation-subtitle-menu .subtitle-menu-header input[type="search"] {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: #f8fafc;
        font-size: 13px;
        outline: none;
        transition: border-color 0.2s ease, background 0.2s ease;
      }
      .presentation-subtitle-menu .subtitle-menu-header input[type="search"]::placeholder {
        color: rgba(148, 163, 184, 0.7);
      }
      .presentation-subtitle-menu .subtitle-menu-header input[type="search"]:focus {
        border-color: rgba(96, 165, 250, 0.85);
        background: rgba(30, 41, 59, 0.85);
      }
      .presentation-subtitle-menu .subtitle-language-list {
        overflow-y: auto;
        padding: 8px 0;
        display: flex;
        flex-direction: column;
      }
      .presentation-subtitle-menu .subtitle-language-option {
        width: 100%;
        border: 0;
        padding: 10px 18px;
        background: transparent;
        color: inherit;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        font-size: 13px;
        text-align: left;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }
      .presentation-subtitle-menu .subtitle-language-option .option-label {
        flex: 1;
        font-weight: 500;
      }
      .presentation-subtitle-menu .subtitle-language-option .option-code {
        font-size: 11px;
        opacity: 0.75;
        letter-spacing: 0.05em;
      }
      .presentation-subtitle-menu .subtitle-language-option:hover,
      .presentation-subtitle-menu .subtitle-language-option:focus {
        background: rgba(59, 130, 246, 0.2);
        outline: none;
        transform: translateX(2px);
      }
      .presentation-subtitle-menu .subtitle-language-option.active {
        background: rgba(59, 130, 246, 0.35);
        color: #e2e8f0;
        font-weight: 600;
      }
      .presentation-subtitle-menu .subtitle-language-empty {
        padding: 24px 18px;
        text-align: center;
        font-size: 13px;
        color: rgba(148, 163, 184, 0.8);
        display: none;
      }
      .presentation-subtitle-menu .subtitle-language-empty.show {
        display: block;
      }
      .presentation-translation-menu {
        position: absolute;
        min-width: 260px;
        max-width: 360px;
        max-height: 340px;
        display: none;
        flex-direction: column;
        border-radius: 16px;
        border: 1px solid rgba(96, 165, 250, 0.35);
        background: rgba(15, 23, 42, 0.9);
        backdrop-filter: blur(14px);
        box-shadow: 0 22px 48px rgba(15, 23, 42, 0.45);
        color: #e2e8f0;
        z-index: 16000;
        overflow: hidden;
      }
      .presentation-translation-menu.show {
        display: flex;
      }
      .presentation-translation-menu .translation-menu-header {
        padding: 16px 18px 12px 18px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .presentation-translation-menu .translation-menu-header h4 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.04em;
        color: #f8fafc;
        text-transform: uppercase;
      }
      .presentation-translation-menu .translation-menu-header input[type="search"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.6);
        color: #f8fafc;
        font-size: 13px;
        outline: none;
        transition: border-color 0.2s ease, background 0.2s ease;
      }
      .presentation-translation-menu .translation-menu-header input[type="search"]::placeholder {
        color: rgba(148, 163, 184, 0.7);
      }
      .presentation-translation-menu .translation-menu-header input[type="search"]:focus {
        border-color: rgba(96, 165, 250, 0.85);
        background: rgba(30, 41, 59, 0.85);
      }
      .presentation-translation-menu .translation-language-list {
        overflow-y: auto;
        padding: 8px 0;
        display: flex;
        flex-direction: column;
      }
      .presentation-translation-menu .translation-language-option {
        width: 100%;
        border: 0;
        padding: 10px 18px;
        background: transparent;
        color: inherit;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        font-size: 13px;
        text-align: left;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }
      .presentation-translation-menu .translation-language-option .option-label {
        flex: 1;
        font-weight: 500;
      }
      .presentation-translation-menu .translation-language-option .option-code {
        font-size: 11px;
        opacity: 0.75;
        letter-spacing: 0.05em;
      }
      .presentation-translation-menu .translation-language-option:hover,
      .presentation-translation-menu .translation-language-option:focus {
        background: rgba(59, 130, 246, 0.2);
        outline: none;
        transform: translateX(2px);
      }
      .presentation-translation-menu .translation-language-option.active {
        background: rgba(59, 130, 246, 0.35);
        color: #e2e8f0;
        font-weight: 600;
      }
      .presentation-translation-menu .translation-language-empty {
        padding: 24px 18px;
        text-align: center;
        font-size: 13px;
        color: rgba(148, 163, 184, 0.8);
        display: none;
      }
      .presentation-translation-menu .translation-language-empty.show {
        display: block;
      }
      .presentation-subtitles {
        position: absolute;
        left: 50%;
        bottom: 120px;
        transform: translate(-50%, 0);
        max-width: 80vw;
        background: rgba(15, 23, 42, 0.75);
        padding: 14px 20px;
        border-radius: 12px;
        font-size: 20px;
        line-height: 1.4;
        letter-spacing: 0.03em;
        text-align: center;
        color: #f8fafc;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
        display: none;
        pointer-events: none;
      }
      .presentation-subtitles.show {
        display: block;
      }
      .presentation-translation {
        position: absolute;
        left: 50%;
        bottom: 40px;
        transform: translate(-50%, 0);
        max-width: 80vw;
        background: rgba(15, 23, 42, 0.75);
        padding: 14px 20px;
        border-radius: 12px;
        font-size: 20px;
        line-height: 1.4;
        letter-spacing: 0.03em;
        text-align: center;
        color: #f8fafc;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
        display: none;
        pointer-events: none;
      }
      .presentation-translation.show {
        display: block;
      }
      body.presenting {
        overflow: hidden;
      }
      body.presenting .layout {
        visibility: hidden;
      }
      body.presenting .presentation-overlay {
        visibility: visible;
      }

      /* Template Background Styles */
      .canvas.marketing-template {
        background-image: url('./CURSOR-Project/Background/B1.avif');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.marketing-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.business-template {
        background-image: url('./CURSOR-Project/Background/business-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.business-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.education-template {
        background-image: url('./CURSOR-Project/Background/education-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.education-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      .canvas.project-template {
        background-image: url('./CURSOR-Project/Background/project-bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background 0.6s ease-in-out;
      }
      
      .canvas.project-template::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        border-radius: 10px;
        z-index: 0;
      }
      
      /* Ensure content is above overlay */
      .canvas .title-box,
      .canvas .text-box {
        position: relative;
        z-index: 1;
      }
      
      /* Title box per Editor.json */
      .title-box {
        font-size: 28px;
        font-weight: bold;
        color: #000000;
        border: 1px dashed transparent;
        padding: 10px;
        min-height: 50px;
        min-width: 200px;
        outline: none;
        position: absolute;
        top: 24px;
        left: 24px;
        width: calc(100% - 48px);
        outline: none;
        white-space: nowrap;
        word-wrap: normal;
        overflow-wrap: normal;
      }
      .title-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .title-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      .title-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .title-box.resizing {
        user-select: none;
      }
      
      /* Resize edges for title box */
      .title-box .resize-edge {
        position: absolute;
        background: transparent;
        z-index: 10;
      }
      .title-box .resize-edge.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
      .title-box .resize-edge.left { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.right { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
      .title-box .resize-edge.corner { width: 15px; height: 15px; }
      .title-box .resize-edge.top-left { top: -5px; left: -5px; cursor: nw-resize; }
      .title-box .resize-edge.top-right { top: -5px; right: -5px; cursor: ne-resize; }
      .title-box .resize-edge.bottom-left { bottom: -5px; left: -5px; cursor: sw-resize; }
      .title-box .resize-edge.bottom-right { bottom: -5px; right: -5px; cursor: se-resize; }

      /* Text box per Editor.json */
      .text-box {
        font-size: 16px;
        border: 1px dashed transparent;
        padding: 10px;
        min-height: 250px;
        min-width: 200px;
        outline: none;
        overflow: visible;
        color: #000000;
        position: absolute;
        top: 100px;
        left: 24px;
        width: calc(100% - 48px);
        bottom: 24px;
        outline: none;
        white-space: nowrap;
        word-wrap: normal;
        overflow-wrap: normal;
      }
      /* When manually resized, enable word wrapping */
      .text-box[data-manually-resized="true"],
      .title-box[data-manually-resized="true"],
      .additional-text-box[data-manually-resized="true"] {
        white-space: normal;
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
      }
      /* Auto-resize mode - fit content */
      .text-box:not([data-manually-resized="true"]) {
        width: auto !important;
        height: auto !important;
        bottom: auto !important;
        min-width: 200px;
        min-height: 40px;
      }
      .title-box:not([data-manually-resized="true"]) {
        width: auto !important;
        height: auto !important;
        min-width: 200px;
        min-height: 40px;
      }
      .additional-text-box:not([data-manually-resized="true"]) {
        width: auto !important;
        height: auto !important;
        min-width: 200px;
        min-height: 40px;
      }
      /* Ensure text boxes use block display for proper horizontal text flow */
      .text-box,
      .title-box,
      .additional-text-box {
        display: block !important;
        flex-direction: row !important;
        flex-wrap: wrap !important;
        writing-mode: horizontal-tb !important;
        text-orientation: mixed !important;
        word-break: normal !important;
        overflow-wrap: normal !important;
        word-wrap: normal !important;
      }
      /* Override any inline styles that might set display to flex */
      .text-box[style*="display: flex"],
      .text-box[style*="display:flex"],
      .title-box[style*="display: flex"],
      .title-box[style*="display:flex"],
      .additional-text-box[style*="display: flex"],
      .additional-text-box[style*="display:flex"] {
        display: block !important;
      }
      /* CRITICAL: Ensure text boxes have adequate width to prevent vertical character wrapping */
      .text-box:not([data-manually-resized="true"]),
      .title-box:not([data-manually-resized="true"]),
      .additional-text-box:not([data-manually-resized="true"]) {
        min-width: 200px !important;
        width: auto !important;
      }
      /* Force minimum width even with inline styles */
      .text-box[style*="width"],
      .title-box[style*="width"],
      .additional-text-box[style*="width"] {
        min-width: 200px !important;
      }
      .text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .additional-text-box[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
      }
      .text-box:focus {
        border-color: #1a73e8;
        border-style: solid;
      }
      
      /* Selected state for text boxes and title box */
      .text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .additional-text-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      .title-box.selected {
        border-color: #1a73e8;
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }
      
      .text-box.dragging {
        opacity: 0.8;
        z-index: 1000;
      }
      .text-box.resizing {
        user-select: none;
      }
      

      /* Save notification */
      .save-notification {
        position: fixed;
        top: 70px;
        right: 20px;
        background: #10b981;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity .3s, transform .3s;
        z-index: 1000;
        pointer-events: none;
      }
      .save-notification.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="topbar">
        <button class="btn blue toolbar-btn" id="btnBack" data-action="back" title="Back (Cmd+Z / Ctrl+Z)">
          <i class="fas fa-arrow-left"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnForward" data-action="forward" title="Forward (Cmd+Shift+Z / Ctrl+Shift+Z)">
          <i class="fas fa-arrow-right"></i>
        </button>
        <button class="btn red toolbar-btn" id="btnDel" data-action="delete_slide" title="Delete Slide">
          <i class="fas fa-trash"></i>
        </button>
        <button class="btn light toolbar-btn" id="btnReset" data-action="reset_slides" title="Reset Slides">
          <i class="fas fa-rotate-right"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnSave" title="Save Presentation">
          <i class="fas fa-save"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnImportTemplate" title="Import Template (JSON or PPTX)">
          <i class="fas fa-file-import"></i>
        </button>
        <input type="file" id="jsonTemplateInput" accept=".json,.pptx" style="display: none;">
        <div class="save-as-wrapper">
          <button class="btn blue toolbar-btn save-as-toggle" id="btnSaveAs" title="Save As">
            <i class="fas fa-folder-open"></i>
            <span class="caret"><i class="fas fa-caret-down"></i></span>
          </button>
          <div class="save-as-menu" id="saveAsMenu" role="menu" aria-label="Export presentation" style="display: none;">
            <button type="button" class="save-as-option" data-format="pdf" role="menuitem">
              <span class="option-icon"><i class="fas fa-file-pdf"></i></span>
              <span>Export as PDF</span>
            </button>
            <button type="button" class="save-as-option" data-format="pptx" role="menuitem">
              <span class="option-icon"><i class="fas fa-file-powerpoint"></i></span>
              <span>Export as PPTX</span>
            </button>
          </div>
        </div>
        <!-- Save As Modal -->
        <div class="section-name-modal" id="sectionNameModal" role="dialog" aria-modal="true" aria-labelledby="sectionNameModalTitle">
          <div class="section-name-modal-content">
            <div class="section-name-modal-header">
              <h2 class="section-name-modal-title" id="sectionNameModalTitle">
                <i class="fas fa-folder-plus"></i>
                <span id="sectionNameModalTitleText">New Section</span>
              </h2>
              <button type="button" class="section-name-modal-close" id="sectionNameModalClose" aria-label="Close">&times;</button>
            </div>
            <div class="section-name-form-group">
              <label for="sectionNameInput" class="section-name-form-label">Section Name</label>
              <input 
                type="text" 
                id="sectionNameInput" 
                class="section-name-form-input" 
                placeholder="Enter section name..."
                autocomplete="off"
                maxlength="50"
              />
            </div>
            <div class="section-name-modal-actions">
              <button type="button" class="section-name-modal-btn section-name-modal-btn-cancel" id="sectionNameModalCancel">Cancel</button>
              <button type="button" class="section-name-modal-btn section-name-modal-btn-submit" id="sectionNameModalSubmit">Create</button>
            </div>
          </div>
        </div>
        <!-- Section Confirmation Modal -->
        <div class="section-name-modal" id="sectionConfirmModal" role="dialog" aria-modal="true" aria-labelledby="sectionConfirmModalTitle">
          <div class="section-name-modal-content">
            <div class="section-name-modal-header">
              <h2 class="section-name-modal-title" id="sectionConfirmModalTitle">
                <i class="fas fa-exclamation-triangle"></i>
                <span id="sectionConfirmModalTitleText">Confirm Action</span>
              </h2>
              <button type="button" class="section-name-modal-close" id="sectionConfirmModalClose" aria-label="Close">&times;</button>
            </div>
            <div class="section-name-form-group">
              <p id="sectionConfirmModalMessage" style="color: #e0f2ff; margin: 0; line-height: 1.6;"></p>
            </div>
            <div class="section-name-modal-actions">
              <button type="button" class="section-name-modal-btn section-name-modal-btn-cancel" id="sectionConfirmModalCancel">Cancel</button>
              <button type="button" class="section-name-modal-btn section-name-modal-btn-submit" id="sectionConfirmModalConfirm" style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.95) 100%); border-color: rgba(239, 68, 68, 0.5);">Confirm</button>
            </div>
          </div>
        </div>
        <!-- Delete Section Modal -->
        <div class="delete-section-modal" id="deleteSectionModal" role="dialog" aria-modal="true" aria-labelledby="deleteSectionModalTitle">
          <div class="delete-section-modal-content">
            <h2 class="section-name-modal-title" id="deleteSectionModalTitle" style="margin-bottom: 20px;">
              <i class="fas fa-exclamation-triangle" style="color: rgba(248, 113, 113, 0.9);"></i>
              <span>Delete Section</span>
            </h2>
            <p class="delete-section-modal-message" id="deleteSectionModalMessage"></p>
            <div class="delete-section-modal-actions">
              <button type="button" class="delete-section-modal-btn delete-section-modal-btn-cancel" id="deleteSectionModalCancel">Cancel</button>
              <button type="button" class="delete-section-modal-btn delete-section-modal-btn-confirm" id="deleteSectionModalConfirm">OK</button>
            </div>
          </div>
        </div>
        <div class="save-as-modal" id="saveAsModal" role="dialog" aria-modal="true" aria-labelledby="saveAsModalTitle">
          <div class="save-as-modal-content">
            <div class="save-as-modal-header">
              <h3 class="save-as-modal-title" id="saveAsModalTitle">Save As</h3>
              <button type="button" class="save-as-modal-close" id="saveAsModalClose" aria-label="Close">&times;</button>
            </div>
            <div class="save-as-form-group">
              <label for="saveAsFormat" class="save-as-form-label">File Format</label>
              <select id="saveAsFormat" class="save-as-form-select">
                <option value="pptx">PowerPoint (.pptx)</option>
                <option value="pdf">PDF (.pdf)</option>
                <option value="png">PNG Image (.png)</option>
                <option value="json">JSON Data (.json)</option>
                <option value="html">HTML Document (.html)</option>
              </select>
            </div>
            <div class="save-as-form-group">
              <label for="saveAsFileName" class="save-as-form-label">File Name</label>
              <input type="text" id="saveAsFileName" class="save-as-form-input" placeholder="Enter file name" autocomplete="off">
            </div>
            <div class="save-as-modal-actions">
              <button type="button" class="save-as-modal-btn save-as-modal-btn-cancel" id="saveAsModalCancel">Cancel</button>
              <button type="button" class="save-as-modal-btn save-as-modal-btn-save" id="saveAsModalSave">Save</button>
            </div>
          </div>
        </div>
        <div class="ai-designer-modal" id="aiDesignerModal" role="dialog" aria-modal="true" aria-labelledby="aiDesignerModalTitle">
          <div class="ai-designer-modal-content">
            <div class="ai-designer-modal-header">
              <h3 class="ai-designer-modal-title" id="aiDesignerModalTitle">Image Generator</h3>
              <button type="button" class="ai-designer-modal-close" id="aiDesignerModalClose" aria-label="Close">&times;</button>
            </div>
            <div class="ai-designer-form-group">
              <label for="aiDesignerPrompt" class="ai-designer-form-label">Design Prompt</label>
              <textarea id="aiDesignerPrompt" class="ai-designer-form-textarea" placeholder="Describe the image you want to generate, e.g., 'a car in a dark road in the middle of the night', 'a cat wearing a suit', 'a sunset over mountains'" rows="4"></textarea>
            </div>
            <div class="ai-designer-preview" id="aiDesignerPreview">
              <div class="ai-designer-preview-placeholder">Generated image will appear here</div>
            </div>
            <div class="ai-designer-status" id="aiDesignerStatus" style="display: none;"></div>
            <div class="ai-designer-modal-actions">
              <button type="button" class="ai-designer-modal-btn ai-designer-modal-btn-cancel" id="aiDesignerModalCancel">Cancel</button>
              <button type="button" class="ai-designer-modal-btn ai-designer-modal-btn-generate" id="aiDesignerGenerate">Generate</button>
              <button type="button" class="ai-designer-modal-btn ai-designer-modal-btn-insert" id="aiDesignerInsert" style="display: none;">Insert Image</button>
            </div>
          </div>
        </div>
        <div class="ai-presentation-modal" id="aiPresentationModal" role="dialog" aria-modal="true" aria-labelledby="aiPresentationModalTitle">
          <div class="ai-presentation-modal-content">
            <div class="ai-presentation-modal-header">
              <h3 class="ai-presentation-modal-title" id="aiPresentationModalTitle">AI Presentation Designer</h3>
              <button type="button" class="ai-presentation-modal-close" id="aiPresentationModalClose" aria-label="Close">&times;</button>
            </div>
            <div class="ai-presentation-form-group">
              <label for="aiPresentationTopic" class="ai-presentation-form-label">Presentation Topic</label>
              <input type="text" id="aiPresentationTopic" class="ai-presentation-form-input" placeholder="e.g., AI Benefits, Introduction to Machine Learning, Company Q4 Results" autocomplete="off">
            </div>
            <div class="ai-presentation-form-group">
              <label for="aiPresentationTextStructure" class="ai-presentation-form-label">Text Structure (Optional)</label>
              <input type="text" id="aiPresentationTextStructure" class="ai-presentation-form-input" placeholder="e.g., Use bullet points with subtitles, Include detailed explanations, Use numbered lists, Add examples for each point" autocomplete="off">
            </div>
            <div class="ai-presentation-form-group">
              <label for="aiPresentationSlides" class="ai-presentation-form-label">Number of Slides</label>
              <input type="number" id="aiPresentationSlides" class="ai-presentation-form-input" min="3" max="20" value="5" autocomplete="off">
            </div>
            <div class="ai-presentation-progress" id="aiPresentationProgress">
              <div class="ai-presentation-progress-bar">
                <div class="ai-presentation-progress-fill" id="aiPresentationProgressFill"></div>
              </div>
              <div class="ai-presentation-progress-text" id="aiPresentationProgressText">Preparing presentation...</div>
            </div>
            <div class="ai-presentation-status" id="aiPresentationStatus" style="display: none;"></div>
            <div class="ai-presentation-modal-actions">
              <button type="button" class="ai-presentation-modal-btn ai-presentation-modal-btn-cancel" id="aiPresentationModalCancel">Cancel</button>
              <button type="button" class="ai-presentation-modal-btn ai-presentation-modal-btn-generate" id="aiPresentationGenerate">Create</button>
            </div>
          </div>
        </div>
        <div style="flex:1"></div>
        <button class="btn blue toolbar-btn" id="guideButton" title="Start Guide">
          <i class="fas fa-question-circle"></i>
        </button>
        <button class="btn blue toolbar-btn" id="btnHome" data-action="go_home" title="Return Home">
          <i class="fas fa-home"></i>
        </button>
      </div>
      
      <!-- Welcome Popup for Guide Button -->
      <div id="guideWelcomeOverlay" class="guide-welcome-overlay" style="display: none;">
        <div class="guide-welcome-popup">
          <button class="guide-welcome-close" id="guideWelcomeClose" title="Close">
            <i class="fas fa-times"></i>
          </button>
          <div class="guide-welcome-icon">ðŸ’¡</div>
          <h2 class="guide-welcome-title">Welcome to the Editor!</h2>
          <p class="guide-welcome-text">
            Discover our interactive tutorial guide! Click the guide button highlighted at the top to learn about all the features and tools.
          </p>
        </div>
      </div>
      
      <!-- Guide Popup -->
      <div id="guideOverlay" class="guide-overlay" style="display: none;">
        <div class="guide-popup">
          <button class="guide-skip-btn" id="guideSkipBtn" title="Skip Guide">
            <i class="fas fa-times"></i>
          </button>
          <div class="guide-progress" id="guideProgress">1/16</div>
          <div class="guide-content">
            <h3 class="guide-title" id="guideTitle">Bold</h3>
            <p class="guide-description" id="guideDescription">Make selected text bold.</p>
          </div>
          <div class="guide-actions">
            <button class="guide-btn guide-btn-next" id="guideNextBtn">Next</button>
          </div>
        </div>
      </div>

      <div class="main" id="layoutMain">
        <aside class="sidebar" id="sidebar"></aside>
        <section class="editor">
          <div class="toolbar" id="toolbar">
            <div class="toolbar-tabs" role="tablist" aria-label="Editor toolbar categories">
              <button class="toolbar-tab active" type="button" role="tab" aria-selected="true" aria-controls="toolbar-panel-home" data-tab-target="home" id="toolbar-tab-home">Home</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-insert" data-tab-target="insert" id="toolbar-tab-insert" tabindex="-1">Insert</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-transitions" data-tab-target="transitions" id="toolbar-tab-transitions" tabindex="-1">Transitions</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-animations" data-tab-target="animations" id="toolbar-tab-animations" tabindex="-1">Animations</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-view" data-tab-target="view" id="toolbar-tab-view" tabindex="-1">View</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-templates" data-tab-target="templates" id="toolbar-tab-templates" tabindex="-1">Templates</button>
              <button class="toolbar-tab" type="button" role="tab" aria-selected="false" aria-controls="toolbar-panel-tools" data-tab-target="tools" id="toolbar-tab-tools" tabindex="-1">Tools</button>
            </div>
            <div class="toolbar-panels">
              <div class="toolbar-panel active" role="tabpanel" id="toolbar-panel-home" aria-labelledby="toolbar-tab-home" data-tab-panel="home" tabindex="0">
                <button class="tool" data-action="bold" title="Bold"><i class="fas fa-bold"></i></button>
                <button class="tool" data-action="italic" title="Italic"><i class="fas fa-italic"></i></button>
                <button class="tool" data-action="underline" title="Underline"><i class="fas fa-underline"></i></button>
                <button class="tool" data-action="strikeThrough" title="Strikethrough"><i class="fas fa-strikethrough"></i></button>
                <button class="tool" data-action="subscript" title="Subscript"><i class="fas fa-subscript"></i></button>
                <button class="tool" data-action="superscript" title="Superscript"><i class="fas fa-superscript"></i></button>
                <button class="tool toolbar-btn-with-label" data-action="layout" title="Layout" id="layoutButton">
                  <i class="fas fa-th"></i>
                  <span class="tool-label">Layout</span>
                </button>
                <div class="tool-divider" aria-hidden="true"></div>
                <input type="number" class="tool-select" id="fontSize" title="Font Size" min="8" max="72" step="2" value="16" style="width: 80px; color: #e8f5e9;">
                <button type="button" class="tool font-picker-button" id="fontPickerButton" title="Font Family" aria-haspopup="true" aria-expanded="false">
                  <span class="font-picker-label" id="fontPickerLabel">Aa</span>
                </button>
                <div id="colorControlsRoot" class="color-controls"></div>
                <button type="button" class="tool" id="backgroundColorButton" title="Slide Background Color">
                  <i class="fas fa-fill-drip"></i>
                  <span class="new-slide-button-label">Background</span>
                </button>
                <input type="color" id="backgroundColorInput" class="visually-hidden" value="#ffffff" aria-hidden="true">
                <div class="tool-divider" aria-hidden="true"></div>
                <button class="tool" data-action="justifyLeft" title="Align Left"><i class="fas fa-align-left"></i></button>
                <button class="tool" data-action="justifyCenter" title="Align Center"><i class="fas fa-align-center"></i></button>
                <button class="tool" data-action="justifyRight" title="Align Right"><i class="fas fa-align-right"></i></button>
                <button class="tool" data-action="justifyFull" title="Justify"><i class="fas fa-align-justify"></i></button>
                <button class="tool" data-action="insertUnorderedList" title="Bullet List"><i class="fas fa-list-ul"></i></button>
                <button class="tool" data-action="insertOrderedList" title="Numbered List"><i class="fas fa-list-ol"></i></button>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-insert" aria-labelledby="toolbar-tab-insert" data-tab-panel="insert" aria-hidden="true" hidden tabindex="0">
                <button type="button" class="tool new-slide-toolbar-button" id="insertNewSlideButton" title="New Slide" aria-label="Add new slide">
                  <span class="new-slide-button-icon">
                    <i class="fas fa-square-plus"></i>
                  </span>
                  <span class="new-slide-button-label">New Slide</span>
                </button>
                <button type="button" class="tool shape-picker-button" id="shapePickerButton" title="Insert Shape" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-shapes"></i>
                  <span class="new-slide-button-label">Shapes</span>
                </button>
                <button type="button" class="tool image-picker-button" id="imagePickerButton" title="Insert Image">
                  <i class="fas fa-image"></i>
                  <span class="new-slide-button-label">Pictures</span>
                </button>
                <button type="button" class="tool video-picker-button" id="videoPickerButton" title="Insert Video">
                  <i class="fas fa-film"></i>
                  <span class="new-slide-button-label">Video</span>
                </button>
                <button type="button" class="tool chart-picker-button" id="chartPickerButton" title="Insert Chart" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-chart-pie"></i>
                  <span class="new-slide-button-label">Chart</span>
                </button>
                <button type="button" class="tool table-picker-button" id="tablePickerButton" title="Insert Table" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-table"></i>
                  <span class="new-slide-button-label">Table</span>
                </button>
                <button type="button" class="tool logo-picker-button" id="logoPickerButton" title="Insert Company Logo" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-building"></i>
                  <span class="new-slide-button-label">Logo</span>
                </button>
                <button type="button" class="tool icon-picker-button" id="iconPickerButton" title="Insert Icon" aria-haspopup="true" aria-expanded="false">
                  <i class="fas fa-icons"></i>
                  <span class="new-slide-button-label">Icons</span>
                </button>
                <button type="button" class="tool" id="dictateButton" title="Dictate" aria-haspopup="dialog" aria-expanded="false">
                  <i class="fas fa-microphone"></i>
                  <span class="new-slide-button-label">Dictate</span>
                </button>
                <button class="tool" data-action="addTextBox" title="Add Text Box"><i class="fas fa-text-width"></i> Text Box</button>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-templates" aria-labelledby="toolbar-tab-templates" data-tab-panel="templates" aria-hidden="true" hidden tabindex="0">
                <div class="templates-panel">
                  <div class="template-categories-container" id="templateCategoriesContainer">
                    <p style="color: #e7fbff; padding: 16px; text-align: center; opacity: 0.8;">Templates coming soon</p>
                  </div>
                </div>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-transitions" aria-labelledby="toolbar-tab-transitions" data-tab-panel="transitions" aria-hidden="true" hidden tabindex="0">
                <div class="transition-controls" role="group" aria-label="Slide transition controls">
                  <label class="transition-field" for="transitionEffectSelect">
                    <span class="transition-label">Effect</span>
                    <div class="transition-select-wrapper">
                      <span class="transition-select-icon" aria-hidden="true">
                        <i class="fas fa-wand-magic-sparkles"></i>
                      </span>
                    <select class="tool-select transition-select" id="transitionEffectSelect" title="Transition Effect">
                      <option value="none">None</option>
                      <option value="fade">Fade</option>
                      <option value="slide-left">Slide Left</option>
                      <option value="slide-right">Slide Right</option>
                      <option value="slide-up">Slide Up</option>
                      <option value="slide-down">Slide Down</option>
                      <option value="zoom-in">Zoom In</option>
                      <option value="zoom-out">Zoom Out</option>
                      <option value="flip">Flip</option>
                      <option value="rotate">Rotate</option>
                    </select>
                      <span class="transition-select-caret" aria-hidden="true">
                        <i class="fas fa-chevron-down"></i>
                      </span>
                    </div>
                  </label>
                  <label class="transition-field" for="transitionDurationInput">
                    <span class="transition-label">Duration</span>
                    <div class="transition-duration-control">
                      <input type="number" class="tool-select transition-duration-input" id="transitionDurationInput" title="Transition Duration (seconds)" min="0.1" max="5" step="0.1" value="0.7" inputmode="decimal" autocomplete="off">
                      <span class="transition-duration-suffix">s</span>
                    </div>
                  </label>
                  <button class="tool transition-apply-button" type="button" id="applyTransitionButton" title="Apply transition to current slide">
                    <i class="fas fa-check" aria-hidden="true"></i>
                    <span>Apply</span>
                  </button>
                  <button class="tool transition-apply-all-button" type="button" id="applyTransitionAllButton" title="Apply transition to all slides">
                    <i class="fas fa-layer-group" aria-hidden="true"></i>
                    <span>Apply to All</span>
                  </button>
                </div>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-animations" aria-labelledby="toolbar-tab-animations" data-tab-panel="animations" aria-hidden="true" hidden tabindex="0">
                <div class="animation-panel">
                  <div class="animation-controls" role="group" aria-label="Object animation controls">
                    <label class="animation-field" for="animationEffectSelect">
                      <span class="animation-label">Effect</span>
                      <div class="transition-select-wrapper">
                        <span class="transition-select-icon" aria-hidden="true">
                          <i class="fas fa-wand-magic-sparkles"></i>
                        </span>
                        <select class="tool-select transition-select animation-select" id="animationEffectSelect" title="Animation Effect">
                          <option value="fade-in">Fade In</option>
                          <option value="pop-up">Pop Up</option>
                          <option value="slide-in-right">Slide In Right</option>
                          <option value="slide-in-left">Slide In Left</option>
                          <option value="slide-in-up">Slide In Up</option>
                        </select>
                        <span class="transition-select-caret" aria-hidden="true">
                          <i class="fas fa-chevron-down"></i>
                        </span>
                      </div>
                    </label>
                    <label class="animation-field" for="animationDurationInput">
                      <span class="animation-label">Duration</span>
                      <div class="animation-duration-control">
                        <input type="number" class="tool-select" id="animationDurationInput" title="Animation Duration (seconds)" min="0.1" max="5" step="0.1" value="0.7" inputmode="decimal" autocomplete="off">
                        <span class="animation-duration-suffix">s</span>
                      </div>
                    </label>
                    <button class="tool animation-assign-button" type="button" id="assignAnimationButton" title="Apply animation to selected object">
                      <i class="fas fa-wand-magic-sparkles" aria-hidden="true"></i>
                      <span>Apply</span>
                    </button>
                    <button class="tool animation-remove-button" type="button" id="removeAnimationButton" title="Remove animation from selected object">
                      <i class="fas fa-ban" aria-hidden="true"></i>
                      <span>Remove</span>
                  </button>
                  </div>
                  <div class="animation-sequence-container hidden">
                    <div class="animation-sequence-header">
                      <span>Animation Sequence</span>
                      <div class="animation-sequence-actions">
                        <span class="animation-sequence-hint">Drag to reorder</span>
                        <button type="button" class="animation-sequence-close" id="closeAnimationSequenceButton" title="Close animation sequence panel" aria-label="Close animation sequence panel">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                    <div class="animation-sequence-list" id="animationSequenceList" role="list"></div>
                  </div>
                </div>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-view" aria-labelledby="toolbar-tab-view" data-tab-panel="view" aria-hidden="true" hidden tabindex="0">
                <div class="zoom-controls" role="group" aria-label="Canvas zoom controls">
                  <button class="tool zoom-button" type="button" id="zoomOutButton" title="Zoom out" aria-label="Zoom out">-</button>
                  <span class="zoom-display" id="zoomDisplay">100%</span>
                  <button class="tool zoom-button" type="button" id="zoomInButton" title="Zoom in" aria-label="Zoom in">+</button>
                  <button class="tool zoom-reset-button" type="button" id="zoomResetButton" title="Reset zoom" aria-label="Reset zoom">Reset</button>
                </div>
                <div class="sidebar-view-toggle" role="group" aria-label="Sidebar layout">
                  <button type="button" class="tool sidebar-view-button" data-sidebar-view="list" id="sidebarViewListButton" aria-pressed="false">
                    <i class="fas fa-list" aria-hidden="true"></i>
                    <span>Compact</span>
                  </button>
                  <button type="button" class="tool sidebar-view-button" data-sidebar-view="thumbnail" id="sidebarViewThumbnailButton" aria-pressed="false">
                    <i class="fas fa-table-cells-large" aria-hidden="true"></i>
                    <span>Preview</span>
                  </button>
                </div>
                <button class="tool present-button" data-action="present" title="Present Slideshow" aria-label="Present">
                  <svg class="present-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M6 4l12 8-12 8z" fill="currentColor"></path>
                  </svg>
                </button>
              </div>
              <div class="toolbar-panel" role="tabpanel" id="toolbar-panel-tools" aria-labelledby="toolbar-tab-tools" data-tab-panel="tools" aria-hidden="true" hidden tabindex="0">
                <button type="button" class="tool spell-check-toggle active" id="spellCheckToggle" aria-pressed="true" title="Toggle spell check">
                  <i class="fas fa-spell-check" aria-hidden="true"></i>
                  <span class="tool-label">
                    Spell Check
                    <span class="tool-state" data-role="spell-toggle-state">On</span>
                  </span>
                </button>
                <button type="button" class="tool" id="translateToolButton" title="Translate text" aria-label="Translate text">
                  <i class="fas fa-language" aria-hidden="true"></i>
                  <span>Translate</span>
                </button>
                <button type="button" class="tool" id="aiDesignerButton" title="Image Generator" aria-label="Image Generator">
                  <i class="fas fa-magic" aria-hidden="true"></i>
                  <span>Image Generator</span>
                </button>
                <button type="button" class="tool" id="aiPresentationButton" title="AI Presentation Designer" aria-label="AI Presentation Designer">
                  <i class="fas fa-wand-magic-sparkles" aria-hidden="true"></i>
                  <span>AI Presentation</span>
                </button>
              </div>
            </div>
          </div>
          <div class="canvas-wrap">
            <div class="canvas" id="canvas">
              <div class="title-box" contenteditable="true" spellcheck="true" id="titleBox" data-placeholder="Click to add title"></div>
              <div class="text-box" contenteditable="true" spellcheck="true" id="textBox" data-placeholder="Click to add text"></div>
            </div>
          </div>
          <section class="comments-panel" id="commentsPanel" aria-label="Slide comments">
            <div class="comments-header">
              <h3 class="comments-title">Comments</h3>
              <span class="comments-count" id="commentsCount">0 comments</span>
            </div>
            <div class="comments-list" id="commentsList" role="list"></div>
            <form class="comment-form" id="commentForm" novalidate>
              <label for="commentInput" class="visually-hidden">Add a comment</label>
              <textarea id="commentInput" class="comment-input" placeholder="Share your thoughts about this slideâ€¦" rows="3"></textarea>
              <div class="comment-form-actions">
                <button type="submit" class="comment-submit" id="commentSubmitButton">Post Comment</button>
              </div>
            </form>
          </section>
        </section>
        <aside class="translator-panel hidden" id="translatorPanel" aria-label="Translator">
          <div class="translator-header">
            <span class="translator-title">Translate Text</span>
            <button type="button" class="translator-close" id="translatorCloseButton" aria-label="Close translation panel">&times;</button>
          </div>
          <div class="translator-body">
            <div class="translator-source">
              <label class="translator-label" for="translatorSourceInput">Original Text</label>
              <textarea class="translator-textarea" id="translatorSourceInput" placeholder="Select text to translate"></textarea>
            </div>
            <div class="translator-field">
              <label class="translator-label" for="translatorLanguageSelect">Target Language</label>
              <select class="translator-select" id="translatorLanguageSelect"></select>
            </div>
            <div class="translator-result">
              <label class="translator-label" for="translatorResultArea">Translation</label>
              <textarea class="translator-textarea" id="translatorResultArea" readonly placeholder="Translation will appear here"></textarea>
            </div>
          </div>
          <div class="translator-actions">
            <span class="translator-status" id="translatorStatusLabel"></span>
            <button type="button" class="tool" id="translatorInsertButton">
              <i class="fas fa-check" aria-hidden="true"></i>
              <span>Insert</span>
            </button>
          </div>
        </aside>
      </div>
    </div>

    <div class="save-notification" id="saveNotification">Presentation saved!</div>

    <script type="module">
      import React, { useEffect, useRef, useState } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { PaintBucket } from 'https://esm.sh/lucide-react@0.312.0?deps=react@18.2.0';

      const { createElement, Fragment } = React;

      const TextIcon = (props) => createElement(
        'svg',
        Object.assign({
          width: 18,
          height: 18,
          viewBox: '0 0 24 24',
          fill: 'none',
          stroke: 'currentColor',
          strokeWidth: 2,
          strokeLinecap: 'round',
          strokeLinejoin: 'round'
        }, props),
        createElement('path', { d: 'M5 20h14' }),
        createElement('path', { d: 'M12 4l5 12' }),
        createElement('path', { d: 'M12 4L7 16' }),
        createElement('line', { x1: 10.5, y1: 12, x2: 13.5, y2: 12 })
      );

      const DEFAULT_TEXT_COLOR = '#000000';
      const DEFAULT_BG_COLOR = '#ffff00';

      const ColorControls = ({ textColorHandler, bgColorHandler }) => {
        const [textColor, setTextColor] = useState(DEFAULT_TEXT_COLOR);
        const [bgColor, setBgColor] = useState(DEFAULT_BG_COLOR);
        const textInputRef = useRef(null);
        const bgInputRef = useRef(null);

        useEffect(() => {
          if (textInputRef.current) {
            setTextColor(textInputRef.current.value || DEFAULT_TEXT_COLOR);
          }
          if (bgInputRef.current) {
            setBgColor(bgInputRef.current.value || DEFAULT_BG_COLOR);
          }
        }, []);

        const handleTextColorChange = (event) => {
          const color = event.target.value;
          setTextColor(color);
          if (typeof textColorHandler === 'function') {
            textColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-text-color', { detail: { color } }));
          }
        };

        const handleBgColorChange = (event) => {
          const color = event.target.value;
          setBgColor(color);
          if (typeof bgColorHandler === 'function') {
            bgColorHandler(color);
          } else {
            document.dispatchEvent(new CustomEvent('apply-bg-color', { detail: { color } }));
          }
        };

        const triggerTextPicker = () => {
          if (textInputRef.current) {
            textInputRef.current.click();
          }
        };

        const triggerBgPicker = () => {
          if (bgInputRef.current) {
            bgInputRef.current.click();
          }
        };

        return createElement(
          Fragment,
          null,
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerTextPicker,
              title: 'Font Color',
              'aria-label': 'Font Color'
            },
            createElement(TextIcon, { className: 'color-tool-icon' }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: textColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'fontColor',
            ref: textInputRef,
            defaultValue: DEFAULT_TEXT_COLOR,
            className: 'visually-hidden',
            onChange: handleTextColorChange
          }),
          createElement(
            'button',
            {
              type: 'button',
              className: 'tool color-tool-button',
              onClick: triggerBgPicker,
              title: 'Text Box Background Color',
              'aria-label': 'Text Box Background Color'
            },
            createElement(PaintBucket, { size: 18 }),
            createElement('span', {
              className: 'color-bar',
              style: { backgroundColor: bgColor }
            })
          ),
          createElement('input', {
            type: 'color',
            id: 'highlightColor',
            ref: bgInputRef,
            defaultValue: DEFAULT_BG_COLOR,
            className: 'visually-hidden',
            onChange: handleBgColorChange
          })
        );
      };

      const rootElement = document.getElementById('colorControlsRoot');
      if (rootElement) {
        const handlers = window.slideEditorColorHandlers || {};
        createRoot(rootElement).render(createElement(ColorControls, {
          textColorHandler: handlers.onTextColor,
          bgColorHandler: handlers.onBackgroundColor
        }));
      }
    </script>

    <script>
      // Define functions first, before they're called
      window.highlightGuideButton = function() {
        const guideButton = document.getElementById('guideButton');
        if (!guideButton) return;
        
        // Add class to button to make it stand out
        guideButton.classList.add('guide-highlighted');
        
        // Remove existing highlight if any
        const existing = document.getElementById('guideButtonHighlight');
        if (existing) {
          if (existing._cleanup) existing._cleanup();
          existing.remove();
        }
        
        // Force layout recalculation
        void guideButton.offsetWidth;
        
        // Function to create/update highlight
        const createHighlight = () => {
          // Get button position relative to viewport
          const rect = guideButton.getBoundingClientRect();
          
          // Check if button is visible and has dimensions
          if (rect.width === 0 || rect.height === 0 || rect.left === 0 && rect.top === 0) {
            // Button not positioned yet, retry
            setTimeout(createHighlight, 100);
            return;
          }
          
          // Remove old highlight if exists
          const oldHighlight = document.getElementById('guideButtonHighlight');
          if (oldHighlight) {
            if (oldHighlight._cleanup) oldHighlight._cleanup();
            oldHighlight.remove();
          }
          
          // Create highlight wrapper - position fixed relative to viewport
          const wrapper = document.createElement('div');
          wrapper.className = 'guide-button-highlight-wrapper';
          wrapper.id = 'guideButtonHighlight';
          document.body.appendChild(wrapper);
          
          // Create pulsing ring
          const pulse = document.createElement('div');
          pulse.className = 'guide-button-pulse-ring';
          wrapper.appendChild(pulse);
          
          // Arrow removed - no arrow indicator needed
          
          // Function to update positions
          const updatePositions = () => {
            // Force reflow
            void guideButton.offsetWidth;
            
            const btnRect = guideButton.getBoundingClientRect();
            
            if (btnRect.width > 0 && btnRect.height > 0) {
              // Position pulse ring
              pulse.style.position = 'fixed';
              pulse.style.left = `${btnRect.left - 12}px`;
              pulse.style.top = `${btnRect.top - 12}px`;
              pulse.style.width = `${btnRect.width + 24}px`;
              pulse.style.height = `${btnRect.height + 24}px`;
            }
          };
          
          // Initial position update
          updatePositions();
          
          // Update on scroll and resize
          window.addEventListener('scroll', updatePositions, true);
          window.addEventListener('resize', updatePositions);
          
          // Update position periodically to catch any layout changes
          const positionInterval = setInterval(updatePositions, 100);
          
          // Store cleanup function
          wrapper._cleanup = () => {
            window.removeEventListener('scroll', updatePositions, true);
            window.removeEventListener('resize', updatePositions);
            clearInterval(positionInterval);
            guideButton.classList.remove('guide-highlighted');
          };
          
          // Store references for external access
          wrapper._pulse = pulse;
          wrapper._updatePositions = updatePositions;
        };
        
        // Wait a bit for layout to settle, then create highlight
        setTimeout(createHighlight, 100);
      };
      
      window.dismissWelcomePopup = function() {
        const welcomeOverlay = document.getElementById('guideWelcomeOverlay');
        const highlight = document.getElementById('guideButtonHighlight');
        const guideButton = document.getElementById('guideButton');
        
        // Hide popup
        if (welcomeOverlay) {
          welcomeOverlay.style.display = 'none';
          
          // Clean up position update listeners
          if (welcomeOverlay._positionUpdate) {
            window.removeEventListener('resize', welcomeOverlay._positionUpdate);
            window.removeEventListener('scroll', welcomeOverlay._positionUpdate, true);
            delete welcomeOverlay._positionUpdate;
          }
        }
        
        // Remove highlight
        if (highlight) {
          if (highlight._cleanup) highlight._cleanup();
          highlight.style.opacity = '0';
          highlight.style.transition = 'opacity 0.3s ease';
          setTimeout(() => {
            highlight.remove();
          }, 300);
        }
        
        // Remove highlight class from button
        if (guideButton) {
          guideButton.classList.remove('guide-highlighted');
        }
        
        // Save to localStorage so popup doesn't show again
        try {
          localStorage.setItem('guideWelcomePopupDismissed', 'true');
        } catch (e) {
          console.warn('Failed to save welcome popup dismissal to localStorage:', e);
        }
      };
      
      // Show Welcome Popup and Highlight Guide Button - Make globally accessible
      window.showGuideWelcomePopup = function() {
        console.log('=== showGuideWelcomePopup called ===');
        // Check if popup has been dismissed before
        let shouldShowPopup = true;
        try {
          const wasDismissed = localStorage.getItem('guideWelcomePopupDismissed');
          console.log('localStorage guideWelcomePopupDismissed:', wasDismissed);
          console.log('Type of wasDismissed:', typeof wasDismissed);
          console.log('Is equal to "true"?', wasDismissed === 'true');
          if (wasDismissed === 'true') {
            // Popup was dismissed before, don't show it again
            console.log('âš ï¸ Welcome popup was previously dismissed, not showing again');
            console.log('ðŸ’¡ To show it again, run in console: localStorage.removeItem("guideWelcomePopupDismissed")');
            shouldShowPopup = false;
          } else {
            console.log('âœ… Popup has not been dismissed, will show');
          }
        } catch (e) {
          console.warn('Failed to check welcome popup dismissal status:', e);
        }
        
        console.log('Should show popup:', shouldShowPopup);
        
        const welcomeOverlay = document.getElementById('guideWelcomeOverlay');
        const welcomePopup = welcomeOverlay ? welcomeOverlay.querySelector('.guide-welcome-popup') : null;
        const guideButton = document.getElementById('guideButton');
        
        if (!welcomeOverlay) {
          console.warn('Welcome overlay not found');
          return;
        }
        
        if (!welcomePopup) {
          console.warn('Welcome popup not found');
          return;
        }
        
        if (!guideButton) {
          console.warn('Guide button not found');
          return;
        }
        
        // Function to position popup under guide button
        const positionPopupUnderButton = () => {
          const btnRect = guideButton.getBoundingClientRect();
          
          if (btnRect.width > 0 && btnRect.height > 0) {
            // Position popup below and aligned with button (right-aligned)
            const popupTop = btnRect.bottom + 15; // 15px gap below button
            const popupWidth = Math.min(360, window.innerWidth - 40);
            const rightOffset = window.innerWidth - btnRect.right; // Distance from right edge
            
            welcomePopup.style.position = 'fixed';
            welcomePopup.style.top = `${popupTop}px`;
            welcomePopup.style.right = `${rightOffset}px`;
            welcomePopup.style.left = 'auto';
            welcomePopup.style.maxWidth = `${popupWidth}px`;
            
            // If popup would go off bottom, position it above button instead
            const popupHeight = welcomePopup.offsetHeight || 250;
            if (popupTop + popupHeight > window.innerHeight - 20) {
              welcomePopup.style.top = `${btnRect.top - popupHeight - 15}px`;
            }
          }
        };
        
        // Show overlay and popup if it should be shown
        if (shouldShowPopup) {
          console.log('Displaying welcome popup');
          console.log('Overlay element:', welcomeOverlay);
          console.log('Popup element:', welcomePopup);
          
          // Force remove any inline display:none
          welcomeOverlay.removeAttribute('style');
          
          // Set display and styles
          welcomeOverlay.style.display = 'flex';
          welcomeOverlay.style.zIndex = '10000';
          welcomeOverlay.style.visibility = 'visible';
          welcomeOverlay.style.opacity = '1';
          welcomeOverlay.style.position = 'fixed';
          welcomeOverlay.style.top = '0';
          welcomeOverlay.style.left = '0';
          welcomeOverlay.style.right = '0';
          welcomeOverlay.style.bottom = '0';
          
          // Ensure popup is visible
          if (welcomePopup) {
            welcomePopup.style.display = 'block';
            welcomePopup.style.visibility = 'visible';
            welcomePopup.style.opacity = '1';
          }
          
          console.log('Overlay display after setting:', window.getComputedStyle(welcomeOverlay).display);
          console.log('Overlay visibility after setting:', window.getComputedStyle(welcomeOverlay).visibility);
          
          // Position popup after a brief delay to ensure layout
          setTimeout(() => {
            positionPopupUnderButton();
            console.log('Popup positioned');
            console.log('Popup computed display:', window.getComputedStyle(welcomePopup).display);
            console.log('Popup computed visibility:', window.getComputedStyle(welcomePopup).visibility);
            
            // Update position on resize/scroll
            const updatePosition = () => positionPopupUnderButton();
            window.addEventListener('resize', updatePosition);
            window.addEventListener('scroll', updatePosition, true);
            
            // Store cleanup
            welcomeOverlay._positionUpdate = updatePosition;
          }, 100);
        } else {
          console.log('Popup not shown - was previously dismissed');
          console.log('To show it again, run: localStorage.removeItem("guideWelcomePopupDismissed")');
          welcomeOverlay.style.display = 'none';
        }
        
        // Always highlight the guide button - wait for button to be positioned
        setTimeout(() => {
          if (typeof window.highlightGuideButton === 'function') {
            // Ensure button is visible and positioned before highlighting
            const btnRect = guideButton.getBoundingClientRect();
            if (btnRect.width > 0 && btnRect.height > 0) {
              window.highlightGuideButton();
            } else {
              // Retry if button not positioned yet
              setTimeout(() => {
                if (typeof window.highlightGuideButton === 'function') {
                  window.highlightGuideButton();
                }
              }, 500);
            }
          }
        }, shouldShowPopup ? 800 : 300);
        
        // Close button handler - use event delegation to ensure it works
        const closeBtn = document.getElementById('guideWelcomeClose');
        if (closeBtn) {
          // Remove any existing listeners first
          const newCloseBtn = closeBtn.cloneNode(true);
          closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
          
          newCloseBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.dismissWelcomePopup();
          });
        }
        
        // Close when clicking overlay (but not the popup itself)
        welcomeOverlay.addEventListener('click', (e) => {
          if (e.target === welcomeOverlay) {
            window.dismissWelcomePopup();
          }
        });
        
        // Dismiss when clicking the guide button
        guideButton.addEventListener('click', () => {
          window.dismissWelcomePopup();
        }, { once: true });
      };
      
      // Route Protection - Check authentication on page load
      (function() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        // If not authenticated and not a guest, redirect to welcome page
        if (!currentUser && !isGuest) {
          window.location.href = './index.html';
          return;
        }
        
        // Show guide button for all users
        const guideButton = document.getElementById('guideButton');
        if (guideButton) {
          guideButton.style.display = 'flex';
          guideButton.style.visibility = 'visible';
          
          // Function to highlight guide button
          const highlightGuide = () => {
            setTimeout(() => {
              if (typeof window.highlightGuideButton === 'function') {
                const btnRect = guideButton.getBoundingClientRect();
                if (btnRect.width > 0 && btnRect.height > 0) {
                  window.highlightGuideButton();
                } else {
                  setTimeout(() => {
                    if (typeof window.highlightGuideButton === 'function') {
                      window.highlightGuideButton();
                    }
                  }, 500);
                }
              }
            }, 1000);
          };
          
          // Show welcome popup and highlight guide button for all users
          // Use window load event to ensure everything is ready
          const showWelcome = () => {
            console.log('showWelcome called');
            // Wait for function to be available with multiple retries
            const tryShowWelcome = (attempt = 0) => {
              const maxAttempts = 10;
              if (typeof window.showGuideWelcomePopup === 'function') {
                console.log('Calling showGuideWelcomePopup (attempt ' + attempt + ')');
                window.showGuideWelcomePopup();
              } else if (attempt < maxAttempts) {
                console.log('showGuideWelcomePopup not found, retrying... (attempt ' + attempt + ')');
                setTimeout(() => tryShowWelcome(attempt + 1), 200);
              } else {
                console.log('showGuideWelcomePopup still not found after ' + maxAttempts + ' attempts, just highlighting');
                // If popup function not available, just highlight the button
                highlightGuide();
              }
            };
            
            // Start trying after a short delay
            setTimeout(() => {
              tryShowWelcome(0);
            }, 500);
          };
          
          // Also ensure highlight happens even if popup doesn't
          const ensureHighlight = () => {
            setTimeout(() => {
              if (typeof window.highlightGuideButton === 'function') {
                const btnRect = guideButton.getBoundingClientRect();
                if (btnRect.width > 0 && btnRect.height > 0) {
                  console.log('Ensuring highlight is shown');
                  window.highlightGuideButton();
                }
              }
            }, 2000);
          };
          
          // Use multiple initialization strategies to ensure it works on both file:// and localhost
          const initializeWelcome = () => {
            // Wait a bit longer to ensure all functions are defined
            setTimeout(() => {
              showWelcome();
              ensureHighlight();
            }, 500);
          };
          
          if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initializeWelcome();
          } else {
            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initializeWelcome);
            }
            // Also wait for full load
            window.addEventListener('load', initializeWelcome);
          }
        }
      })();
      
      // Guide System
      (function() {
        const guideButton = document.getElementById('guideButton');
        const guideOverlay = document.getElementById('guideOverlay');
        const guideSkipBtn = document.getElementById('guideSkipBtn');
        const guideNextBtn = document.getElementById('guideNextBtn');
        const guideTitle = document.getElementById('guideTitle');
        const guideDescription = document.getElementById('guideDescription');
        const guideProgress = document.getElementById('guideProgress');
        
        // Guide steps for all sections
        const guideSteps = {
          home: [
            { selector: 'button[data-action="bold"]', title: 'Bold', description: 'Make selected text bold. Click this button to apply bold formatting to your text.' },
            { selector: 'button[data-action="italic"]', title: 'Italic', description: 'Make selected text italic. Use this to emphasize text with italic styling.' },
            { selector: 'button[data-action="underline"]', title: 'Underline', description: 'Add an underline to selected text. Perfect for highlighting important information.' },
            { selector: 'button[data-action="strikeThrough"]', title: 'Strikethrough', description: 'Apply strikethrough formatting to selected text. Useful for showing deleted or outdated content.' },
            { selector: 'button[data-action="subscript"]', title: 'Subscript', description: 'Format text as subscript (smaller text below the baseline). Common for chemical formulas and footnotes.' },
            { selector: 'button[data-action="superscript"]', title: 'Superscript', description: 'Format text as superscript (smaller text above the baseline). Used for exponents and citations.' },
            { selector: '#layoutButton', title: 'Layout', description: 'Change the layout of your slide. Click to choose from various slide layouts like title slide, content slide, two-column, and more.' },
            { selector: '#fontSize', title: 'Font Size', description: 'Adjust the size of your text. Enter a number between 8 and 72 to change the font size.' },
            { selector: '#fontPickerButton', title: 'Font Family', description: 'Change the font style of your text. Click to open the font picker and choose from various font families.' },
            { selector: '#colorControlsRoot', title: 'Text Color', description: 'Change the color of your text. Click the color picker to select a custom color for your text.' },
            { selector: '#backgroundColorButton', title: 'Background Color', description: 'Change the background color of your slide. Click to open the color picker and customize your slide background.' },
            { selector: 'button[data-action="justifyLeft"]', title: 'Align Left', description: 'Align text to the left side of the text box. This is the default alignment for most text.' },
            { selector: 'button[data-action="justifyCenter"]', title: 'Align Center', description: 'Center align your text. Perfect for titles and headings that need to be centered.' },
            { selector: 'button[data-action="justifyRight"]', title: 'Align Right', description: 'Align text to the right side of the text box. Useful for dates, signatures, or right-aligned content.' },
            { selector: 'button[data-action="justifyFull"]', title: 'Justify', description: 'Justify text to fill the entire width of the text box, creating even margins on both sides.' },
            { selector: 'button[data-action="insertUnorderedList"]', title: 'Bullet List', description: 'Create a bulleted list. Click to convert selected text into a list with bullet points.' },
            { selector: 'button[data-action="insertOrderedList"]', title: 'Numbered List', description: 'Create a numbered list. Click to convert selected text into a numbered list (1, 2, 3...).' }
          ],
          insert: [
            { selector: '#insertNewSlideButton', title: 'New Slide', description: 'Add a new slide to your presentation. Click to create a blank slide after the current one.' },
            { selector: '#shapePickerButton', title: 'Shapes', description: 'Insert shapes into your slide. Click to open the shape picker and choose from various shapes like rectangles, circles, arrows, and more.' },
            { selector: '#imagePickerButton', title: 'Pictures', description: 'Insert an image into your slide. Click to upload or select an image file from your computer.' },
            { selector: '#videoPickerButton', title: 'Video', description: 'Insert a video into your slide. Click to add a video file to your presentation.' },
            { selector: '#chartPickerButton', title: 'Chart', description: 'Insert a chart or graph. Click to create charts like bar charts, pie charts, and line graphs.' },
            { selector: '#tablePickerButton', title: 'Table', description: 'Insert a table into your slide. Click to create a grid table with rows and columns for organizing data.' },
            { selector: '#logoPickerButton', title: 'Logo', description: 'Insert a company logo or brand image. Click to add logos and brand assets to your slide.' },
            { selector: '#iconPickerButton', title: 'Icons', description: 'Insert icons and symbols. Click to browse and add various icons to enhance your slide design.' },
            { selector: '#dictateButton', title: 'Dictate', description: 'Use voice input to add text. Click to activate speech-to-text and speak your content.' },
            { selector: 'button[data-action="addTextBox"]', title: 'Text Box', description: 'Add a new text box to your slide. Click to create a customizable text container.' }
          ],
          templates: [
            { selector: '#templateCategoriesContainer', title: 'Templates', description: 'Browse and apply slide templates. Choose from various pre-designed templates to quickly style your slides.' }
          ],
          transitions: [
            { selector: '#transitionEffectSelect', title: 'Transition Effect', description: 'Choose how slides transition during presentation. Select from effects like fade, slide, zoom, and more.' },
            { selector: '#transitionDurationInput', title: 'Transition Duration', description: 'Set how long the transition effect takes. Enter a value between 0.1 and 5 seconds.' },
            { selector: '#applyTransitionAllButton', title: 'Apply to All', description: 'Apply the current transition effect to all slides in your presentation with one click.' }
          ],
          animations: [
            { selector: '#animationEffectSelect', title: 'Animation Effect', description: 'Choose an animation effect for selected objects. Select from fade-in, pop-up, slide-in effects, and more.' },
            { selector: '#animationDurationInput', title: 'Animation Duration', description: 'Set how long the animation takes. Enter a value between 0.1 and 5 seconds for the animation duration.' },
            { selector: '#assignAnimationButton', title: 'Apply Animation', description: 'Apply the selected animation to the currently selected object on your slide.' },
            { selector: '#removeAnimationButton', title: 'Remove Animation', description: 'Remove animation from the selected object. Click to clear any applied animations.' }
          ],
          view: [
            { selector: '#zoomOutButton', title: 'Zoom Out', description: 'Zoom out to see more of your slide. Click to reduce the zoom level.' },
            { selector: '#zoomInButton', title: 'Zoom In', description: 'Zoom in to see details better. Click to increase the zoom level.' },
            { selector: '#zoomResetButton', title: 'Reset Zoom', description: 'Reset zoom to the default level (100%). Click to return to normal view. The current zoom level is shown in the zoom display.' },
            { selector: '#sidebarViewListButton', title: 'Compact View', description: 'Switch sidebar to compact list view. Shows slides in a vertical list format.' },
            { selector: '#sidebarViewThumbnailButton', title: 'Preview View', description: 'Switch sidebar to thumbnail preview view. Shows slide thumbnails for visual navigation.' },
            { selector: 'button[data-action="present"]', title: 'Present', description: 'Start the presentation mode. Click to enter fullscreen slideshow mode for presenting your slides.' }
          ],
          tools: [
            { selector: '#spellCheckToggle', title: 'Spell Check', description: 'Toggle spell checking on or off. When enabled, misspelled words will be underlined in red.' },
            { selector: '#translateToolButton', title: 'Translate', description: 'Translate selected text to different languages. Click to open the translation tool.' },
            { selector: '#aiDesignerButton', title: 'Image Generator', description: 'Generate images using AI. Click to create custom images based on text descriptions.' },
            { selector: '#aiPresentationButton', title: 'AI Presentation', description: 'Generate an entire presentation using AI. Click to create slides automatically based on a topic.' }
          ]
        };
        
        let currentStep = 0;
        let currentSection = null;
        let currentSteps = [];
        let highlightElement = null;
        let isGuideActive = false;
        
        function getCurrentSection() {
          // Find the active toolbar tab
          const activeTab = document.querySelector('.toolbar-tab.active');
          if (activeTab) {
            return activeTab.getAttribute('data-tab-target') || activeTab.id.replace('toolbar-tab-', '');
          }
          
          // Fallback: find active toolbar panel
          const activePanel = document.querySelector('.toolbar-panel.active');
          if (activePanel) {
            return activePanel.getAttribute('data-tab-panel') || activePanel.id.replace('toolbar-panel-', '');
          }
          
          return 'home'; // Default to home
        }
        
        function showGuideStep(stepIndex) {
          if (stepIndex >= currentSteps.length) {
            endGuide();
            return;
          }
          
          const step = currentSteps[stepIndex];
          const element = document.querySelector(step.selector);
          
          if (!element) {
            // If element not found, skip to next step
            showGuideStep(stepIndex + 1);
            return;
          }
          
          // Update guide content
          guideTitle.textContent = step.title;
          guideDescription.textContent = step.description;
          guideProgress.textContent = `${stepIndex + 1}/${currentSteps.length}`;
          
          // Show overlay
          guideOverlay.style.display = 'flex';
          isGuideActive = true;
          
          // Remove previous highlight
          if (highlightElement) {
            highlightElement.remove();
          }
          
          // Wait a bit for any panel animations
          setTimeout(() => {
            const rect = element.getBoundingClientRect();
            
            // Check if element is visible
            if (rect.width === 0 && rect.height === 0) {
              // Element not visible, try again
              showGuideStep(stepIndex + 1);
              return;
            }
            
            highlightElement = document.createElement('div');
            highlightElement.className = 'guide-highlight';
            highlightElement.style.left = `${rect.left - 6}px`;
            highlightElement.style.top = `${rect.top - 6}px`;
            highlightElement.style.width = `${rect.width + 12}px`;
            highlightElement.style.height = `${rect.height + 12}px`;
            document.body.appendChild(highlightElement);
            
            // Scroll element into view if needed
            element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
          }, 100);
          
          // Update button text for last step
          if (stepIndex === currentSteps.length - 1) {
            guideNextBtn.textContent = 'Finish';
          } else {
            guideNextBtn.textContent = 'Next';
          }
        }
        
        function nextStep() {
          currentStep++;
          showGuideStep(currentStep);
        }
        
        function endGuide() {
          guideOverlay.style.display = 'none';
          isGuideActive = false;
          currentStep = 0;
          currentSection = null;
          currentSteps = [];
          
          if (highlightElement) {
            highlightElement.remove();
            highlightElement = null;
          }
        }
        
        function skipGuide() {
          endGuide();
        }
        
        function startGuide() {
          // Dismiss welcome popup and remove highlight if they exist
          if (typeof window.dismissWelcomePopup === 'function') {
            window.dismissWelcomePopup();
          }
          
          // Get current active section
          currentSection = getCurrentSection();
          currentSteps = guideSteps[currentSection] || guideSteps.home;
          
          if (currentSteps.length === 0) {
            console.warn(`No guide steps defined for section: ${currentSection}`);
            return;
          }
          
          // Make sure the correct section tab is active
          const tabButton = document.querySelector(`.toolbar-tab[data-tab-target="${currentSection}"]`) || 
                          document.getElementById(`toolbar-tab-${currentSection}`);
          if (tabButton && !tabButton.classList.contains('active')) {
            tabButton.click();
          }
          
          // Wait for tab to switch and panel to show
          setTimeout(() => {
            currentStep = 0;
            showGuideStep(0);
          }, 300);
        }
        
        // Event listeners
        if (guideButton) {
          guideButton.addEventListener('click', startGuide);
        }
        
        if (guideNextBtn) {
          guideNextBtn.addEventListener('click', nextStep);
        }
        
        if (guideSkipBtn) {
          guideSkipBtn.addEventListener('click', skipGuide);
        }
        
        // Close guide when clicking outside (but not on the popup itself)
        if (guideOverlay) {
          guideOverlay.addEventListener('click', (e) => {
            if (e.target === guideOverlay) {
              skipGuide();
            }
          });
        }
      })();
      
      const DEFAULT_FONT_STACK = '"Trebuchet MS", "Helvetica Neue", Helvetica, Arial, sans-serif';
      const DEFAULT_SLIDE_BACKGROUND_COLOR = '#ffffff';
      const SLIDE_TEMPLATE_CLASSES = ['marketing-template', 'business-template', 'education-template', 'project-template'];
      const DEFAULT_TRANSITION_DURATION = 0.7;
      const TRANSITION_DURATION_MIN = 0.1;
      const TRANSITION_DURATION_MAX = 5;
      const ANIMATION_DURATION_MIN = 0.1;
      const ANIMATION_DURATION_MAX = 5;
      const DEFAULT_ANIMATION_DURATION = 0.7;
      const ANIMATION_EFFECTS = [
        { value: 'fade-in', label: 'Fade In' },
        { value: 'pop-up', label: 'Pop Up' },
        { value: 'slide-in-right', label: 'Slide In Right' },
        { value: 'slide-in-left', label: 'Slide In Left' },
        { value: 'slide-in-up', label: 'Slide In Up' }
      ];
      const DEFAULT_ANIMATION_EFFECT = 'fade-in';
      const ANIMATION_EFFECT_VALUE_SET = new Set(ANIMATION_EFFECTS.map(opt => opt.value));
      const ANIMATION_EFFECT_LABEL_MAP = new Map(ANIMATION_EFFECTS.map(opt => [opt.value, opt.label]));
      const ANIMATION_EFFECT_CLASS_NAMES = ANIMATION_EFFECTS.map(opt => `presentation-animation-effect-${opt.value}`);
      const SPELLCHECK_STORAGE_KEY = 'slideEditorSpellCheckEnabled';
      const SPELLCHECK_TARGET_SELECTOR = '.text-box, .title-box, td[contenteditable="true"], th[contenteditable="true"]';
      let isSpellCheckEnabled = true;

      let elementIdCounter = 0;
      function generateElementId(prefix = 'el') {
        if (window.crypto && typeof window.crypto.randomUUID === 'function') {
          return `${prefix}_${window.crypto.randomUUID()}`;
        }
        elementIdCounter += 1;
        return `${prefix}_${Date.now().toString(36)}_${elementIdCounter.toString(36)}`;
      }
      function ensureElementHasId(element, prefix = 'el') {
        if (!element) return null;
        if (!element.dataset.elementId) {
          element.dataset.elementId = generateElementId(prefix);
        }
        return element.dataset.elementId;
      }
      function escapeSelector(value) {
        if (window.CSS && typeof window.CSS.escape === 'function') {
          return window.CSS.escape(value);
        }
        return String(value).replace(/([.*+?^${}()|[\]\\])/g, '\\$1');
      }
      function truncateText(text, maxLength = 32) {
        if (!text) return '';
        const normalized = text.trim();
        if (normalized.length <= maxLength) {
          return normalized;
        }
        return `${normalized.slice(0, maxLength - 1)}â€¦`;
      }
      function normalizeAnimationEffect(effect) {
        if (ANIMATION_EFFECT_VALUE_SET.has(effect)) {
          return effect;
        }
        return DEFAULT_ANIMATION_EFFECT;
      }
      function clampAnimationDuration(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_ANIMATION_DURATION;
        }
        return Math.min(ANIMATION_DURATION_MAX, Math.max(ANIMATION_DURATION_MIN, numeric));
      }

      function createEmptySlide() {
        return {
        name: '', // Slide name for sidebar identification (separate from title content)
        title: '', // Title content that appears on the slide itself
        content: '',
          titleBox: { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false, id: generateElementId('title') },
          textBox: { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false, id: generateElementId('body') },
        titleFontFamily: DEFAULT_FONT_STACK,
        textFontFamily: DEFAULT_FONT_STACK,
        shapes: [],
        charts: [],
        additionalTextBoxes: [],
      tables: [],
      images: [],
        videos: [],
        comments: [],
          animations: [],
        transition: 'none',
        transitionDuration: DEFAULT_TRANSITION_DURATION,
        background: { image: '', size: '', position: '', repeat: '', color: '#ffffff' }
        };
      }

      // Model per Editor.json: starting with one slide titled "Title"
      const slides = [createEmptySlide()];
      let active = 0;
      let slideDragSourceIndex = null;
      
      // Sections data structure: { id: string, name: string, slideIndices: number[], collapsed: boolean, anchorSlideIndex: number }
      // anchorSlideIndex: the slide index that determines where this section appears in the sidebar
      let sections = [];
      let nextSectionId = 1;

      const sidebar = document.getElementById('sidebar');
      const titleBox = document.getElementById('titleBox');
      const textBox = document.getElementById('textBox');
      
      // ResizablePanel Class - Reusable panel resizing functionality
      class ResizablePanel {
        constructor(panelElement, options = {}) {
          if (!panelElement) {
            console.warn('ResizablePanel: panelElement is required');
            return;
          }
          
          this.panel = panelElement;
          this.side = options.side || 'right'; // 'left' or 'right'
          this.cssVar = options.cssVar || null; // CSS variable name (e.g., '--sidebar-width')
          this.minWidth = options.minWidth || 180;
          this.maxWidth = options.maxWidth || 600;
          this.storageKey = options.storageKey || null; // localStorage key for persisting width
          
          // Get initial width from CSS variable or computed style
          const computedWidth = parseInt(window.getComputedStyle(this.panel).width, 10);
          
          // Store the default width (original default before localStorage restore)
          // This is the "reset" size that users can return to
          this.defaultWidth = options.initialWidth || computedWidth || 260;
          this.defaultSizeThreshold = 6; // Threshold in pixels for showing default size indicator
          
          // Set initial width to default first
          this.initialWidth = this.defaultWidth;
          
          // Restore from localStorage if available
          if (this.storageKey) {
            try {
              const savedWidth = localStorage.getItem(this.storageKey);
              if (savedWidth) {
                const width = parseInt(savedWidth, 10);
                if (width >= this.minWidth && width <= this.maxWidth) {
                  this.initialWidth = width;
                }
              }
            } catch (e) {
              console.warn('Failed to restore panel width from localStorage', e);
            }
          }
          
          // Set initial width
          if (this.cssVar) {
            document.documentElement.style.setProperty(this.cssVar, `${this.initialWidth}px`);
          } else {
            this.panel.style.width = `${this.initialWidth}px`;
          }
          
          this.createResizer();
          this.createDefaultSizeIndicator();
          this.isResizing = false;
          this.startX = 0;
          this.startWidth = 0;
          this.animationFrameId = null;
        }
        
        createResizer() {
          // Remove existing resizer if present
          const existingResizer = this.panel.querySelector('.panel-resizer');
          if (existingResizer) {
            existingResizer.remove();
          }
          
          // Create resizer handle
          const resizer = document.createElement('div');
          resizer.className = 'panel-resizer';
          resizer.setAttribute('role', 'separator');
          resizer.setAttribute('aria-orientation', 'vertical');
          resizer.setAttribute('aria-label', 'Resize panel');
          
          // Add event listeners
          resizer.addEventListener('mousedown', (e) => this.startResize(e));
          resizer.addEventListener('touchstart', (e) => this.startResize(e), { passive: false });
          
          this.panel.appendChild(resizer);
          this.resizer = resizer;
        }
        
        createDefaultSizeIndicator() {
          // Create default size indicator (similar to alignment guides)
          const indicator = document.createElement('div');
          indicator.className = 'panel-default-size-indicator';
          indicator.style.display = 'none';
          document.body.appendChild(indicator);
          this.defaultSizeIndicator = indicator;
        }
        
        showDefaultSizeIndicator() {
          if (!this.defaultSizeIndicator || !this.resizer || !this.isResizing) return;
          
          // Use requestAnimationFrame to ensure we get the updated position after DOM changes
          requestAnimationFrame(() => {
            if (!this.resizer || !this.isResizing) return;
            
            const resizerRect = this.resizer.getBoundingClientRect();
            const indicator = this.defaultSizeIndicator;
            
            if (!indicator || !resizerRect) return;
            
            // Position indicator at the resizer location (works for both left and right side panels)
            indicator.style.position = 'fixed';
            indicator.style.left = `${resizerRect.left + resizerRect.width / 2}px`;
            indicator.style.top = `${resizerRect.top}px`;
            indicator.style.width = '2px';
            indicator.style.height = `${resizerRect.height}px`;
            indicator.style.display = 'block';
          });
        }
        
        hideDefaultSizeIndicator() {
          if (!this.defaultSizeIndicator) return;
          this.defaultSizeIndicator.style.display = 'none';
        }
        
        recreateResizer() {
          // Recreate the resizer handle if it was removed
          // Check if resizer exists in DOM
          const existingResizer = this.panel.querySelector('.panel-resizer');
          if (!existingResizer && this.panel) {
            // Resizer was removed, recreate it
            this.createResizer();
          } else if (existingResizer && this.resizer !== existingResizer) {
            // Resizer exists but our reference is outdated, update it
            this.resizer = existingResizer;
          }
        }
        
        startResize(e) {
          e.preventDefault();
          e.stopPropagation();
          
          this.isResizing = true;
          this.resizer.classList.add('resizing');
          document.body.classList.add('resizing-panel');
          
          // Disable transitions during resize for smooth dragging
          if (this.panel) {
            this.panel.style.transition = 'none';
          }
          const main = document.querySelector('.main');
          if (main) {
            main.style.transition = 'none';
          }
          
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          this.startX = clientX;
          
          // Get current width
          if (this.cssVar) {
            const currentValue = getComputedStyle(document.documentElement).getPropertyValue(this.cssVar);
            this.startWidth = parseInt(currentValue, 10) || this.initialWidth;
          } else {
            this.startWidth = parseInt(window.getComputedStyle(this.panel).width, 10) || this.initialWidth;
          }
          
          // Add global event listeners
          document.addEventListener('mousemove', this.handleResize);
          document.addEventListener('mouseup', this.stopResize);
          document.addEventListener('touchmove', this.handleResize, { passive: false });
          document.addEventListener('touchend', this.stopResize);
          document.addEventListener('touchcancel', this.stopResize);
        }
        
        handleResize = (e) => {
          if (!this.isResizing) return;
          
          e.preventDefault();
          
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const deltaX = this.side === 'right' 
            ? clientX - this.startX 
            : this.startX - clientX;
          
          let newWidth = this.startWidth + deltaX;
          newWidth = Math.max(this.minWidth, Math.min(this.maxWidth, newWidth));
          
          // Check if we're close to the default width
          const distanceFromDefault = Math.abs(newWidth - this.defaultWidth);
          const isAtDefaultSize = distanceFromDefault <= this.defaultSizeThreshold;
          
          if (isAtDefaultSize) {
            // Snap to default width
            newWidth = this.defaultWidth;
          }
          
          // Apply new width immediately for smooth, responsive dragging
          if (this.cssVar) {
            document.documentElement.style.setProperty(this.cssVar, `${newWidth}px`);
          } else {
            this.panel.style.width = `${newWidth}px`;
          }
          
          // Update indicator position - update continuously when at default size
          if (isAtDefaultSize) {
            this.showDefaultSizeIndicator();
          } else {
            this.hideDefaultSizeIndicator();
          }
          
          // Throttle layout updates using requestAnimationFrame for performance
          if (!this.animationFrameId) {
            this.animationFrameId = requestAnimationFrame(() => {
              // Trigger resize event for canvas and other dependent elements
              window.dispatchEvent(new Event('resize'));
              this.animationFrameId = null;
            });
          }
        }
        
        stopResize = () => {
          if (!this.isResizing) return;
          
          this.isResizing = false;
          this.resizer.classList.remove('resizing');
          document.body.classList.remove('resizing-panel');
          
          // Hide default size indicator
          this.hideDefaultSizeIndicator();
          
          // Re-enable transitions after resize
          if (this.panel) {
            this.panel.style.transition = '';
          }
          const main = document.querySelector('.main');
          if (main) {
            main.style.transition = '';
          }
          
          // Cancel any pending animation frame
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          
          // Final update and save to localStorage
          if (this.storageKey) {
            try {
              const currentWidth = this.cssVar
                ? parseInt(getComputedStyle(document.documentElement).getPropertyValue(this.cssVar), 10)
                : parseInt(window.getComputedStyle(this.panel).width, 10);
              if (currentWidth) {
                localStorage.setItem(this.storageKey, String(currentWidth));
              }
            } catch (e) {
              console.warn('Failed to save panel width to localStorage', e);
            }
          }
          
          // Trigger final resize event to ensure everything is updated
          requestAnimationFrame(() => {
            window.dispatchEvent(new Event('resize'));
          });
          
          // Remove global event listeners
          document.removeEventListener('mousemove', this.handleResize);
          document.removeEventListener('mouseup', this.stopResize);
          document.removeEventListener('touchmove', this.handleResize);
          document.removeEventListener('touchend', this.stopResize);
          document.removeEventListener('touchcancel', this.stopResize);
        }
        
        destroy() {
          if (this.resizer) {
            this.resizer.remove();
          }
          if (this.defaultSizeIndicator) {
            this.defaultSizeIndicator.remove();
            this.defaultSizeIndicator = null;
          }
          this.stopResize();
        }
      }
      const saveNotification = document.getElementById('saveNotification');
      const saveAsButton = document.getElementById('btnSaveAs');
      const saveAsMenu = document.getElementById('saveAsMenu');
      const canvas = document.getElementById('canvas');
      const insertNewSlideButton = document.getElementById('insertNewSlideButton');
      const backgroundColorButton = document.getElementById('backgroundColorButton');
      const backgroundColorInput = document.getElementById('backgroundColorInput');
      const dictateButton = document.getElementById('dictateButton');
      const SpeechRecognitionConstructor = window.SpeechRecognition || window.webkitSpeechRecognition || null;
      const subtitlesSupported = Boolean(SpeechRecognitionConstructor);
      const SPEECH_LANGUAGE_STORAGE_KEY = 'slideEditorSpeechLanguage';
      const DEFAULT_SPEECH_LANGUAGE = 'en-US';
      const SPEECH_RECOGNITION_LANGUAGES = Object.freeze([
        { code: 'af-ZA', label: 'Afrikaans' },
        { code: 'am-ET', label: 'Amharic' },
        { code: 'ar-SA', label: 'Arabic' },
        { code: 'az-AZ', label: 'Azerbaijani' },
        { code: 'be-BY', label: 'Belarusian' },
        { code: 'bg-BG', label: 'Bulgarian' },
        { code: 'bn-IN', label: 'Bengali' },
        { code: 'bs-BA', label: 'Bosnian' },
        { code: 'ca-ES', label: 'Catalan' },
        { code: 'ceb-PH', label: 'Cebuano' },
        { code: 'cs-CZ', label: 'Czech' },
        { code: 'cy-GB', label: 'Welsh' },
        { code: 'da-DK', label: 'Danish' },
        { code: 'de-DE', label: 'German' },
        { code: 'el-GR', label: 'Greek' },
        { code: 'en-US', label: 'English' },
        { code: 'es-ES', label: 'Spanish' },
        { code: 'et-EE', label: 'Estonian' },
        { code: 'eu-ES', label: 'Basque' },
        { code: 'fa-IR', label: 'Persian' },
        { code: 'fi-FI', label: 'Finnish' },
        { code: 'fil-PH', label: 'Filipino' },
        { code: 'fr-FR', label: 'French' },
        { code: 'ga-IE', label: 'Irish' },
        { code: 'gl-ES', label: 'Galician' },
        { code: 'gu-IN', label: 'Gujarati' },
        { code: 'he-IL', label: 'Hebrew' },
        { code: 'hi-IN', label: 'Hindi' },
        { code: 'hr-HR', label: 'Croatian' },
        { code: 'hu-HU', label: 'Hungarian' },
        { code: 'hy-AM', label: 'Armenian' },
        { code: 'id-ID', label: 'Indonesian' },
        { code: 'is-IS', label: 'Icelandic' },
        { code: 'it-IT', label: 'Italian' },
        { code: 'ja-JP', label: 'Japanese' },
        { code: 'jv-ID', label: 'Javanese' },
        { code: 'ka-GE', label: 'Georgian' },
        { code: 'kk-KZ', label: 'Kazakh' },
        { code: 'km-KH', label: 'Khmer' },
        { code: 'kn-IN', label: 'Kannada' },
        { code: 'ko-KR', label: 'Korean' },
        { code: 'lo-LA', label: 'Lao' },
        { code: 'lt-LT', label: 'Lithuanian' },
        { code: 'lv-LV', label: 'Latvian' },
        { code: 'mk-MK', label: 'Macedonian' },
        { code: 'ml-IN', label: 'Malayalam' },
        { code: 'mn-MN', label: 'Mongolian' },
        { code: 'mr-IN', label: 'Marathi' },
        { code: 'ms-MY', label: 'Malay' },
        { code: 'mt-MT', label: 'Maltese' },
        { code: 'my-MM', label: 'Burmese' },
        { code: 'nb-NO', label: 'Norwegian' },
        { code: 'ne-NP', label: 'Nepali' },
        { code: 'nl-NL', label: 'Dutch' },
        { code: 'pa-IN', label: 'Punjabi' },
        { code: 'pl-PL', label: 'Polish' },
        { code: 'pt-PT', label: 'Portuguese' },
        { code: 'ro-RO', label: 'Romanian' },
        { code: 'ru-RU', label: 'Russian' },
        { code: 'si-LK', label: 'Sinhala' },
        { code: 'sk-SK', label: 'Slovak' },
        { code: 'sl-SI', label: 'Slovenian' },
        { code: 'sq-AL', label: 'Albanian' },
        { code: 'sr-RS', label: 'Serbian' },
        { code: 'su-ID', label: 'Sundanese' },
        { code: 'sv-SE', label: 'Swedish' },
        { code: 'sw-KE', label: 'Swahili' },
        { code: 'ta-IN', label: 'Tamil' },
        { code: 'te-IN', label: 'Telugu' },
        { code: 'th-TH', label: 'Thai' },
        { code: 'tr-TR', label: 'Turkish' },
        { code: 'uk-UA', label: 'Ukrainian' },
        { code: 'ur-PK', label: 'Urdu' },
        { code: 'uz-UZ', label: 'Uzbek' },
        { code: 'vi-VN', label: 'Vietnamese' },
        { code: 'xh-ZA', label: 'Xhosa' },
        { code: 'yue-Hant-HK', label: 'Cantonese' },
        { code: 'zh-CN', label: 'Chinese (Simplified)' },
        { code: 'zh-TW', label: 'Chinese (Traditional)' },
        { code: 'zu-ZA', label: 'Zulu' }
      ]);
      const SPEECH_LANGUAGE_MAP = new Map(SPEECH_RECOGNITION_LANGUAGES.map((entry) => [entry.code, entry]));
      const TRANSLATION_LANGUAGES = [
        { code: 'es', label: 'Spanish' },
        { code: 'fr', label: 'French' },
        { code: 'de', label: 'German' },
        { code: 'it', label: 'Italian' },
        { code: 'pt', label: 'Portuguese' },
        { code: 'ar', label: 'Arabic' },
        { code: 'zh', label: 'Chinese (Simplified)' },
        { code: 'ja', label: 'Japanese' },
        { code: 'ko', label: 'Korean' },
        { code: 'ru', label: 'Russian' }
      ];
      const TRANSLATION_ENDPOINT = 'https://libretranslate.de/translate';
      const TRANSLATION_STORAGE_KEY = 'slideEditorTranslationLanguage';
      const TRANSLATION_LANGUAGE_MAP = new Map(TRANSLATION_LANGUAGES.map((entry) => [entry.code, entry]));
      const DEFAULT_TRANSLATION_TARGET = 'es';
      const SPEECH_TRANSLATION_STORAGE_KEY = 'presentationSpeechTranslationLanguage';
      let dictateRecognition = null;
      let dictateTargetBox = null;
      let dictationFinalText = '';
      let isDictating = false;
      let subtitlesDragState = null;
      let currentLanguage = (() => {
        try {
          const stored = localStorage.getItem(SPEECH_LANGUAGE_STORAGE_KEY);
          if (stored && SPEECH_LANGUAGE_MAP.has(stored)) {
            return stored;
          }
        } catch (error) {
          // ignore storage errors
        }
        return DEFAULT_SPEECH_LANGUAGE;
      })();
      let presentationSubtitleMenu = null;
      let presentationSubtitleMenuButton = null;
      let presentationSubtitleMenuSearch = null;
      let presentationSubtitleMenuList = null;
      let subtitleLanguageEmptyState = null;
      let subtitleLanguageOptionButtons = [];
      let subtitleMenuOpen = false;
      let subtitleMenuOutsideHandler = null;
      let subtitleMenuEscapeHandler = null;
      let presentationTranslationToggle = null;
      let presentationTranslationMenu = null;
      let presentationTranslationMenuButton = null;
      let presentationTranslationMenuSearch = null;
      let presentationTranslationMenuList = null;
      let translationLanguageEmptyState = null;
      let translationLanguageOptionButtons = [];
      let translationMenuOpen = false;
      let translationMenuOutsideHandler = null;
      let translationMenuEscapeHandler = null;
      let presentationTranslationEl = null;
      const speechRecognitionConsumers = new Set();
      let translationTargetLanguage = (() => {
        try {
          const storedSpeech = localStorage.getItem(SPEECH_TRANSLATION_STORAGE_KEY);
          if (storedSpeech && TRANSLATION_LANGUAGE_MAP.has(storedSpeech)) {
            return storedSpeech;
          }
          const storedGeneral = localStorage.getItem(TRANSLATION_STORAGE_KEY);
          if (storedGeneral && TRANSLATION_LANGUAGE_MAP.has(storedGeneral)) {
            return storedGeneral;
          }
        } catch (error) {
          // ignore read errors
        }
        return DEFAULT_TRANSLATION_TARGET;
      })();
      let translationActive = false;
      let translationAbortController = null;
      let translationPending = false;
      let lastTranslationSource = '';
      let dictationLanguageMenu = null;
      let dictationLanguageList = null;
      let dictationLanguageSearch = null;
      let dictationLanguageEmptyState = null;
      let dictationLanguageOptionButtons = [];
      let dictationMenuOpen = false;
      let dictationMenuOutsideHandler = null;
      let dictationMenuEscapeHandler = null;
      let previousBackgroundColorValue = null;

      function getSpeechLanguageLabel(code) {
        const entry = SPEECH_LANGUAGE_MAP.get(code);
        return entry ? entry.label : code;
      }

      function updateDictationButtonLabel() {
        if (!dictateButton) return;
        if (!SpeechRecognitionConstructor) {
          dictateButton.setAttribute('aria-label', 'Dictation is not supported in this browser.');
          dictateButton.setAttribute('aria-expanded', 'false');
          return;
        }
        const languageLabel = getSpeechLanguageLabel(currentLanguage);
        const base = isDictating ? 'Stop dictation' : 'Dictate';
        dictateButton.title = `${base} (Language: ${languageLabel})`;
        dictateButton.setAttribute('aria-label', `${base}. Current language ${languageLabel}`);
        dictateButton.setAttribute('aria-expanded', dictationMenuOpen ? 'true' : 'false');
      }

      function updateDictationMenuSelection() {
        if (!dictationLanguageOptionButtons.length) return;
        dictationLanguageOptionButtons.forEach((button) => {
          const isActive = button.dataset.lang === currentLanguage;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
      }

      function filterDictationLanguageMenu(query) {
        if (!dictationLanguageOptionButtons.length || !dictationLanguageEmptyState) return;
        const filterValue = (query || '').trim().toLowerCase();
        let visibleCount = 0;
        dictationLanguageOptionButtons.forEach((button) => {
          const haystack = button.dataset.search || '';
          const matches = !filterValue || haystack.includes(filterValue);
          button.style.display = matches ? '' : 'none';
          if (matches) {
            visibleCount += 1;
          }
        });
        dictationLanguageEmptyState.classList.toggle('show', visibleCount === 0);
      }

      function buildDictationLanguageMenu() {
        if (!dictationLanguageList) return;
        dictationLanguageList.innerHTML = '';
        dictationLanguageOptionButtons = [];
        const fragment = document.createDocumentFragment();
        SPEECH_RECOGNITION_LANGUAGES.forEach((entry) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'dictation-language-option';
          button.dataset.lang = entry.code;
          button.dataset.search = `${entry.label} ${entry.code}`.toLowerCase();
          button.setAttribute('role', 'option');
          button.setAttribute('aria-selected', 'false');
          button.innerHTML = `
            <span class="option-label">${entry.label}</span>
            <span class="option-code">${entry.code}</span>
          `;
          button.addEventListener('click', () => {
            applySpeechRecognitionLanguage(entry.code, { announce: false, restartSubtitles: false });
            updateDictationMenuSelection();
            closeDictationLanguageMenu();
            beginDictation();
          });
          fragment.appendChild(button);
          dictationLanguageOptionButtons.push(button);
        });
        dictationLanguageList.appendChild(fragment);
        updateDictationMenuSelection();
        filterDictationLanguageMenu(dictationLanguageSearch ? dictationLanguageSearch.value : '');
      }

      function ensureDictationLanguageMenu() {
        if (dictationLanguageMenu) return;
        dictationLanguageMenu = document.createElement('div');
        dictationLanguageMenu.id = 'dictationLanguageMenu';
        dictationLanguageMenu.className = 'dictation-language-menu';
        dictationLanguageMenu.setAttribute('role', 'dialog');
        dictationLanguageMenu.setAttribute('aria-modal', 'false');
        dictationLanguageMenu.setAttribute('aria-hidden', 'true');
        dictationLanguageMenu.setAttribute('aria-label', 'Dictation language selector');
        dictationLanguageMenu.tabIndex = -1;
        dictationLanguageMenu.innerHTML = `
          <div class="dictation-menu-header">
            <span>Select dictation language</span>
            <button type="button" class="dictation-menu-close" aria-label="Close language menu">
              <i class="fas fa-xmark"></i>
            </button>
          </div>
          <div class="dictation-menu-search">
            <input type="search" class="dictation-language-search" placeholder="Search languages..." aria-label="Search dictation languages">
          </div>
          <div class="dictation-language-list" role="listbox" aria-label="Dictation languages"></div>
          <div class="dictation-language-empty">No languages found.</div>
        `;
        document.body.appendChild(dictationLanguageMenu);
        if (dictateButton) {
          dictateButton.setAttribute('aria-controls', 'dictationLanguageMenu');
        }
        dictationLanguageList = dictationLanguageMenu.querySelector('.dictation-language-list');
        dictationLanguageSearch = dictationLanguageMenu.querySelector('.dictation-language-search');
        dictationLanguageEmptyState = dictationLanguageMenu.querySelector('.dictation-language-empty');
        const closeButton = dictationLanguageMenu.querySelector('.dictation-menu-close');
        if (closeButton) {
          closeButton.addEventListener('click', () => {
            closeDictationLanguageMenu({ restoreFocus: true });
          });
        }
        if (dictationLanguageSearch) {
          dictationLanguageSearch.addEventListener('input', (event) => {
            filterDictationLanguageMenu(event.target.value);
          });
        }
        buildDictationLanguageMenu();
      }

      function positionDictationLanguageMenu() {
        if (!dictationLanguageMenu || !dictateButton) return;
        const rect = dictationLanguageMenu.getBoundingClientRect();
        const buttonRect = dictateButton.getBoundingClientRect();
        const scrollX = window.scrollX || window.pageXOffset || 0;
        const scrollY = window.scrollY || window.pageYOffset || 0;
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        let left = buttonRect.left + scrollX + (buttonRect.width / 2) - (rect.width / 2);
        let top = buttonRect.bottom + scrollY + 12;
        const minLeft = scrollX + 16;
        const maxLeft = scrollX + viewportWidth - rect.width - 16;
        left = Math.max(minLeft, Math.min(left, maxLeft));
        const minTop = scrollY + 16;
        const maxTop = scrollY + viewportHeight - rect.height - 16;
        if (top > maxTop) {
          top = buttonRect.top + scrollY - rect.height - 12;
        }
        top = Math.max(minTop, Math.min(top, maxTop));
        dictationLanguageMenu.style.left = `${left}px`;
        dictationLanguageMenu.style.top = `${top}px`;
      }

      function closeDictationLanguageMenu({ restoreFocus = false } = {}) {
        if (!dictationLanguageMenu || !dictationMenuOpen) return;
        dictationMenuOpen = false;
        dictationLanguageMenu.classList.remove('show');
        dictationLanguageMenu.style.display = 'none';
        dictationLanguageMenu.style.visibility = '';
        dictationLanguageMenu.setAttribute('aria-hidden', 'true');
        dictateButton?.setAttribute('aria-expanded', 'false');
        if (dictationMenuOutsideHandler) {
          document.removeEventListener('pointerdown', dictationMenuOutsideHandler, true);
          dictationMenuOutsideHandler = null;
        }
        if (dictationMenuEscapeHandler) {
          document.removeEventListener('keydown', dictationMenuEscapeHandler, true);
          dictationMenuEscapeHandler = null;
        }
        if (dictationLanguageSearch) {
          dictationLanguageSearch.value = '';
        }
        if (dictationLanguageEmptyState) {
          dictationLanguageEmptyState.classList.remove('show');
        }
        if (restoreFocus && dictateButton) {
          dictateButton.focus({ preventScroll: true });
        }
        updateDictationButtonLabel();
      }

      function openDictationLanguageMenu() {
        if (!dictateButton) return;
        ensureDictationLanguageMenu();
        if (!dictationLanguageMenu) return;
        if (dictationMenuOpen) {
          if (dictationLanguageSearch) {
            setTimeout(() => dictationLanguageSearch?.focus({ preventScroll: true }), 0);
          }
          return;
        }
        dictationLanguageMenu.style.display = 'flex';
        dictationLanguageMenu.classList.add('show');
        dictationLanguageMenu.style.visibility = 'hidden';
        dictationLanguageMenu.setAttribute('aria-hidden', 'false');
        dictationMenuOpen = true;
        dictateButton.setAttribute('aria-expanded', 'true');
        updateDictationMenuSelection();
        if (dictationLanguageSearch) {
          dictationLanguageSearch.value = '';
          filterDictationLanguageMenu('');
        }
        requestAnimationFrame(() => {
          positionDictationLanguageMenu();
          dictationLanguageMenu.style.visibility = 'visible';
        });
        dictationMenuOutsideHandler = (event) => {
          if (!dictationLanguageMenu.contains(event.target) && event.target !== dictateButton) {
            closeDictationLanguageMenu();
          }
        };
        dictationMenuEscapeHandler = (event) => {
          if (event.key === 'Escape') {
            event.preventDefault();
            closeDictationLanguageMenu({ restoreFocus: true });
          }
        };
        document.addEventListener('pointerdown', dictationMenuOutsideHandler, true);
        document.addEventListener('keydown', dictationMenuEscapeHandler, true);
        if (dictationLanguageSearch) {
          setTimeout(() => dictationLanguageSearch?.focus({ preventScroll: true }), 0);
        }
        updateDictationButtonLabel();
      }

      function toggleDictationLanguageMenu() {
        if (dictationMenuOpen) {
          closeDictationLanguageMenu();
        } else {
          openDictationLanguageMenu();
        }
      }

      function beginDictation() {
        closeDictationLanguageMenu();
        if (isDictating) {
          stopDictation({ commit: true, message: 'Dictation stopped.' });
          return;
        }
        if (!SpeechRecognitionConstructor) {
          showNotification('Speech recognition is not supported in this browser.');
          return;
        }
        try {
          dictateRecognition = new SpeechRecognitionConstructor();
        } catch (error) {
          console.error('Dictation init error', error);
          showNotification('Unable to access microphone.');
          dictateRecognition = null;
          return;
        }
        dictationFinalText = '';
        dictateRecognition.continuous = true;
        dictateRecognition.interimResults = true;
        const languageCode = (typeof currentLanguage === 'string' && currentLanguage)
          ? currentLanguage
          : DEFAULT_SPEECH_LANGUAGE;
        if (languageCode) {
          try {
            dictateRecognition.lang = languageCode;
          } catch (error) {
            console.warn('Unable to set dictation language', error);
          }
        }
        dictateTargetBox = addTextBoxAtCanvasPosition(canvas.clientWidth / 2, canvas.clientHeight / 2);
        if (!dictateTargetBox) {
          showNotification('Unable to create text box for dictation.');
          dictateRecognition = null;
          updateDictationButtonLabel();
          return;
        }
        dictateTargetBox.textContent = '';
        dictateTargetBox.dataset.placeholder = 'Listening...';
        dictateButton?.classList.add('active');
        isDictating = true;
        updateDictationButtonLabel();

        dictateRecognition.onresult = (event) => {
          let interim = '';
          for (let i = event.resultIndex; i < event.results.length; i += 1) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              dictationFinalText += transcript;
            } else {
              interim += transcript;
            }
          }
          if (dictateTargetBox) {
            dictateTargetBox.textContent = (dictationFinalText + interim).trim();
          }
        };

        dictateRecognition.onerror = (event) => {
          console.error('Dictation error', event);
          const reason = event && event.error ? `Dictation error: ${event.error}` : 'Dictation error.';
          stopDictation({ commit: false, message: reason });
        };

        dictateRecognition.onend = () => {
          dictateRecognition = null;
          if (!isDictating) return;
          resetDictationState({
            commit: true,
            message: dictationFinalText ? 'Dictation finished.' : 'Dictation ended.'
          });
        };

        try {
          dictateRecognition.start();
          const languageLabel = getSpeechLanguageLabel(languageCode);
          showNotification(`Dictation started in ${languageLabel}. Speak now.`);
        } catch (error) {
          console.error('Dictation start error', error);
          stopDictation({ commit: false, message: 'Unable to start dictation.' });
          updateDictationButtonLabel();
        }
      }

      function updateSubtitleMenuButtonLabel() {
        if (!presentationSubtitleMenuButton) return;
        if (!subtitlesSupported) {
          presentationSubtitleMenuButton.setAttribute('title', 'Subtitles are not supported in this browser.');
          presentationSubtitleMenuButton.setAttribute('aria-label', 'Subtitle options unavailable. Subtitles are not supported in this browser.');
          return;
        }
        const languageLabel = getSpeechLanguageLabel(currentLanguage);
        presentationSubtitleMenuButton.setAttribute('title', `Subtitle options (Language: ${languageLabel})`);
        presentationSubtitleMenuButton.setAttribute('aria-label', `Subtitle options. Current language ${languageLabel}`);
      }

      function updateSubtitleToggleLabel() {
        if (!presentationSubtitleToggle) return;
        if (!subtitlesSupported) {
          presentationSubtitleToggle.title = 'Subtitles are not supported in this browser.';
          return;
        }
        const languageLabel = getSpeechLanguageLabel(currentLanguage);
        const base = subtitlesActive ? 'Disable subtitles' : 'Enable subtitles';
        presentationSubtitleToggle.title = `${base} (Language: ${languageLabel})`;
      }

      function getTranslationLanguageLabel(code) {
        const entry = TRANSLATION_LANGUAGE_MAP.get(code);
        return entry ? entry.label : code;
      }

      function updateTranslationMenuButtonLabel() {
        if (!presentationTranslationMenuButton) return;
        if (!subtitlesSupported) {
          presentationTranslationMenuButton.setAttribute('title', 'Live translation is not supported in this browser.');
          presentationTranslationMenuButton.setAttribute('aria-label', 'Translation options unavailable. Live translation is not supported in this browser.');
          return;
        }
        const label = getTranslationLanguageLabel(translationTargetLanguage);
        presentationTranslationMenuButton.setAttribute('title', `Translation options (Target: ${label})`);
        presentationTranslationMenuButton.setAttribute('aria-label', `Translation options. Current target ${label}`);
      }

      function updateTranslationToggleLabel() {
        if (!presentationTranslationToggle) return;
        if (!subtitlesSupported) {
          presentationTranslationToggle.title = 'Live translation is not supported in this browser.';
          return;
        }
        const sourceLabel = getSpeechLanguageLabel(currentLanguage);
        const targetLabel = getTranslationLanguageLabel(translationTargetLanguage);
        const base = translationActive ? 'Disable translation' : 'Enable translation';
        presentationTranslationToggle.title = `${base} (${sourceLabel} -> ${targetLabel})`;
      }

      function updateTranslationMenuSelection() {
        if (!translationLanguageOptionButtons.length) return;
        translationLanguageOptionButtons.forEach((button) => {
          const isActive = button.dataset.lang === translationTargetLanguage;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
      }

      function filterTranslationLanguageMenu(query) {
        if (!translationLanguageOptionButtons.length || !translationLanguageEmptyState) return;
        const filterValue = (query || '').trim().toLowerCase();
        let visibleCount = 0;
        translationLanguageOptionButtons.forEach((button) => {
          const haystack = button.dataset.search || '';
          const matches = !filterValue || haystack.includes(filterValue);
          button.style.display = matches ? '' : 'none';
          if (matches) {
            visibleCount += 1;
          }
        });
        translationLanguageEmptyState.classList.toggle('show', visibleCount === 0);
      }

      function positionTranslationLanguageMenu() {
        if (!presentationTranslationMenu || !presentationTranslationMenuButton) return;
        const overlayRect = presentationOverlay.getBoundingClientRect();
        const buttonRect = presentationTranslationMenuButton.getBoundingClientRect();
        const menuRect = presentationTranslationMenu.getBoundingClientRect();

        let left = buttonRect.right - overlayRect.left - menuRect.width;
        let top = buttonRect.top - overlayRect.top - menuRect.height - 12;

        if (left < 16) {
          left = 16;
        }
        if (top < 16) {
          top = buttonRect.bottom - overlayRect.top + 12;
        }
        const maxLeft = overlayRect.width - menuRect.width - 16;
        const maxTop = overlayRect.height - menuRect.height - 16;
        presentationTranslationMenu.style.left = `${Math.min(Math.max(left, 16), Math.max(maxLeft, 16))}px`;
        presentationTranslationMenu.style.top = `${Math.min(Math.max(top, 16), Math.max(maxTop, 16))}px`;
      }

      function closeTranslationLanguageMenu({ restoreFocus = false } = {}) {
        if (!presentationTranslationMenu || !translationMenuOpen) return;
        translationMenuOpen = false;
        presentationTranslationMenu.classList.remove('show');
        presentationTranslationMenu.style.display = 'none';
        presentationTranslationMenuButton?.setAttribute('aria-expanded', 'false');
        if (translationMenuOutsideHandler) {
          document.removeEventListener('pointerdown', translationMenuOutsideHandler, true);
          translationMenuOutsideHandler = null;
        }
        if (translationMenuEscapeHandler) {
          document.removeEventListener('keydown', translationMenuEscapeHandler, true);
          translationMenuEscapeHandler = null;
        }
        if (restoreFocus && presentationTranslationMenuButton) {
          presentationTranslationMenuButton.focus({ preventScroll: true });
        }
      }

      function openTranslationLanguageMenu({ focusSearch = true } = {}) {
        if (!presentationTranslationMenu || !presentationTranslationMenuButton) return;
        if (translationMenuOpen) {
          if (focusSearch && presentationTranslationMenuSearch) {
            presentationTranslationMenuSearch.focus({ preventScroll: true });
          }
          return;
        }
        presentationTranslationMenu.style.display = 'flex';
        presentationTranslationMenu.classList.add('show');
        presentationTranslationMenu.style.visibility = 'hidden';
        positionTranslationLanguageMenu();
        presentationTranslationMenu.style.visibility = 'visible';
        translationMenuOpen = true;
        presentationTranslationMenuButton.setAttribute('aria-expanded', 'true');
        translationMenuOutsideHandler = (event) => {
          if (!presentationTranslationMenu.contains(event.target) && event.target !== presentationTranslationMenuButton) {
            closeTranslationLanguageMenu();
          }
        };
        translationMenuEscapeHandler = (event) => {
          if (event.key === 'Escape') {
            closeTranslationLanguageMenu({ restoreFocus: true });
          }
        };
        document.addEventListener('pointerdown', translationMenuOutsideHandler, true);
        document.addEventListener('keydown', translationMenuEscapeHandler, true);
        if (presentationTranslationMenuSearch) {
          presentationTranslationMenuSearch.value = '';
          filterTranslationLanguageMenu('');
          if (focusSearch) {
            setTimeout(() => {
              presentationTranslationMenuSearch?.focus({ preventScroll: true });
            }, 0);
          }
        }
      }

      function toggleTranslationLanguageMenu() {
        if (translationMenuOpen) {
          closeTranslationLanguageMenu({ restoreFocus: false });
        } else {
          openTranslationLanguageMenu();
        }
      }

      function buildTranslationLanguageMenu() {
        if (!presentationTranslationMenuList) return;
        presentationTranslationMenuList.innerHTML = '';
        translationLanguageOptionButtons = [];
        const fragment = document.createDocumentFragment();
        TRANSLATION_LANGUAGES.forEach((entry) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'translation-language-option';
          button.dataset.lang = entry.code;
          button.dataset.search = `${entry.label} ${entry.code}`.toLowerCase();
          button.setAttribute('role', 'option');
          button.setAttribute('aria-selected', entry.code === translationTargetLanguage ? 'true' : 'false');
          button.innerHTML = `
            <span class="option-label">${entry.label}</span>
            <span class="option-code">${entry.code}</span>
          `;
          button.addEventListener('click', () => {
            translationTargetLanguage = entry.code;
            try {
              localStorage.setItem(SPEECH_TRANSLATION_STORAGE_KEY, translationTargetLanguage);
              localStorage.setItem(TRANSLATION_STORAGE_KEY, translationTargetLanguage);
            } catch (error) {
              // ignore storage errors
            }
            updateTranslationMenuSelection();
            updateTranslationMenuButtonLabel();
            updateTranslationToggleLabel();
            closeTranslationLanguageMenu({ restoreFocus: true });
            if (translationActive && lastTranslationSource) {
              requestTranslationForText(lastTranslationSource);
            }
          });
          fragment.appendChild(button);
          translationLanguageOptionButtons.push(button);
        });
        presentationTranslationMenuList.appendChild(fragment);
        updateTranslationMenuSelection();
        filterTranslationLanguageMenu('');
      }

      function updateTranslationDisplay(text) {
        if (!presentationTranslationEl) return;
        const normalized = typeof text === 'string' ? text : '';
        if (normalized) {
          presentationTranslationEl.textContent = normalized;
          presentationTranslationEl.classList.add('show');
        } else if (translationActive) {
          presentationTranslationEl.textContent = '';
          presentationTranslationEl.classList.remove('show');
        } else {
          presentationTranslationEl.textContent = '';
          presentationTranslationEl.classList.remove('show');
        }
      }

      function resetTranslationState({ message = null } = {}) {
        translationPending = false;
        lastTranslationSource = '';
        if (translationAbortController) {
          translationAbortController.abort();
          translationAbortController = null;
        }
        if (presentationTranslationEl) {
          presentationTranslationEl.textContent = '';
          presentationTranslationEl.classList.remove('show');
        }
        if (message) {
          showNotification(message);
        }
      }

      function maybeStopSpeechRecognition() {
        if (!speechRecognitionConsumers.size) {
          stopSpeechRecognitionEngine({ message: null });
        }
      }

      function stopSpeechRecognitionEngine({ message = null } = {}) {
        if (!subtitlesRecognition) {
          if (message) {
            showNotification(message);
          }
          return;
        }
        try {
          subtitlesRecognition.onresult = null;
          subtitlesRecognition.onerror = null;
          subtitlesRecognition.onend = null;
          subtitlesRecognition.stop();
        } catch (error) {
          console.warn('Speech recognition stop error', error);
        }
        subtitlesRecognition = null;
        subtitlesFinalText = '';
        translationPending = false;
        if (translationAbortController) {
          translationAbortController.abort();
          translationAbortController = null;
        }
        if (message) {
          showNotification(message);
        }
      }

      function ensureSpeechRecognition({ skipNotification = false } = {}) {
        if (!isPresenting) {
          if (!skipNotification) {
            showNotification('Start presentation to enable live speech features.');
          }
          return false;
        }
        if (!subtitlesSupported) {
          if (!skipNotification) {
            showNotification('Speech recognition is not supported in this browser.');
          }
          return false;
        }
        if (isDictating) {
          stopDictation({ commit: true, message: 'Dictation stopped to enable speech features.' });
        }
        if (!subtitlesRecognition) {
          try {
            subtitlesRecognition = new SpeechRecognitionConstructor();
          } catch (error) {
            console.error('Speech recognition init error', error);
            subtitlesRecognition = null;
            if (!skipNotification) {
              showNotification('Unable to access microphone for speech recognition.');
            }
            return false;
          }
          subtitlesRecognition.continuous = true;
          subtitlesRecognition.interimResults = true;
          if (typeof currentLanguage === 'string' && currentLanguage) {
            try {
              subtitlesRecognition.lang = currentLanguage;
            } catch (error) {
              console.warn('Unable to set speech recognition language', error);
            }
          }
          subtitlesRecognition.onresult = handleSpeechRecognitionResult;
          subtitlesRecognition.onerror = handleSpeechRecognitionError;
          subtitlesRecognition.onend = handleSpeechRecognitionEnd;
          subtitlesFinalText = '';
          try {
            subtitlesRecognition.start();
          } catch (error) {
            console.error('Speech recognition start error', error);
            subtitlesRecognition = null;
            if (!skipNotification) {
              showNotification('Unable to start speech recognition.');
            }
            return false;
          }
        } else if (typeof currentLanguage === 'string' && currentLanguage) {
          try {
            subtitlesRecognition.lang = currentLanguage;
          } catch (error) {
            console.warn('Unable to update speech recognition language', error);
          }
        }
        return true;
      }

      function restartSpeechRecognition({ skipNotification = true } = {}) {
        if (!speechRecognitionConsumers.size) {
          stopSpeechRecognitionEngine({ message: null });
          return;
        }
        stopSpeechRecognitionEngine({ message: null });
        if (!ensureSpeechRecognition({ skipNotification })) {
          return;
        }
        if (subtitlesActive) {
          updateSubtitlesDisplay('Listeningâ€¦', { scheduleClear: false });
        }
        if (translationActive) {
          if (subtitlesFinalText) {
            requestTranslationForText(subtitlesFinalText);
          } else {
            updateTranslationDisplay('Listeningâ€¦');
          }
        }
      }

      async function requestTranslationForText(text) {
        if (!translationActive) return;
        const normalized = typeof text === 'string' ? text.trim() : '';
        if (!normalized) {
          updateTranslationDisplay('');
          translationPending = false;
          return;
        }
        if (normalized === lastTranslationSource && translationPending) {
          return;
        }
        if (normalized === lastTranslationSource && !translationPending) {
          return;
        }
        lastTranslationSource = normalized;
        if (translationAbortController) {
          translationAbortController.abort();
        }
        translationAbortController = new AbortController();
        translationPending = true;
        updateTranslationDisplay('Translatingâ€¦');
        try {
          const controller = translationAbortController;
          const timeoutId = window.setTimeout(() => controller.abort(), 12000);
          const response = await fetch(TRANSLATION_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              q: normalized,
              source: 'auto',
              target: translationTargetLanguage,
              format: 'text'
            }),
            signal: controller.signal
          });
          window.clearTimeout(timeoutId);
          translationPending = false;
          if (controller !== translationAbortController) {
            return;
          }
          translationAbortController = null;
          if (!translationActive) {
            return;
          }
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          const translated = typeof data === 'object' && data !== null && typeof data.translatedText === 'string'
            ? data.translatedText.trim()
            : '';
          if (translated) {
            updateTranslationDisplay(translated);
          } else {
            updateTranslationDisplay('Translation unavailable.');
          }
        } catch (error) {
          if (error && error.name === 'AbortError') {
            translationPending = false;
            if (translationAbortController === null) {
              updateTranslationDisplay('');
            }
            return;
          }
        translationPending = false;
        translationAbortController = null;
        if (translationActive) {
          console.error('Translation error', error);
          updateTranslationDisplay('Translation unavailable.');
        }
      }
      }

      function startTranslation({ skipNotification = false } = {}) {
        if (!ensureSpeechRecognition({ skipNotification })) {
          return;
        }
        if (!speechRecognitionConsumers.has('translation')) {
          speechRecognitionConsumers.add('translation');
        }
        if (translationActive) {
          return;
        }
        translationActive = true;
        updateTranslationToggleLabel();
        if (presentationTranslationToggle) {
          presentationTranslationToggle.classList.add('active');
          presentationTranslationToggle.setAttribute('aria-pressed', 'true');
        }
        if (subtitlesFinalText) {
          requestTranslationForText(subtitlesFinalText);
        } else {
          updateTranslationDisplay('Listeningâ€¦');
        }
        if (!skipNotification) {
          showNotification('Translation enabled.');
        }
      }

      function stopTranslation({ message = null, suppressSpeechStop = false } = {}) {
        if (!speechRecognitionConsumers.has('translation') && !translationActive) {
          return;
        }
        translationActive = false;
        speechRecognitionConsumers.delete('translation');
        if (presentationTranslationToggle) {
          presentationTranslationToggle.classList.remove('active');
          presentationTranslationToggle.setAttribute('aria-pressed', 'false');
        }
        resetTranslationState({ message: null });
        updateTranslationToggleLabel();
        if (message) {
          showNotification(message);
        }
        if (!suppressSpeechStop) {
          maybeStopSpeechRecognition();
        }
      }

      function toggleTranslation() {
        if (translationActive) {
          stopTranslation({ message: 'Translation disabled.' });
        } else {
          startTranslation();
        }
      }

      function handleSpeechRecognitionResult(event) {
        if (!event || !event.results) return;
        let interim = '';
        let newFinalText = null;
        for (let i = event.resultIndex; i < event.results.length; i += 1) {
          const result = event.results[i];
          if (!result || !result[0]) continue;
          const transcript = result[0].transcript;
          if (result.isFinal) {
            const trimmed = typeof transcript === 'string' ? transcript.trim() : '';
            if (trimmed) {
              newFinalText = trimmed;
            }
          } else if (transcript) {
            interim += transcript;
          }
        }
        if (newFinalText !== null) {
          subtitlesFinalText = newFinalText.length > SUBTITLES_MAX_BUFFER
            ? newFinalText.slice(-SUBTITLES_MAX_BUFFER)
            : newFinalText;
        }
        const interimText = interim.trim();
        const displayText = interimText || subtitlesFinalText;
        if (subtitlesActive) {
          if (displayText) {
            updateSubtitlesDisplay(displayText, { scheduleClear: !interimText });
          } else {
            updateSubtitlesDisplay('', { scheduleClear: false });
          }
        }
        if (translationActive) {
          if (interimText) {
            updateTranslationDisplay('Translatingâ€¦');
          } else if (newFinalText) {
            requestTranslationForText(subtitlesFinalText);
          } else if (!subtitlesFinalText) {
            updateTranslationDisplay('Listeningâ€¦');
          }
        }
      }

      function handleSpeechRecognitionError(event) {
        console.error('Speech recognition error', event);
        const reason = event && event.error
          ? `Speech recognition error: ${event.error}`
          : 'Speech recognition error.';
        handleSpeechRecognitionFailure(reason);
      }

      function handleSpeechRecognitionEnd() {
        if (!speechRecognitionConsumers.size) {
          stopSpeechRecognitionEngine({ message: null });
          return;
        }
        if (!subtitlesRecognition) {
          ensureSpeechRecognition({ skipNotification: true });
          return;
        }
        try {
          subtitlesRecognition.start();
        } catch (error) {
          console.error('Speech recognition restart error', error);
          handleSpeechRecognitionFailure('Speech recognition stopped.');
        }
      }

      function handleSpeechRecognitionFailure(message) {
        stopTranslation({ message: null, suppressSpeechStop: true });
        stopSubtitles({ message: null, suppressSpeechStop: true });
        speechRecognitionConsumers.clear();
        stopSpeechRecognitionEngine({ message });
      }

      function updateSubtitleMenuSelection() {
        if (!subtitleLanguageOptionButtons.length) return;
        subtitleLanguageOptionButtons.forEach((button) => {
          const isActive = button.dataset.lang === currentLanguage;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
      }

      function filterSubtitleLanguageMenu(query) {
        if (!subtitleLanguageOptionButtons.length || !subtitleLanguageEmptyState) return;
        const filterValue = (query || '').trim().toLowerCase();
        let visibleCount = 0;
        subtitleLanguageOptionButtons.forEach((button) => {
          const haystack = button.dataset.search || '';
          const matches = !filterValue || haystack.includes(filterValue);
          button.style.display = matches ? '' : 'none';
          if (matches) {
            visibleCount += 1;
          }
        });
        subtitleLanguageEmptyState.classList.toggle('show', visibleCount === 0);
      }

      function positionSubtitleLanguageMenu() {
        if (!presentationSubtitleMenu || !presentationSubtitleMenuButton) return;
        const overlayRect = presentationOverlay.getBoundingClientRect();
        const buttonRect = presentationSubtitleMenuButton.getBoundingClientRect();
        const menuRect = presentationSubtitleMenu.getBoundingClientRect();

        let left = buttonRect.right - overlayRect.left - menuRect.width;
        let top = buttonRect.top - overlayRect.top - menuRect.height - 12;

        if (left < 16) {
          left = 16;
        }
        if (top < 16) {
          top = buttonRect.bottom - overlayRect.top + 12;
        }
        const maxLeft = overlayRect.width - menuRect.width - 16;
        const maxTop = overlayRect.height - menuRect.height - 16;
        presentationSubtitleMenu.style.left = `${Math.min(Math.max(left, 16), Math.max(maxLeft, 16))}px`;
        presentationSubtitleMenu.style.top = `${Math.min(Math.max(top, 16), Math.max(maxTop, 16))}px`;
      }

      function closeSubtitleLanguageMenu({ restoreFocus = false } = {}) {
        if (!presentationSubtitleMenu || !subtitleMenuOpen) return;
        subtitleMenuOpen = false;
        presentationSubtitleMenu.classList.remove('show');
        presentationSubtitleMenu.style.display = 'none';
        presentationSubtitleMenuButton?.setAttribute('aria-expanded', 'false');
        if (subtitleMenuOutsideHandler) {
          document.removeEventListener('pointerdown', subtitleMenuOutsideHandler, true);
          subtitleMenuOutsideHandler = null;
        }
        if (subtitleMenuEscapeHandler) {
          document.removeEventListener('keydown', subtitleMenuEscapeHandler, true);
          subtitleMenuEscapeHandler = null;
        }
        if (restoreFocus && presentationSubtitleMenuButton) {
          presentationSubtitleMenuButton.focus({ preventScroll: true });
        }
      }

      function openSubtitleLanguageMenu({ focusSearch = true } = {}) {
        if (!presentationSubtitleMenu || !presentationSubtitleMenuButton) return;
        if (subtitleMenuOpen) {
          if (focusSearch && presentationSubtitleMenuSearch) {
            presentationSubtitleMenuSearch.focus({ preventScroll: true });
          }
          return;
        }
        presentationSubtitleMenu.style.display = 'flex';
        presentationSubtitleMenu.classList.add('show');
        presentationSubtitleMenu.style.visibility = 'hidden';
        positionSubtitleLanguageMenu();
        presentationSubtitleMenu.style.visibility = 'visible';
        subtitleMenuOpen = true;
        presentationSubtitleMenuButton.setAttribute('aria-expanded', 'true');
        subtitleMenuOutsideHandler = (event) => {
          if (!presentationSubtitleMenu.contains(event.target) && event.target !== presentationSubtitleMenuButton) {
            closeSubtitleLanguageMenu();
          }
        };
        subtitleMenuEscapeHandler = (event) => {
          if (event.key === 'Escape') {
            closeSubtitleLanguageMenu({ restoreFocus: true });
          }
        };
        document.addEventListener('pointerdown', subtitleMenuOutsideHandler, true);
        document.addEventListener('keydown', subtitleMenuEscapeHandler, true);
        if (presentationSubtitleMenuSearch) {
          presentationSubtitleMenuSearch.value = '';
          filterSubtitleLanguageMenu('');
          if (focusSearch) {
            setTimeout(() => {
              presentationSubtitleMenuSearch?.focus({ preventScroll: true });
            }, 0);
          }
        }
      }

      function toggleSubtitleLanguageMenu() {
        if (subtitleMenuOpen) {
          closeSubtitleLanguageMenu({ restoreFocus: false });
        } else {
          openSubtitleLanguageMenu();
        }
      }

      function buildSubtitleLanguageMenu() {
        if (!presentationSubtitleMenuList) return;
        presentationSubtitleMenuList.innerHTML = '';
        subtitleLanguageOptionButtons = [];
        const fragment = document.createDocumentFragment();
        SPEECH_RECOGNITION_LANGUAGES.forEach((entry) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'subtitle-language-option';
          button.dataset.lang = entry.code;
          button.dataset.search = `${entry.label} ${entry.code}`.toLowerCase();
          button.setAttribute('role', 'option');
          button.innerHTML = `
            <span class="option-label">${entry.label}</span>
            <span class="option-code">${entry.code}</span>
          `;
          button.addEventListener('click', () => {
            applySpeechRecognitionLanguage(entry.code);
            closeSubtitleLanguageMenu({ restoreFocus: true });
          });
          fragment.appendChild(button);
          subtitleLanguageOptionButtons.push(button);
        });
        presentationSubtitleMenuList.appendChild(fragment);
        updateSubtitleMenuSelection();
        filterSubtitleLanguageMenu('');
      }

      function applySpeechRecognitionLanguage(code, { announce = true, restartSubtitles = true } = {}) {
        if (!code || !SPEECH_LANGUAGE_MAP.has(code)) {
          showNotification('Selected language is not supported.');
          return;
        }
        if (code === currentLanguage) {
          if (announce) {
            showNotification(`Subtitles language is already ${getSpeechLanguageLabel(currentLanguage)}.`);
          }
          return;
        }
        currentLanguage = code;
        try {
          localStorage.setItem(SPEECH_LANGUAGE_STORAGE_KEY, currentLanguage);
        } catch (error) {
          // ignore storage write errors
        }
        updateSubtitleMenuSelection();
        updateSubtitleMenuButtonLabel();
        updateSubtitleToggleLabel();
        updateTranslationToggleLabel();
        updateTranslationMenuButtonLabel();
        updateDictationMenuSelection();
        updateDictationButtonLabel();
        if (announce) {
          showNotification(`Subtitles language set to ${getSpeechLanguageLabel(code)}.`);
        }
        if (subtitlesActive && restartSubtitles) {
          const wasMenuOpen = subtitleMenuOpen;
          stopSubtitles({ message: null, suppressSpeechStop: true });
          startSubtitles({ skipNotification: true });
          if (wasMenuOpen) {
            setTimeout(() => {
              openSubtitleLanguageMenu({ focusSearch: false });
            }, 0);
          }
        }
        if (speechRecognitionConsumers.size) {
          restartSpeechRecognition({ skipNotification: true });
          if (translationActive && subtitlesFinalText) {
            requestTranslationForText(subtitlesFinalText);
          }
        }
      }
      const fontPickerButton = document.getElementById('fontPickerButton');
      const fontPickerLabel = document.getElementById('fontPickerLabel');
      const shapePickerButton = document.getElementById('shapePickerButton');
      const chartPickerButton = document.getElementById('chartPickerButton');
      const imagePickerButton = document.getElementById('imagePickerButton');
      const videoPickerButton = document.getElementById('videoPickerButton');
      const tablePickerButton = document.getElementById('tablePickerButton');
      const logoPickerButton = document.getElementById('logoPickerButton');
      const iconPickerButton = document.getElementById('iconPickerButton');
      const transitionEffectSelect = document.getElementById('transitionEffectSelect');
      const transitionDurationInput = document.getElementById('transitionDurationInput');
      const applyTransitionAllButton = document.getElementById('applyTransitionAllButton');
      const animationEffectSelect = document.getElementById('animationEffectSelect');
      const animationDurationInput = document.getElementById('animationDurationInput');
      const assignAnimationButton = document.getElementById('assignAnimationButton');
      const removeAnimationButton = document.getElementById('removeAnimationButton');
      const animationSequenceList = document.getElementById('animationSequenceList');
      const animationSequenceContainer = document.querySelector('.animation-sequence-container');
      const animationSequenceCloseButton = document.getElementById('closeAnimationSequenceButton');
      const animationTabButton = document.getElementById('toolbar-tab-animations');
      const spellCheckToggleButton = document.getElementById('spellCheckToggle');
      const spellCheckToggleState = spellCheckToggleButton
        ? spellCheckToggleButton.querySelector('[data-role="spell-toggle-state"]')
        : null;
      const translateToolButton = document.getElementById('translateToolButton');
      const zoomOutButton = document.getElementById('zoomOutButton');
      const zoomInButton = document.getElementById('zoomInButton');
      const zoomResetButton = document.getElementById('zoomResetButton');
      const zoomDisplay = document.getElementById('zoomDisplay');
      const canvasWrap = document.querySelector('.canvas-wrap');
      const commentsPanel = document.getElementById('commentsPanel');
      const commentsList = document.getElementById('commentsList');
      const commentsCount = document.getElementById('commentsCount');
      const commentForm = document.getElementById('commentForm');
      const commentInput = document.getElementById('commentInput');
      const commentSubmitButton = document.getElementById('commentSubmitButton');
      const sidebarViewButtons = Array.from(document.querySelectorAll('[data-sidebar-view]'));
      const SIDEBAR_VIEW_STORAGE_KEY = 'editorSidebarViewMode';
      let sidebarViewMode = (localStorage.getItem(SIDEBAR_VIEW_STORAGE_KEY) || 'list') === 'thumbnail' ? 'thumbnail' : 'list';
      // Use SidebarThumbnailManager for thumbnail generation
      let thumbnailManager = null;
      
      function ensureSlideComments(slide) {
        if (!slide) return [];
        if (!Array.isArray(slide.comments)) {
          slide.comments = [];
        }
        return slide.comments;
      }

      function initializeThumbnailManager() {
        if (typeof SidebarThumbnailManager === 'undefined') {
          // Wait for script to load
          setTimeout(initializeThumbnailManager, 100);
          return;
        }
        
        if (!thumbnailManager && sidebar && canvas) {
          thumbnailManager = new SidebarThumbnailManager({
            sidebar: sidebar,
            canvas: canvas,
            slides: slides,
            activeSlideIndex: active,
            onSlideChange: (index) => {
              active = index;
            },
            onLoad: () => {
              load();
            },
            onRender: () => {
              renderSidebar();
            }
          });
        }
      }
      
      function invalidateSidebarThumbnails() {
        if (thumbnailManager) {
          thumbnailManager.invalidateAll();
        }
      }
      
      function shouldRegenerateThumbnails() {
        if (sidebarViewMode !== 'thumbnail') return false;
        if (!thumbnailManager) return true;
        return thumbnailManager.shouldGenerate();
      }

      function updateSidebarViewButtons() {
        if (!sidebarViewButtons.length) return;
        sidebarViewButtons.forEach((button) => {
          const mode = button.dataset.sidebarView;
          const isActive = mode === sidebarViewMode;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      function setSidebarViewMode(mode) {
        if (mode !== 'list' && mode !== 'thumbnail') return;
        if (sidebarViewMode === mode) return;
        sidebarViewMode = mode;
        localStorage.setItem(SIDEBAR_VIEW_STORAGE_KEY, sidebarViewMode);
        updateSidebarViewButtons();
        if (sidebarViewMode === 'thumbnail') {
          ensureSidebarThumbnails();
        }
        renderSidebar();
      }

      if (sidebarViewButtons.length) {
        sidebarViewButtons.forEach((button) => {
          button.addEventListener('click', () => {
            setSidebarViewMode(button.dataset.sidebarView);
          });
        });
      }
      updateSidebarViewButtons();
      if (sidebarViewMode === 'thumbnail') {
        ensureSidebarThumbnails();
      }

      function formatCommentTimestamp(value) {
        if (!value) return '';
        try {
          return new Date(value).toLocaleString(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short'
          });
        } catch (error) {
          return value;
        }
      }

      function renderComments() {
        if (!commentsList || !commentsCount) return;
        const slide = slides[active];
        const comments = ensureSlideComments(slide);
        commentsList.innerHTML = '';
        if (commentInput) {
          commentInput.value = '';
        }
        if (commentSubmitButton) {
          commentSubmitButton.disabled = true;
        }
        if (!comments.length) {
          const emptyState = document.createElement('div');
          emptyState.className = 'comment-empty';
          emptyState.textContent = 'No comments yet. Share your thoughts about this slide.';
          commentsList.appendChild(emptyState);
        } else {
          comments.forEach((comment) => {
            const commentItem = document.createElement('article');
            commentItem.className = 'comment-item';
            commentItem.setAttribute('role', 'listitem');

            const textElement = document.createElement('p');
            textElement.className = 'comment-text';
            textElement.textContent = comment.text || '';
            commentItem.appendChild(textElement);

            const metaRow = document.createElement('div');
            metaRow.className = 'comment-meta';

            const timestamp = document.createElement('span');
            timestamp.textContent = formatCommentTimestamp(comment.createdAt);
            metaRow.appendChild(timestamp);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'comment-delete';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
              deleteComment(comment.id);
            });
            metaRow.appendChild(deleteButton);

            commentItem.appendChild(metaRow);
            commentsList.appendChild(commentItem);
          });
        }

        const count = comments.length;
        commentsCount.textContent = count === 1 ? '1 comment' : `${count} comments`;
      }

      function addComment(text) {
        const trimmed = text.trim();
        if (!trimmed) return;
        const slide = slides[active];
        const comments = ensureSlideComments(slide);
        const comment = {
          id: generateElementId('comment'),
          text: trimmed,
          createdAt: new Date().toISOString()
        };
        comments.push(comment);
        renderComments();
        if (commentInput) {
          commentInput.focus();
        }
        capture();
        saveEditorState('add_comment');
      }

      function deleteComment(commentId) {
        const slide = slides[active];
        const comments = ensureSlideComments(slide);
        const index = comments.findIndex((comment) => comment.id === commentId);
        if (index === -1) return;
        comments.splice(index, 1);
        renderComments();
        if (commentInput) {
          commentInput.focus();
        }
        capture();
        saveEditorState('delete_comment');
      }

      async function ensureSidebarThumbnails() {
        if (sidebarViewMode !== 'thumbnail') return;
        
        // Initialize manager if needed
        if (!thumbnailManager) {
          initializeThumbnailManager();
          if (!thumbnailManager) return; // Still loading
        }
        
        // Update references
        thumbnailManager.updateReferences({
          slides: slides,
          activeSlideIndex: active,
          canvas: canvas,
          sidebar: sidebar
        });
        
        // Generate thumbnails
        await thumbnailManager.generateThumbnails();
      }

      function handleCommentSubmit(event) {
        event.preventDefault();
        if (!commentInput) return;
        const value = commentInput.value || '';
        if (!value.trim()) return;
        addComment(value);
      }

      if (commentForm) {
        commentForm.addEventListener('submit', handleCommentSubmit);
      }

      if (commentInput && commentSubmitButton) {
        commentSubmitButton.disabled = true;
        commentInput.addEventListener('input', () => {
          const hasText = Boolean(commentInput.value && commentInput.value.trim());
          commentSubmitButton.disabled = !hasText;
        });
      }

      let canvasZoom = 1;
      const MIN_CANVAS_ZOOM = 0.25;
      const MAX_CANVAS_ZOOM = 3;
      const CANVAS_ZOOM_STEP = 0.1;
      const CANVAS_WHEEL_ZOOM_STEP = 0.05;
      let animationDragState = {
        sourceId: null,
        targetId: null
      };
      let isAnimationSequencePanelVisible = false;
      if (animationEffectSelect) {
        animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
      }
      if (animationDurationInput) {
        animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
      }
      const initialSlide = slides[0];
      if (initialSlide) {
        if (!initialSlide.titleBox) {
          initialSlide.titleBox = { id: ensureElementHasId(titleBox, 'title') };
        }
        if (!initialSlide.titleBox.id) {
          initialSlide.titleBox.id = ensureElementHasId(titleBox, 'title');
        } else {
          titleBox.dataset.elementId = initialSlide.titleBox.id;
        }
        if (!initialSlide.textBox) {
          initialSlide.textBox = { id: ensureElementHasId(textBox, 'body') };
        }
        if (!initialSlide.textBox.id) {
          initialSlide.textBox.id = ensureElementHasId(textBox, 'body');
        } else {
          textBox.dataset.elementId = initialSlide.textBox.id;
        }
        if (!Array.isArray(initialSlide.animations)) {
          initialSlide.animations = [];
        }
      } else {
        ensureElementHasId(titleBox, 'title');
        ensureElementHasId(textBox, 'body');
      }
      const DEFAULT_FONT_FAMILY = window.getComputedStyle(textBox).fontFamily || DEFAULT_FONT_STACK;
      titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
      textBox.dataset.rotation = textBox.dataset.rotation || '0';
      titleBox.style.transform = `rotate(${parseFloat(titleBox.dataset.rotation || '0')}deg)`;
      textBox.style.transform = `rotate(${parseFloat(textBox.dataset.rotation || '0')}deg)`;
      titleBox.dataset.minWidth = titleBox.dataset.minWidth || '200';
      titleBox.dataset.minHeight = titleBox.dataset.minHeight || '50';
      textBox.dataset.minWidth = textBox.dataset.minWidth || '200';
      textBox.dataset.minHeight = textBox.dataset.minHeight || '50';
      titleBox.style.display = 'none';
      textBox.style.display = 'none';
      let isExportingPresentation = false;
      const CANVAS_INTERACTIVE_SELECTOR = '.text-box, #titleBox, #textBox, .additional-text-box, .shape-element, .chart-element, .image-element, .video-element, .table-element, .icon-element, .table-resize-handle, .table-selection-border-handle, .resize-edge, .shape-rotation-handle';

      if (canvas) {
        canvas.addEventListener('pointerdown', handleCanvasPointerDown, { passive: false });
        // Track last click time and position for double-click detection
        let lastClickTime = 0;
        let lastClickX = 0;
        let lastClickY = 0;
        const DOUBLE_CLICK_DELAY = 300; // ms
        const DOUBLE_CLICK_DISTANCE = 10; // pixels
        
        // Double-click handler for creating text boxes on empty space
        // Use both click-based detection and native dblclick for better Chrome compatibility
        canvas.addEventListener('click', (event) => {
          if (isPresenting) return;
          
          // Cancel any pending marquee start
          if (pendingMarqueeStart) {
            clearTimeout(pendingMarqueeStart);
            pendingMarqueeStart = null;
          }
          
          const now = Date.now();
          const { x: canvasX, y: canvasY } = getCanvasPointFromClient(event.clientX, event.clientY);
          
          // Check if this is a double-click (two clicks close together in time and space)
          const isDoubleClick = (now - lastClickTime) < DOUBLE_CLICK_DELAY &&
                                Math.abs(canvasX - lastClickX) < DOUBLE_CLICK_DISTANCE &&
                                Math.abs(canvasY - lastClickY) < DOUBLE_CLICK_DISTANCE;
          
          if (isDoubleClick) {
            // Prevent multiple text boxes from being created rapidly
            if (isCreatingTextBox) {
              lastClickTime = 0;
              return;
            }
            
            event.preventDefault();
            event.stopPropagation();
            
            // Clear any active marquee
            if (marqueeState) {
              const { overlay } = marqueeState;
              if (overlay) overlay.remove();
              marqueeState = null;
            }
            
            const clickedElement = event.target;
            const interactiveElement = clickedElement.closest 
              ? clickedElement.closest(CANVAS_INTERACTIVE_SELECTOR)
              : null;
            
            // If clicking on an interactive element, focus it
            if (interactiveElement && interactiveElement !== canvas) {
              if (interactiveElement.classList && 
                  (interactiveElement.classList.contains('text-box') || 
                   interactiveElement.classList.contains('title-box') || 
                   interactiveElement.classList.contains('additional-text-box'))) {
                interactiveElement.focus();
                try {
                  const range = document.createRange();
                  const sel = window.getSelection();
                  if (interactiveElement.firstChild) {
                    range.setStart(interactiveElement.firstChild, 0);
                  } else {
                    range.selectNodeContents(interactiveElement);
                  }
                  range.collapse(true);
                  sel.removeAllRanges();
                  sel.addRange(range);
                } catch (e) {
                  interactiveElement.focus();
                }
              }
              lastClickTime = 0; // Reset to prevent triple-click
              return;
            }
            
            // Set lock to prevent rapid creation
            isCreatingTextBox = true;
            
            // Otherwise create new text box
            lastCanvasInsertPosition = { x: canvasX, y: canvasY };
            const newTextBox = addTextBoxAtCanvasPosition(canvasX, canvasY);
            if (newTextBox) {
              selectTextBox(newTextBox);
              setTimeout(() => {
                if (document.contains(newTextBox)) {
                  newTextBox.focus();
                  if (!newTextBox.textContent || !newTextBox.textContent.trim()) {
                    newTextBox.innerHTML = '';
                  }
                  try {
                    const range = document.createRange();
                    const sel = window.getSelection();
                    if (newTextBox.firstChild) {
                      range.setStart(newTextBox.firstChild, 0);
                    } else {
                      range.selectNodeContents(newTextBox);
                    }
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                  } catch (e) {
                    newTextBox.focus();
                  }
                }
                // Release lock after text box is created and focused
                setTimeout(() => {
                  isCreatingTextBox = false;
                }, 500); // Wait 500ms before allowing another text box creation
              }, 50);
              capture();
              saveEditorState('add_textbox_doubleclick');
            } else {
              // Release lock if text box creation failed
              isCreatingTextBox = false;
            }
            lastClickTime = 0; // Reset
            return;
          }
          
          // Store this click for potential double-click detection
          lastClickTime = now;
          lastClickX = canvasX;
          lastClickY = canvasY;
          
          // Also update lastCanvasInsertPosition (existing functionality)
          lastCanvasInsertPosition = {
            x: canvasX,
            y: canvasY
          };
        });
        
        // Also handle native dblclick event as fallback (works better in Safari)
        canvas.addEventListener('dblclick', (event) => {
          if (isPresenting) return;
          
          const clickedElement = event.target;
          const interactiveElement = clickedElement.closest 
            ? clickedElement.closest(CANVAS_INTERACTIVE_SELECTOR)
            : null;
          
          // If clicking on an interactive element, focus it
          if (interactiveElement && interactiveElement !== canvas) {
            if (interactiveElement.classList && 
                (interactiveElement.classList.contains('text-box') || 
                 interactiveElement.classList.contains('title-box') || 
                 interactiveElement.classList.contains('additional-text-box'))) {
              interactiveElement.focus();
              try {
                const range = document.createRange();
                const sel = window.getSelection();
                if (interactiveElement.firstChild) {
                  range.setStart(interactiveElement.firstChild, 0);
                } else {
                  range.selectNodeContents(interactiveElement);
                }
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              } catch (e) {
                interactiveElement.focus();
              }
            }
            return;
          }
          
          // Prevent multiple text boxes from being created rapidly
          if (isCreatingTextBox) {
            lastClickTime = 0;
            return;
          }
          
          // Set lock to prevent rapid creation
          isCreatingTextBox = true;
          
          // Create new text box
          event.preventDefault();
          event.stopPropagation();
          
          try {
          const { x: canvasX, y: canvasY } = getCanvasPointFromClient(event.clientX, event.clientY);
          lastCanvasInsertPosition = {
            x: canvasX,
            y: canvasY
          };
            
          const newTextBox = addTextBoxAtCanvasPosition(canvasX, canvasY);
          if (newTextBox) {
              selectTextBox(newTextBox);
              setTimeout(() => {
                if (document.contains(newTextBox)) {
                  newTextBox.focus();
                  if (!newTextBox.textContent || !newTextBox.textContent.trim()) {
                    newTextBox.innerHTML = '';
                  }
                  try {
                    const range = document.createRange();
                    const sel = window.getSelection();
                    if (newTextBox.firstChild) {
                      range.setStart(newTextBox.firstChild, 0);
                    } else {
                      range.selectNodeContents(newTextBox);
                    }
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                  } catch (e) {
                    newTextBox.focus();
                  }
                }
                // Release lock after text box is created and focused
                setTimeout(() => {
                  isCreatingTextBox = false;
                }, 500); // Wait 500ms before allowing another text box creation
              }, 50);
              capture();
              saveEditorState('add_textbox_doubleclick');
            } else {
              // Release lock if text box creation failed
              isCreatingTextBox = false;
            }
          } catch (error) {
            console.error('Error creating text box on double-click:', error);
            isCreatingTextBox = false; // Release lock on error
          }
          
          // Reset click tracking to prevent triple-click
          lastClickTime = 0;
        });
        canvas.addEventListener('contextmenu', (event) => {
          const objectTarget = event.target.closest('.image-element, .video-element, .shape-element, .chart-element, .table-element, .additional-text-box, #titleBox, #textBox');
          if (objectTarget) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          const point = getCanvasPointFromClient(event.clientX, event.clientY);
          lastCanvasInsertPosition = {
            x: point.x,
            y: point.y
          };
          showSlideCanvasContextMenu(event, active);
        });
      }
      if (titleBox) {
        titleBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(titleBox);
          showElementContextMenu(event, titleBox);
        });
      }
      if (textBox) {
        textBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(textBox);
          showElementContextMenu(event, textBox);
        });
      }

      function showNotification(message) {
        if (!saveNotification) return;
        saveNotification.textContent = message;
        saveNotification.classList.add('show');
        setTimeout(() => {
          saveNotification.classList.remove('show');
        }, 2200);
      }

      function getCanvasZoom() {
        return canvasZoom || 1;
      }

      function updateZoomUI() {
        if (zoomDisplay) {
          zoomDisplay.textContent = `${Math.round(getCanvasZoom() * 100)}%`;
        }
        if (zoomOutButton) {
          zoomOutButton.disabled = getCanvasZoom() <= MIN_CANVAS_ZOOM + 0.0001;
        }
        if (zoomInButton) {
          zoomInButton.disabled = getCanvasZoom() >= MAX_CANVAS_ZOOM - 0.0001;
        }
      }

      function applyCanvasZoomTransform() {
        if (!canvas) return;
        canvas.style.transformOrigin = '50% 50%';
        canvas.style.transform = `scale(${getCanvasZoom()})`;
      }

      function setCanvasZoom(newZoom, options = {}) {
        if (!canvas) return;
        const clampedZoom = Math.min(MAX_CANVAS_ZOOM, Math.max(MIN_CANVAS_ZOOM, newZoom));
        if (Math.abs(clampedZoom - canvasZoom) < 0.0001) {
          return;
        }
        const previousZoom = getCanvasZoom();
        const previousScrollLeft = canvasWrap ? canvasWrap.scrollLeft : 0;
        const previousScrollTop = canvasWrap ? canvasWrap.scrollTop : 0;
        let focusPoint = options.focus;
        if (!focusPoint && canvasWrap) {
          const centerX = previousScrollLeft + canvasWrap.clientWidth / 2;
          const centerY = previousScrollTop + canvasWrap.clientHeight / 2;
          focusPoint = {
            x: centerX / Math.max(previousZoom, 0.0001),
            y: centerY / Math.max(previousZoom, 0.0001)
          };
        }
        canvasZoom = clampedZoom;
        applyCanvasZoomTransform();
        if (canvasWrap && focusPoint) {
          const scaledWidth = canvas.clientWidth * canvasZoom;
          const scaledHeight = canvas.clientHeight * canvasZoom;
          const maxScrollLeft = Math.max(0, scaledWidth - canvasWrap.clientWidth);
          const maxScrollTop = Math.max(0, scaledHeight - canvasWrap.clientHeight);
          const targetScrollLeft = focusPoint.x * canvasZoom - canvasWrap.clientWidth / 2;
          const targetScrollTop = focusPoint.y * canvasZoom - canvasWrap.clientHeight / 2;
          canvasWrap.scrollLeft = Math.min(maxScrollLeft, Math.max(0, targetScrollLeft));
          canvasWrap.scrollTop = Math.min(maxScrollTop, Math.max(0, targetScrollTop));
        }
        updateZoomUI();
      }

      function adjustCanvasZoom(delta, options = {}) {
        setCanvasZoom(getCanvasZoom() + delta, options);
      }

      function resetCanvasZoom() {
        setCanvasZoom(1);
      }

      function getCanvasPointFromClient(clientX, clientY) {
        if (!canvas) {
          return { x: clientX, y: clientY };
        }
        const rect = canvas.getBoundingClientRect();
        const zoom = getCanvasZoom();
        return {
          x: (clientX - rect.left) / zoom,
          y: (clientY - rect.top) / zoom
        };
      }

      function getElementCanvasCoordinates(element) {
        if (!element) {
          return { left: 0, top: 0 };
        }
        const leftStyle = parseFloat(element.style.left);
        const topStyle = parseFloat(element.style.top);
        if (Number.isFinite(leftStyle) && Number.isFinite(topStyle)) {
          return { left: leftStyle, top: topStyle };
        }
        if (!canvas) {
          return { left: 0, top: 0 };
        }
        const rect = element.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const zoom = getCanvasZoom();
        return {
          left: (rect.left - canvasRect.left) / zoom,
          top: (rect.top - canvasRect.top) / zoom
        };
      }

      applyCanvasZoomTransform();
      updateZoomUI();

      if (zoomOutButton) {
        zoomOutButton.addEventListener('click', () => {
          adjustCanvasZoom(-CANVAS_ZOOM_STEP);
        });
      }
      if (zoomInButton) {
        zoomInButton.addEventListener('click', () => {
          adjustCanvasZoom(CANVAS_ZOOM_STEP);
        });
      }
      if (zoomResetButton) {
        zoomResetButton.addEventListener('click', () => {
          resetCanvasZoom();
        });
      }
      if (canvasWrap) {
        canvasWrap.addEventListener('wheel', (event) => {
          if (!event.ctrlKey && !event.metaKey) {
            return;
          }
          event.preventDefault();
          const delta = event.deltaY < 0 ? CANVAS_WHEEL_ZOOM_STEP : -CANVAS_WHEEL_ZOOM_STEP;
          const focus = getCanvasPointFromClient(event.clientX, event.clientY);
          adjustCanvasZoom(delta, { focus });
        }, { passive: false });
      }

      const FONT_OPTIONS = [
        { name: 'Inter', stack: DEFAULT_FONT_STACK },
        { name: 'System UI', stack: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif' },
        { name: 'Roboto', stack: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Open Sans', stack: '"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Lato', stack: 'Lato, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Montserrat', stack: 'Montserrat, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Poppins', stack: 'Poppins, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Source Sans Pro', stack: '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Nunito', stack: 'Nunito, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway', stack: 'Raleway, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Oswald', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Cabin', stack: 'Cabin, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Fira Sans', stack: '"Fira Sans", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Arial', stack: 'Arial, Helvetica, sans-serif' },
        { name: 'Verdana', stack: 'Verdana, Geneva, sans-serif' },
        { name: 'Tahoma', stack: 'Tahoma, Geneva, sans-serif' },
        { name: 'Trebuchet MS', stack: '"Trebuchet MS", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Antic', stack: 'Antic, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Amaranth', stack: 'Amaranth, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Helvetica Neue', stack: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Times New Roman', stack: '"Times New Roman", Times, serif' },
        { name: 'Georgia', stack: 'Georgia, serif' },
        { name: 'Garamond', stack: 'Garamond, Baskerville, "Times New Roman", serif' },
        { name: 'Merriweather', stack: 'Merriweather, Georgia, serif' },
        { name: 'Playfair Display', stack: '"Playfair Display", Georgia, serif' },
        { name: 'Cambria', stack: 'Cambria, Georgia, serif' },
        { name: 'Palatino', stack: '"Palatino Linotype", "Book Antiqua", Palatino, serif' },
        { name: 'Courier New', stack: '"Courier New", Courier, monospace' },
        { name: 'IBM Plex Mono', stack: '"IBM Plex Mono", "Courier New", Courier, monospace' },
        { name: 'Consolas', stack: 'Consolas, "Liberation Mono", Courier, monospace' },
        { name: 'Fira Code', stack: '"Fira Code", "Fira Mono", "DejaVu Sans Mono", monospace' },
        { name: 'Lucida Console', stack: '"Lucida Console", Monaco, monospace' },
        { name: 'Brush Script', stack: '"Brush Script MT", cursive' },
        { name: 'Pacifico', stack: 'Pacifico, "Brush Script MT", cursive' },
        { name: 'Dancing Script', stack: '"Dancing Script", "Brush Script MT", cursive' },
        { name: 'Great Vibes', stack: '"Great Vibes", "Brush Script MT", cursive' },
        { name: 'Oswald Condensed', stack: 'Oswald, "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Bebas Neue', stack: '"Bebas Neue", "Helvetica Neue", Helvetica, Arial, sans-serif' },
        { name: 'Raleway Dots', stack: '"Raleway Dots", "Helvetica Neue", Helvetica, Arial, sans-serif' }
      ];

      const fontDropdown = document.createElement('div');
      fontDropdown.id = 'fontDropdown';
      fontDropdown.className = 'font-dropdown';
      document.body.appendChild(fontDropdown);
      const imageFileInput = document.createElement('input');
      imageFileInput.type = 'file';
      imageFileInput.accept = 'image/*';
      imageFileInput.id = 'imageFileInput';
      imageFileInput.className = 'visually-hidden';
      document.body.appendChild(imageFileInput);
      const videoFileInput = document.createElement('input');
      videoFileInput.type = 'file';
      videoFileInput.accept = 'video/*';
      videoFileInput.id = 'videoFileInput';
      videoFileInput.className = 'visually-hidden';
      document.body.appendChild(videoFileInput);

      const fontOptionButtons = new Map();
      const fontStackToName = new Map();
      const fontNameToStack = new Map();

      const shapeDropdown = document.createElement('div');
      shapeDropdown.id = 'shapeDropdown';
      shapeDropdown.className = 'shape-dropdown';
      document.body.appendChild(shapeDropdown);
      const shapeOptionButtons = new Map();
      
      // Layout dropdown
      const layoutDropdown = document.createElement('div');
      layoutDropdown.id = 'layoutDropdown';
      layoutDropdown.className = 'layout-dropdown';
      layoutDropdown.innerHTML = `
        <button type="button" class="layout-option" data-layout="title-content">
          <div class="layout-preview">
            <div class="layout-preview-box" style="width: 100%; height: 20px; margin-bottom: 8px; background: rgba(104, 196, 255, 0.3); border-radius: 4px;"></div>
            <div class="layout-preview-box" style="width: 100%; height: 40px; background: rgba(104, 196, 255, 0.2); border-radius: 4px;"></div>
          </div>
          <span>Title + Content</span>
        </button>
        <button type="button" class="layout-option" data-layout="two-column">
          <div class="layout-preview">
            <div class="layout-preview-box" style="width: 48%; height: 60px; display: inline-block; margin-right: 4%; background: rgba(104, 196, 255, 0.3); border-radius: 4px;"></div>
            <div class="layout-preview-box" style="width: 48%; height: 60px; display: inline-block; background: rgba(104, 196, 255, 0.3); border-radius: 4px;"></div>
          </div>
          <span>Two Column</span>
        </button>
        <button type="button" class="layout-option" data-layout="three-column">
          <div class="layout-preview">
            <div class="layout-preview-box" style="width: 31%; height: 60px; display: inline-block; margin-right: 3.5%; background: rgba(104, 196, 255, 0.3); border-radius: 4px;"></div>
            <div class="layout-preview-box" style="width: 31%; height: 60px; display: inline-block; margin-right: 3.5%; background: rgba(104, 196, 255, 0.3); border-radius: 4px;"></div>
            <div class="layout-preview-box" style="width: 31%; height: 60px; display: inline-block; background: rgba(104, 196, 255, 0.3); border-radius: 4px;"></div>
          </div>
          <span>Three Column</span>
        </button>
      `;
      document.body.appendChild(layoutDropdown);
      const chartDropdown = document.createElement('div');
      chartDropdown.id = 'chartDropdown';
      chartDropdown.className = 'chart-dropdown';
      document.body.appendChild(chartDropdown);
      const iconDropdown = document.createElement('div');
      iconDropdown.id = 'iconDropdown';
      iconDropdown.className = 'icon-dropdown';
      iconDropdown.innerHTML = `
        <div class="icon-folder-menu" id="iconFolderMenu">
          <button type="button" class="icon-folder-option" data-folder="solid">
            <i class="fas fa-square"></i>
            <span>Solid</span>
          </button>
          <button type="button" class="icon-folder-option" data-folder="outline">
            <i class="fas fa-square-full"></i>
            <span>Outline</span>
          </button>
        </div>
        <div class="icon-view" id="iconView" style="display: none;">
          <div class="icon-view-header">
            <button type="button" class="icon-back-button" id="iconBackButton">
              <i class="fas fa-arrow-left"></i>
              <span id="iconFolderName"></span>
            </button>
          </div>
        <div class="icon-search">
          <input type="text" id="iconSearchInput" placeholder="Search icons..." />
        </div>
        <div class="icon-grid" id="iconGrid"></div>
        </div>
      `;
      document.body.appendChild(iconDropdown);
      const chartOptionButtons = new Map();
      
      const logoDropdown = document.createElement('div');
      logoDropdown.id = 'logoDropdown';
      logoDropdown.className = 'logo-dropdown';
      document.body.appendChild(logoDropdown);

      const tableInsertPanel = document.createElement('div');
      tableInsertPanel.id = 'tableInsertPanel';
      tableInsertPanel.className = 'table-insert-panel';
      tableInsertPanel.innerHTML = `
        <h4>Insert Table</h4>
        <div class="table-insert-grid">
          <div class="table-insert-field">
            <label for="tableRowsInput">Rows</label>
            <input type="number" id="tableRowsInput" min="1" max="12" value="3">
          </div>
          <div class="table-insert-field">
            <label for="tableColsInput">Columns</label>
            <input type="number" id="tableColsInput" min="1" max="12" value="3">
          </div>
        </div>
        <div class="table-insert-actions">
          <button type="button" id="tableInsertConfirm">Insert</button>
        </div>
      `;
      document.body.appendChild(tableInsertPanel);
      const tableRowsInput = tableInsertPanel.querySelector('#tableRowsInput');
      const tableColsInput = tableInsertPanel.querySelector('#tableColsInput');
      const tableInsertConfirm = tableInsertPanel.querySelector('#tableInsertConfirm');

      let tablePanelManualPosition = null;
      const tablePanelDragState = {
        isDragging: false,
        pointerId: null,
        offsetX: 0,
        offsetY: 0
      };

      function clampTablePanelPosition(left, top) {
        const margin = 16;
        const panelRect = tableInsertPanel.getBoundingClientRect();
        const width = panelRect.width || tableInsertPanel.offsetWidth || 0;
        const height = panelRect.height || tableInsertPanel.offsetHeight || 0;
        const maxLeft = Math.max(margin, window.innerWidth - width - margin);
        const maxTop = Math.max(margin, window.innerHeight - height - margin);
        const clampedLeft = Math.min(Math.max(left, margin), maxLeft);
        const clampedTop = Math.min(Math.max(top, margin), maxTop);
        return { left: clampedLeft, top: clampedTop };
      }

      const tableInsertPanelHeader = tableInsertPanel.querySelector('h4');
      if (tableInsertPanelHeader) {
        tableInsertPanelHeader.addEventListener('pointerdown', (event) => {
          if (typeof event.button === 'number' && event.button > 0) {
            return;
          }
          event.preventDefault();
          const panelRect = tableInsertPanel.getBoundingClientRect();
          tablePanelDragState.isDragging = true;
          tablePanelDragState.pointerId = event.pointerId;
          tablePanelDragState.offsetX = event.clientX - panelRect.left;
          tablePanelDragState.offsetY = event.clientY - panelRect.top;
          tableInsertPanel.classList.add('dragging');
          try {
            tableInsertPanelHeader.setPointerCapture(event.pointerId);
          } catch (error) {
            // Ignore if pointer capture is not supported.
          }
        });

        tableInsertPanelHeader.addEventListener('pointermove', (event) => {
          if (!tablePanelDragState.isDragging || event.pointerId !== tablePanelDragState.pointerId) {
            return;
          }
          const desiredLeft = event.clientX - tablePanelDragState.offsetX;
          const desiredTop = event.clientY - tablePanelDragState.offsetY;
          const { left, top } = clampTablePanelPosition(desiredLeft, desiredTop);
          tableInsertPanel.style.left = `${left}px`;
          tableInsertPanel.style.top = `${top}px`;
          tablePanelManualPosition = { left, top };
        });

        const endTablePanelDrag = (event) => {
          if (!tablePanelDragState.isDragging || (event.pointerId !== undefined && event.pointerId !== tablePanelDragState.pointerId)) {
            return;
          }
          tablePanelDragState.isDragging = false;
          tablePanelDragState.pointerId = null;
          tableInsertPanel.classList.remove('dragging');
          try {
            tableInsertPanelHeader.releasePointerCapture(event.pointerId);
          } catch (error) {
            // Ignore if pointer capture cannot be released.
          }
        };

        tableInsertPanelHeader.addEventListener('pointerup', endTablePanelDrag);
        tableInsertPanelHeader.addEventListener('pointercancel', endTablePanelDrag);
      }

      const COLOR_CANVAS = document.createElement('canvas');
      COLOR_CANVAS.width = COLOR_CANVAS.height = 1;
      const COLOR_CTX = COLOR_CANVAS.getContext('2d');
      function normalizeColorHex(color) {
        if (!color) return '#ffffff';
        try {
          COLOR_CTX.fillStyle = '#000000';
          COLOR_CTX.fillStyle = color;
      const resolved = COLOR_CTX.fillStyle;
      if (typeof resolved === 'string' && resolved.startsWith('#')) {
        return resolved;
      }
      if (typeof resolved === 'string' && (resolved.startsWith('rgb') || resolved.startsWith('rgba'))) {
        const parts = resolved
          .replace(/rgba?\(|\)|\s/g, '')
          .split(',')
          .map(part => parseFloat(part));
        const toHex = (value) => {
          const clamped = Math.max(0, Math.min(255, Math.round(value)));
          return clamped.toString(16).padStart(2, '0');
        };
        if (parts.length >= 3) {
          return `#${toHex(parts[0])}${toHex(parts[1])}${toHex(parts[2])}`;
        }
      }
      return resolved || '#ffffff';
        } catch (err) {
          return '#ffffff';
        }
      }

      function applyGlobalThemeColor(color, { persist = false } = {}) {
        const normalized = normalizeColorHex(color || DEFAULT_SLIDE_BACKGROUND_COLOR);
        document.body.classList.remove('dark-theme', 'light-mode');
        document.body.style.background = '';
        document.body.style.color = '';
        if (normalized === '#000000') {
          document.body.classList.add('dark-theme');
        } else if (normalized === '#ffffff') {
          document.body.classList.add('light-mode');
        } else {
          document.body.style.background = normalized;
          if (normalized !== '#0b3d2e') {
            document.body.style.color = '#e8f5e9';
          }
        }
        if (persist) {
          try {
            localStorage.setItem('siteBackgroundColor', normalized);
          } catch (error) {
            console.warn('Unable to persist background color preference', error);
          }
        }
        return normalized;
      }

      function getCanvasBackgroundColor() {
        if (!canvas) return DEFAULT_SLIDE_BACKGROUND_COLOR;
        try {
          return normalizeColorHex(window.getComputedStyle(canvas).backgroundColor || DEFAULT_SLIDE_BACKGROUND_COLOR);
        } catch (error) {
          return DEFAULT_SLIDE_BACKGROUND_COLOR;
        }
      }

      function applySlideBackgroundColor(color, { recordHistory = true, showNotificationMessage = true } = {}) {
        if (!canvas || !slides[active]) return;
        const normalized = normalizeColorHex(color || DEFAULT_SLIDE_BACKGROUND_COLOR);
        if (backgroundColorInput && backgroundColorInput.value.toLowerCase() !== normalized.toLowerCase()) {
          backgroundColorInput.value = normalized;
        }
        SLIDE_TEMPLATE_CLASSES.forEach(cls => canvas.classList.remove(cls));
        canvas.style.backgroundImage = '';
        canvas.style.backgroundSize = '';
        canvas.style.backgroundPosition = '';
        canvas.style.backgroundRepeat = '';
        canvas.style.backgroundColor = normalized;
        if (recordHistory) {
          const slide = slides[active];
          if (slide) {
            const existingColor = slide.background && slide.background.color
              ? normalizeColorHex(slide.background.color)
              : DEFAULT_SLIDE_BACKGROUND_COLOR;
            if (existingColor.toLowerCase() === normalized.toLowerCase()) {
              return;
            }
            slide.background = {
              image: '',
              size: '',
              position: '',
              repeat: '',
              color: normalized
            };
          }
          capture();
          saveEditorState('change_background_color');
          refreshSidebarSoon();
          if (showNotificationMessage && typeof showNotification === 'function') {
            showNotification('Updated slide background');
          }
        }
      }

      const SHAPE_OPTIONS = [
        {
          id: 'rectangle',
          name: 'Rectangle',
          viewBox: '0 0 100 70',
          svg: '<rect x="6" y="10" width="88" height="50" rx="10" ry="10"></rect>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#9ae6b4'
        },
        {
          id: 'square',
          name: 'Square',
          viewBox: '0 0 100 100',
          svg: '<rect x="12" y="12" width="76" height="76" rx="12" ry="12"></rect>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#a5b4fc'
        },
        {
          id: 'circle',
          name: 'Circle',
          viewBox: '0 0 100 100',
          svg: '<circle cx="50" cy="50" r="38"></circle>',
          defaultWidth: 140,
          defaultHeight: 140,
          minWidth: 60,
          minHeight: 60,
          defaultColor: '#fbb6ce'
        },
        {
          id: 'triangle',
          name: 'Triangle',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 12 L90 78 H10 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#f6ad55'
        },
        {
          id: 'star',
          name: 'Star',
          viewBox: '0 0 100 100',
          svg: '<path d="M50 6 L61 36 H92 L66 54 L76 84 L50 66 L24 84 L34 54 L8 36 H39 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 160,
          minWidth: 80,
          minHeight: 80,
          defaultColor: '#fcd34d'
        },
        {
          id: 'arrow-right',
          name: 'Arrow',
          viewBox: '0 0 120 70',
          svg: '<path d="M16 28 H70 V14 L104 35 L70 56 V42 H16 Z"></path>',
          defaultWidth: 200,
          defaultHeight: 120,
          minWidth: 80,
          minHeight: 60,
          defaultColor: '#4ade80'
        },
        {
          id: 'line',
          name: 'Line',
          viewBox: '0 0 100 40',
          svg: '<line x1="8" y1="32" x2="92" y2="8" stroke-linecap="round" fill="none"></line>',
          defaultWidth: 220,
          defaultHeight: 60,
          minWidth: 80,
          minHeight: 30,
          defaultColor: '#63b3ed',
          strokeWidth: 8
        },
        {
          id: 'pentagon',
          name: 'Pentagon',
          viewBox: '0 0 100 90',
          svg: '<path d="M50 8 L90 36 L74 80 H26 L10 36 Z"></path>',
          defaultWidth: 160,
          defaultHeight: 140,
          minWidth: 80,
          minHeight: 70,
          defaultColor: '#f472b6'
        }
      ];

      const SHAPE_OPTION_MAP = new Map(SHAPE_OPTIONS.map(shape => [shape.id, shape]));
      const CHART_OPTIONS = [
        {
          id: 'bar-classic',
          type: 'bar',
          variant: 'classic',
          variantLabel: 'Classic',
          name: 'Bar Chart (Classic)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          bars: [60, 85, 70],
          legend: [
            { label: 'Alpha', color: '#60a5fa' },
            { label: 'Beta', color: '#34d399' },
            { label: 'Gamma', color: '#fbbf24' }
          ]
        },
        {
          id: 'bar-rounded',
          type: 'bar',
          variant: 'rounded',
          variantLabel: 'Rounded',
          name: 'Bar Chart (Rounded)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          bars: [55, 78, 64],
          legend: [
            { label: 'Series A', color: '#818cf8' },
            { label: 'Series B', color: '#34d399' },
            { label: 'Series C', color: '#f97316' }
          ]
        },
        {
          id: 'bar-gradient',
          type: 'bar',
          variant: 'gradient',
          variantLabel: 'Gradient',
          name: 'Bar Chart (Gradient)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          bars: [48, 68, 80, 56],
          legend: [
            { label: 'Q1', color: '#38bdf8' },
            { label: 'Q2', color: '#22d3ee' },
            { label: 'Q3', color: '#818cf8' },
            { label: 'Q4', color: '#f472b6' }
          ]
        },
        {
          id: 'line-smooth',
          type: 'line',
          variant: 'smooth',
          variantLabel: 'Smooth',
          name: 'Line Chart (Smooth)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 260,
          minHeight: 180,
          points: [35, 62, 58, 74, 82],
          series: [
            {
              label: 'Series A',
              color: '#6366f1',
              values: [35, 62, 58, 74, 82]
            },
            {
              label: 'Series B',
              color: '#22c55e',
              values: [28, 54, 60, 68, 75]
            }
          ],
          legend: [
            { label: 'North', color: '#6366f1' },
            { label: 'South', color: '#22d3ee' },
            { label: 'West', color: '#f59e0b' },
            { label: 'East', color: '#ef4444' },
            { label: 'Central', color: '#10b981' }
          ]
        },
        {
          id: 'line-dotted',
          type: 'line',
          variant: 'dotted',
          variantLabel: 'Dotted',
          name: 'Line Chart (Dotted)',
          defaultWidth: 360,
          defaultHeight: 240,
          minWidth: 260,
          minHeight: 180,
          points: [28, 46, 52, 64, 58],
          series: [
            {
              label: 'Series A',
              color: '#f97316',
              values: [28, 46, 52, 64, 58]
            },
            {
              label: 'Series B',
              color: '#3b82f6',
              values: [22, 40, 48, 60, 54]
            }
          ],
          legend: [
            { label: 'Week 1', color: '#f97316' },
            { label: 'Week 2', color: '#38bdf8' },
            { label: 'Week 3', color: '#a855f7' },
            { label: 'Week 4', color: '#4ade80' },
            { label: 'Week 5', color: '#facc15' }
          ]
        },
        {
          id: 'pie-solid',
          type: 'pie',
          variant: 'solid',
          variantLabel: 'Solid',
          name: 'Pie Chart (Solid)',
          defaultWidth: 320,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          slices: [40, 35, 25],
          legend: [
            { label: 'North', color: '#60a5fa' },
            { label: 'South', color: '#34d399' },
            { label: 'West', color: '#f97316' }
          ]
        },
        {
          id: 'pie-donut',
          type: 'pie',
          variant: 'donut',
          variantLabel: 'Donut',
          name: 'Pie Chart (Donut)',
          defaultWidth: 320,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          slices: [30, 28, 22, 20],
          legend: [
            { label: 'Q1', color: '#4f46e5' },
            { label: 'Q2', color: '#22d3ee' },
            { label: 'Q3', color: '#f59e0b' },
            { label: 'Q4', color: '#f97316' }
          ]
        },
        {
          id: 'pie-gradient',
          type: 'pie',
          variant: 'gradient',
          variantLabel: 'Gradient',
          name: 'Pie Chart (Gradient)',
          defaultWidth: 320,
          defaultHeight: 240,
          minWidth: 220,
          minHeight: 160,
          slices: [50, 30, 20],
          legend: [
            { label: 'Completed', color: '#22c55e' },
            { label: 'Pending', color: '#f97316' },
            { label: 'Upcoming', color: '#a855f7' }
          ]
        }
      ];

      const CHART_OPTION_MAP = new Map(CHART_OPTIONS.map(chart => [chart.id, chart]));
      const CHART_OPTION_ALIASES = new Map([
        ['pie', 'pie-solid'],
        ['bar', 'bar-classic'],
        ['line', 'line-smooth']
      ]);
      const PIE_VARIANT_OPTIONS = CHART_OPTIONS.filter(chart => (chart.type || chart.id) === 'pie');

      const CHART_VARIANT_MAP = new Map();
      CHART_OPTIONS.forEach((chart) => {
        const typeKey = chart.type || chart.id;
        if (!CHART_VARIANT_MAP.has(typeKey)) {
          CHART_VARIANT_MAP.set(typeKey, []);
        }
        CHART_VARIANT_MAP.get(typeKey).push(chart);
      });

      function getChartOptionById(id) {
        if (!id) return CHART_OPTIONS[0];
        const normalized = CHART_OPTION_MAP.has(id)
          ? id
          : (CHART_OPTION_ALIASES.get(id) || id);
        return CHART_OPTION_MAP.get(normalized) || CHART_OPTIONS[0];
      }

      function normalizeFontStack(value) {
        if (!value) return '';
        return value.replace(/"/g, "'").split(',').map(part => part.replace(/['"]/g, '').trim().toLowerCase()).join(',');
      }

      FONT_OPTIONS.forEach(font => {
        const normalized = normalizeFontStack(font.stack);
        fontStackToName.set(normalized, font.name);
        fontNameToStack.set(font.name.toLowerCase(), font.stack);
      });

      function renderFontOptions() {
        fontDropdown.innerHTML = '';
        fontOptionButtons.clear();
        FONT_OPTIONS.forEach(font => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'font-option';
          option.textContent = font.name;
          option.style.fontFamily = font.stack;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            applyFontFamilyToCurrent(font.stack);
            hideFontDropdown();
          });
          fontDropdown.appendChild(option);
          fontOptionButtons.set(normalizeFontStack(font.stack), option);
        });
      }

      function renderShapeOptions() {
        shapeDropdown.innerHTML = '';
        shapeOptionButtons.clear();
        SHAPE_OPTIONS.forEach(shape => {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'shape-option';
          option.innerHTML = `
            <div class="shape-option-preview">${renderShapeSvg(shape)}</div>
            <span class="shape-option-label">${shape.name}</span>
          `;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            insertShape(shape.id);
            hideShapeDropdown();
          });
          shapeDropdown.appendChild(option);
          shapeOptionButtons.set(shape.id, option);
        });
      }

      function renderChartOptions() {
        chartDropdown.innerHTML = '';
        chartOptionButtons.clear();
        const seenTypes = new Set();
        CHART_OPTIONS.forEach(chart => {
          const chartTypeKey = chart.type || chart.id;
          if (seenTypes.has(chartTypeKey)) {
            return;
          }
          seenTypes.add(chartTypeKey);
        const option = document.createElement('button');
        option.type = 'button';
        option.className = 'chart-option';
        const isPieChart = chart.type === 'pie' || chartTypeKey === 'pie';
        const isLineChart = chart.type === 'line' || chartTypeKey === 'line';
        let preview;
        let label;
        if (isPieChart) {
          preview = '<div class="chart-mini pie"></div>';
          label = 'Pie Chart';
        } else if (isLineChart) {
          preview = '<div class="chart-mini line"><span></span></div>';
          label = 'Line Chart';
        } else {
          preview = '<div class="chart-mini bar"><span></span></div>';
          label = 'Bar Chart';
        }
        option.innerHTML = `
          <div class="chart-option-preview">
            ${preview}
          </div>
          <span class="chart-option-label">${label}</span>
        `;
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            insertChart(chart.id);
            hideChartDropdown();
          });
          chartDropdown.appendChild(option);
          chartOptionButtons.set(chart.id, option);
        });
      }

      renderShapeOptions();
      renderChartOptions();

      renderFontOptions();

      const shapeColorPicker = document.createElement('div');
      shapeColorPicker.id = 'shapeColorPicker';
      shapeColorPicker.className = 'shape-color-picker';
      shapeColorPicker.innerHTML = `
        <button type="button" id="shapeColorButton" class="shape-color-button" title="Shape Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="shapeColorInput" class="shape-color-input" value="#e8f5e9" aria-label="Shape Fill Color Picker">
      `;
      document.body.appendChild(shapeColorPicker);
      const shapeColorButton = document.getElementById('shapeColorButton');
      const shapeColorInput = document.getElementById('shapeColorInput');
      const shapeSizeBadge = document.createElement('div');
      shapeSizeBadge.id = 'shapeSizeBadge';
      shapeSizeBadge.className = 'shape-size-badge';
      document.body.appendChild(shapeSizeBadge);

      const tableColumnColorPicker = document.createElement('div');
      tableColumnColorPicker.id = 'tableColumnColorPicker';
      tableColumnColorPicker.className = 'shape-color-picker table-column-color-picker';
      tableColumnColorPicker.innerHTML = `
        <button type="button" id="tableColumnColorButton" class="shape-color-button" title="Column Fill Color">
          <i class="fas fa-fill-drip"></i>
        </button>
        <input type="color" id="tableColumnColorInput" class="shape-color-input" value="#ffffff" aria-label="Column Fill Color Picker">
      `;
      document.body.appendChild(tableColumnColorPicker);
      const tableColumnColorButton = tableColumnColorPicker.querySelector('#tableColumnColorButton');
      const tableColumnColorInput = tableColumnColorPicker.querySelector('#tableColumnColorInput');

      const chartDataEditor = document.createElement('div');
      chartDataEditor.id = 'chartDataEditor';
      chartDataEditor.className = 'chart-data-editor';
      chartDataEditor.innerHTML = `
        <div class="chart-data-header">
          <div class="chart-data-title">Chart Data</div>
          <button type="button" class="chart-data-close" aria-label="Close chart data editor">&times;</button>
        </div>
        <div class="chart-data-subtitle" id="chartDataSubtitle"></div>
        <div class="chart-data-title-input-wrapper">
          <label class="chart-data-title-label" for="chartDataTitleInput">Chart Title</label>
          <input type="text" id="chartDataTitleInput" class="chart-data-title-input" placeholder="Enter chart title">
        </div>
        <div class="chart-data-variant" id="chartDataVariantContainer" hidden>
          <span class="chart-data-variant-label">Style</span>
          <div class="chart-data-variant-options" id="chartDataVariantOptions"></div>
        </div>
        <div class="chart-data-toggle hidden" id="chartDataShowValuesRow">
          <span class="chart-data-toggle-label">Show values on chart</span>
          <input type="checkbox" id="chartDataShowValuesCheckbox" aria-label="Show values on chart">
        </div>
        <div class="chart-data-table-wrapper" id="chartDataStandardEditor">
          <table class="chart-data-table">
            <thead>
              <tr>
                <th>Label</th>
                <th>Value</th>
                <th>Color</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <div class="chart-data-empty" id="chartDataEmptyMessage" hidden>No data rows yet</div>
        </div>
        <div class="chart-data-line-editor hidden" id="chartDataLineEditor">
          <div class="chart-line-series-section">
            <div class="chart-line-series-header">
              <span class="chart-line-series-title">Lines</span>
              <button type="button" id="lineSeriesAddButton">Add Line</button>
            </div>
            <div class="chart-line-series-list" id="lineSeriesList"></div>
          </div>
          <div class="chart-line-points-section">
            <div class="chart-line-points-header">
              <span class="chart-line-points-title">Data Points</span>
              <div class="chart-line-points-actions">
                <button type="button" id="linePointAddButton">Add Point</button>
                <button type="button" id="linePointRemoveButton">Remove Point</button>
              </div>
            </div>
            <div class="chart-line-values-table-wrapper">
              <table class="chart-data-table chart-line-values-table" id="lineValuesTable">
                <thead></thead>
                <tbody></tbody>
              </table>
              <div class="chart-data-empty" id="lineValuesEmptyMessage" hidden>No data points yet</div>
            </div>
          </div>
        </div>
        <div class="chart-data-actions" id="chartDataStandardActions">
          <button type="button" id="chartDataAddRowButton">Add Row</button>
          <button type="button" id="chartDataRemoveRowButton">Remove Row</button>
        </div>
      `;
      document.body.appendChild(chartDataEditor);
      const chartDataSubtitle = document.getElementById('chartDataSubtitle');
      const chartDataTitleInput = document.getElementById('chartDataTitleInput');
      const chartDataEmptyMessage = document.getElementById('chartDataEmptyMessage');
      const chartDataStandardEditor = document.getElementById('chartDataStandardEditor');
      const chartDataStandardActions = document.getElementById('chartDataStandardActions');
      const chartDataEditorTableBody = chartDataStandardEditor.querySelector('tbody');
      const chartDataAddRowButton = document.getElementById('chartDataAddRowButton');
      const chartDataRemoveRowButton = document.getElementById('chartDataRemoveRowButton');
      const chartDataCloseButton = chartDataEditor.querySelector('.chart-data-close');
      const chartDataVariantContainer = document.getElementById('chartDataVariantContainer');
      const chartDataVariantOptions = document.getElementById('chartDataVariantOptions');
      const chartDataShowValuesRow = document.getElementById('chartDataShowValuesRow');
      const chartDataShowValuesCheckbox = document.getElementById('chartDataShowValuesCheckbox');
      const chartDataLineEditor = document.getElementById('chartDataLineEditor');
      const lineSeriesList = document.getElementById('lineSeriesList');
      const lineSeriesAddButton = document.getElementById('lineSeriesAddButton');
      const linePointAddButton = document.getElementById('linePointAddButton');
      const linePointRemoveButton = document.getElementById('linePointRemoveButton');
      const lineValuesTable = document.getElementById('lineValuesTable');
      const lineValuesTableHead = lineValuesTable.querySelector('thead');
      const lineValuesTableBody = lineValuesTable.querySelector('tbody');
      const lineValuesEmptyMessage = document.getElementById('lineValuesEmptyMessage');
      let chartDataDragState = null;

      const CHART_COLOR_SEQUENCE = ['#60a5fa', '#34d399', '#f97316', '#fbbf24', '#a78bfa', '#f472b6', '#10b981', '#f87171'];
      let activeChartDataElement = null;
      let chartDataAutoSaveTimeout = null;

      function applyChartVariantToElement(element, variantId) {
        if (!element) return;
        const chartConfig = getChartOptionById(variantId);
        if (!chartConfig) return;
        const chartType = chartConfig.type || chartConfig.id;
        if (chartType === 'line') {
          element.dataset.chartType = chartConfig.id;
          if (chartConfig.variant) {
            element.dataset.chartVariant = chartConfig.variant;
          } else {
            delete element.dataset.chartVariant;
          }
          if (chartConfig.minWidth) {
            element.dataset.minWidth = String(chartConfig.minWidth);
          }
          if (chartConfig.minHeight) {
            element.dataset.minHeight = String(chartConfig.minHeight);
          }
          const showValues = element.dataset.showValues === 'true';
          const currentState = getLineChartState(element, chartConfig);
          setLineChartState(element, chartConfig, {
            categories: currentState.categories,
            series: currentState.series,
            title: element.dataset.title || chartConfig.name || 'Chart',
            showValues
          });
          return;
        }
        let legend = normalizeChartLegend(element.dataset.legend, chartConfig.legend || []);
        let values = chartType === 'pie'
          ? normalizeNumberArray(element.dataset.slices, [])
          : normalizeNumberArray(element.dataset.bars, []);
        const defaults = chartType === 'pie' ? (chartConfig.slices || []) : (chartConfig.bars || []);
        if (!values.length) {
          values = defaults.length ? [...defaults] : [chartType === 'pie' ? 25 : 50];
        }
        const targetLength = defaults.length || Math.max(values.length, legend.length, 1);
        if (values.length < targetLength) {
          for (let i = values.length; i < targetLength; i += 1) {
            values.push(defaults[i] != null ? defaults[i] : values[values.length - 1] || (chartType === 'pie' ? 25 : 50));
          }
        } else if (values.length > targetLength) {
          values = values.slice(0, targetLength);
        }
        if (legend.length < targetLength) {
          const baseLegend = chartConfig.legend || [];
          for (let i = legend.length; i < targetLength; i += 1) {
            const fallback = baseLegend[i] || {};
            legend.push({
              label: fallback.label || `${chartType === 'pie' ? 'Slice' : 'Series'} ${i + 1}`,
            color: normalizeColorHex(fallback.color || CHART_COLOR_SEQUENCE[i % CHART_COLOR_SEQUENCE.length])
            });
          }
        } else if (legend.length > targetLength) {
          legend = legend.slice(0, targetLength);
        }
        element.dataset.chartType = chartConfig.id;
        if (chartConfig.variant) {
          element.dataset.chartVariant = chartConfig.variant;
        } else {
          delete element.dataset.chartVariant;
        }
        if (chartConfig.minWidth) {
          element.dataset.minWidth = String(chartConfig.minWidth);
        }
        if (chartConfig.minHeight) {
          element.dataset.minHeight = String(chartConfig.minHeight);
        }
        const showValues = element.dataset.showValues === 'true';
        element.dataset.showValues = showValues ? 'true' : 'false';
        element.dataset.legend = JSON.stringify(legend);
        if (chartType === 'pie') {
          element.dataset.slices = JSON.stringify(values);
          delete element.dataset.bars;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        } else {
          element.dataset.bars = JSON.stringify(values);
          delete element.dataset.slices;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        }
        const payload = {
          legend,
          title: element.dataset.title || chartConfig.name || 'Chart',
          showValues
        };
        if (chartType === 'pie') {
          payload.slices = values;
        } else if (chartType === 'line') {
          payload.points = values;
        } else {
          payload.bars = values;
        }
        element.innerHTML = renderChartMarkup(chartConfig, payload);
        createResizeEdges(element);
      }

      function getChartConfigForElement(element) {
        if (!element) return null;
        const chartKey = element.dataset.chartType || 'bar';
        return getChartOptionById(chartKey);
      }

      function getChartValuesForElement(element, chartConfig) {
        if (!element) return [];
        const chartKey = element.dataset.chartType || chartConfig?.id || 'bar';
        const chartType = chartConfig?.type || chartKey;
        if (chartType === 'pie') {
          return normalizeNumberArray(element.dataset.slices, chartConfig?.slices || []);
        }
        if (chartType === 'line') {
          const state = getLineChartState(element, chartConfig);
          return state.series[0]?.values || normalizeNumberArray(element.dataset.points, chartConfig?.points || []);
        }
        return normalizeNumberArray(element.dataset.bars, chartConfig?.bars || []);
      }

      function applyChartDataToElement(element, legendInput, valuesInput) {
        if (!element) return;
        const chartConfig = getChartConfigForElement(element);
        const chartKey = element.dataset.chartType || chartConfig?.id || 'bar';
        const chartType = chartConfig?.type || chartKey;
        if (chartType === 'line') {
          const existingState = getLineChartState(element, chartConfig);
          const categories = legendInput.length
            ? legendInput.map((legendItem, index) => ({
                label: typeof legendItem?.label === 'string' && legendItem.label.trim()
                  ? legendItem.label.trim()
                  : (existingState.categories[index]?.label || `Point ${index + 1}`),
                color: normalizeColorHex(
                  legendItem?.color
                  || existingState.categories[index]?.color
                  || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
                )
              }))
            : existingState.categories;
          const firstSeriesValues = valuesInput.map((rawValue, index) => {
            const numericValue = Number(rawValue);
            const fallbackValue = existingState.series[0]?.values?.[index];
            if (Number.isFinite(numericValue)) return numericValue;
            if (Number.isFinite(fallbackValue)) return fallbackValue;
            return 0;
          });
          const adjustedValues = adjustNumberArrayLength(
            firstSeriesValues,
            Math.max(categories.length, firstSeriesValues.length, 1),
            existingState.series[0]?.values || []
          );
          const series = existingState.series.length
            ? existingState.series.map((seriesItem, index) => {
                if (index === 0) {
                  return {
                    label: seriesItem.label || 'Line 1',
                    color: normalizeColorHex(seriesItem.color || CHART_COLOR_SEQUENCE[0]),
                    values: adjustedValues
                  };
                }
                const paddedValues = adjustNumberArrayLength(
                  Array.isArray(seriesItem.values) ? seriesItem.values : [],
                  adjustedValues.length,
                  seriesItem.values || []
                );
                return {
                  label: seriesItem.label || `Line ${index + 1}`,
                  color: normalizeColorHex(seriesItem.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]),
                  values: paddedValues
                };
              })
            : [{
                label: 'Line 1',
                color: normalizeColorHex(CHART_COLOR_SEQUENCE[0]),
                values: adjustedValues
              }];
          setLineChartState(element, chartConfig, {
            categories,
            series,
            title: element.dataset.title || '',
            showValues: element.dataset.showValues === 'true'
          });
          return;
        }
        const targetLength = Math.max(legendInput.length, valuesInput.length, 1);
        const legend = [];
        const values = [];
        for (let index = 0; index < targetLength; index += 1) {
          const legendItem = legendInput[index] || {};
          const label = typeof legendItem?.label === 'string' ? legendItem.label.trim() : '';
          const fallbackColor = (chartConfig?.legend && chartConfig.legend[index]?.color)
            || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length];
          const color = legendItem?.color && legendItem.color.trim() ? legendItem.color : fallbackColor;
          legend.push({ label, color });
          const rawValue = valuesInput[index];
          const numericValue = Number(rawValue);
          values.push(Number.isFinite(numericValue) ? numericValue : 0);
        }
        element.dataset.legend = JSON.stringify(legend);
        if (chartType === 'pie') {
          element.dataset.slices = JSON.stringify(values);
          delete element.dataset.bars;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        } else {
          element.dataset.bars = JSON.stringify(values);
          delete element.dataset.slices;
          delete element.dataset.lineSeries;
          delete element.dataset.points;
        }
        const payload = {
          legend,
          title: element.dataset.title || '',
          showValues: element.dataset.showValues === 'true'
        };
        if (chartType === 'pie') {
          payload.slices = values;
        } else if (chartType === 'line') {
          payload.points = values;
        } else {
          payload.bars = values;
        }
        element.innerHTML = renderChartMarkup(chartConfig, payload);
        createResizeEdges(element);
      }

      function populateChartDataEditor(element) {
        if (!element) return;
        const chartConfig = getChartConfigForElement(element);
        const legend = normalizeChartLegend(element.dataset.legend, chartConfig?.legend || []);
        const values = getChartValuesForElement(element, chartConfig);
        const chartType = chartConfig?.type || chartConfig?.id;
        const supportsToggle = chartType === 'bar' || chartType === 'pie' || chartType === 'line';
        if (chartDataShowValuesRow && chartDataShowValuesCheckbox) {
          if (supportsToggle) {
            chartDataShowValuesRow.classList.remove('hidden');
            chartDataShowValuesCheckbox.checked = element.dataset.showValues === 'true';
            chartDataShowValuesCheckbox.disabled = false;
          } else {
            chartDataShowValuesRow.classList.add('hidden');
            chartDataShowValuesCheckbox.checked = false;
            chartDataShowValuesCheckbox.disabled = true;
          }
        }
        if (chartDataVariantContainer && chartDataVariantOptions) {
          const variantOptions = CHART_VARIANT_MAP.get(chartType) || [];
          if (variantOptions.length > 1) {
            chartDataVariantContainer.hidden = false;
            chartDataVariantOptions.innerHTML = '';
            const currentVariantConfig = getChartOptionById(element.dataset.chartType || chartConfig.id);
            const currentVariantId = currentVariantConfig?.id || chartConfig.id;
            variantOptions.forEach((variant) => {
              const button = document.createElement('button');
              button.type = 'button';
              button.className = 'chart-data-variant-button' + (variant.id === currentVariantId ? ' active' : '');
              const variantLabel = variant.variantLabel
                || (variant.variant ? variant.variant.charAt(0).toUpperCase() + variant.variant.slice(1) : 'Default');
              button.textContent = variantLabel;
              button.title = variant.name;
              button.dataset.variantId = variant.id;
              button.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                const activeConfig = getChartOptionById(element.dataset.chartType || chartConfig.id);
                if (activeConfig?.id === variant.id) {
                  return;
                }
                applyChartVariantToElement(element, variant.id);
                populateChartDataEditor(element);
                capture();
                renderSidebar();
                saveEditorState('change_chart_style');
              });
              chartDataVariantOptions.appendChild(button);
            });
          } else {
            chartDataVariantContainer.hidden = true;
            chartDataVariantOptions.innerHTML = '';
          }
        }
        const length = Math.max(legend.length, values.length, 1);
        const table = chartDataEditorTableBody.closest('table');
        if (chartType === 'line') {
          chartDataStandardEditor.classList.add('hidden');
          chartDataStandardActions.classList.add('hidden');
          chartDataLineEditor.classList.remove('hidden');
          const state = getLineChartState(element, chartConfig, { ensureDataset: true });
          renderLineChartEditor(state.categories, state.series, chartConfig);
          chartDataSubtitle.textContent = chartConfig?.name ? `${chartConfig.name}` : 'Chart';
          if (chartDataTitleInput) {
            chartDataTitleInput.value = element.dataset.title || chartConfig?.name || '';
          }
          return;
        }
        chartDataLineEditor.classList.add('hidden');
        chartDataStandardEditor.classList.remove('hidden');
        chartDataStandardActions.classList.remove('hidden');
        chartDataEditorTableBody.innerHTML = '';
        for (let index = 0; index < length; index += 1) {
          const row = document.createElement('tr');
          row.dataset.index = String(index);

          const labelCell = document.createElement('td');
          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.placeholder = 'Label';
          labelInput.value = legend[index]?.label || '';
          labelInput.className = 'chart-data-input';
          labelInput.dataset.field = 'label';
          labelCell.appendChild(labelInput);

          const valueCell = document.createElement('td');
          const valueInput = document.createElement('input');
          valueInput.type = 'number';
          valueInput.step = 'any';
          valueInput.placeholder = '0';
          const numericValue = Number(values[index]);
          valueInput.value = Number.isFinite(numericValue) ? String(numericValue) : '';
          valueInput.className = 'chart-data-input';
          valueInput.dataset.field = 'value';
          valueCell.appendChild(valueInput);

          const colorCell = document.createElement('td');
          const colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.className = 'chart-data-color-input';
          colorInput.value = normalizeColorHex(legend[index]?.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]);
          colorInput.dataset.field = 'color';
          colorCell.appendChild(colorInput);

          row.appendChild(labelCell);
          row.appendChild(valueCell);
          row.appendChild(colorCell);
          chartDataEditorTableBody.appendChild(row);
        }
        const rowCount = chartDataEditorTableBody.querySelectorAll('tr').length;
        if (rowCount > 0) {
          table.removeAttribute('hidden');
          chartDataEmptyMessage.hidden = true;
        } else {
          table.setAttribute('hidden', 'hidden');
          chartDataEmptyMessage.hidden = false;
        }
        chartDataRemoveRowButton.disabled = rowCount <= 1;
        chartDataSubtitle.textContent = chartConfig?.name ? `${chartConfig.name}` : 'Chart';
        if (chartDataTitleInput) {
          chartDataTitleInput.value = element.dataset.title || chartConfig?.name || '';
        }
      }

      function renderLineChartEditor(categories, series, chartConfig) {
        const categoryCount = Math.max(
          Array.isArray(categories) ? categories.length : 0,
          series.reduce((max, item) => Math.max(max, Array.isArray(item?.values) ? item.values.length : 0), 0),
          1
        );
        const normalizedCategories = normalizeLineCategories(categories, chartConfig?.legend || [], categoryCount);
        const normalizedSeries = normalizeLineSeries(series, chartConfig?.series || [], categoryCount);
        lineSeriesList.innerHTML = '';
        normalizedSeries.forEach((seriesItem, index) => {
          const item = document.createElement('div');
          item.className = 'chart-line-series-item';
          item.dataset.index = String(index);

          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.className = 'chart-data-input line-series-label';
          labelInput.placeholder = 'Line Name';
          labelInput.value = seriesItem.label || `Line ${index + 1}`;

          const colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.className = 'chart-data-color-input line-series-color';
          colorInput.value = normalizeColorHex(seriesItem.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]);

          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'chart-line-series-remove';
          removeButton.dataset.index = String(index);
          removeButton.textContent = 'Remove';
          if (normalizedSeries.length <= 1) {
            removeButton.disabled = true;
            removeButton.hidden = true;
          }

          item.appendChild(labelInput);
          item.appendChild(colorInput);
          item.appendChild(removeButton);
          lineSeriesList.appendChild(item);
        });

        lineValuesTableHead.innerHTML = '';
        const headerRow = document.createElement('tr');
        const labelHeader = document.createElement('th');
        labelHeader.textContent = 'Point Label';
        headerRow.appendChild(labelHeader);
        normalizedSeries.forEach((seriesItem, index) => {
          const th = document.createElement('th');
          th.textContent = seriesItem.label || `Line ${index + 1}`;
          th.dataset.seriesIndex = String(index);
          headerRow.appendChild(th);
        });
        lineValuesTableHead.appendChild(headerRow);

        lineValuesTableBody.innerHTML = '';
        normalizedCategories.forEach((categoryItem, index) => {
          const row = document.createElement('tr');
          row.dataset.index = String(index);

          const labelCell = document.createElement('td');
          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.className = 'chart-data-input line-point-label';
          labelInput.placeholder = 'Label';
          labelInput.value = categoryItem.label || `Point ${index + 1}`;
          labelCell.appendChild(labelInput);
          row.appendChild(labelCell);

          normalizedSeries.forEach((seriesItem, seriesIndex) => {
            const valueCell = document.createElement('td');
            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.step = 'any';
            valueInput.className = 'chart-data-input line-point-value';
            valueInput.dataset.seriesIndex = String(seriesIndex);
            const numericValue = Number(seriesItem.values?.[index]);
            valueInput.value = Number.isFinite(numericValue) ? String(numericValue) : '';
            valueCell.appendChild(valueInput);
            row.appendChild(valueCell);
          });

          lineValuesTableBody.appendChild(row);
        });
        const hasRows = lineValuesTableBody.querySelectorAll('tr').length > 0;
        lineValuesEmptyMessage.hidden = hasRows;
        ensureLineEditorButtonState(normalizedCategories.length, normalizedSeries.length);
      }

      function ensureLineEditorButtonState(categoriesLength, seriesLength) {
        if (linePointRemoveButton) {
          linePointRemoveButton.disabled = categoriesLength <= 1;
        }
        const removeButtons = lineSeriesList.querySelectorAll('.chart-line-series-remove');
        removeButtons.forEach((button) => {
          button.disabled = seriesLength <= 1;
          button.hidden = seriesLength <= 1;
        });
      }

      function updateLineHeaderLabels() {
        const headerCells = lineValuesTableHead.querySelectorAll('th[data-series-index]');
        headerCells.forEach((cell) => {
          const index = Number(cell.dataset.seriesIndex);
          if (!Number.isFinite(index)) return;
          const labelInput = lineSeriesList.querySelector(`.chart-line-series-item[data-index="${index}"] .line-series-label`);
          if (labelInput) {
            cell.textContent = labelInput.value || `Line ${index + 1}`;
          }
        });
      }

      function collectLineEditorState(chartConfig) {
        const previousState = activeChartDataElement
          ? getLineChartState(activeChartDataElement, chartConfig)
          : { categories: [], series: [] };
        const seriesNodes = Array.from(lineSeriesList.querySelectorAll('.chart-line-series-item'));
        const series = seriesNodes.map((node, index) => {
          const labelInput = node.querySelector('.line-series-label');
          const colorInput = node.querySelector('.line-series-color');
          const fallbackSeries = previousState.series[index] || {};
          return {
            label: labelInput ? labelInput.value : (fallbackSeries.label || `Line ${index + 1}`),
            color: normalizeColorHex(
              colorInput ? colorInput.value || fallbackSeries.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
                : (fallbackSeries.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length])
            ),
            values: []
          };
        });
        const rows = Array.from(lineValuesTableBody.querySelectorAll('tr'));
        const categories = rows.map((row, rowIndex) => {
          const labelInput = row.querySelector('.line-point-label');
          const fallbackCategory = previousState.categories[rowIndex] || {};
          return {
            label: labelInput ? labelInput.value : (fallbackCategory.label || `Point ${rowIndex + 1}`),
            color: normalizeColorHex(
              fallbackCategory.color
              || chartConfig?.legend?.[rowIndex]?.color
              || CHART_COLOR_SEQUENCE[rowIndex % CHART_COLOR_SEQUENCE.length]
            )
          };
        });
        rows.forEach((row, rowIndex) => {
          series.forEach((seriesItem, seriesIndex) => {
            const valueInput = row.querySelector(`input[data-series-index="${seriesIndex}"]`);
            const numericValue = valueInput ? Number(valueInput.value) : NaN;
            if (Number.isFinite(numericValue)) {
              seriesItem.values.push(numericValue);
            } else {
              const fallbackValue = previousState.series[seriesIndex]?.values?.[rowIndex];
              seriesItem.values.push(Number.isFinite(fallbackValue) ? fallbackValue : 0);
            }
          });
        });
        const categoriesLength = categories.length;
        series.forEach((seriesItem, seriesIndex) => {
          seriesItem.values = adjustNumberArrayLength(
            seriesItem.values,
            Math.max(categoriesLength, 1),
            previousState.series[seriesIndex]?.values || []
          );
        });
        return { categories, series };
      }

      function addLineChartSeries() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        const newIndex = state.series.length;
        const categoriesLength = Math.max(state.categories.length, 1);
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        const templateSeries = fallbackSeries[newIndex] || fallbackSeries[0] || {};
        const defaultLabel = templateSeries.label || `Line ${newIndex + 1}`;
        const defaultColor = normalizeColorHex(
          templateSeries.color || CHART_COLOR_SEQUENCE[newIndex % CHART_COLOR_SEQUENCE.length]
        );
        const templateValues = Array.isArray(templateSeries.values) && templateSeries.values.length
          ? templateSeries.values
          : (state.series[0]?.values || []);
        const paddedValues = adjustNumberArrayLength(
          templateValues.map((value) => {
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : 0;
          }),
          categoriesLength,
          templateValues
        );
        state.series.push({
          label: defaultLabel,
          color: defaultColor,
          values: paddedValues
        });
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function removeLineChartSeries(index) {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        if (state.series.length <= 1) return;
        if (!Number.isFinite(index) || index < 0 || index >= state.series.length) return;
        state.series.splice(index, 1);
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function addLineChartPoint() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        const newIndex = state.categories.length;
        const fallbackCategory = chartConfig?.legend?.[newIndex] || {};
        state.categories.push({
          label: fallbackCategory.label || `Point ${newIndex + 1}`,
          color: normalizeColorHex(
            fallbackCategory.color || CHART_COLOR_SEQUENCE[newIndex % CHART_COLOR_SEQUENCE.length]
          )
        });
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        state.series = state.series.map((seriesItem, seriesIndex) => {
          const fallbackValues = fallbackSeries[seriesIndex]?.values || seriesItem.values;
          const fallbackValue = Number(fallbackValues?.[fallbackValues.length - 1]);
          const priorValue = seriesItem.values.length ? seriesItem.values[seriesItem.values.length - 1] : 50;
          const valueToAdd = Number.isFinite(fallbackValue) ? fallbackValue : priorValue;
          return {
            ...seriesItem,
            values: [...seriesItem.values, Number.isFinite(valueToAdd) ? valueToAdd : 0]
          };
        });
        state.series.forEach((seriesItem, seriesIndex) => {
          seriesItem.values = adjustNumberArrayLength(
            seriesItem.values,
            state.categories.length,
            chartConfig?.series?.[seriesIndex]?.values || seriesItem.values
          );
        });
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function removeLineChartPoint() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        const state = collectLineEditorState(chartConfig);
        if (state.categories.length <= 1) return;
        state.categories.pop();
        state.series.forEach((seriesItem) => {
          if (Array.isArray(seriesItem.values) && seriesItem.values.length) {
            seriesItem.values.pop();
          }
        });
        setLineChartState(activeChartDataElement, chartConfig, {
          categories: state.categories,
          series: state.series,
          title: activeChartDataElement.dataset.title || '',
          showValues: activeChartDataElement.dataset.showValues === 'true'
        });
        const updatedState = getLineChartState(activeChartDataElement, chartConfig);
        renderLineChartEditor(updatedState.categories, updatedState.series, chartConfig);
        scheduleChartDataStateSave();
      }

      function scheduleChartDataStateSave() {
        clearTimeout(chartDataAutoSaveTimeout);
        chartDataAutoSaveTimeout = setTimeout(() => {
          capture();
          renderSidebar();
          saveEditorState('edit_chart_data');
        }, 600);
      }

      function syncActiveChartDataFromEditor() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        if ((chartConfig?.type || chartConfig?.id) === 'line') {
          const state = collectLineEditorState(chartConfig);
          setLineChartState(activeChartDataElement, chartConfig, {
            categories: state.categories,
            series: state.series,
            title: activeChartDataElement.dataset.title || '',
            showValues: activeChartDataElement.dataset.showValues === 'true'
          });
          updateLineHeaderLabels();
          scheduleChartDataStateSave();
          return;
        }
        const existingLegend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
        const rows = Array.from(chartDataEditorTableBody.querySelectorAll('tr'));
        if (!rows.length) {
          applyChartDataToElement(activeChartDataElement, existingLegend.length ? existingLegend : (chartConfig?.legend || []), getChartValuesForElement(activeChartDataElement, chartConfig));
          scheduleChartDataStateSave();
          return;
        }
        const updatedLegend = [];
        const updatedValues = [];
        rows.forEach((row, index) => {
          const labelInput = row.querySelector('input[data-field="label"]');
          const valueInput = row.querySelector('input[data-field="value"]');
          const colorInput = row.querySelector('input[data-field="color"]');
          const baseLegendItem = existingLegend[index] || {};
          const label = labelInput ? labelInput.value : '';
          const valueRaw = valueInput ? valueInput.value : '';
          const fallbackColor = normalizeColorHex(
            baseLegendItem.color
            || (chartConfig?.legend && chartConfig.legend[index]?.color)
            || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
          );
          const colorValue = colorInput ? normalizeColorHex(colorInput.value || fallbackColor) : fallbackColor;
          updatedLegend.push({
            label,
            color: colorValue
          });
          const numericValue = Number(valueRaw);
          updatedValues.push(Number.isFinite(numericValue) ? numericValue : 0);
        });
        applyChartDataToElement(activeChartDataElement, updatedLegend, updatedValues);
        scheduleChartDataStateSave();
      }

      function addChartDataRow() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        if ((chartConfig?.type || chartConfig?.id) === 'line') {
          addLineChartPoint();
          return;
        }
        const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
        const values = getChartValuesForElement(activeChartDataElement, chartConfig);
        const nextIndex = Math.max(legend.length, values.length);
        const typeForBase = chartConfig?.type || chartConfig?.id;
        let defaultLabelBase = 'Series';
        if (typeForBase === 'pie') {
          defaultLabelBase = 'Slice';
        } else if (typeForBase === 'line') {
          defaultLabelBase = 'Point';
        }
        legend.push({
          label: `${defaultLabelBase} ${nextIndex + 1}`,
          color: normalizeColorHex(
            (chartConfig?.legend && chartConfig.legend[nextIndex]?.color) || CHART_COLOR_SEQUENCE[nextIndex % CHART_COLOR_SEQUENCE.length]
          )
        });
        const previousValue = values.length ? values[values.length - 1] : ((chartConfig?.type || chartConfig?.id) === 'pie' ? 25 : 50);
        values.push(previousValue);
        applyChartDataToElement(activeChartDataElement, legend, values);
        populateChartDataEditor(activeChartDataElement);
        scheduleChartDataStateSave();
      }

      function removeChartDataRow() {
        if (!activeChartDataElement) return;
        const chartConfig = getChartConfigForElement(activeChartDataElement);
        if ((chartConfig?.type || chartConfig?.id) === 'line') {
          removeLineChartPoint();
          return;
        }
        const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
        const values = getChartValuesForElement(activeChartDataElement, chartConfig);
        if (legend.length <= 1 || values.length <= 1) {
          return;
        }
        legend.pop();
        values.pop();
        applyChartDataToElement(activeChartDataElement, legend, values);
        populateChartDataEditor(activeChartDataElement);
        scheduleChartDataStateSave();
      }

      function showChartDataEditor(element) {
        if (!element) return;
        activeChartDataElement = element;
        populateChartDataEditor(element);
        chartDataEditor.classList.add('visible');
        chartDataEditor.style.left = '';
        chartDataEditor.style.top = '';
        chartDataEditor.style.right = '36px';
        chartDataEditor.style.top = '120px';
      }

      function hideChartDataEditor() {
        chartDataEditor.classList.remove('visible');
        activeChartDataElement = null;
      }

      function getConstrainedChartDataPosition(left, top) {
        const padding = 16;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const rect = chartDataEditor.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        const maxLeft = viewportWidth - width - padding;
        const maxTop = viewportHeight - height - padding;
        return {
          left: Math.min(Math.max(padding, left), Math.max(padding, maxLeft)),
          top: Math.min(Math.max(padding, top), Math.max(padding, maxTop))
        };
      }

      function handleChartDataHeaderPointerDown(event) {
        const header = event.target.closest('.chart-data-header');
        if (!header || event.target.closest('.chart-data-close')) {
          return;
        }
        event.preventDefault();
        const rect = chartDataEditor.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        chartDataDragState = { offsetX, offsetY };
        chartDataEditor.style.right = 'auto';
        chartDataEditor.setPointerCapture?.(event.pointerId);
      }

      function handleChartDataHeaderPointerMove(event) {
        if (!chartDataDragState) return;
        const { offsetX, offsetY } = chartDataDragState;
        const left = event.clientX - offsetX;
        const top = event.clientY - offsetY;
        const constrained = getConstrainedChartDataPosition(left, top);
        chartDataEditor.style.left = `${constrained.left}px`;
        chartDataEditor.style.top = `${constrained.top}px`;
      }

      function handleChartDataHeaderPointerUp(event) {
        if (!chartDataDragState) return;
        chartDataDragState = null;
        chartDataEditor.releasePointerCapture?.(event.pointerId);
      }

      chartDataEditor.addEventListener('pointerdown', handleChartDataHeaderPointerDown);
      chartDataEditor.addEventListener('pointermove', handleChartDataHeaderPointerMove);
      chartDataEditor.addEventListener('pointerup', handleChartDataHeaderPointerUp);
      chartDataEditor.addEventListener('pointercancel', handleChartDataHeaderPointerUp);

      chartDataEditorTableBody.addEventListener('input', (event) => {
        if (!(event.target instanceof HTMLInputElement)) return;
        if (!event.target.classList.contains('chart-data-input') && !event.target.classList.contains('chart-data-color-input')) return;
        syncActiveChartDataFromEditor();
      });

      chartDataEditorTableBody.addEventListener('change', (event) => {
        if (!(event.target instanceof HTMLInputElement)) return;
        if (!event.target.classList.contains('chart-data-input') && !event.target.classList.contains('chart-data-color-input')) return;
        syncActiveChartDataFromEditor();
      });

      if (lineSeriesAddButton) {
        lineSeriesAddButton.addEventListener('click', () => {
          if (!activeChartDataElement) return;
          addLineChartSeries();
        });
      }

      if (linePointAddButton) {
        linePointAddButton.addEventListener('click', () => {
          if (!activeChartDataElement) return;
          addLineChartPoint();
        });
      }

      if (linePointRemoveButton) {
        linePointRemoveButton.addEventListener('click', () => {
          if (!activeChartDataElement) return;
          removeLineChartPoint();
        });
      }

      if (lineSeriesList) {
        lineSeriesList.addEventListener('click', (event) => {
          if (!activeChartDataElement) return;
          const removeButton = event.target instanceof HTMLElement ? event.target.closest('.chart-line-series-remove') : null;
          if (removeButton) {
            const buttonIndex = Number(removeButton.dataset.index);
            const itemIndex = Number(removeButton.closest('.chart-line-series-item')?.dataset.index);
            const index = Number.isFinite(buttonIndex) ? buttonIndex : itemIndex;
            if (Number.isFinite(index)) {
              removeLineChartSeries(index);
            }
          }
        });
        lineSeriesList.addEventListener('input', (event) => {
          if (!activeChartDataElement) return;
          if (event.target instanceof HTMLInputElement && event.target.classList.contains('line-series-label')) {
            updateLineHeaderLabels();
            syncActiveChartDataFromEditor();
          }
        });
        lineSeriesList.addEventListener('change', (event) => {
          if (!activeChartDataElement) return;
          if (event.target instanceof HTMLInputElement && event.target.classList.contains('line-series-color')) {
            syncActiveChartDataFromEditor();
          }
        });
      }

      if (lineValuesTableBody) {
        lineValuesTableBody.addEventListener('input', (event) => {
          if (!activeChartDataElement) return;
          if (event.target instanceof HTMLInputElement && (event.target.classList.contains('line-point-label') || event.target.classList.contains('line-point-value'))) {
            syncActiveChartDataFromEditor();
          }
        });
      }

      if (chartDataShowValuesCheckbox) {
        chartDataShowValuesCheckbox.addEventListener('change', () => {
          if (!activeChartDataElement) return;
          const showValues = chartDataShowValuesCheckbox.checked;
          activeChartDataElement.dataset.showValues = showValues ? 'true' : 'false';
          const chartConfig = getChartConfigForElement(activeChartDataElement);
          const chartType = chartConfig?.type || chartConfig?.id;
          if (chartType === 'line') {
            const state = getLineChartState(activeChartDataElement, chartConfig);
            setLineChartState(activeChartDataElement, chartConfig, {
              categories: state.categories,
              series: state.series,
              title: activeChartDataElement.dataset.title || '',
              showValues
            });
          } else {
            const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
            const values = getChartValuesForElement(activeChartDataElement, chartConfig);
            const payload = {
              legend,
              title: activeChartDataElement.dataset.title || '',
              showValues
            };
            if (chartType === 'pie') {
              payload.slices = values;
            } else {
              payload.bars = values;
            }
            activeChartDataElement.innerHTML = renderChartMarkup(chartConfig, payload);
            createResizeEdges(activeChartDataElement);
          }
          capture();
          renderSidebar();
          saveEditorState('toggle_chart_values');
        });
      }

      if (chartDataTitleInput) {
        chartDataTitleInput.addEventListener('input', () => {
          if (!activeChartDataElement) return;
          const newTitle = chartDataTitleInput.value.trim();
          activeChartDataElement.dataset.title = newTitle;
          const chartConfig = getChartConfigForElement(activeChartDataElement);
          const chartType = chartConfig?.type || chartConfig?.id;
          if (chartType === 'line') {
            const state = getLineChartState(activeChartDataElement, chartConfig);
            setLineChartState(activeChartDataElement, chartConfig, {
              categories: state.categories,
              series: state.series,
              title: newTitle,
              showValues: activeChartDataElement.dataset.showValues === 'true'
            });
          } else {
            const legend = normalizeChartLegend(activeChartDataElement.dataset.legend, chartConfig?.legend || []);
            const values = getChartValuesForElement(activeChartDataElement, chartConfig);
            const payload = {
              legend,
              title: newTitle,
              showValues: activeChartDataElement.dataset.showValues === 'true'
            };
            if (chartType === 'pie') {
              payload.slices = values;
            } else {
              payload.bars = values;
            }
            activeChartDataElement.innerHTML = renderChartMarkup(chartConfig, payload);
            createResizeEdges(activeChartDataElement);
          }
          scheduleChartDataStateSave();
        });
        chartDataTitleInput.addEventListener('blur', () => {
          scheduleChartDataStateSave();
        });
      }

      chartDataAddRowButton.addEventListener('click', (event) => {
        event.preventDefault();
        addChartDataRow();
      });

      chartDataRemoveRowButton.addEventListener('click', (event) => {
        event.preventDefault();
        removeChartDataRow();
      });

      chartDataCloseButton.addEventListener('click', (event) => {
        event.preventDefault();
        hideChartDataEditor();
      });

      chartDataEditor.addEventListener('mousedown', (event) => {
        event.stopPropagation();
      });

      const slideContextMenu = document.createElement('div');
      slideContextMenu.id = 'slideContextMenu';
      slideContextMenu.className = 'slide-context-menu';
      slideContextMenu.innerHTML = `
        <button type="button" data-action="cut-slide">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
          <span class="menu-shortcut">âŒ˜X</span>
        </button>
        <button type="button" data-action="copy-slide">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
          <span class="menu-shortcut">âŒ˜C</span>
        </button>
        <button type="button" data-action="paste-slide">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
          <span class="menu-shortcut">âŒ˜V</span>
        </button>
        <button type="button" data-action="select-all-slides">
          <span class="menu-icon"><i class="fas fa-check-double"></i></span>
          <span>Select All</span>
          <span class="menu-shortcut">âŒ˜A</span>
        </button>
        <div class="menu-divider"></div>
        <button type="button" data-action="new-slide">
          <span class="menu-icon"><i class="fas fa-plus"></i></span>
          <span>New Slide</span>
          <span class="menu-shortcut">â‡§âŒ˜N</span>
        </button>
        <button type="button" data-action="add-section">
          <span class="menu-icon"><i class="fas fa-folder-plus"></i></span>
          <span>Add Section</span>
        </button>
        <button type="button" data-action="rename-slide">
          <span class="menu-icon"><i class="fas fa-pen"></i></span>
          <span>Rename</span>
        </button>
        <div class="menu-divider"></div>
        <button type="button" data-action="duplicate-slide">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Duplicate Slide</span>
          <span class="menu-shortcut">â‡§âŒ˜D</span>
        </button>
        <button type="button" data-action="delete-slide">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete Slide</span>
        </button>
      `;
      document.body.appendChild(slideContextMenu);
      
      // Sidebar context menu (for empty sidebar area)
      const sidebarContextMenu = document.createElement('div');
      sidebarContextMenu.id = 'sidebarContextMenu';
      sidebarContextMenu.className = 'slide-context-menu';
      sidebarContextMenu.innerHTML = `
        <button type="button" data-action="cut-slide">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
          <span class="menu-shortcut">âŒ˜X</span>
        </button>
        <button type="button" data-action="copy-slide">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
          <span class="menu-shortcut">âŒ˜C</span>
        </button>
        <button type="button" data-action="paste-slide">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
          <span class="menu-shortcut">âŒ˜V</span>
        </button>
        <button type="button" data-action="select-all-slides">
          <span class="menu-icon"><i class="fas fa-check-double"></i></span>
          <span>Select All</span>
          <span class="menu-shortcut">âŒ˜A</span>
        </button>
        <div class="menu-divider"></div>
        <button type="button" data-action="new-slide">
          <span class="menu-icon"><i class="fas fa-plus"></i></span>
          <span>New Slide</span>
          <span class="menu-shortcut">â‡§âŒ˜N</span>
        </button>
        <button type="button" data-action="add-section">
          <span class="menu-icon"><i class="fas fa-folder-plus"></i></span>
          <span>Add Section</span>
        </button>
      `;
      document.body.appendChild(sidebarContextMenu);
      
      // Section context menu
      const sectionContextMenu = document.createElement('div');
      sectionContextMenu.id = 'sectionContextMenu';
      sectionContextMenu.className = 'section-context-menu';
      sectionContextMenu.innerHTML = `
        <button type="button" data-action="rename-section">
          <span class="menu-icon"><i class="fas fa-pen"></i></span>
          <span>Rename Section</span>
        </button>
        <div class="menu-divider"></div>
        <button type="button" data-action="remove-section">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Remove Section</span>
        </button>
        <button type="button" data-action="remove-section-and-slides">
          <span class="menu-icon"><i class="fas fa-trash-alt"></i></span>
          <span>Remove Section and Slides</span>
        </button>
        <button type="button" data-action="remove-all-sections">
          <span class="menu-icon"><i class="fas fa-folder-minus"></i></span>
          <span>Remove All Sections</span>
        </button>
        <div class="menu-divider"></div>
        <button type="button" data-action="move-section-up">
          <span class="menu-icon"><i class="fas fa-arrow-up"></i></span>
          <span>Move Section Up</span>
        </button>
        <div class="menu-divider"></div>
        <button type="button" data-action="move-section-down">
          <span class="menu-icon"><i class="fas fa-arrow-down"></i></span>
          <span>Move Section Down</span>
        </button>
      `;
      document.body.appendChild(sectionContextMenu);
      
      const slideContextRenameBtn = slideContextMenu.querySelector('[data-action="rename-slide"]');
      const slideContextAddSectionBtn = slideContextMenu.querySelector('[data-action="add-section"]');

      const slideTransitionMenu = document.createElement('div');
      slideTransitionMenu.id = 'slideTransitionMenu';
      slideTransitionMenu.className = 'slide-context-menu';
      slideTransitionMenu.innerHTML = '';
      document.body.appendChild(slideTransitionMenu);
      const elementContextMenu = document.createElement('div');
      elementContextMenu.id = 'elementContextMenu';
      elementContextMenu.className = 'image-context-menu';
      elementContextMenu.innerHTML = `
        <button type="button" data-action="copy">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
        </button>
        <button type="button" data-action="cut">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
        </button>
        <button type="button" data-action="paste">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
        </button>
        <button type="button" data-action="translate">
          <span class="menu-icon"><i class="fas fa-language"></i></span>
          <span>Translate</span>
        </button>
        <button type="button" data-action="delete">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete</span>
        </button>
        <button type="button" data-action="bring-forward">
          <span class="menu-icon"><i class="fas fa-arrow-up"></i></span>
          <span>Bring Forward</span>
        </button>
        <button type="button" data-action="send-backward">
          <span class="menu-icon"><i class="fas fa-arrow-down"></i></span>
          <span>Send Backward</span>
        </button>
        <button type="button" data-action="bring-to-front">
          <span class="menu-icon"><i class="fas fa-angle-double-up"></i></span>
          <span>Bring to Front</span>
        </button>
        <button type="button" data-action="send-to-back">
          <span class="menu-icon"><i class="fas fa-angle-double-down"></i></span>
          <span>Send to Back</span>
        </button>
        <button type="button" data-action="crop">
          <span class="menu-icon"><i class="fas fa-crop"></i></span>
          <span>Crop Image</span>
        </button>
        <button type="button" data-action="background">
          <span class="menu-icon"><i class="fas fa-image"></i></span>
          <span>Set Image as Background</span>
        </button>
      `;
      document.body.appendChild(elementContextMenu);
      const elementContextButtons = {
        copy: elementContextMenu.querySelector('[data-action="copy"]'),
        cut: elementContextMenu.querySelector('[data-action="cut"]'),
        paste: elementContextMenu.querySelector('[data-action="paste"]'),
        translate: elementContextMenu.querySelector('[data-action="translate"]'),
        delete: elementContextMenu.querySelector('[data-action="delete"]'),
        bringForward: elementContextMenu.querySelector('[data-action="bring-forward"]'),
        sendBackward: elementContextMenu.querySelector('[data-action="send-backward"]'),
        bringToFront: elementContextMenu.querySelector('[data-action="bring-to-front"]'),
        sendToBack: elementContextMenu.querySelector('[data-action="send-to-back"]'),
        crop: elementContextMenu.querySelector('[data-action="crop"]'),
        background: elementContextMenu.querySelector('[data-action="background"]')
      };
      const spellSuggestionEntries = [];
      let spellSuggestionLabel = null;
      const SPELL_SUGGESTION_LIMIT = 5;
      const SPELL_SUGGESTION_API = 'https://api.datamuse.com/words';
      const SpellCheckManager = (() => {
        const suggestionCache = new Map();
        const pendingRequests = new Map();
        const sanitizeWord = (word) => {
          if (!word) return '';
          return word.replace(/[^A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿']/g, '');
        };
        const normalizeWord = (word) => (word || '').toLowerCase();
        const getSuggestions = async (word) => {
          const sanitized = sanitizeWord(word);
          const normalized = normalizeWord(sanitized);
          if (!normalized || normalized.length < 2) {
            return [];
          }
          if (suggestionCache.has(normalized)) {
            return suggestionCache.get(normalized);
          }
          if (pendingRequests.has(normalized)) {
            return pendingRequests.get(normalized);
          }
          const controller = new AbortController();
          const timeoutId = window.setTimeout(() => controller.abort(), 4000);
          const request = fetch(`${SPELL_SUGGESTION_API}?max=${SPELL_SUGGESTION_LIMIT}&sp=${encodeURIComponent(normalized)}&v=enwiki`, {
            signal: controller.signal,
            headers: {
              'Accept': 'application/json'
            }
          })
            .then((response) => {
              if (!response.ok) {
                throw new Error('Spell suggestion request failed');
              }
              return response.json();
            })
            .then((data) => {
              if (!Array.isArray(data)) {
                return [];
              }
              const suggestions = data
                .map((item) => (item && typeof item.word === 'string') ? item.word : '')
                .filter(Boolean);
              suggestionCache.set(normalized, suggestions);
              return suggestions;
            })
            .catch(() => {
              suggestionCache.set(normalized, []);
              return [];
            })
            .finally(() => {
              window.clearTimeout(timeoutId);
              pendingRequests.delete(normalized);
            });
          pendingRequests.set(normalized, request);
          return request;
        };
        return {
          getSuggestions,
          sanitizeWord,
          normalizeWord
        };
      })();
      let spellSuggestionContext = null;
      function isSpellCheckTextElement(element) {
        if (!element) return false;
        if (element === titleBox || element === textBox) return true;
        return element.classList && element.classList.contains('additional-text-box');
      }
      function removeSpellSuggestionEntries() {
        while (spellSuggestionEntries.length) {
          const entry = spellSuggestionEntries.pop();
          if (entry && entry.parentNode) {
            entry.parentNode.removeChild(entry);
          }
        }
        if (spellSuggestionLabel && spellSuggestionLabel.parentNode) {
          spellSuggestionLabel.parentNode.removeChild(spellSuggestionLabel);
        }
        spellSuggestionLabel = null;
      }
      function addSpellSuggestionLabel() {
        if (spellSuggestionLabel || !elementContextButtons.copy) return;
        spellSuggestionLabel = document.createElement('div');
        spellSuggestionLabel.className = 'spell-suggestion-label';
        spellSuggestionLabel.textContent = 'Suggestions';
        elementContextMenu.insertBefore(spellSuggestionLabel, elementContextButtons.copy);
      }
      function showSpellSuggestionPlaceholder(message) {
        removeSpellSuggestionEntries();
        if (!elementContextButtons.copy) return;
        addSpellSuggestionLabel();
        if (!message) return;
        const placeholder = document.createElement('button');
        placeholder.type = 'button';
        placeholder.setAttribute('data-role', 'spell-suggestion');
        placeholder.disabled = true;
        placeholder.innerHTML = `<span>${message}</span>`;
        spellSuggestionEntries.push(placeholder);
        elementContextMenu.insertBefore(placeholder, elementContextButtons.copy);
      }
      function clearSpellSuggestionSection() {
        removeSpellSuggestionEntries();
        spellSuggestionContext = null;
      }
      function applySpellCheckStateToElement(element, enabled = isSpellCheckEnabled) {
        if (!element) return;
        element.spellcheck = enabled;
        element.setAttribute('spellcheck', enabled ? 'true' : 'false');
      }
      function refreshSpellCheckTargets() {
        const scope = canvas || document;
        scope.querySelectorAll(SPELLCHECK_TARGET_SELECTOR).forEach((el) => {
          applySpellCheckStateToElement(el);
        });
      }
      function updateSpellCheckToggleUI() {
        if (!spellCheckToggleButton) return;
        spellCheckToggleButton.classList.toggle('active', isSpellCheckEnabled);
        spellCheckToggleButton.setAttribute('aria-pressed', String(isSpellCheckEnabled));
        spellCheckToggleButton.setAttribute(
          'title',
          isSpellCheckEnabled ? 'Turn off spell check' : 'Turn on spell check'
        );
        spellCheckToggleButton.setAttribute(
          'aria-label',
          isSpellCheckEnabled ? 'Disable spell check' : 'Enable spell check'
        );
        if (spellCheckToggleState) {
          spellCheckToggleState.textContent = isSpellCheckEnabled ? 'On' : 'Off';
        }
      }
      function setSpellCheckEnabled(enabled, { persist = true } = {}) {
        const normalized = Boolean(enabled);
        if (isSpellCheckEnabled === normalized) {
          refreshSpellCheckTargets();
          updateSpellCheckToggleUI();
          return;
        }
        isSpellCheckEnabled = normalized;
        if (persist) {
          try {
            localStorage.setItem(SPELLCHECK_STORAGE_KEY, normalized ? 'true' : 'false');
          } catch (error) { /* ignore persistence errors */ }
        }
        refreshSpellCheckTargets();
        updateSpellCheckToggleUI();
        if (!normalized) {
          clearSpellSuggestionSection();
          hideElementContextMenu();
        }
      }
      function initializeSpellCheckControls() {
        let storedPreference = null;
        try {
          storedPreference = localStorage.getItem(SPELLCHECK_STORAGE_KEY);
        } catch (error) { /* ignore read errors */ }
        const shouldEnable = storedPreference === null ? true : storedPreference === 'true';
        isSpellCheckEnabled = shouldEnable;
        refreshSpellCheckTargets();
        updateSpellCheckToggleUI();
        if (!shouldEnable) {
          clearSpellSuggestionSection();
        }
        if (spellCheckToggleButton) {
          spellCheckToggleButton.addEventListener('click', () => {
            setSpellCheckEnabled(!isSpellCheckEnabled);
          });
        }
      }
      function getPreferredTranslationElement() {
        if (selectedTextBox && document.contains(selectedTextBox)) {
          return selectedTextBox;
        }
        const context = getSelectedElementContext();
        if (context && context.element && context.element.isContentEditable) {
          return context.element;
        }
        const activeElement = document.activeElement;
        if (activeElement && activeElement.isContentEditable) {
          return activeElement;
        }
        if (textBox && textBox.style.display !== 'none') {
          return textBox;
        }
        if (titleBox && titleBox.style.display !== 'none') {
          return titleBox;
        }
        return null;
      }
      function showTranslatorPanel() {
        if (!translatorPanel) return;
        translatorPanel.classList.remove('hidden');
        if (layoutMain) {
          layoutMain.classList.add('show-translator');
        }
      }
      function hideTranslatorPanel({ refocus = true } = {}) {
        if (!translatorPanel) return;
        translatorPanel.classList.add('hidden');
        if (layoutMain) {
          layoutMain.classList.remove('show-translator');
        }
        setTranslatorStatus('');
        if (translatorSourceInput) translatorSourceInput.value = '';
        if (translatorResultArea) translatorResultArea.value = '';
        if (refocus && translatorTargetElement && document.contains(translatorTargetElement)) {
          try {
            translatorTargetElement.focus({ preventScroll: true });
          } catch (error) {
            translatorTargetElement.focus();
          }
        }
        translatorTargetElement = null;
        translatorSelectionRange = null;
        isTranslatorBusy = false;
        if (translatorInsertButton) translatorInsertButton.disabled = false;
      }
      function captureSelectionRange(element) {
        translatorSelectionRange = null;
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);
        if (element && element.contains(range.commonAncestorContainer)) {
          translatorSelectionRange = range.cloneRange();
        }
      }
      function getSelectedTextWithinElement(element) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
          return '';
        }
        const selected = selection.toString();
        if (!selected) return '';
        if (element && element.contains(selection.anchorNode) && element.contains(selection.focusNode)) {
          return selected;
        }
        return '';
      }
      function openTranslatorPanel(targetElement = null, { autoTranslate = false } = {}) {
        translatorTargetElement = targetElement && document.contains(targetElement)
          ? targetElement
          : getPreferredTranslationElement();
        const selectedText = translatorTargetElement
          ? getSelectedTextWithinElement(translatorTargetElement)
          : '';
        const sourceText = selectedText && selectedText.trim().length
          ? selectedText.trim()
          : translatorTargetElement
            ? (translatorTargetElement.innerText || translatorTargetElement.textContent || '')
            : '';
        if (translatorSourceInput) translatorSourceInput.value = sourceText.trim();
        if (translatorResultArea) translatorResultArea.value = '';
        setTranslatorStatus(sourceText
          ? 'Choose a language and click Translate.'
          : 'Select text to translate.');
        captureSelectionRange(translatorTargetElement);
        showTranslatorPanel();
        requestAnimationFrame(() => {
          if (translatorSourceInput) {
            translatorSourceInput.focus({ preventScroll: true });
            translatorSourceInput.setSelectionRange(translatorSourceInput.value.length, translatorSourceInput.value.length);
          }
        });
        if (autoTranslate && sourceText) {
          performTranslatorLookup();
        }
      }
      async function performTranslatorLookup() {
        if (isTranslatorBusy) return;
        if (!translatorSourceInput || !translatorLanguageSelect) return;
        const sourceText = translatorSourceInput.value.trim();
        if (!sourceText) {
          setTranslatorStatus('Select or enter text to translate.');
          translatorSourceInput.focus({ preventScroll: true });
          return;
        }
        const targetLanguage = translatorLanguageSelect.value;
        if (!targetLanguage) {
          setTranslatorStatus('Select a target language.');
          translatorLanguageSelect.focus({ preventScroll: true });
          return;
        }
        isTranslatorBusy = true;
        if (translatorInsertButton) translatorInsertButton.disabled = true;
        setTranslatorStatus('Translatingâ€¦');
        try {
          const controller = new AbortController();
          const timeoutId = window.setTimeout(() => controller.abort(), 12000);
          const response = await fetch(TRANSLATION_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              q: sourceText,
              source: 'auto',
              target: targetLanguage,
              format: 'text'
            }),
            signal: controller.signal
          });
          window.clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          const translated = typeof data === 'object' && data !== null && typeof data.translatedText === 'string'
            ? data.translatedText
            : '';
          if (translatorResultArea) {
            translatorResultArea.value = translated;
          }
          if (translated) {
            const inserted = insertTranslatedText(translated, { updatePanel: false });
            setTranslatorStatus(inserted ? 'Translation inserted.' : 'Translation ready.');
            if (!inserted && translatorResultArea) {
              translatorResultArea.value = translated;
            }
            try {
              localStorage.setItem(TRANSLATION_STORAGE_KEY, targetLanguage);
            } catch (error) { /* ignore persistence issues */ }
            lastTranslationLanguage = targetLanguage;
          } else {
            setTranslatorStatus('No translation available.');
          }
        } catch (error) {
          setTranslatorStatus('Unable to translate. Please try again.');
        } finally {
          isTranslatorBusy = false;
          if (translatorInsertButton) translatorInsertButton.disabled = false;
        }
      }
      function cloneTextBoxOptions(element) {
        const computed = window.getComputedStyle(element);
        const coords = getElementCanvasCoordinates(element);
        return {
          top: coords.top,
          left: coords.left,
          width: element.offsetWidth,
          height: element.offsetHeight,
          fontSize: computed.fontSize,
          fontFamily: computed.fontFamily,
          color: computed.color,
          backgroundColor: computed.backgroundColor,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          textAlign: computed.textAlign,
          fontWeight: computed.fontWeight,
          fontStyle: computed.fontStyle,
          textDecoration: computed.textDecoration,
          letterSpacing: computed.letterSpacing,
          lineHeight: computed.lineHeight
        };
      }
      function insertTranslatedText(translatedText, { updatePanel = true } = {}) {
        const normalized = typeof translatedText === 'string' ? translatedText.trim() : '';
        if (!normalized) {
          setTranslatorStatus('Translate text before inserting.');
          return false;
        }
        const element = translatorTargetElement && document.contains(translatorTargetElement)
          ? translatorTargetElement
          : getPreferredTranslationElement();
        if (!element) {
          setTranslatorStatus('Select a text box to insert translation.');
          return false;
        }
        const options = cloneTextBoxOptions(element);
        capture();
        const newBox = createAdditionalTextBox({
          top: options.top + 24,
          left: options.left + 24,
          width: options.width,
          height: options.height,
          fontSize: options.fontSize,
          fontFamily: options.fontFamily,
          color: options.color,
          backgroundColor: options.backgroundColor,
          rotation: options.rotation,
          zIndex: options.zIndex
        });
        if (!newBox) {
          setTranslatorStatus('Unable to insert translation.');
          return false;
        }
        newBox.textContent = normalized;
        newBox.style.fontWeight = options.fontWeight;
        newBox.style.fontStyle = options.fontStyle;
        newBox.style.textDecoration = options.textDecoration;
        newBox.style.textAlign = options.textAlign;
        if (options.letterSpacing && options.letterSpacing !== 'normal') {
          newBox.style.letterSpacing = options.letterSpacing;
        }
        if (options.lineHeight && options.lineHeight !== 'normal') {
          newBox.style.lineHeight = options.lineHeight;
        }
        translatorSelectionRange = null;
        queueMicrotask(() => {
          newBox.dispatchEvent(new Event('input', { bubbles: true }));
          newBox.dispatchEvent(new Event('change', { bubbles: true }));
          saveEditorState('translate_text_insert');
        });
        if (updatePanel && translatorResultArea) {
          translatorResultArea.value = normalized;
        }
        if (updatePanel) {
          setTranslatorStatus('Translation inserted.');
        }
        showNotification('Translation inserted');
        return true;
      }
      function insertTranslatorResult() {
        if (!translatorResultArea) return;
        const translation = translatorResultArea.value;
        insertTranslatedText(translation);
      }
      function repositionElementContextMenu() {
        if (!elementContextMenu || !elementContextMenu.classList.contains('show')) return;
        const padding = 12;
        const rect = elementContextMenu.getBoundingClientRect();
        let top = parseFloat(elementContextMenu.style.top || '0');
        let left = parseFloat(elementContextMenu.style.left || '0');
        if (Number.isNaN(top)) top = rect.top;
        if (Number.isNaN(left)) left = rect.left;
        if (rect.bottom > window.innerHeight - padding) {
          top = Math.max(padding, window.innerHeight - rect.height - padding);
        }
        if (rect.right > window.innerWidth - padding) {
          left = Math.max(padding, window.innerWidth - rect.width - padding);
        }
        elementContextMenu.style.top = `${top}px`;
        elementContextMenu.style.left = `${left}px`;
      }
      function getCaretRangeFromPoint(x, y) {
        if (typeof document.caretRangeFromPoint === 'function') {
          try {
            return document.caretRangeFromPoint(x, y);
          } catch (error) {
            return null;
          }
        }
        if (typeof document.caretPositionFromPoint === 'function') {
          const position = document.caretPositionFromPoint(x, y);
          if (!position) return null;
          const range = document.createRange();
          range.setStart(position.offsetNode, position.offset);
          range.collapse(true);
          return range;
        }
        return null;
      }
      function isWordCharacter(char) {
        if (!char) return false;
        return /[A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿']/u.test(char);
      }
      function extractWordInfoFromPoint(element, event) {
        if (!element || !event) return null;
        const range = getCaretRangeFromPoint(event.clientX, event.clientY);
        if (!range) return null;
        let container = range.startContainer;
        let offset = range.startOffset;
        if (container.nodeType !== Node.TEXT_NODE) {
          if (container.childNodes && container.childNodes.length > 0) {
            const childIndex = Math.min(offset, container.childNodes.length - 1);
            const childNode = container.childNodes[childIndex];
            if (childNode && childNode.nodeType === Node.TEXT_NODE) {
              container = childNode;
              offset = container.textContent ? container.textContent.length : 0;
            } else if (childIndex > 0) {
              const previousNode = container.childNodes[childIndex - 1];
              if (previousNode && previousNode.nodeType === Node.TEXT_NODE) {
                container = previousNode;
                offset = container.textContent ? container.textContent.length : 0;
              }
            }
          } else if (container.parentNode && container.parentNode.nodeType === Node.TEXT_NODE) {
            container = container.parentNode;
            offset = container.textContent ? container.textContent.length : offset;
          }
        }
        if (!container || container.nodeType !== Node.TEXT_NODE) return null;
        if (!element.contains(container)) return null;
        const textContent = container.textContent || '';
        if (!textContent.trim()) return null;
        let start = offset;
        let end = offset;
        while (start > 0 && isWordCharacter(textContent[start - 1])) {
          start -= 1;
        }
        while (end < textContent.length && isWordCharacter(textContent[end])) {
          end += 1;
        }
        if (start === end) {
          return null;
        }
        const rawWord = textContent.slice(start, end);
        const sanitized = SpellCheckManager.sanitizeWord(rawWord);
        if (!sanitized) {
          return null;
        }
        const wordRange = document.createRange();
        wordRange.setStart(container, start);
        wordRange.setEnd(container, end);
        return {
          id: Symbol('spell-word'),
          element,
          range: wordRange,
          word: rawWord,
          cleaned: SpellCheckManager.normalizeWord(sanitized)
        };
      }
      function renderSpellSuggestions(wordInfo) {
        if (!isSpellCheckEnabled) {
          clearSpellSuggestionSection();
          return;
        }
        if (!wordInfo) {
          clearSpellSuggestionSection();
          return;
        }
        SpellCheckManager.getSuggestions(wordInfo.cleaned)
          .then((suggestions) => {
            if (!spellSuggestionContext || spellSuggestionContext.id !== wordInfo.id) {
              return;
            }
            if (!isSpellCheckEnabled) {
              clearSpellSuggestionSection();
              repositionElementContextMenu();
              return;
            }
            const hasExactMatch = Array.isArray(suggestions)
              ? suggestions.some((suggestion) => SpellCheckManager.normalizeWord(suggestion) === wordInfo.cleaned)
              : false;
            if (hasExactMatch) {
              clearSpellSuggestionSection();
              repositionElementContextMenu();
              return;
            }
            const uniqueSuggestions = [];
            const lowerSeen = new Set();
            suggestions.forEach((suggestion) => {
              if (!suggestion || typeof suggestion !== 'string') return;
              const trimmed = suggestion.trim();
              if (!trimmed) return;
              const lowered = SpellCheckManager.normalizeWord(trimmed);
              if (lowered === wordInfo.cleaned) return;
              if (lowerSeen.has(lowered)) return;
              lowerSeen.add(lowered);
              uniqueSuggestions.push(trimmed);
            });
            if (!uniqueSuggestions.length) {
              showSpellSuggestionPlaceholder('No suggestions');
              repositionElementContextMenu();
              return;
            }
            removeSpellSuggestionEntries();
            addSpellSuggestionLabel();
            const reference = elementContextButtons.copy;
            uniqueSuggestions
              .slice(0, SPELL_SUGGESTION_LIMIT)
              .reverse()
              .forEach((suggestion) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.setAttribute('data-role', 'spell-suggestion');
                button.innerHTML = `<span>${suggestion}</span><span class="spell-suggestion-hint">â†µ</span>`;
                button.addEventListener('click', () => applySpellSuggestion(suggestion));
                spellSuggestionEntries.push(button);
                elementContextMenu.insertBefore(button, reference);
              });
            repositionElementContextMenu();
          })
          .catch(() => {
            if (!spellSuggestionContext || spellSuggestionContext.id !== wordInfo.id) {
              return;
            }
            if (!isSpellCheckEnabled) {
              clearSpellSuggestionSection();
              return;
            }
            showSpellSuggestionPlaceholder('No suggestions');
          });
      }
      function prepareSpellSuggestions(event, element) {
        if (!isSpellCheckEnabled) {
          clearSpellSuggestionSection();
          return false;
        }
        if (!isSpellCheckTextElement(element)) {
          clearSpellSuggestionSection();
          return false;
        }
        const wordInfo = extractWordInfoFromPoint(element, event);
        if (!wordInfo || !wordInfo.cleaned || wordInfo.cleaned.length < 2) {
          clearSpellSuggestionSection();
          return false;
        }
        spellSuggestionContext = wordInfo;
        showSpellSuggestionPlaceholder('Checkingâ€¦');
        renderSpellSuggestions(wordInfo);
        return true;
      }
      function applySpellSuggestion(suggestion) {
        if (!spellSuggestionContext || !suggestion) return;
        const { range, element } = spellSuggestionContext;
        if (!range || !element || !document.contains(element)) {
          clearSpellSuggestionSection();
          return;
        }
        const replacement = suggestion;
        const workingRange = range.cloneRange();
        workingRange.deleteContents();
        const textNode = document.createTextNode(replacement);
        workingRange.insertNode(textNode);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          const caretRange = document.createRange();
          caretRange.setStart(textNode, textNode.textContent.length);
          caretRange.collapse(true);
          selection.addRange(caretRange);
        }
        element.normalize();
        clearSpellSuggestionSection();
        hideElementContextMenu();
        queueMicrotask(() => {
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        });
      }
      clearSpellSuggestionSection();
      const slideCanvasContextMenu = document.createElement('div');
      slideCanvasContextMenu.id = 'slideCanvasContextMenu';
      slideCanvasContextMenu.className = 'slide-canvas-context-menu';
      slideCanvasContextMenu.innerHTML = `
        <button type="button" data-action="copy-slide">
          <span class="menu-icon"><i class="fas fa-copy"></i></span>
          <span>Copy</span>
        </button>
        <button type="button" data-action="cut-slide">
          <span class="menu-icon"><i class="fas fa-cut"></i></span>
          <span>Cut</span>
        </button>
        <button type="button" data-action="paste-slide">
          <span class="menu-icon"><i class="fas fa-paste"></i></span>
          <span>Paste</span>
        </button>
        <button type="button" data-action="new-slide">
          <span class="menu-icon"><i class="fas fa-plus"></i></span>
          <span>New Slide</span>
        </button>
        <button type="button" data-action="duplicate-slide">
          <span class="menu-icon"><i class="fas fa-clone"></i></span>
          <span>Duplicate Slide</span>
        </button>
        <button type="button" data-action="delete-slide">
          <span class="menu-icon"><i class="fas fa-trash"></i></span>
          <span>Delete Slide</span>
        </button>
      `;
      document.body.appendChild(slideCanvasContextMenu);
      const slideCanvasMenuButtons = {
        copy: slideCanvasContextMenu.querySelector('[data-action="copy-slide"]'),
        cut: slideCanvasContextMenu.querySelector('[data-action="cut-slide"]'),
        paste: slideCanvasContextMenu.querySelector('[data-action="paste-slide"]'),
        newSlide: slideCanvasContextMenu.querySelector('[data-action="new-slide"]'),
        duplicate: slideCanvasContextMenu.querySelector('[data-action="duplicate-slide"]'),
        delete: slideCanvasContextMenu.querySelector('[data-action="delete-slide"]')
      };
      const layoutMain = document.getElementById('layoutMain');
      const translatorPanel = document.getElementById('translatorPanel');
      const translatorCloseButton = document.getElementById('translatorCloseButton');
      const translatorSourceInput = document.getElementById('translatorSourceInput');
      const translatorLanguageSelect = document.getElementById('translatorLanguageSelect');
      const translatorResultArea = document.getElementById('translatorResultArea');
      const translatorStatusLabel = document.getElementById('translatorStatusLabel');
      const translatorInsertButton = document.getElementById('translatorInsertButton');
      let translatorTargetElement = null;
      let translatorSelectionRange = null;
      let isTranslatorBusy = false;
      let lastTranslationLanguage = (() => {
        try {
          return localStorage.getItem(TRANSLATION_STORAGE_KEY) || 'es';
        } catch (error) {
          return 'es';
        }
      })();
      if (translatorLanguageSelect) {
        TRANSLATION_LANGUAGES.forEach(({ code, label }) => {
          const option = document.createElement('option');
          option.value = code;
          option.textContent = label;
          translatorLanguageSelect.appendChild(option);
        });
        if (TRANSLATION_LANGUAGES.some(({ code }) => code === lastTranslationLanguage)) {
          translatorLanguageSelect.value = lastTranslationLanguage;
        }
      }
      function setTranslatorStatus(message) {
        if (!translatorStatusLabel) return;
        translatorStatusLabel.textContent = message || '';
      }
      const imageCropOverlay = document.createElement('div');
      imageCropOverlay.id = 'imageCropOverlay';
      imageCropOverlay.className = 'image-crop-overlay';
      imageCropOverlay.innerHTML = `
        <div class="image-crop-dialog" role="dialog" aria-modal="true" aria-labelledby="imageCropTitle">
          <div class="image-crop-header">
            <span id="imageCropTitle">Crop Image</span>
            <button type="button" id="imageCropClose" class="image-crop-close" aria-label="Close crop dialog">&times;</button>
          </div>
          <div class="image-crop-content">
            <img id="imageCropperImage" alt="Image crop preview">
          </div>
          <div class="image-crop-actions">
            <button type="button" id="imageCropCancel">Cancel</button>
            <button type="button" id="imageCropApply">Apply Crop</button>
          </div>
        </div>
      `;
      document.body.appendChild(imageCropOverlay);
      const imageCropperImage = imageCropOverlay.querySelector('#imageCropperImage');
      const imageCropCancel = imageCropOverlay.querySelector('#imageCropCancel');
      const imageCropApply = imageCropOverlay.querySelector('#imageCropApply');
      const imageCropClose = imageCropOverlay.querySelector('#imageCropClose');
      let elementContextTarget = null;
      let editorClipboard = {
        type: null,
        mode: 'copy',
        data: null,
        offset: 0
      };
      let imageCropperInstance = null;
      let imageCropTargetElement = null;
      let slideCanvasContextTargetIndex = null;
      function setEditorClipboard(type, data, mode = 'copy') {
        editorClipboard = {
          type,
          data,
          mode,
          offset: 0
        };
        updateSlideCanvasMenuState();
        updateElementContextMenuState();
      }
      function hideElementContextMenu() {
        if (!elementContextMenu) return;
        clearSpellSuggestionSection();
        elementContextMenu.classList.remove('show');
        elementContextMenu.style.top = '-9999px';
        elementContextMenu.style.left = '-9999px';
        elementContextTarget = null;
      }
      function updateElementContextMenuState() {
        if (!elementContextMenu) return;
        if (elementContextButtons.paste) {
          const hasElementsClipboard = editorClipboard.type === 'elements'
            && editorClipboard.data
            && Array.isArray(editorClipboard.data.items)
            && editorClipboard.data.items.length > 0;
          elementContextButtons.paste.disabled = !hasElementsClipboard;
        }
      }
      function getElementPosition(element) {
        return getElementCanvasCoordinates(element);
      }
      function serializeImageElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'image');
        const img = element.querySelector('img');
        if (!img) return null;
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          src: img.getAttribute('src'),
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '80'),
          minHeight: parseFloat(element.dataset.minHeight || '60'),
          aspectRatio: parseFloat(element.dataset.aspectRatio || (element.offsetWidth / Math.max(element.offsetHeight, 0.01))),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeVideoElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'video');
        const video = element.querySelector('video');
        if (!video) return null;
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          src: video.getAttribute('src'),
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '160'),
          minHeight: parseFloat(element.dataset.minHeight || '90'),
          aspectRatio: parseFloat(element.dataset.aspectRatio || (element.offsetWidth / Math.max(element.offsetHeight, 0.01))),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeShapeElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'shape');
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          shapeId: element.dataset.shape,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          color: normalizeColorHex(element.dataset.color || element.style.color || '#e8f5e9'),
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          minWidth: element.dataset.minWidth ? parseFloat(element.dataset.minWidth) : undefined,
          minHeight: element.dataset.minHeight ? parseFloat(element.dataset.minHeight) : undefined,
          rotation: parseFloat(element.dataset.rotation || '0') || 0
        };
      }
      function serializeChartElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'chart');
        const { left, top } = getElementPosition(element);
        const chartType = element.dataset.chartType || 'bar';
        const legend = normalizeChartLegend(element.dataset.legend, []);
        const lineSeries = (chartType.startsWith('line') || (chartType === 'line'))
          ? normalizeLineSeries(element.dataset.lineSeries, [], legend.length)
          : [];
        return {
          id: elementId,
          chartType,
          chartVariant: element.dataset.chartVariant || null,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: parseFloat(element.dataset.minWidth || '220'),
          minHeight: parseFloat(element.dataset.minHeight || '160'),
          bars: normalizeNumberArray(element.dataset.bars, []),
          slices: normalizeNumberArray(element.dataset.slices, []),
          lineSeries,
          legend,
          title: element.dataset.title || '',
          showValues: element.dataset.showValues === 'true',
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeTableElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, 'table');
        const table = element.querySelector('table');
        const rows = table ? table.rows.length : parseInt(element.dataset.rows || '1', 10) || 1;
        const cols = table && table.rows[0] ? table.rows[0].cells.length : parseInt(element.dataset.cols || '1', 10) || 1;
        const clone = element.cloneNode(true);
        clone.querySelectorAll('.table-resize-handle').forEach((handle) => handle.remove());
        clone.querySelectorAll('.table-cell-selected').forEach(cell => cell.classList.remove('table-cell-selected'));
        const sanitizedHtml = clone.innerHTML;
        const { left, top } = getElementPosition(element);
        return {
          id: elementId,
          rows,
          cols,
          html: sanitizedHtml,
          left,
          top,
          width: element.offsetWidth,
          height: element.offsetHeight,
          minWidth: parseFloat(element.dataset.minWidth || '240'),
          minHeight: parseFloat(element.dataset.minHeight || '160'),
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
        };
      }
      function serializeTextBoxElement(element) {
        if (!element) return null;
        const elementId = ensureElementHasId(element, element === titleBox ? 'title' : element === textBox ? 'body' : 'textbox');
        const { left, top } = getElementPosition(element);
        const computed = window.getComputedStyle(element);
        const minWidthValue = parseFloat(element.dataset.minWidth || element.style.minWidth || 200);
        const minHeightValue = parseFloat(element.dataset.minHeight || element.style.minHeight || 50);
        const sanitizedClone = element.cloneNode(true);
        sanitizedClone.querySelectorAll('.animation-order-badge').forEach(badge => badge.remove());
        const sanitizedHtml = sanitizedClone.innerHTML;
        return {
          id: elementId,
          html: sanitizedHtml,
          top,
          left,
          width: element.offsetWidth,
          height: element.offsetHeight,
          fontSize: element.style.fontSize || computed.fontSize,
          fontFamily: computed.fontFamily,
          display: element.style.display || '',
          rotation: parseFloat(element.dataset.rotation || '0') || 0,
          minWidth: minWidthValue,
          minHeight: minHeightValue,
          backgroundColor: element.style.backgroundColor || '',
          color: element.style.color || '',
          zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined,
          isTitle: element === titleBox,
          isBody: element === textBox
        };
      }
      function applyTextBoxData(element, data) {
        if (!element || !data) return;
        const elementId = data.id || ensureElementHasId(element, element === titleBox ? 'title' : element === textBox ? 'body' : 'textbox');
        element.dataset.elementId = elementId;
        if (!data.id) {
          data.id = elementId;
        }
        if (Number.isFinite(data.left)) {
          element.style.left = `${data.left}px`;
        }
        if (Number.isFinite(data.top)) {
          element.style.top = `${data.top}px`;
        }
        if (Number.isFinite(data.width)) {
          element.style.width = `${data.width}px`;
        }
        if (Number.isFinite(data.height)) {
          element.style.height = `${data.height}px`;
        }
        if (Number.isFinite(data.minWidth)) {
          element.dataset.minWidth = String(data.minWidth);
          element.style.minWidth = `${data.minWidth}px`;
        }
        if (Number.isFinite(data.minHeight)) {
          element.dataset.minHeight = String(data.minHeight);
          element.style.minHeight = `${data.minHeight}px`;
        }
        element.style.fontSize = data.fontSize || element.style.fontSize || '16px';
        element.style.fontFamily = data.fontFamily || element.style.fontFamily || DEFAULT_FONT_FAMILY;
        elementFontSizes.set(element, parseFloat(element.style.fontSize) || 16);
        elementFontFamilies.set(element, element.style.fontFamily || DEFAULT_FONT_FAMILY);
        element.style.backgroundColor = data.backgroundColor || '';
        element.style.color = data.color || '';
        // Ensure text boxes always use block display, never flex (to prevent vertical text stacking)
        const isTextBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        if (isTextBox) {
          element.style.display = 'block';
        } else {
        element.style.display = data.display || '';
        }
        const rotation = Number.isFinite(data.rotation) ? data.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = data.html || '';
        if (Number.isFinite(data.zIndex)) {
          element.style.zIndex = String(data.zIndex);
        }
        applySpellCheckStateToElement(element);
        createResizeEdges(element);
      }
      function serializeElement(element) {
        if (!element) return null;
        if (element.classList.contains('image-element')) {
          const data = serializeImageElement(element);
          return data ? { type: 'image', data } : null;
        }
        if (element.classList.contains('video-element')) {
          const data = serializeVideoElement(element);
          return data ? { type: 'video', data } : null;
        }
        if (element.classList.contains('shape-element')) {
          const data = serializeShapeElement(element);
          return data ? { type: 'shape', data } : null;
        }
        if (element.classList.contains('chart-element')) {
          const data = serializeChartElement(element);
          return data ? { type: 'chart', data } : null;
        }
        if (element.classList.contains('table-element')) {
          const data = serializeTableElement(element);
          return data ? { type: 'table', data } : null;
        }
        if (element.classList.contains('additional-text-box') || element === titleBox || element === textBox) {
          const data = serializeTextBoxElement(element);
          return data ? { type: 'textbox', data } : null;
        }
        return null;
      }
      function showElementContextMenu(event, element) {
        if (!elementContextMenu || !element) return;
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        elementContextTarget = element;
        prepareSpellSuggestions(event, element);
        elementContextMenu.classList.add('show');
        elementContextMenu.style.top = '0px';
        elementContextMenu.style.left = '0px';
        const menuRect = elementContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        elementContextMenu.style.top = `${Math.max(padding, top)}px`;
        elementContextMenu.style.left = `${Math.max(padding, left)}px`;
        const isImage = element.classList.contains('image-element');
        if (elementContextButtons.crop) {
          elementContextButtons.crop.style.display = isImage ? 'flex' : 'none';
        }
        if (elementContextButtons.background) {
          elementContextButtons.background.style.display = isImage ? 'flex' : 'none';
        }
        updateElementContextMenuState();
        repositionElementContextMenu();
      }
      function getSelectedElementContext() {
        if (selectedImage) return { type: 'image', element: selectedImage };
        if (selectedVideo) return { type: 'video', element: selectedVideo };
        if (selectedShape) return { type: 'shape', element: selectedShape };
        if (selectedChart) return { type: 'chart', element: selectedChart };
        if (selectedTable) return { type: 'table', element: selectedTable };
        if (selectedTextBox) return { type: 'textbox', element: selectedTextBox };
        return null;
      }

      function getLayerManagedElements() {
        return Array.from(canvas.querySelectorAll('.additional-text-box, .shape-element, .chart-element, .image-element, .video-element, .table-element'))
          .filter(el => !el.classList.contains('dragging'));
      }

      function getElementZIndex(element) {
        if (!element) return 0;
        const computed = window.getComputedStyle(element).zIndex;
        const parsed = parseInt(element.style.zIndex || computed || '0', 10);
        return Number.isFinite(parsed) ? parsed : 0;
      }

      function setElementZIndex(element, value) {
        if (!element) return;
        const normalized = Number.isFinite(value) ? value : 0;
        element.style.zIndex = String(normalized);
      }

      function bringSelectedElementsForward() {
        const context = getSelectedElementContext();
        const element = context?.element;
        if (!element) {
          showNotification('Select an object first');
          return;
        }
        const elements = getLayerManagedElements();
        const currentZ = getElementZIndex(element);
        const maxBelow = Math.max(
          currentZ,
          ...elements
            .filter(el => el !== element && getElementZIndex(el) > currentZ)
            .map(el => getElementZIndex(el))
        );
        const nextZ = Math.min(maxBelow, currentZ + 1);
        setElementZIndex(element, nextZ);
        capture();
        saveEditorState('bring_forward');
        refreshSidebarSoon();
        showNotification('Moved forward');
      }

      function sendSelectedElementsBackward() {
        const context = getSelectedElementContext();
        const element = context?.element;
        if (!element) {
          showNotification('Select an object first');
          return;
        }
        const elements = getLayerManagedElements();
        const currentZ = getElementZIndex(element);
        const minAbove = Math.min(
          currentZ,
          ...elements
            .filter(el => el !== element && getElementZIndex(el) < currentZ)
            .map(el => getElementZIndex(el))
        );
        const nextZ = Math.max(minAbove, currentZ - 1);
        setElementZIndex(element, nextZ);
        capture();
        saveEditorState('send_backward');
        refreshSidebarSoon();
        showNotification('Moved backward');
      }

      function bringSelectedElementsToFront() {
        const context = getSelectedElementContext();
        const element = context?.element;
        if (!element) {
          showNotification('Select an object first');
          return;
        }
        const elements = getLayerManagedElements();
        const maxZ = Math.max(0, ...elements.filter(el => el !== element).map(el => getElementZIndex(el)));
        setElementZIndex(element, maxZ + 1);
        capture();
        saveEditorState('bring_to_front');
        refreshSidebarSoon();
        showNotification('Brought to front');
      }

      function sendSelectedElementsToBack() {
        const context = getSelectedElementContext();
        const element = context?.element;
        if (!element) {
          showNotification('Select an object first');
          return;
        }
        const elements = getLayerManagedElements();
        const minZ = Math.min(0, ...elements.filter(el => el !== element).map(el => getElementZIndex(el)));
        setElementZIndex(element, minZ - 1);
        capture();
        saveEditorState('send_to_back');
        refreshSidebarSoon();
        showNotification('Sent to back');
      }

      function resetDictationState({ commit = true, message = null } = {}) {
        if (dictateButton) {
          dictateButton.classList.remove('active');
        }
        const target = dictateTargetBox;
        dictateTargetBox = null;
        isDictating = false;
        if (target) {
          const finalText = (dictationFinalText || target.textContent || '').trim();
          dictationFinalText = '';
          delete target.dataset.dictationFinal;
          target.textContent = finalText;
          if (!finalText) {
            target.dataset.placeholder = 'Click to add text';
          }
          if (commit) {
            capture();
            saveEditorState('dictate_text');
          }
        } else {
          dictationFinalText = '';
        }
        if (message) {
          showNotification(message);
        }
        updateDictationButtonLabel();
      }

      function stopDictation({ commit = true, message = null } = {}) {
        if (dictateRecognition) {
          try {
            dictateRecognition.onresult = null;
            dictateRecognition.onerror = null;
            dictateRecognition.onend = null;
            dictateRecognition.stop();
          } catch (error) {
            console.warn('Dictation stop error', error);
          }
          dictateRecognition = null;
        }
        resetDictationState({ commit, message });
      }

      let subtitlesClearTimeout = null;

      function updateSubtitlesDisplay(text, { scheduleClear = true } = {}) {
        if (!presentationSubtitlesEl) return;
        const content = (text || '').trim();
        if (subtitlesClearTimeout) {
          clearTimeout(subtitlesClearTimeout);
          subtitlesClearTimeout = null;
        }
        if (content) {
          presentationSubtitlesEl.textContent = content;
          presentationSubtitlesEl.classList.add('show');
          presentationSubtitlesEl.style.pointerEvents = 'auto';
          if (scheduleClear) {
            subtitlesClearTimeout = window.setTimeout(() => {
              updateSubtitlesDisplay('', { scheduleClear: false });
            }, SUBTITLES_CLEAR_DELAY);
          }
        } else {
          presentationSubtitlesEl.textContent = '';
          presentationSubtitlesEl.classList.remove('show');
          presentationSubtitlesEl.style.pointerEvents = 'none';
        }
      }

      function resetSubtitlesState({ message = null } = {}) {
        subtitlesFinalText = '';
        updateSubtitlesDisplay('', { scheduleClear: false });
        if (presentationSubtitlesEl) {
          delete presentationSubtitlesEl.dataset.posX;
          delete presentationSubtitlesEl.dataset.posY;
          presentationSubtitlesEl.style.left = '50%';
          presentationSubtitlesEl.style.bottom = '120px';
          presentationSubtitlesEl.style.transform = 'translate(-50%, 0)';
        }
        if (message) {
          showNotification(message);
        }
      }

      function stopSubtitles({ message = null, suppressSpeechStop = false } = {}) {
        if (!speechRecognitionConsumers.has('subtitles') && !subtitlesActive) {
          if (message) {
            showNotification(message);
          }
          return;
        }
        speechRecognitionConsumers.delete('subtitles');
        subtitlesActive = false;
        if (presentationSubtitleToggle) {
          presentationSubtitleToggle.classList.remove('active');
          presentationSubtitleToggle.setAttribute('aria-pressed', 'false');
        }
        updateSubtitleToggleLabel();
        resetSubtitlesState({ message: null });
        closeSubtitleLanguageMenu({ restoreFocus: false });
        if (presentationSubtitlesEl) {
          presentationSubtitlesEl.style.cursor = 'default';
          presentationSubtitlesEl.removeEventListener('pointerdown', startSubtitlesDrag);
          presentationSubtitlesEl.style.pointerEvents = 'none';
        }
        if (message) {
          showNotification(message);
        }
        if (!suppressSpeechStop) {
          maybeStopSpeechRecognition();
        }
      }

      function startSubtitles(options = {}) {
        const { skipNotification = false } = options;
        if (!ensureSpeechRecognition({ skipNotification })) {
          return;
        }
        if (!speechRecognitionConsumers.has('subtitles')) {
          speechRecognitionConsumers.add('subtitles');
        }
        if (subtitlesActive) {
          if (!skipNotification) {
            showNotification('Subtitles already enabled.');
          }
          return;
        }
        subtitlesActive = true;
        updateSubtitleToggleLabel();
        if (presentationSubtitleToggle) {
          presentationSubtitleToggle.classList.add('active');
          presentationSubtitleToggle.setAttribute('aria-pressed', 'true');
        }
        if (presentationSubtitlesEl) {
          presentationSubtitlesEl.style.cursor = 'grab';
          presentationSubtitlesEl.addEventListener('pointerdown', startSubtitlesDrag);
        }
        updateSubtitlesDisplay('Listeningâ€¦', { scheduleClear: false });
        if (!skipNotification) {
          showNotification('Subtitles enabled.');
        }
      }

      function toggleSubtitles() {
        if (subtitlesActive) {
          stopSubtitles({ message: 'Subtitles disabled.' });
        } else {
          startSubtitles();
        }
      }

      function startSubtitlesDrag(event) {
        if (!presentationSubtitlesEl || !isPresenting) return;
        const overlayRect = presentationOverlay.getBoundingClientRect();
        const subtitleRect = presentationSubtitlesEl.getBoundingClientRect();
        let originX = parseFloat(presentationSubtitlesEl.dataset.posX);
        if (!Number.isFinite(originX)) {
          const centerX = subtitleRect.left + subtitleRect.width / 2;
          originX = ((centerX - overlayRect.left) / Math.max(overlayRect.width, 1)) * 100;
        }
        let originY = parseFloat(presentationSubtitlesEl.dataset.posY);
        if (!Number.isFinite(originY)) {
          const distanceFromBottom = overlayRect.bottom - subtitleRect.bottom;
          originY = (distanceFromBottom / Math.max(overlayRect.height, 1)) * 100;
        }
        originX = Math.min(100, Math.max(0, originX));
        originY = Math.min(100, Math.max(0, originY));
        subtitlesDragState = {
          pointerId: event.pointerId,
          startX: event.clientX,
          startY: event.clientY,
          originX,
          originY
        };
        presentationSubtitlesEl.setPointerCapture(event.pointerId);
        event.preventDefault();
      }

      function moveSubtitlesDrag(event) {
        if (!subtitlesDragState || event.pointerId !== subtitlesDragState.pointerId) return;
        const overlayRect = presentationOverlay.getBoundingClientRect();
        const deltaXPercent = ((event.clientX - subtitlesDragState.startX) / overlayRect.width) * 100;
        const deltaYPercent = ((event.clientY - subtitlesDragState.startY) / overlayRect.height) * 100;
        const posX = Math.min(100, Math.max(0, subtitlesDragState.originX + deltaXPercent));
        const posY = Math.min(100, Math.max(0, subtitlesDragState.originY - deltaYPercent));
        presentationSubtitlesEl.dataset.posX = String(posX);
        presentationSubtitlesEl.dataset.posY = String(posY);
        presentationSubtitlesEl.style.left = `${posX}%`;
        presentationSubtitlesEl.style.bottom = `${posY}%`;
        presentationSubtitlesEl.style.transform = 'translate(-50%, 0)';
      }

      function endSubtitlesDrag(event) {
        if (!subtitlesDragState || event.pointerId !== subtitlesDragState.pointerId) return;
        try {
          presentationSubtitlesEl.releasePointerCapture(event.pointerId);
        } catch (error) {
          // Ignore
        }
        subtitlesDragState = null;
      }

      function isEditableShortcutTarget(target) {
        if (!target) return false;
        if (target.nodeType === Node.TEXT_NODE) {
          target = target.parentElement;
        }
        if (!target) return false;
        if (!(target instanceof HTMLElement)) return false;
        if (target.matches('input, textarea, [contenteditable="true"]')) return true;
        const editableAncestor = target.closest('input, textarea, [contenteditable="true"]');
        return Boolean(editableAncestor);
      }
      function removeElementElement(element) {
        if (!element) return false;
        if (element.classList.contains('image-element')) {
          deleteImage(element);
          return true;
        }
        if (element.classList.contains('video-element')) {
          deleteVideo(element);
          return true;
        }
        if (element.classList.contains('shape-element')) {
          deleteShape(element);
          return true;
        }
        if (element.classList.contains('chart-element')) {
          deleteChart(element);
          return true;
        }
        if (element.classList.contains('table-element')) {
          deleteTable(element);
          return true;
        }
        if (element.classList.contains('additional-text-box') || element === titleBox || element === textBox) {
          deleteTextBox(element);
          return true;
        }
        return false;
      }
      function copySelectedElements(targetElement = null) {
        const context = targetElement
          ? { element: targetElement }
          : getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('No object selected');
          return false;
        }
        const serialized = serializeElement(context.element);
        if (!serialized) {
          showNotification('Cannot copy this object');
          return false;
        }
        setEditorClipboard('elements', { items: [serialized] }, 'copy');
        showNotification('Copied object');
        return true;
      }
      function cutSelectedElements(targetElement = null) {
        const context = targetElement
          ? { element: targetElement }
          : getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('No object selected');
          return false;
        }
        const serialized = serializeElement(context.element);
        if (!serialized) {
          showNotification('Cannot cut this object');
          return false;
        }
        setEditorClipboard('elements', { items: [serialized] }, 'cut');
        if (removeElementElement(context.element)) {
          showNotification('Cut object');
          return true;
        }
        return false;
      }
      function instantiateClipboardElement(item, offsetMultiplier = 1, referenceElement = null) {
        if (!item || !item.type || !item.data) return null;
        const offsetAmount = 24 * offsetMultiplier;
        const preserveId = editorClipboard.mode === 'cut';
        let baseLeft = item.data.left;
        let baseTop = item.data.top;
        if (referenceElement) {
          const refPos = getElementPosition(referenceElement);
          baseLeft = refPos.left;
          baseTop = refPos.top;
        } else if (editorClipboard.mode === 'copy' && lastCanvasInsertPosition && Number.isFinite(item.data.width) && Number.isFinite(item.data.height)) {
          baseLeft = lastCanvasInsertPosition.x - item.data.width / 2;
          baseTop = lastCanvasInsertPosition.y - item.data.height / 2;
        }
        if (!Number.isFinite(baseLeft)) {
          baseLeft = 0;
        }
        if (!Number.isFinite(baseTop)) {
          baseTop = 0;
        }
        switch (item.type) {
          case 'image': {
            const element = createImageElement({
              id: preserveId ? item.data.id : undefined,
              src: item.data.src,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount,
              width: item.data.width,
              height: item.data.height,
              rotation: item.data.rotation,
              minWidth: item.data.minWidth,
              minHeight: item.data.minHeight,
              aspectRatio: item.data.aspectRatio,
              zIndex: item.data.zIndex,
              animate: false,
              select: true
            });
            return element;
          }
          case 'video': {
            const element = createVideoElement({
              id: preserveId ? item.data.id : undefined,
              src: item.data.src,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount,
              width: item.data.width,
              height: item.data.height,
              rotation: item.data.rotation,
              minWidth: item.data.minWidth,
              minHeight: item.data.minHeight,
              aspectRatio: item.data.aspectRatio,
              zIndex: item.data.zIndex,
              animate: false,
              select: true
            });
            return element;
          }
          case 'shape': {
            const shapeData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = instantiateShape(shapeData);
            if (element) {
              selectShape(element);
            }
            return element;
          }
          case 'chart': {
            const chartData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = instantiateChart(chartData);
            if (element) {
              selectChart(element);
            }
            return element;
          }
          case 'table': {
            const tableData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = instantiateTable(tableData);
            if (element) {
              selectTableElement(element);
            }
            return element;
          }
          case 'textbox': {
            const isTitle = !!item.data.isTitle;
            const isBody = !!item.data.isBody;
            const restoringMain = editorClipboard.mode === 'cut';
            if (isTitle && titleBox && restoringMain) {
              applyTextBoxData(titleBox, item.data);
              selectTextBox(titleBox);
              return titleBox;
            }
            if (isBody && textBox && restoringMain) {
              applyTextBoxData(textBox, item.data);
              selectTextBox(textBox);
              return textBox;
            }
            const textboxData = {
              ...item.data,
              id: preserveId ? item.data.id : undefined,
              left: baseLeft + offsetAmount,
              top: baseTop + offsetAmount
            };
            const element = createAdditionalTextBox(textboxData);
            if (element) {
              selectTextBox(element);
            }
            return element;
          }
          default:
            return null;
        }
      }
      function pasteElementsFromClipboard(options = {}) {
        if (!editorClipboard || editorClipboard.type !== 'elements' || !editorClipboard.data || !Array.isArray(editorClipboard.data.items)) {
          showNotification('Clipboard is empty');
          return false;
        }
        const items = editorClipboard.data.items;
        if (!items.length) {
          showNotification('Clipboard is empty');
          return false;
        }
        const baseOffset = (editorClipboard.offset || 0) + 1;
        editorClipboard.offset = baseOffset;
        const createdElements = [];
        const referenceElement = options.referenceElement || elementContextTarget || null;
        items.forEach((item, index) => {
          const element = instantiateClipboardElement(item, baseOffset + index - 1, referenceElement);
          if (element) {
            createdElements.push(element);
          }
        });
        if (!createdElements.length) {
          showNotification('Nothing to paste');
          return false;
        }
        const lastElement = createdElements[createdElements.length - 1];
        if (lastElement) {
          if (lastElement.classList.contains('image-element')) {
            selectImage(lastElement);
          } else if (lastElement.classList.contains('video-element')) {
            selectVideo(lastElement);
          } else if (lastElement.classList.contains('shape-element')) {
            selectShape(lastElement);
          } else if (lastElement.classList.contains('table-element')) {
            selectTableElement(lastElement);
          } else if (lastElement.classList.contains('additional-text-box')) {
            selectTextBox(lastElement);
          }
        }
        capture();
        saveEditorState('paste_elements');
        editorClipboard.mode = 'copy';
        showNotification('Pasted object');
        updateElementContextMenuState();
        updateSlideCanvasMenuState();
        return true;
      }
      function openImageCropper(element) {
        if (!element) return;
        if (typeof window.Cropper !== 'function') {
          alert('Image crop tools are still loading. Please try again in a moment.');
          return;
        }
        const img = element.querySelector('img');
        if (!img) return;
        imageCropTargetElement = element;
        imageCropOverlay.classList.add('visible');
        if (imageCropperInstance) {
          imageCropperInstance.destroy();
          imageCropperInstance = null;
        }
        const source = img.getAttribute('src');
        imageCropperImage.onload = () => {
          if (imageCropperInstance) {
            imageCropperInstance.destroy();
          }
          imageCropperInstance = new window.Cropper(imageCropperImage, {
            viewMode: 1,
            autoCropArea: 1,
            responsive: true,
            background: false,
            movable: true,
            zoomable: true,
            scalable: false,
            modal: true
          });
        };
        if (imageCropperImage.getAttribute('src') === source) {
          imageCropperImage.onload();
        } else {
          imageCropperImage.setAttribute('src', source || '');
        }
      }
      function closeImageCropper() {
        if (imageCropperInstance) {
          imageCropperInstance.destroy();
          imageCropperInstance = null;
        }
        imageCropOverlay.classList.remove('visible');
        imageCropperImage.removeAttribute('src');
        imageCropperImage.onload = null;
        imageCropTargetElement = null;
      }
      function applyImageCrop() {
        if (!imageCropperInstance || !imageCropTargetElement) return;
        const croppedCanvas = imageCropperInstance.getCroppedCanvas();
        if (!croppedCanvas) return;
        const dataUrl = croppedCanvas.toDataURL('image/png');
        const img = imageCropTargetElement.querySelector('img');
        if (!img) return;
        img.src = dataUrl;
        const newAspect = croppedCanvas.width / Math.max(croppedCanvas.height, 0.01);
        const minWidth = parseFloat(imageCropTargetElement.dataset.minWidth || '80');
        imageCropTargetElement.dataset.aspectRatio = String(newAspect);
        imageCropTargetElement.dataset.minHeight = String(Math.max(60, minWidth / Math.max(newAspect, 0.01)));
        capture();
        saveEditorState('crop_image');
        showNotification('Cropped image');
        closeImageCropper();
      }
      function setImageAsBackground(element) {
        if (!element) return;
        const img = element.querySelector('img');
        if (!img) return;
        const src = img.getAttribute('src');
        if (!src) return;
        const backgroundConfig = {
          image: `url(${src})`,
          size: 'cover',
          position: 'center center',
          repeat: 'no-repeat'
        };
        canvas.style.backgroundImage = backgroundConfig.image;
        canvas.style.backgroundSize = backgroundConfig.size;
        canvas.style.backgroundPosition = backgroundConfig.position;
        canvas.style.backgroundRepeat = backgroundConfig.repeat;
        deleteImage(element, { skipCapture: true, skipHistory: true });
        if (slides[active]) {
          const existingColor = slides[active].background && slides[active].background.color
            ? slides[active].background.color
            : DEFAULT_SLIDE_BACKGROUND_COLOR;
          slides[active].background = { ...backgroundConfig, color: existingColor };
        }
        canvas.style.backgroundColor = slides[active]?.background?.color || DEFAULT_SLIDE_BACKGROUND_COLOR;
        if (backgroundColorInput) {
          backgroundColorInput.value = slides[active]?.background?.color || DEFAULT_SLIDE_BACKGROUND_COLOR;
        }
        capture();
        saveEditorState('set_image_background');
        showNotification('Set image as background');
      }
      function hideSlideCanvasContextMenu() {
        if (!slideCanvasContextMenu) return;
        slideCanvasContextMenu.classList.remove('show');
        slideCanvasContextMenu.style.top = '-9999px';
        slideCanvasContextMenu.style.left = '-9999px';
        slideCanvasContextTargetIndex = null;
      }
      function updateSlideCanvasMenuState() {
        if (!slideCanvasContextMenu) return;
        let hasClipboard = false;
        if (editorClipboard) {
          if (editorClipboard.type === 'slide') {
            hasClipboard = !!(editorClipboard.data && editorClipboard.data.slide);
          } else if (editorClipboard.type === 'elements') {
            hasClipboard = !!(editorClipboard.data && Array.isArray(editorClipboard.data.items) && editorClipboard.data.items.length > 0);
          }
        }
        if (slideCanvasMenuButtons.paste) {
          slideCanvasMenuButtons.paste.disabled = !hasClipboard;
        }
        const singleSlide = slides.length <= 1;
        if (slideCanvasMenuButtons.cut) {
          slideCanvasMenuButtons.cut.disabled = singleSlide;
        }
        if (slideCanvasMenuButtons.delete) {
          slideCanvasMenuButtons.delete.disabled = singleSlide;
        }
      }
      function showSlideCanvasContextMenu(event, index) {
        if (!slideCanvasContextMenu) return;
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        slideCanvasContextTargetIndex = index;
        slideCanvasContextMenu.classList.add('show');
        slideCanvasContextMenu.style.top = '0px';
        slideCanvasContextMenu.style.left = '0px';
        const menuRect = slideCanvasContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        slideCanvasContextMenu.style.top = `${Math.max(padding, top)}px`;
        slideCanvasContextMenu.style.left = `${Math.max(padding, left)}px`;
        updateSlideCanvasMenuState();
      }
      function copySlideAt(index) {
        if (!Number.isInteger(index) || index < 0 || index >= slides.length) return false;
        capture();
        setEditorClipboard('slide', {
          slide: JSON.parse(JSON.stringify(slides[index]))
        }, 'copy');
        return true;
      }
      function deleteSlide(index, options = {}) {
        if (!Number.isInteger(index) || index < 0 || index >= slides.length) return false;
        if (slides.length <= 1) {
          showNotification('Cannot delete the only slide');
          return false;
        }
        const { skipHistory = false } = options;
        capture();
        slides.splice(index, 1);
        if (active > index) {
          active -= 1;
        } else if (active >= slides.length) {
          active = slides.length - 1;
        }
        load();
        renderSidebar();
        if (!skipHistory) {
          saveEditorState('delete_slide');
        }
        updateSlideCanvasMenuState();
        return true;
      }
      function cutSlideAt(index) {
        if (slides.length <= 1) {
          showNotification('Cannot cut the only slide');
          return false;
        }
        if (!copySlideAt(index)) return false;
      editorClipboard.mode = 'cut';
        return deleteSlide(index);
      }
      function pasteSlideAfter(index) {
        if (!editorClipboard || editorClipboard.type !== 'slide' || !editorClipboard.data || !editorClipboard.data.slide) {
          showNotification('Clipboard is empty');
          return false;
        }
        const insertIndex = Math.min(slides.length, Math.max(0, index) + 1);
        capture();
        const newSlide = JSON.parse(JSON.stringify(editorClipboard.data.slide));
        slides.splice(insertIndex, 0, newSlide);
        active = insertIndex;
        load();
        renderSidebar();
        saveEditorState('paste_slide');
        editorClipboard.mode = 'copy';
        updateSlideCanvasMenuState();
        updateElementContextMenuState();
        showNotification('Pasted slide');
        return true;
      }
      if (elementContextButtons.copy) {
        elementContextButtons.copy.addEventListener('click', () => {
          copySelectedElements(elementContextTarget);
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.cut) {
        elementContextButtons.cut.addEventListener('click', () => {
          cutSelectedElements(elementContextTarget);
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.paste) {
        elementContextButtons.paste.addEventListener('click', () => {
          pasteElementsFromClipboard({ referenceElement: elementContextTarget });
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.translate) {
        elementContextButtons.translate.addEventListener('click', () => {
          const target = elementContextTarget || (getSelectedElementContext()?.element ?? null);
          hideElementContextMenu();
          openTranslatorPanel(target, { autoTranslate: true });
        });
      }
      if (translatorInsertButton) {
        translatorInsertButton.addEventListener('click', insertTranslatorResult);
      }
      if (translatorCloseButton) {
        translatorCloseButton.addEventListener('click', () => hideTranslatorPanel());
      }
      if (translatorLanguageSelect) {
        translatorLanguageSelect.addEventListener('change', () => {
          setTranslatorStatus('');
        });
      }
      if (translatorSourceInput) {
        translatorSourceInput.addEventListener('input', () => {
          setTranslatorStatus('');
          if (translatorResultArea) {
            translatorResultArea.value = '';
          }
        });
      }
      document.addEventListener('keydown', (event) => {
        if (isDictating && event.key === 'Escape') {
          stopDictation({ commit: true, message: 'Dictation stopped.' });
          return;
        }
        if (event.key === 'Escape' && translatorPanel && !translatorPanel.classList.contains('hidden')) {
          hideTranslatorPanel();
        }
      });
      if (translateToolButton) {
        translateToolButton.addEventListener('click', () => {
          openTranslatorPanel(getPreferredTranslationElement(), { autoTranslate: true });
        });
      }
      
      // AI Designer functionality
      const aiDesignerButton = document.getElementById('aiDesignerButton');
      const aiDesignerModal = document.getElementById('aiDesignerModal');
      const aiDesignerModalClose = document.getElementById('aiDesignerModalClose');
      const aiDesignerModalCancel = document.getElementById('aiDesignerModalCancel');
      const aiDesignerPrompt = document.getElementById('aiDesignerPrompt');
      const aiDesignerGenerate = document.getElementById('aiDesignerGenerate');
      const aiDesignerInsert = document.getElementById('aiDesignerInsert');
      const aiDesignerPreview = document.getElementById('aiDesignerPreview');
      const aiDesignerStatus = document.getElementById('aiDesignerStatus');
      
      let generatedImageDataUrl = null;
      
      function showAIDesignerModal() {
        if (aiDesignerModal) {
          aiDesignerModal.classList.add('show');
          if (aiDesignerPrompt) {
            aiDesignerPrompt.focus();
          }
        }
      }
      
      function hideAIDesignerModal() {
        if (aiDesignerModal) {
          aiDesignerModal.classList.remove('show');
          generatedImageDataUrl = null;
          if (aiDesignerPreview) {
            aiDesignerPreview.innerHTML = '<div class="ai-designer-preview-placeholder">Generated image will appear here</div>';
          }
          if (aiDesignerInsert) {
            aiDesignerInsert.style.display = 'none';
          }
          if (aiDesignerStatus) {
            aiDesignerStatus.style.display = 'none';
            aiDesignerStatus.className = 'ai-designer-status';
            aiDesignerStatus.textContent = '';
          }
          if (aiDesignerPrompt) {
            aiDesignerPrompt.value = '';
          }
        }
      }
      
      function setAIDesignerStatus(message, type = '') {
        if (aiDesignerStatus) {
          aiDesignerStatus.textContent = message;
          aiDesignerStatus.className = 'ai-designer-status' + (type ? ' ' + type : '');
          aiDesignerStatus.style.display = message ? 'block' : 'none';
        }
      }
      
      async function generateImageWithHuggingFace(prompt) {
        if (!prompt || !prompt.trim()) {
          setAIDesignerStatus('Please enter an image description', 'error');
          return null;
        }
        
        setAIDesignerStatus('Generating image... This may take 20-30 seconds', '');
        if (aiDesignerPreview) {
          aiDesignerPreview.innerHTML = '<div class="ai-designer-preview-loading">Generating your image... Please wait</div>';
        }
        if (aiDesignerGenerate) {
          aiDesignerGenerate.disabled = true;
        }
        
        try {
          // Use HF_IMAGE_TOKEN specifically for image generation
          const apiToken = HF_IMAGE_TOKEN;
          
          // Use the standard Hugging Face Inference API endpoint
          // The model black-forest-labs/FLUX.1-dev works with the standard endpoint (provider: auto)
          const apiUrl = "https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-dev";
          
          // Request body format for Hugging Face Inference API
          // For text-to-image, just send the prompt as inputs
          const requestBody = {
            inputs: prompt.trim()
          };
          
          const headers = {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          };
          
          console.log('Generating image with:', { apiUrl, prompt: prompt.trim() });
          
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (!response.ok) {
            let errorMessage = `API Error: ${response.status}`;
            try {
              const errorData = await response.json();
              if (errorData.error) {
                errorMessage = errorData.error;
              } else if (typeof errorData === 'string') {
                errorMessage = errorData;
              }
            } catch (e) {
              const errorText = await response.text();
              if (errorText) {
                errorMessage += ` - ${errorText.substring(0, 200)}`;
              }
            }
            
            if (response.status === 503) {
              // Model is loading, wait and retry
              setAIDesignerStatus('Model is loading. Please wait 20 seconds and try again.', 'error');
              if (aiDesignerGenerate) {
                aiDesignerGenerate.disabled = false;
              }
              return null;
            }
            
            throw new Error(errorMessage);
          }
          
          // The router API returns the image directly as a blob
          const imageBlob = await response.blob();
          console.log('Received image blob, size:', imageBlob.size, 'type:', imageBlob.type);
          
          // Verify it's actually an image
          if (!imageBlob.type || !imageBlob.type.startsWith('image/')) {
            // If not an image, try to read as text to see the error
            const text = await imageBlob.text();
            try {
              const errorData = JSON.parse(text);
              throw new Error(errorData.error || errorData.message || 'Invalid response from API');
            } catch (e) {
              throw new Error(`API returned non-image data: ${text.substring(0, 200)}`);
            }
          }
          
          // Convert blob to data URL
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              generatedImageDataUrl = reader.result;
              if (aiDesignerPreview) {
                aiDesignerPreview.innerHTML = `<img src="${reader.result}" alt="Generated design" />`;
              }
              if (aiDesignerInsert) {
                aiDesignerInsert.style.display = 'inline-block';
              }
              setAIDesignerStatus('Image generated successfully!', 'success');
              if (aiDesignerGenerate) {
                aiDesignerGenerate.disabled = false;
              }
              resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
          });
          
        } catch (error) {
          console.error('Error generating image:', error);
          setAIDesignerStatus(`Error: ${error.message}. Please try again.`, 'error');
          if (aiDesignerPreview) {
            aiDesignerPreview.innerHTML = '<div class="ai-designer-preview-placeholder">Error generating image. Please try again.</div>';
          }
          if (aiDesignerGenerate) {
            aiDesignerGenerate.disabled = false;
          }
          return null;
        }
      }
      
      function insertGeneratedImage() {
        if (!generatedImageDataUrl) {
          setAIDesignerStatus('No image to insert. Please generate an image first.', 'error');
          return;
        }
        
        if (typeof insertImageFromDataUrl === 'function') {
          insertImageFromDataUrl(generatedImageDataUrl);
          hideAIDesignerModal();
          showNotification('AI-generated image inserted');
        } else {
          setAIDesignerStatus('Unable to insert image. Please try again.', 'error');
        }
      }
      
      if (aiDesignerButton) {
        aiDesignerButton.addEventListener('click', () => {
          showAIDesignerModal();
        });
      }
      
      if (aiDesignerModalClose) {
        aiDesignerModalClose.addEventListener('click', () => {
          hideAIDesignerModal();
        });
      }
      
      if (aiDesignerModalCancel) {
        aiDesignerModalCancel.addEventListener('click', () => {
          hideAIDesignerModal();
        });
      }
      
      if (aiDesignerGenerate) {
        aiDesignerGenerate.addEventListener('click', async () => {
          const prompt = aiDesignerPrompt ? aiDesignerPrompt.value : '';
          await generateImageWithHuggingFace(prompt);
        });
      }
      
      if (aiDesignerInsert) {
        aiDesignerInsert.addEventListener('click', () => {
          insertGeneratedImage();
        });
      }
      
      // Close modal on Escape key
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && aiDesignerModal && aiDesignerModal.classList.contains('show')) {
          hideAIDesignerModal();
        }
      });
      
      // Allow Enter key in textarea to generate (Ctrl/Cmd + Enter)
      if (aiDesignerPrompt) {
        aiDesignerPrompt.addEventListener('keydown', (event) => {
          if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
            event.preventDefault();
            if (aiDesignerGenerate && !aiDesignerGenerate.disabled) {
              aiDesignerGenerate.click();
            }
          }
        });
      }
      
      // AI Presentation Designer functionality
      const aiPresentationButton = document.getElementById('aiPresentationButton');
      const aiPresentationModal = document.getElementById('aiPresentationModal');
      const aiPresentationModalClose = document.getElementById('aiPresentationModalClose');
      const aiPresentationModalCancel = document.getElementById('aiPresentationModalCancel');
      const aiPresentationTopic = document.getElementById('aiPresentationTopic');
      const aiPresentationTextStructure = document.getElementById('aiPresentationTextStructure');
      const aiPresentationSlides = document.getElementById('aiPresentationSlides');
      const aiPresentationGenerate = document.getElementById('aiPresentationGenerate');
      
      // Hugging Face API Token (hardcoded)
      // API Tokens - Replace with your own tokens
      const HF_TOKEN = ""; // For Llama/Presentation generation - Add your token here
      const HF_IMAGE_TOKEN = ""; // For Stable Diffusion/Image generation - Add your token here
      
      const aiPresentationProgress = document.getElementById('aiPresentationProgress');
      const aiPresentationProgressFill = document.getElementById('aiPresentationProgressFill');
      const aiPresentationProgressText = document.getElementById('aiPresentationProgressText');
      const aiPresentationStatus = document.getElementById('aiPresentationStatus');
      
      function showAIPresentationModal() {
        if (aiPresentationModal) {
          aiPresentationModal.classList.add('show');
          if (aiPresentationTopic) {
            aiPresentationTopic.focus();
          }
        }
      }
      
      function hideAIPresentationModal() {
        if (aiPresentationModal) {
          aiPresentationModal.classList.remove('show');
          if (aiPresentationProgress) {
            aiPresentationProgress.classList.remove('show');
          }
          if (aiPresentationProgressFill) {
            aiPresentationProgressFill.style.width = '0%';
          }
          if (aiPresentationStatus) {
            aiPresentationStatus.style.display = 'none';
            aiPresentationStatus.className = 'ai-presentation-status';
            aiPresentationStatus.textContent = '';
          }
          if (aiPresentationTopic) {
            aiPresentationTopic.value = '';
          }
          if (aiPresentationTextStructure) {
            aiPresentationTextStructure.value = '';
          }
          if (aiPresentationSlides) {
            aiPresentationSlides.value = '5';
          }
        }
      }
      
      function setAIPresentationStatus(message, type = '') {
        if (aiPresentationStatus) {
          // Convert newlines to HTML line breaks for better display
          const formattedMessage = message.replace(/\n/g, '<br>');
          aiPresentationStatus.innerHTML = formattedMessage;
          aiPresentationStatus.className = 'ai-presentation-status' + (type ? ' ' + type : '');
          aiPresentationStatus.style.display = message ? 'block' : 'none';
        }
      }
      
      function updateProgress(percent, text) {
        if (aiPresentationProgressFill) {
          aiPresentationProgressFill.style.width = percent + '%';
        }
        if (aiPresentationProgressText) {
          aiPresentationProgressText.textContent = text || `Progress: ${percent}%`;
        }
        if (aiPresentationProgress) {
          aiPresentationProgress.classList.add('show');
        }
      }
      
      // Parse AI design suggestions from text
      function parseDesignSuggestions(text) {
        const designMatch = text.match(/DESIGN:\s*(.+)/i);
        if (!designMatch) return null;
        
        const designText = designMatch[1].toLowerCase();
        const design = {
          colors: [],
          shapes: [],
          style: 'professional'
        };
        
        // Extract hex colors
        const colorMatches = designText.match(/#[0-9a-f]{6}/gi);
        if (colorMatches) {
          design.colors = colorMatches.slice(0, 2); // Take up to 2 colors
        }
        
        // Extract shape types
        const shapeKeywords = ['star', 'circle', 'rectangle', 'triangle', 'square', 'pentagon', 'arrow-right', 'arrow'];
        shapeKeywords.forEach(shape => {
          if (designText.includes(shape)) {
            design.shapes.push(shape === 'arrow' ? 'arrow-right' : shape);
          }
        });
        
        // Extract style
        const styleKeywords = ['modern', 'bold', 'elegant', 'minimal', 'warm', 'professional'];
        styleKeywords.forEach(style => {
          if (designText.includes(style)) {
            design.style = style;
          }
        });
        
        return design.colors.length > 0 || design.shapes.length > 0 ? design : null;
      }

      // Intelligent parsing - extract design from natural AI text
      function extractDesignFromText(text) {
        const design = {
          colors: [],
          shapes: [],
          style: null
        };
        
        // Look for hex colors anywhere in text
        const colorMatches = text.match(/#[0-9a-f]{6}/gi);
        if (colorMatches) {
          design.colors = [...new Set(colorMatches)].slice(0, 3); // Unique colors, max 3
        }
        
        // Look for color names that can be converted
        const colorNames = {
          'blue': '#3b82f6', 'red': '#ef4444', 'green': '#10b981', 'yellow': '#f59e0b',
          'purple': '#8b5cf6', 'pink': '#ec4899', 'orange': '#f97316', 'teal': '#14b8a6',
          'indigo': '#6366f1', 'cyan': '#06b6d4', 'gray': '#6b7280', 'black': '#000000',
          'white': '#ffffff', 'navy': '#1e40af', 'maroon': '#991b1b', 'lime': '#84cc16'
        };
        
        const lowerText = text.toLowerCase();
        for (const [name, hex] of Object.entries(colorNames)) {
          if (lowerText.includes(name) && !design.colors.includes(hex)) {
            design.colors.push(hex);
            if (design.colors.length >= 3) break;
          }
        }
        
        // Look for shape mentions
        const shapeKeywords = ['star', 'circle', 'rectangle', 'triangle', 'square', 'pentagon', 'arrow'];
        shapeKeywords.forEach(shape => {
          if (lowerText.includes(shape)) {
            design.shapes.push(shape === 'arrow' ? 'arrow-right' : shape);
          }
        });
        
        // Look for style keywords
        const styleKeywords = ['modern', 'bold', 'elegant', 'minimal', 'warm', 'professional', 'vibrant', 'clean', 'sophisticated'];
        styleKeywords.forEach(style => {
          if (lowerText.includes(style) && !design.style) {
            design.style = style;
          }
        });
        
        return design.colors.length > 0 || design.shapes.length > 0 ? design : null;
      }

      function parsePresentationContent(text, numSlides = 5) {
        if (!text || typeof text !== 'string' || text.trim().length === 0) {
          console.warn('parsePresentationContent: Empty or invalid text');
          return [];
        }
        
        // Parse natural AI-generated content - flexible parsing
        const slides = [];
        const lines = text.split('\n').filter(line => line.trim());
        
        let currentSlide = { title: '', content: '' };
        let slideNumber = 1;
        let inSlide = false;
        let slideText = '';
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          // Detect slide markers (various formats AI might use)
          const slideMarker = line.match(/^(?:Slide\s*)?(\d+)[:\.]\s*(.+)/i) || 
                             line.match(/^#+\s*(.+)/) ||
                             line.match(/^##\s*(.+)/) ||
                             line.match(/^###\s*(.+)/) ||
                             (line.length < 80 && line.length > 3 && (line.endsWith(':') || line.match(/^[A-Z][^.!?]*$/)));
          
          if (slideMarker) {
            // Save previous slide if it has content
            if (currentSlide.title || currentSlide.content) {
              // Ensure slide has valid content
              if (!currentSlide.title) currentSlide.title = `Slide ${slides.length + 1}`;
              if (!currentSlide.content) currentSlide.content = 'Content';
              // No design extraction - text only
              slides.push({ ...currentSlide });
            }
            
            // Start new slide
            const title = slideMarker[2] || slideMarker[1] || line.replace(/^#+\s*/, '').replace(':', '').trim();
            currentSlide = { 
              title: title || `Slide ${slides.length + 1}`,
              content: ''
            };
            slideText = line;
            inSlide = true;
            slideNumber++;
          } else if (inSlide && line.length > 0) {
            // Add to current slide content - preserve line breaks and structure
            slideText += '\n' + line;
            if (currentSlide.content) {
              // Preserve line breaks - don't concatenate into one line
              currentSlide.content += '\n' + line;
            } else {
              currentSlide.content = line;
            }
          } else if (!inSlide && line.length > 10) {
            // First slide might not have a marker
            if (slides.length === 0) {
              // Use the first substantial line as title, and start collecting content
              currentSlide.title = line.substring(0, 60).trim() || `Slide 1`;
              currentSlide.content = ''; // Will be populated by subsequent lines
              slideText = line;
              inSlide = true;
            }
          }
        }
        
        // Add the last slide - ensure it has content
        if (currentSlide.title || currentSlide.content) {
          if (!currentSlide.title) currentSlide.title = `Slide ${slides.length + 1}`;
          // Ensure last slide has meaningful content, not just "Content"
          if (!currentSlide.content || currentSlide.content.trim() === 'Content' || currentSlide.content.trim().length < 10) {
            // If last slide has no real content, use the title or create default content
            currentSlide.content = currentSlide.title.includes('Slide') 
              ? `Content for ${currentSlide.title}`
              : currentSlide.title;
          }
          // No design extraction - text only
          slides.push(currentSlide);
        }
        
        // If no slides found, try to split by paragraphs or sections
        if (slides.length === 0 && text.length > 50) {
          const paragraphs = text.split(/\n\n+/).filter(p => p.trim().length > 20);
          
          if (paragraphs.length > 0) {
            paragraphs.forEach((para, idx) => {
              const paraLines = para.split('\n').filter(l => l.trim());
              const title = paraLines[0]?.substring(0, 60).trim() || `Slide ${idx + 1}`;
              const content = paraLines.slice(1).join('\n').trim() || paraLines[0]?.trim() || para.trim() || 'Content';
              
              slides.push({ title, content });
            });
          }
        }
        
        // Filter out invalid slides and ensure all have required fields with sufficient content
        const validSlides = slides.filter((slide, idx) => {
          if (!slide || typeof slide !== 'object') return false;
          
          // Ensure title is valid
          if (!slide.title || typeof slide.title !== 'string' || slide.title.trim().length === 0) {
            slide.title = `Slide ${idx + 1}`;
          }
          
          // Clean and validate title - remove "Slide X:" prefix if present
          slide.title = slide.title.replace(/^Slide\s*\d+[:\.]\s*/i, '').trim();
          if (slide.title.length === 0) {
            slide.title = `Slide ${idx + 1}`;
          }
          
          // Ensure content is valid and has sufficient length (at least 20 characters)
          if (!slide.content || typeof slide.content !== 'string') {
            slide.content = '';
          }
          
          // Clean content
          slide.content = cleanTextContent(slide.content);
          
          // Ensure minimum content length - if too short, enhance it
          if (slide.content.trim().length < 20) {
            // If content is too short, create meaningful default based on title
            if (slide.title.toLowerCase().includes('title')) {
              slide.content = `Welcome to this presentation about the topic.`;
            } else if (slide.title.toLowerCase().includes('outline')) {
              slide.content = `This presentation will cover:\n- Key concepts and fundamentals\n- Important insights\n- Practical applications\n- Future implications`;
            } else if (slide.title.toLowerCase().includes('conclusion')) {
              slide.content = `Summary of key points:\n- Main takeaways\n- Important insights\n- Final thoughts`;
            } else if (slide.title.toLowerCase().includes('reference')) {
              slide.content = `References and resources:\n- Additional reading materials\n- Key sources\n- Further information`;
            } else if (slide.title.toLowerCase().includes('thank')) {
              slide.content = `Thank you for your attention!\n\nQuestions?`;
            } else {
              slide.content = `Detailed information about ${slide.title}:\n- Key points and concepts\n- Important details\n- Relevant examples`;
            }
          }
          
          return slide.title.trim().length > 0 && slide.content.trim().length >= 20;
        });
        
        // Ensure we have the right number of slides
        while (validSlides.length < numSlides && validSlides.length > 0) {
          const lastSlide = validSlides[validSlides.length - 1];
          validSlides.push({
            title: `Slide ${validSlides.length + 1}`,
            content: lastSlide.content || 'Content'
          });
        }
        
        // If still no slides, create default ones
        if (validSlides.length === 0) {
          for (let i = 0; i < numSlides; i++) {
            validSlides.push({
              title: `Slide ${i + 1}`,
              content: text.substring(i * Math.floor(text.length / numSlides), (i + 1) * Math.floor(text.length / numSlides)).trim() || 'Content'
            });
          }
        }
        
        return validSlides.slice(0, numSlides);
      }
      
      // Call Hugging Face Chat Completions API with Llama 3 model
      async function callHuggingFaceLlamaAPI(topic, numSlides, textStructure, details) {
        const apiToken = HF_TOKEN;
        const model = "meta-llama/Meta-Llama-3-8B-Instruct:novita";
        const apiUrl = "https://router.huggingface.co/v1/chat/completions";
        
        console.log('API Configuration:', {
          url: apiUrl,
          hasToken: !!apiToken,
          tokenLength: apiToken ? apiToken.length : 0,
          model: model
        });
        
        // Calculate slide distribution for the required structure
        // Structure: Title (1) + Outline (1) + Subject slides (N) + Conclusion (1) + References (1) + Thank you (1) = 6 fixed + N subject slides
        // Minimum structure needs 6 slides, so if numSlides < 6, we adjust
        // If numSlides >= 6: subject slides = numSlides - 5 (5 fixed slides + subject slides)
        // If numSlides < 6: we still need at least 1 subject slide, so we use all available slides
        const fixedSlides = 5; // Title, Outline, Conclusion, References, Thank you
        const subjectSlidesCount = Math.max(1, numSlides - fixedSlides);
        
        // Create user request message - focus only on text content with proper structure
        let userRequest = `Create a comprehensive ${numSlides}-slide presentation about "${topic}" following this EXACT structure:

SLIDE STRUCTURE (MUST FOLLOW THIS ORDER):
1. Slide 1: Title Slide
   - Title: "${topic}"
   - Subtitle or brief introduction (optional)

2. Slide 2: Outline Slide
   - List the main topics/points that will be covered
   - Use bullet points to show the presentation structure

3. Slides 3-${2 + subjectSlidesCount}: Subject Slides (${subjectSlidesCount} slides)
   - These are the main content slides about "${topic}"
   - Cover different aspects, subtopics, and details
   - Provide comprehensive information with bullet points

4. Slide ${3 + subjectSlidesCount}: Conclusion Slide
   - Summarize key points
   - Provide final thoughts or takeaways

5. Slide ${4 + subjectSlidesCount}: References Slide
   - List sources, references, or further reading (if applicable)
   - Or key resources related to the topic

6. Slide ${5 + subjectSlidesCount}: Thank You Slide
   - Thank the audience
   - Optional: contact information or closing message

IMPORTANT FORMATTING:
- Each slide must start with "Slide X: [Title]" on its own line
- Use line breaks between different sections
- Use bullet points with "- " prefix, each bullet on a separate line
- Include subtitles using "### Subtitle" format when appropriate
- Do NOT write everything in one continuous line
- Each bullet point, subtitle, and section must be on separate lines

CONTENT REQUIREMENTS:
- Provide DETAILED and COMPREHENSIVE information about the topic
- Include multiple bullet points per slide (at least 4-6 points per slide for subject slides)
- Add detailed explanations and context for each point
- Include examples, benefits, applications, or relevant information
- Make each slide informative and substantial
- Write enough content to fully cover the topic`;

        // Add text structure preference if provided
        if (textStructure && textStructure.trim()) {
          userRequest += `\n\nTEXT STRUCTURE PREFERENCE: ${textStructure.trim()}`;
        }
        
        // Add additional details if provided
        if (details && details.trim()) {
          userRequest += `\n\nAdditional requirements: ${details.trim()}`;
        }
        
        // System message focused only on text generation - no design elements
        const systemMessage = `You are an expert content writer. Create a ${numSlides}-slide presentation about "${topic}" following this EXACT structure:

STRUCTURE (MUST FOLLOW):
1. Slide 1: Title Slide - Title: "${topic}" with brief introduction
2. Slide 2: Outline Slide - List main topics with bullet points
3. Slides 3-${2 + subjectSlidesCount}: Subject Slides (${subjectSlidesCount} slides) - Main content about "${topic}" with detailed bullet points
4. Slide ${3 + subjectSlidesCount}: Conclusion - Summary of key points
5. Slide ${4 + subjectSlidesCount}: References - Sources and resources
6. Slide ${5 + subjectSlidesCount}: Thank You - Closing message

FORMATTING RULES:
- Start each slide with "Slide X: [Title]" on its own line
- Use line breaks (\\n) between sections
- Use "- " for bullet points, each on a new line
- NO HTML tags (<font>, <b>, etc.)
- NO markdown (**bold**, __bold__, etc.)
- Plain text only with proper line breaks

CONTENT REQUIREMENTS:
- Subject slides: 4-6 detailed bullet points each
- Include explanations, examples, benefits, applications
- Make content comprehensive and informative
- Each slide must have substantial content (not just 1-2 words)

OUTPUT FORMAT:
Slide 1: [Title]
[Content with bullet points]

Slide 2: Outline
- Point 1
- Point 2
- Point 3

[Continue for all slides...]

Generate ONLY plain text. No design elements, HTML, or markdown.`;
        
        const headers = {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiToken}`
        };
        
        // Chat Completions API format
        const requestBody = {
          messages: [
            {
              role: "system",
              content: systemMessage
            },
            {
              role: "user",
              content: userRequest
            }
          ],
          model: model,
          stream: false,
          max_tokens: 2500,
          temperature: 0.7,
          top_p: 0.9
        };
        
        updateProgress(40, 'Sending request to Llama 3 model...');
        
        let response;
        try {
          // Create an AbortController for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
          
          response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody),
            mode: 'cors',
            cache: 'no-cache',
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
        } catch (networkError) {
          console.error('Network error:', networkError);
          
          // Handle different types of errors
          if (networkError.name === 'AbortError') {
            throw new Error('Request timed out. The API is taking too long to respond. Please try again.');
          }
          
          const errorMsg = networkError.message || 'Unknown network error';
          if (errorMsg.includes('Failed to fetch') || errorMsg.includes('Load failed') || errorMsg.includes('NetworkError')) {
            throw new Error('Unable to connect to Hugging Face API.<br>Please check:<br>â€¢ Your internet connection<br>â€¢ If the model is available<br>â€¢ Try refreshing and attempting again');
          }
          
          throw new Error(`Network error: ${errorMsg}`);
        }
        
        if (!response.ok) {
          if (response.status === 503) {
            // Model is loading, wait and retry
            updateProgress(50, 'Model is loading, please wait 20 seconds...');
            await new Promise(resolve => setTimeout(resolve, 20000));
            
            let retryResponse;
            try {
              retryResponse = await fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
              });
            } catch (retryError) {
              throw new Error(`Retry failed: ${retryError.message}`);
            }
            
            if (!retryResponse.ok) {
              let errorText = '';
              try {
                errorText = await retryResponse.text();
              } catch (e) {
                errorText = 'Unable to read error response';
              }
              
              let errorMessage = `Model is not ready. Status: ${retryResponse.status}`;
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorData.message || errorMessage;
              } catch (e) {
                if (errorText) errorMessage += ` - ${errorText}`;
              }
              
              throw new Error(errorMessage);
            }
            
            let retryData;
            try {
              retryData = await retryResponse.json();
            } catch (parseError) {
              throw new Error(`Failed to parse response: ${parseError.message}`);
            }
            
            return extractGeneratedText(retryData);
          }
          
          let errorText = '';
          try {
            errorText = await response.text();
          } catch (e) {
            errorText = 'Unable to read error response';
          }
          
          let errorMessage = `API Error (${response.status})`;
          
          try {
            const errorData = JSON.parse(errorText);
            errorMessage = errorData.error || errorData.message || errorMessage;
          } catch (e) {
            if (errorText && errorText.length < 200) {
              errorMessage += `: ${errorText}`;
            } else if (errorText) {
              errorMessage += `: ${errorText.substring(0, 100)}...`;
            }
          }
          
          // Provide helpful error messages for common status codes
          if (response.status === 401) {
            errorMessage = 'Authentication failed. Please check your Hugging Face API token.';
          } else if (response.status === 403) {
            errorMessage = 'Access forbidden. Your API token may not have access to this model.';
          } else if (response.status === 429) {
            errorMessage = 'Rate limit exceeded. Please wait a moment and try again.';
          } else if (response.status === 500) {
            errorMessage = 'Server error. Hugging Face API is experiencing issues. Please try again later.';
          }
          
          throw new Error(errorMessage);
        }
        
        let data;
        try {
          data = await response.json();
        } catch (parseError) {
          console.error('Failed to parse response:', parseError);
          throw new Error(`Failed to parse API response: ${parseError.message}`);
        }
        
        // Check for valid response
        if (!data) {
          throw new Error('Empty response from API. The model may not be available.');
        }
        
        // Check for Chat Completions API error format
        if (data.error) {
          throw new Error(data.error.message || data.error || 'API returned an error');
        }
        
        // Check if choices array exists and has content
        if (data.choices && Array.isArray(data.choices) && data.choices.length === 0) {
          throw new Error('API returned empty choices. The model may not have generated any content.');
        }
        
        return extractGeneratedText(data);
      }
      
      // Extract generated text from Hugging Face Chat Completions API response
      function extractGeneratedText(data) {
        let text = '';
        
        // Chat Completions API format - response has choices array
        if (data && data.choices && Array.isArray(data.choices) && data.choices.length > 0) {
          const choice = data.choices[0];
          if (choice.message && choice.message.content) {
            text = choice.message.content;
          } else if (choice.text) {
            text = choice.text;
          }
        }
        // Fallback: Handle array responses (old Inference API format)
        else if (Array.isArray(data) && data.length > 0) {
          if (data[0].generated_text) {
            text = data[0].generated_text;
          } else {
            text = data.map(item => item.generated_text || item.text || '').join('\n');
          }
        } 
        // Handle object responses
        else if (typeof data === 'object' && data !== null) {
          text = data.generated_text || data.text || data.content || data[0]?.generated_text || data[0]?.summary_text || '';
        } 
        // Handle string responses
        else if (typeof data === 'string') {
          text = data;
        }
        
        // Clean up any special tokens if present
        if (text) {
          text = text.replace(/<\|begin_of_text\|>/g, '')
                    .replace(/<\|end_of_text\|>/g, '')
                    .replace(/<\|start_header_id\|>/g, '')
                    .replace(/<\|end_header_id\|>/g, '')
                    .replace(/<\|eot_id\|>/g, '')
                    .replace(/<\|.*?\|>/g, '')
                    .trim();
        }
        
        return text;
      }
      
      // Clean HTML tags and markdown formatting from text content
      function cleanTextContent(text) {
        if (!text || typeof text !== 'string') return text;
        
        // Remove HTML tags (like <font color="blue">, </font>, etc.)
        text = text.replace(/<[^>]*>/g, '');
        
        // Convert markdown bold (**text** or __text__) to plain text (remove markers)
        text = text.replace(/\*\*([^*]+)\*\*/g, '$1'); // **bold** -> bold
        text = text.replace(/__([^_]+)__/g, '$1'); // __bold__ -> bold
        text = text.replace(/\*([^*]+)\*/g, '$1'); // *italic* -> italic (single asterisk)
        text = text.replace(/_([^_]+)_/g, '$1'); // _italic_ -> italic (single underscore)
        
        // Remove markdown headers (# ## ###)
        text = text.replace(/^#{1,6}\s+/gm, '');
        
        // Remove HTML entities that might be encoded
        text = text.replace(/&nbsp;/g, ' ');
        text = text.replace(/&amp;/g, '&');
        text = text.replace(/&lt;/g, '<');
        text = text.replace(/&gt;/g, '>');
        text = text.replace(/&quot;/g, '"');
        text = text.replace(/&#39;/g, "'");
        
        return text.trim();
      }

      // AI Presentation Generation - Using Hugging Face Llama API
      async function generatePresentationWithAI(topic, numSlides, textStructure, details) {
        if (!topic || !topic.trim()) {
          setAIPresentationStatus('Please enter a presentation topic', 'error');
          return null;
        }
        
        // Store topic in a variable accessible throughout the function
        const presentationTopic = topic.trim();
        
        setAIPresentationStatus('Generating presentation with Llama AI...', '');
        updateProgress(10, 'Preparing AI request...');
        if (aiPresentationGenerate) {
          aiPresentationGenerate.disabled = true;
        }
        
        try {
          updateProgress(20, 'Connecting to Hugging Face API...');
          
          let generatedText = null;
          
          try {
            updateProgress(30, 'Calling Llama 3 model...');
            console.log('Calling Hugging Face Chat Completions API with model: meta-llama/Meta-Llama-3-8B-Instruct:novita');
            generatedText = await callHuggingFaceLlamaAPI(presentationTopic, numSlides, textStructure, details);
            console.log('API call successful, generated text length:', generatedText?.length || 0);
          } catch (error) {
            console.error('Error calling Llama API:', error);
            console.error('Error details:', {
              message: error.message,
              stack: error.stack,
              name: error.name
            });
            
            // Show specific error message
            const errorMsg = error.message || 'Unknown error occurred';
            setAIPresentationStatus(`Error: ${errorMsg}`, 'error');
            
            if (aiPresentationGenerate) {
              aiPresentationGenerate.disabled = false;
            }
            return null;
          }
          
          updateProgress(60, 'Processing AI response...');
          
          if (!generatedText || generatedText.trim().length < 50) {
            setAIPresentationStatus('AI did not generate sufficient content. Please try again.', 'error');
            if (aiPresentationGenerate) {
              aiPresentationGenerate.disabled = false;
            }
            return null;
          }
          
          updateProgress(80, 'Creating slides from AI-generated content...');
          
          // Log the raw AI response for debugging
          console.log('Raw AI response:', generatedText);
          console.log('Response length:', generatedText?.length);
          
          // Parse the naturally generated AI content into slides
          let presentationSlides = parsePresentationContent(generatedText, numSlides);
          
          console.log('Parsed slides count:', presentationSlides.length);
          console.log('Parsed slides:', presentationSlides);
          
          // Validate and enhance all slides to ensure sufficient content
          presentationSlides.forEach((slide, idx) => {
            // Clean title - remove "Slide X:" prefix
            if (slide.title) {
              slide.title = slide.title.replace(/^Slide\s*\d+[:\.]\s*/i, '').trim();
            }
            
            // Clean content
            if (slide.content) {
              slide.content = cleanTextContent(slide.content);
            }
            
            // Ensure minimum content length (at least 30 characters for meaningful content)
            if (!slide.content || slide.content.trim().length < 30) {
              const slideTitle = slide.title || `Slide ${idx + 1}`;
              
              // Generate appropriate content based on slide position and title
              if (idx === 0 || slideTitle.toLowerCase().includes('title')) {
                slide.content = `Welcome to this presentation about ${presentationTopic}.\n\nThis presentation will provide comprehensive information and insights.`;
              } else if (idx === 1 || slideTitle.toLowerCase().includes('outline')) {
                slide.content = `This presentation will cover:\n- Introduction and overview\n- Key concepts and fundamentals\n- Important insights and findings\n- Practical applications\n- Conclusion and summary`;
              } else if (idx === presentationSlides.length - 1 || slideTitle.toLowerCase().includes('thank')) {
                slide.content = `Thank you for your attention!\n\nWe hope this presentation was informative and valuable.`;
              } else if (idx === presentationSlides.length - 2 || slideTitle.toLowerCase().includes('reference')) {
                slide.content = `References and Resources:\n- Additional reading materials\n- Key sources and citations\n- Further information and resources`;
              } else if (idx === presentationSlides.length - 3 || slideTitle.toLowerCase().includes('conclusion')) {
                slide.content = `Conclusion\n\nSummary of key points:\n- Main takeaways from this presentation\n- Important insights and learnings\n- Final thoughts and recommendations`;
              } else {
                // For subject slides, ensure substantial content
                slide.content = `Detailed information about ${slideTitle}:\n\n- Key concepts and principles\n- Important details and explanations\n- Examples and applications\n- Benefits and implications\n- Relevant insights and findings`;
              }
            }
            
            // Ensure title is meaningful
            if (!slide.title || slide.title.trim().length < 3) {
              if (idx === 0) {
                slide.title = topic || 'Title Slide';
              } else if (idx === 1) {
                slide.title = 'Outline';
              } else if (idx === presentationSlides.length - 1) {
                slide.title = 'Thank You';
              } else if (idx === presentationSlides.length - 2) {
                slide.title = 'References';
              } else if (idx === presentationSlides.length - 3) {
                slide.title = 'Conclusion';
              } else {
                slide.title = `Topic ${idx - 1}`;
              }
            }
          });
          
          // If parsing failed or returned fewer slides, create slides from the content
          if (presentationSlides.length === 0) {
            console.warn('Parsing returned 0 slides, creating slides from content...');
            // Split the content into equal parts
            const contentParts = generatedText.split(/\n\n+/).filter(p => p.trim().length > 10);
            const partsPerSlide = Math.max(1, Math.ceil(contentParts.length / numSlides));
            
            for (let i = 0; i < numSlides; i++) {
              const startIdx = i * partsPerSlide;
              const endIdx = Math.min(startIdx + partsPerSlide, contentParts.length);
              const slideContent = contentParts.slice(startIdx, endIdx).join('\n\n');
              const lines = slideContent.split('\n').filter(l => l.trim());
              const title = lines[0]?.substring(0, 60).trim() || `Slide ${i + 1}`;
              const content = lines.slice(1).join('\n').trim() || lines[0]?.trim() || slideContent.trim() || `Content for slide ${i + 1}`;
              
              presentationSlides.push({
                title: title,
                content: content
              });
            }
          }
          
          // Ensure we have exactly the requested number of slides
          while (presentationSlides.length < numSlides) {
            const lastSlide = presentationSlides[presentationSlides.length - 1] || { title: 'Slide', content: 'Content' };
            presentationSlides.push({
              title: `Slide ${presentationSlides.length + 1}`,
              content: lastSlide.content || `Content for slide ${presentationSlides.length + 1}`
            });
          }
          
          // Limit to requested number
          presentationSlides = presentationSlides.slice(0, numSlides);
          
          console.log('Final slides count:', presentationSlides.length);
          
          updateProgress(90, 'Finalizing presentation...');
          
          // Clear existing slides and create new ones
          if (typeof slides !== 'undefined' && Array.isArray(slides)) {
            // Clear existing slides
            slides.length = 0;
            
            // Create new slides from AI-generated content
            presentationSlides.forEach((slideData, index) => {
              try {
                // Validate slideData
                if (!slideData || typeof slideData !== 'object') {
                  console.warn(`Slide ${index + 1} data is invalid:`, slideData);
                  slideData = { title: `Slide ${index + 1}`, content: 'Content' };
                }
                
                const newSlide = createEmptySlide();
                // Ensure title is valid and clean
                let slideTitle = (slideData.title && typeof slideData.title === 'string' && slideData.title.trim()) 
                  ? slideData.title.trim() 
                  : `Slide ${index + 1}`;
                
                // Clean title - remove "Slide X:" prefix if present
                slideTitle = slideTitle.replace(/^Slide\s*\d+[:\.]\s*/i, '').trim();
                if (slideTitle.length === 0) {
                  // Generate appropriate title based on position
                  if (index === 0) {
                    slideTitle = presentationTopic || 'Title Slide';
                  } else if (index === 1) {
                    slideTitle = 'Outline';
                  } else if (index === presentationSlides.length - 1) {
                    slideTitle = 'Thank You';
                  } else if (index === presentationSlides.length - 2) {
                    slideTitle = 'References';
                  } else if (index === presentationSlides.length - 3) {
                    slideTitle = 'Conclusion';
                  } else {
                    slideTitle = `Topic ${index - 1}`;
                  }
                }
                newSlide.title = slideTitle;
                
                // Preserve content structure with line breaks - ensure content is never empty
                let contentText = (slideData.content && typeof slideData.content === 'string' && slideData.content.trim())
                  ? slideData.content.trim()
                  : '';
                
                // Clean HTML tags and markdown formatting from content
                contentText = cleanTextContent(contentText);
                
                // Ensure minimum content length (at least 30 characters)
                if (!contentText || contentText.trim().length < 30) {
                  // Generate appropriate content based on slide position and title
                  if (index === 0 || slideTitle.toLowerCase().includes('title')) {
                    contentText = `Welcome to this presentation about ${presentationTopic || 'the topic'}.\n\nThis presentation will provide comprehensive information and insights.`;
                  } else if (index === 1 || slideTitle.toLowerCase().includes('outline')) {
                    contentText = `This presentation will cover:\n- Introduction and overview\n- Key concepts and fundamentals\n- Important insights and findings\n- Practical applications\n- Conclusion and summary`;
                  } else if (index === presentationSlides.length - 1 || slideTitle.toLowerCase().includes('thank')) {
                    contentText = `Thank you for your attention!\n\nWe hope this presentation was informative and valuable.`;
                  } else if (index === presentationSlides.length - 2 || slideTitle.toLowerCase().includes('reference')) {
                    contentText = `References and Resources:\n- Additional reading materials\n- Key sources and citations\n- Further information and resources`;
                  } else if (index === presentationSlides.length - 3 || slideTitle.toLowerCase().includes('conclusion')) {
                    contentText = `Conclusion\n\nSummary of key points:\n- Main takeaways from this presentation\n- Important insights and learnings\n- Final thoughts and recommendations`;
                  } else {
                    // For subject slides, ensure substantial content
                    contentText = `Detailed information about ${slideTitle}:\n\n- Key concepts and principles\n- Important details and explanations\n- Examples and applications\n- Benefits and implications\n- Relevant insights and findings`;
                  }
                }
                
                // Ensure content has proper line breaks - normalize multiple spaces but preserve line breaks
                contentText = contentText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                // Remove excessive blank lines but keep single blank lines for structure
                contentText = contentText.replace(/\n{3,}/g, '\n\n');
                
                newSlide.content = contentText;
                newSlide.transition = 'fade';
                newSlide.transitionDuration = 0.5;
                
                // Ensure all required arrays are initialized
                if (!Array.isArray(newSlide.shapes)) newSlide.shapes = [];
                if (!Array.isArray(newSlide.charts)) newSlide.charts = [];
                if (!Array.isArray(newSlide.images)) newSlide.images = [];
                if (!Array.isArray(newSlide.videos)) newSlide.videos = [];
                if (!Array.isArray(newSlide.tables)) newSlide.tables = [];
                if (!Array.isArray(newSlide.additionalTextBoxes)) newSlide.additionalTextBoxes = [];
                if (!Array.isArray(newSlide.comments)) newSlide.comments = [];
                if (!Array.isArray(newSlide.animations)) newSlide.animations = [];
                
                // Ensure background is properly initialized with white color
                newSlide.background = { 
                  image: '', 
                  size: '', 
                  position: '', 
                  repeat: '', 
                  color: '#ffffff' 
                };
                
                // Ensure title and text boxes are visible and properly initialized
                // Initialize titleBox with proper defaults - ensure it stays within slide borders
                newSlide.titleBox = {
                  top: 24,
                  left: 24,
                  right: 24,
                  width: null,
                  height: null,
                  rotation: 0,
                  visible: true,
                  id: newSlide.titleBox?.id || generateElementId('title')
                };
                
                // Initialize textBox with proper defaults - ensure it stays within slide borders
                newSlide.textBox = {
                  top: 100,
                  left: 24,
                  right: 24,
                  bottom: 24,
                  width: null,
                  height: null,
                  rotation: 0,
                  visible: true,
                  id: newSlide.textBox?.id || generateElementId('body')
                };
                
                // Special handling for first slide to ensure proper positioning and constraints
                if (index === 0) {
                  // Ensure first slide title box has proper constraints to stay within borders
                  newSlide.titleBox.top = 24;
                  newSlide.titleBox.left = 24;
                  newSlide.titleBox.right = 24;
                  // Ensure first slide text box has proper constraints to stay within borders
                  newSlide.textBox.top = 100;
                  newSlide.textBox.left = 24;
                  newSlide.textBox.right = 24;
                  newSlide.textBox.bottom = 24;
                }
                
                // Ensure font families are set
                if (!newSlide.titleFontFamily) newSlide.titleFontFamily = DEFAULT_FONT_STACK;
                if (!newSlide.textFontFamily) newSlide.textFontFamily = DEFAULT_FONT_STACK;
                
                // Skip design enhancements - we only want text content
                // No visual elements, just text
                
                slides.push(newSlide);
              } catch (error) {
                console.error(`Error creating slide ${index + 1}:`, error);
                // Create a fallback slide if there's an error
                const fallbackSlide = createEmptySlide();
                let fallbackTitle = slideData?.title || `Slide ${index + 1}`;
                fallbackTitle = fallbackTitle.replace(/^Slide\s*\d+[:\.]\s*/i, '').trim();
                if (fallbackTitle.length === 0) {
                  if (index === 0) {
                    fallbackTitle = presentationTopic || 'Title Slide';
                  } else if (index === 1) {
                    fallbackTitle = 'Outline';
                  } else if (index === presentationSlides.length - 1) {
                    fallbackTitle = 'Thank You';
                  } else if (index === presentationSlides.length - 2) {
                    fallbackTitle = 'References';
                  } else if (index === presentationSlides.length - 3) {
                    fallbackTitle = 'Conclusion';
                  } else {
                    fallbackTitle = `Topic ${index - 1}`;
                  }
                }
                fallbackSlide.title = fallbackTitle;
                
                let fallbackContent = slideData?.content || '';
                fallbackContent = cleanTextContent(fallbackContent);
                if (!fallbackContent || fallbackContent.trim().length < 30) {
                  if (index === 0 || fallbackTitle.toLowerCase().includes('title')) {
                    fallbackContent = `Welcome to this presentation about ${presentationTopic || 'the topic'}.\n\nThis presentation will provide comprehensive information and insights.`;
                  } else if (index === 1 || fallbackTitle.toLowerCase().includes('outline')) {
                    fallbackContent = `This presentation will cover:\n- Introduction and overview\n- Key concepts and fundamentals\n- Important insights and findings\n- Practical applications\n- Conclusion and summary`;
                  } else if (index === presentationSlides.length - 1 || fallbackTitle.toLowerCase().includes('thank')) {
                    fallbackContent = `Thank you for your attention!\n\nWe hope this presentation was informative and valuable.`;
                  } else {
                    fallbackContent = `Detailed information about ${fallbackTitle}:\n\n- Key concepts and principles\n- Important details and explanations\n- Examples and applications`;
                  }
                }
                fallbackSlide.content = fallbackContent;
                fallbackSlide.titleBox.visible = true;
                fallbackSlide.textBox.visible = true;
                // Ensure proper constraints
                fallbackSlide.titleBox.right = 24;
                fallbackSlide.textBox.right = 24;
                fallbackSlide.textBox.bottom = 24;
                slides.push(fallbackSlide);
              }
            });
            
            // Validate all slides have required properties
            slides.forEach((slide, idx) => {
              if (!slide) {
                console.error(`Slide ${idx} is null or undefined`);
                slides[idx] = createEmptySlide();
                slides[idx].title = `Slide ${idx + 1}`;
                slides[idx].titleBox.visible = true;
                slides[idx].textBox.visible = true;
              } else {
                // Ensure all required properties exist
                // Clean and validate title
                if (!slide.title || typeof slide.title !== 'string') {
                  slide.title = `Slide ${idx + 1}`;
                } else {
                  // Clean title - remove "Slide X:" prefix
                  slide.title = slide.title.replace(/^Slide\s*\d+[:\.]\s*/i, '').trim();
                  if (slide.title.length === 0) {
                    // Generate appropriate title based on position
                    if (idx === 0) {
                      slide.title = presentationTopic || 'Title Slide';
                    } else if (idx === 1) {
                      slide.title = 'Outline';
                    } else if (idx === slides.length - 1) {
                      slide.title = 'Thank You';
                    } else if (idx === slides.length - 2) {
                      slide.title = 'References';
                    } else if (idx === slides.length - 3) {
                      slide.title = 'Conclusion';
                    } else {
                      slide.title = `Topic ${idx - 1}`;
                    }
                  }
                }
                
                // Clean and validate content - ensure minimum length
                if (!slide.content || typeof slide.content !== 'string') {
                  slide.content = '';
                }
                slide.content = cleanTextContent(slide.content);
                
                // Ensure content is never empty and has sufficient length (at least 30 characters)
                if (!slide.content || slide.content.trim().length < 30) {
                  const slideTitle = slide.title || `Slide ${idx + 1}`;
                  if (idx === 0 || slideTitle.toLowerCase().includes('title')) {
                    slide.content = `Welcome to this presentation about ${presentationTopic || 'the topic'}.\n\nThis presentation will provide comprehensive information and insights.`;
                  } else if (idx === 1 || slideTitle.toLowerCase().includes('outline')) {
                    slide.content = `This presentation will cover:\n- Introduction and overview\n- Key concepts and fundamentals\n- Important insights and findings\n- Practical applications\n- Conclusion and summary`;
                  } else if (idx === slides.length - 1 || slideTitle.toLowerCase().includes('thank')) {
                    slide.content = `Thank you for your attention!\n\nWe hope this presentation was informative and valuable.`;
                  } else if (idx === slides.length - 2 || slideTitle.toLowerCase().includes('reference')) {
                    slide.content = `References and Resources:\n- Additional reading materials\n- Key sources and citations\n- Further information and resources`;
                  } else if (idx === slides.length - 3 || slideTitle.toLowerCase().includes('conclusion')) {
                    slide.content = `Conclusion\n\nSummary of key points:\n- Main takeaways from this presentation\n- Important insights and learnings\n- Final thoughts and recommendations`;
                  } else {
                    slide.content = `Detailed information about ${slideTitle}:\n\n- Key concepts and principles\n- Important details and explanations\n- Examples and applications\n- Benefits and implications\n- Relevant insights and findings`;
                  }
                }
                if (!slide.titleBox) {
                  slide.titleBox = { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false, id: generateElementId('title') };
                }
                if (!slide.textBox) {
                  slide.textBox = { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false, id: generateElementId('body') };
                }
                if (!Array.isArray(slide.shapes)) slide.shapes = [];
                if (!Array.isArray(slide.charts)) slide.charts = [];
                if (!Array.isArray(slide.images)) slide.images = [];
                if (!Array.isArray(slide.videos)) slide.videos = [];
                if (!Array.isArray(slide.tables)) slide.tables = [];
                if (!Array.isArray(slide.additionalTextBoxes)) slide.additionalTextBoxes = [];
                if (!Array.isArray(slide.comments)) slide.comments = [];
                if (!Array.isArray(slide.animations)) slide.animations = [];
                // Always ensure background is white - fix for wrong coloring issue
                slide.background = { 
                  image: '', 
                  size: '', 
                  position: '', 
                  repeat: '', 
                  color: '#ffffff' 
                };
                if (!slide.titleFontFamily) slide.titleFontFamily = DEFAULT_FONT_STACK;
                if (!slide.textFontFamily) slide.textFontFamily = DEFAULT_FONT_STACK;
                if (!slide.transition) slide.transition = 'fade';
                if (typeof slide.transitionDuration !== 'number') slide.transitionDuration = 0.5;
              }
            });
            
            // Set active slide to first one
            if (typeof active !== 'undefined') {
              active = 0;
            }
            
            // Use setTimeout to ensure slides array is fully populated before rendering
            setTimeout(() => {
              // Capture state AFTER slides are created
              if (typeof capture === 'function') {
                capture();
              }
              
              // Load and render - this must happen after slides are created
              if (typeof load === 'function') {
                load();
              }
              
              // Force update content in DOM elements after load
              if (slides.length > 0 && active >= 0 && active < slides.length) {
                const currentSlide = slides[active];
                if (currentSlide) {
                  // Ensure title is displayed and stays within slide borders
                  if (titleBox && currentSlide.title) {
                    titleBox.textContent = currentSlide.title;
                    titleBox.style.display = 'block';
                    if (currentSlide.titleBox) {
                      titleBox.style.top = (currentSlide.titleBox.top || 24) + 'px';
                      titleBox.style.left = (currentSlide.titleBox.left || 24) + 'px';
                      // Ensure title box stays within slide borders
                      if (currentSlide.titleBox.width) {
                        titleBox.style.width = currentSlide.titleBox.width + 'px';
                        titleBox.style.right = 'auto';
                      } else if (currentSlide.titleBox.right !== undefined) {
                        titleBox.style.right = currentSlide.titleBox.right + 'px';
                      } else {
                        titleBox.style.right = '24px'; // Default right margin
                      }
                    }
                  }
                  // Ensure content is displayed with proper formatting
                  if (textBox && currentSlide.content) {
                    // Clean HTML tags and markdown formatting before displaying
                    let formattedContent = cleanTextContent(currentSlide.content);
                    // Ensure proper line breaks
                    formattedContent = formattedContent.replace(/\n/g, '\n');
                    // Trim each line but preserve structure
                    formattedContent = formattedContent.replace(/^\s+|\s+$/gm, '');
                    textBox.textContent = formattedContent;
                    textBox.style.display = 'block';
                    textBox.style.whiteSpace = 'pre-wrap'; // Preserve line breaks and wrap text
                    // Ensure text box stays within slide borders
                    if (currentSlide.textBox) {
                      textBox.style.top = (currentSlide.textBox.top || 100) + 'px';
                      textBox.style.left = (currentSlide.textBox.left || 24) + 'px';
                      textBox.style.right = (currentSlide.textBox.right || 24) + 'px';
                      textBox.style.bottom = (currentSlide.textBox.bottom || 24) + 'px';
                    }
                  }
                }
              }
              
              if (typeof renderSidebar === 'function') {
                renderSidebar();
              }
              if (typeof saveEditorState === 'function') {
                saveEditorState('ai_generate_presentation');
              }
            }, 100);
          }
          
          updateProgress(100, 'Presentation created!');
          setAIPresentationStatus(`Successfully created ${presentationSlides.length} slides with Llama AI!`, 'success');
          
          // FIXED: Save AI-generated slides to recents after slides array is updated
          setTimeout(() => {
            if (typeof saveToRecents === 'function') {
              saveToRecents();
            }
          }, 200);
          
          // Close modal after a short delay
          setTimeout(() => {
            hideAIPresentationModal();
            if (typeof showNotification === 'function') {
              showNotification(`AI generated ${presentationSlides.length} slides`);
            }
          }, 1500);
          
          if (aiPresentationGenerate) {
            aiPresentationGenerate.disabled = false;
          }
          
          return presentationSlides;
          
        } catch (error) {
          console.error('Error generating presentation:', error);
          setAIPresentationStatus(`Error: ${error.message}. Please try again.`, 'error');
          
          if (aiPresentationGenerate) {
            aiPresentationGenerate.disabled = false;
          }
          return null;
        }
      }
      
      // Function to enhance slides with visual elements - ONLY uses AI-generated design
      function enhanceSlideWithVisuals(slide, slideIndex, totalSlides, topic, aiDesign = null) {
        if (!slide) return;
        
        // Initialize arrays if needed
        if (!Array.isArray(slide.shapes)) {
          slide.shapes = [];
        }
        if (!Array.isArray(slide.images)) {
          slide.images = [];
        }
        
        // ONLY use AI-generated design - no fake/hardcoded design
        if (aiDesign && aiDesign.colors && aiDesign.colors.length > 0) {
          // AI provided colors - use them for background
          if (!slide.background) {
            slide.background = { image: '', size: '', position: '', repeat: '', color: '#ffffff' };
          }
          slide.background.color = aiDesign.colors[0];
        } else {
          // No AI design suggestions - keep default white background
          if (!slide.background) {
            slide.background = { image: '', size: '', position: '', repeat: '', color: '#ffffff' };
          }
          // Don't change background if AI didn't suggest it
        }
        
        // ONLY add shapes if AI explicitly suggested them
        if (aiDesign && aiDesign.shapes && aiDesign.shapes.length > 0) {
          const canvasWidth = canvas ? canvas.clientWidth : 960;
          const canvasHeight = canvas ? canvas.clientHeight : 540;
          
          // Use AI-suggested shapes only
          aiDesign.shapes.forEach((shapeType, i) => {
            const shape = SHAPE_OPTION_MAP.get(shapeType);
            if (shape) {
              const shapeColor = aiDesign.colors && aiDesign.colors.length > i + 1 
                ? aiDesign.colors[i + 1] 
                : (aiDesign.colors && aiDesign.colors[0] ? aiDesign.colors[0] : '#3b82f6');
              
              slide.shapes.push({
                id: generateElementId('shape'),
                shapeId: shapeType,
                left: 40 + (i * 100),
                top: 40 + (i * 80),
                width: 120,
                height: 120,
                color: shapeColor,
                zIndex: 1,
                minWidth: 60,
                minHeight: 60,
                rotation: 0
              });
            }
          });
        }
        
        // Don't add any images, decorative shapes, or other hardcoded elements
        // Only use what the AI actually generated
      }
      
      // Enhanced fallback presentation generator with intelligent content
      function generateEnhancedFallbackPresentation(topic, numSlides, details) {
        const slides = [];
        
        // Intelligent slide templates based on topic keywords
        const topicLower = topic.toLowerCase();
        const isTechnical = topicLower.includes('technology') || topicLower.includes('software') || topicLower.includes('ai') || topicLower.includes('machine learning') || topicLower.includes('programming');
        const isBusiness = topicLower.includes('business') || topicLower.includes('company') || topicLower.includes('marketing') || topicLower.includes('sales') || topicLower.includes('strategy');
        const isEducational = topicLower.includes('education') || topicLower.includes('learning') || topicLower.includes('training') || topicLower.includes('course');
        const isScientific = topicLower.includes('research') || topicLower.includes('study') || topicLower.includes('analysis') || topicLower.includes('data');
        
        // Generate context-aware slide templates
        const slideTemplates = [];
        
        // Slide 1: Introduction
        slideTemplates.push({
          title: `Introduction to ${topic}`,
          content: `Welcome to our comprehensive presentation on ${topic}.\n\nToday, we will explore:\nâ€¢ Key concepts and fundamentals\nâ€¢ Important insights and findings\nâ€¢ Practical applications and examples\nâ€¢ Future implications and opportunities`
        });
        
        // Slide 2: Overview/Background
        if (isTechnical) {
          slideTemplates.push({
            title: 'Technical Overview',
            content: `${topic} represents a significant advancement in technology.\n\nKey aspects:\nâ€¢ Core technical principles\nâ€¢ System architecture and components\nâ€¢ Implementation considerations\nâ€¢ Performance metrics and benchmarks`
          });
        } else if (isBusiness) {
          slideTemplates.push({
            title: 'Business Context',
            content: `${topic} plays a crucial role in today's business landscape.\n\nImportant factors:\nâ€¢ Market trends and opportunities\nâ€¢ Competitive landscape\nâ€¢ Business value and ROI\nâ€¢ Strategic implications`
          });
        } else {
          slideTemplates.push({
            title: 'Overview',
            content: `This presentation provides a comprehensive overview of ${topic}.\n\nWe will cover:\nâ€¢ Fundamental concepts\nâ€¢ Key principles and theories\nâ€¢ Current state and developments\nâ€¢ Important considerations`
          });
        }
        
        // Slide 3: Key Points
        slideTemplates.push({
          title: 'Key Points',
          content: `Main aspects to consider about ${topic}:\n\nâ€¢ Point 1: Fundamental importance and relevance\nâ€¢ Point 2: Critical factors and considerations\nâ€¢ Point 3: Essential elements and components\nâ€¢ Point 4: Key benefits and advantages`
        });
        
        // Slide 4: Detailed Analysis
        if (isScientific) {
          slideTemplates.push({
            title: 'Research Findings',
            content: `Analysis and research findings related to ${topic}:\n\nâ€¢ Finding 1: Significant discovery or insight\nâ€¢ Finding 2: Important data and statistics\nâ€¢ Finding 3: Key correlations and patterns\nâ€¢ Finding 4: Implications for future research`
          });
        } else {
          slideTemplates.push({
            title: 'Detailed Analysis',
            content: `Let's dive deeper into ${topic}:\n\nâ€¢ Analysis point 1: Detailed examination\nâ€¢ Analysis point 2: Critical evaluation\nâ€¢ Analysis point 3: Comparative assessment\nâ€¢ Analysis point 4: Strategic implications`
          });
        }
        
        // Slide 5: Examples/Use Cases
        slideTemplates.push({
          title: 'Examples and Use Cases',
          content: `Real-world applications of ${topic}:\n\nâ€¢ Example 1: Practical implementation scenario\nâ€¢ Example 2: Industry application case study\nâ€¢ Example 3: Success story and outcomes\nâ€¢ Example 4: Best practices and lessons learned`
        });
        
        // Slide 6: Benefits/Advantages
        slideTemplates.push({
          title: 'Benefits and Advantages',
          content: `Key benefits of ${topic}:\n\nâ€¢ Benefit 1: Primary advantage and value proposition\nâ€¢ Benefit 2: Secondary benefits and improvements\nâ€¢ Benefit 3: Long-term positive impacts\nâ€¢ Benefit 4: Competitive advantages`
        });
        
        // Slide 7: Challenges/Considerations
        slideTemplates.push({
          title: 'Challenges and Considerations',
          content: `Important challenges and considerations:\n\nâ€¢ Challenge 1: Potential obstacles and limitations\nâ€¢ Challenge 2: Risk factors and mitigation strategies\nâ€¢ Challenge 3: Resource requirements\nâ€¢ Challenge 4: Implementation considerations`
        });
        
        // Slide 8: Solutions/Recommendations
        slideTemplates.push({
          title: 'Solutions and Recommendations',
          content: `Proposed solutions and recommendations for ${topic}:\n\nâ€¢ Solution 1: Primary approach and methodology\nâ€¢ Solution 2: Alternative strategies\nâ€¢ Solution 3: Best practices and guidelines\nâ€¢ Solution 4: Action items and next steps`
        });
        
        // Slide 9: Future Outlook
        slideTemplates.push({
          title: 'Future Outlook',
          content: `Future trends and developments in ${topic}:\n\nâ€¢ Trend 1: Emerging technologies and innovations\nâ€¢ Trend 2: Market evolution and growth\nâ€¢ Trend 3: Future opportunities\nâ€¢ Trend 4: Long-term vision and goals`
        });
        
        // Slide 10: Conclusion
        slideTemplates.push({
          title: 'Conclusion',
          content: `In conclusion, ${topic} is a critical and evolving field.\n\nKey takeaways:\nâ€¢ Summary of main points\nâ€¢ Important insights and learnings\nâ€¢ Call to action or next steps\nâ€¢ Thank you for your attention`
        });
        
        // Generate slides based on templates
        for (let i = 0; i < numSlides; i++) {
          const templateIndex = i < slideTemplates.length ? i : i % slideTemplates.length;
          const template = slideTemplates[templateIndex];
          slides.push({
            title: template.title || `Slide ${i + 1}`,
            content: template.content.replace(/\$\{topic\}/g, topic)
          });
        }
        
        // Format as text for parsing
        return slides.map((slide, idx) => 
          `Slide ${idx + 1}: ${slide.title}\n${slide.content}`
        ).join('\n\n');
      }
      
      function generateFallbackPresentation(topic, numSlides, details) {
        // Use enhanced fallback
        return generateEnhancedFallbackPresentation(topic, numSlides, details);
      }
      
      if (aiPresentationButton) {
        aiPresentationButton.addEventListener('click', () => {
          showAIPresentationModal();
        });
      }
      
      if (aiPresentationModalClose) {
        aiPresentationModalClose.addEventListener('click', () => {
          hideAIPresentationModal();
        });
      }
      
      if (aiPresentationModalCancel) {
        aiPresentationModalCancel.addEventListener('click', () => {
          hideAIPresentationModal();
        });
      }
      
      if (aiPresentationGenerate) {
        aiPresentationGenerate.addEventListener('click', async () => {
          const topic = aiPresentationTopic ? aiPresentationTopic.value : '';
          const textStructure = aiPresentationTextStructure ? aiPresentationTextStructure.value : '';
          const numSlides = aiPresentationSlides ? parseInt(aiPresentationSlides.value) || 5 : 5;
          await generatePresentationWithAI(topic, numSlides, textStructure, '');
        });
      }
      
      // Close modal on Escape key
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && aiPresentationModal && aiPresentationModal.classList.contains('show')) {
          hideAIPresentationModal();
        }
      });
      
      // Initialize ResizablePanel instances
      let sidebarResizer = null;
      let translatorResizer = null;
      
      function initializeResizablePanels() {
        // Initialize sidebar resizer
        if (sidebar) {
          try {
            sidebarResizer = new ResizablePanel(sidebar, {
              side: 'right',
              cssVar: '--sidebar-width',
              minWidth: 180,
              maxWidth: 600,
              initialWidth: 260,
              storageKey: 'editor-sidebar-width'
            });
            if (sidebarResizer && sidebarResizer.resizer) {
              console.log('Sidebar resizer initialized successfully');
            } else {
              console.warn('Sidebar resizer failed to initialize');
            }
          } catch (error) {
            console.error('Error initializing sidebar resizer:', error);
          }
        } else {
          console.warn('Sidebar element not found');
        }
        
        // Initialize translator panel resizer
        if (translatorPanel) {
          try {
            translatorResizer = new ResizablePanel(translatorPanel, {
              side: 'left',
              cssVar: '--translator-width',
              minWidth: 180,
              maxWidth: 600,
              initialWidth: 280,
              storageKey: 'editor-translator-width'
            });
            if (translatorResizer && translatorResizer.resizer) {
              console.log('Translator panel resizer initialized successfully');
            } else {
              console.warn('Translator panel resizer failed to initialize');
            }
          } catch (error) {
            console.error('Error initializing translator panel resizer:', error);
          }
        } else {
          console.warn('Translator panel element not found');
        }
      }
      
      // Initialize immediately if DOM is ready, otherwise wait
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          initializeResizablePanels();
          initializeThumbnailManager();
        });
      } else {
        // DOM is already ready
        initializeResizablePanels();
        initializeThumbnailManager();
      }
      if (elementContextButtons.delete) {
        elementContextButtons.delete.addEventListener('click', () => {
          const target = elementContextTarget || (getSelectedElementContext()?.element ?? null);
          if (target && removeElementElement(target)) {
            showNotification('Deleted object');
          } else {
            showNotification('No object selected');
          }
          hideElementContextMenu();
        });
      }
      if (elementContextButtons.bringForward) {
        elementContextButtons.bringForward.addEventListener('click', () => {
          hideElementContextMenu();
          bringSelectedElementsForward();
        });
      }
      if (elementContextButtons.sendBackward) {
        elementContextButtons.sendBackward.addEventListener('click', () => {
          hideElementContextMenu();
          sendSelectedElementsBackward();
        });
      }
      if (elementContextButtons.bringToFront) {
        elementContextButtons.bringToFront.addEventListener('click', () => {
          hideElementContextMenu();
          bringSelectedElementsToFront();
        });
      }
      if (elementContextButtons.sendToBack) {
        elementContextButtons.sendToBack.addEventListener('click', () => {
          hideElementContextMenu();
          sendSelectedElementsToBack();
        });
      }
      if (elementContextButtons.crop) {
        elementContextButtons.crop.addEventListener('click', () => {
          if (elementContextTarget && elementContextTarget.classList.contains('image-element')) {
            hideElementContextMenu();
            openImageCropper(elementContextTarget);
          }
        });
      }
      if (elementContextButtons.background) {
        elementContextButtons.background.addEventListener('click', () => {
          if (elementContextTarget && elementContextTarget.classList.contains('image-element')) {
            hideElementContextMenu();
            setImageAsBackground(elementContextTarget);
          }
        });
      }
      if (slideCanvasMenuButtons.copy) {
        slideCanvasMenuButtons.copy.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (copySlideAt(index)) {
            showNotification('Copied slide');
          }
        });
      }
      if (slideCanvasMenuButtons.cut) {
        slideCanvasMenuButtons.cut.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (cutSlideAt(index)) {
            showNotification('Cut slide');
          }
        });
      }
      if (slideCanvasMenuButtons.paste) {
        slideCanvasMenuButtons.paste.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (editorClipboard.type === 'slide') {
            pasteSlideAfter(index);
          } else if (editorClipboard.type === 'elements') {
            pasteElementsFromClipboard({ referenceElement: null });
          } else {
            showNotification('Clipboard is empty');
          }
        });
      }
      if (slideCanvasMenuButtons.newSlide) {
        slideCanvasMenuButtons.newSlide.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          createNewSlide(index);
        });
      }
      if (slideCanvasMenuButtons.duplicate) {
        slideCanvasMenuButtons.duplicate.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          duplicateCurrentSlide(index);
        });
      }
      if (slideCanvasMenuButtons.delete) {
        slideCanvasMenuButtons.delete.addEventListener('click', () => {
          const index = slideCanvasContextTargetIndex != null ? slideCanvasContextTargetIndex : active;
          hideSlideCanvasContextMenu();
          if (deleteSlide(index)) {
            showNotification('Deleted slide');
          }
        });
      }
      if (elementContextMenu) {
        elementContextMenu.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });
        elementContextMenu.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }
      if (slideCanvasContextMenu) {
        slideCanvasContextMenu.addEventListener('contextmenu', (event) => {
          event.preventDefault();
        });
        slideCanvasContextMenu.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }
      document.addEventListener('click', (event) => {
        if (elementContextMenu && elementContextMenu.classList.contains('show') && !elementContextMenu.contains(event.target)) {
          hideElementContextMenu();
        }
        if (slideCanvasContextMenu && slideCanvasContextMenu.classList.contains('show') && !slideCanvasContextMenu.contains(event.target)) {
          hideSlideCanvasContextMenu();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (imageCropOverlay.classList.contains('visible')) {
            closeImageCropper();
          } else {
            hideElementContextMenu();
            hideSlideCanvasContextMenu();
          }
        }
      });
      window.addEventListener('resize', () => {
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
      });
      window.addEventListener('scroll', (event) => {
        if (elementContextMenu && elementContextMenu.classList.contains('show') && !elementContextMenu.contains(event.target)) {
          hideElementContextMenu();
        }
        if (slideCanvasContextMenu && slideCanvasContextMenu.classList.contains('show') && !slideCanvasContextMenu.contains(event.target)) {
          hideSlideCanvasContextMenu();
        }
      }, true);
      if (imageCropOverlay) {
        imageCropOverlay.addEventListener('click', (event) => {
          if (event.target === imageCropOverlay) {
            closeImageCropper();
          }
        });
        imageCropOverlay.addEventListener('contextmenu', (event) => event.preventDefault());
      }
      if (imageCropCancel) {
        imageCropCancel.addEventListener('click', () => closeImageCropper());
      }
      if (imageCropClose) {
        imageCropClose.addEventListener('click', () => closeImageCropper());
      }
      if (imageCropApply) {
        imageCropApply.addEventListener('click', () => applyImageCrop());
      }

      const presentationOverlay = document.createElement('div');
      presentationOverlay.id = 'presentationOverlay';
      presentationOverlay.className = 'presentation-overlay';
      presentationOverlay.setAttribute('tabindex', '-1');
      presentationOverlay.innerHTML = `
        <div class="presentation-stage" tabindex="-1"></div>
        <div class="presentation-meta">
          <span><i class="fas fa-arrow-left"></i> Prev</span>
          <span>Esc to Exit</span>
          <span>Next <i class="fas fa-arrow-right"></i></span>
          <div class="presentation-subtitle-controls">
            <div class="presentation-language-group">
            <button type="button" class="presentation-subtitle-toggle" aria-pressed="false" title="Toggle subtitles">
              <i class="fas fa-closed-captioning"></i>
              <span>Subtitles</span>
            </button>
            <button
              type="button"
              class="presentation-subtitle-menu-button"
              aria-haspopup="true"
              aria-expanded="false"
              title="Subtitle options"
              aria-label="Subtitle options"
            >
              <i class="fas fa-ellipsis-v"></i>
            </button>
            </div>
            <div class="presentation-language-group">
              <button type="button" class="presentation-translation-toggle" aria-pressed="false" title="Toggle translation">
                <i class="fas fa-language"></i>
                <span>Translate</span>
              </button>
              <button
                type="button"
                class="presentation-translation-menu-button"
                aria-haspopup="true"
                aria-expanded="false"
                title="Translation options"
                aria-label="Translation options"
              >
                <i class="fas fa-ellipsis-v"></i>
              </button>
            </div>
          </div>
        </div>
        <div class="presentation-counter"></div>
        <div class="presentation-subtitles" aria-live="polite" aria-atomic="true"></div>
        <div class="presentation-translation" aria-live="polite" aria-atomic="true"></div>
        <div class="presentation-subtitle-menu" role="dialog" aria-label="Subtitle options">
          <div class="subtitle-menu-header">
            <h4>Subtitle language</h4>
            <input
              type="search"
              class="subtitle-language-search"
              placeholder="Search languages"
              aria-label="Search languages"
              autocomplete="off"
              spellcheck="false"
            >
          </div>
          <div class="subtitle-language-list" role="listbox"></div>
          <div class="subtitle-language-empty">No languages found.</div>
        </div>
        <div class="presentation-translation-menu" role="dialog" aria-label="Translation options">
          <div class="translation-menu-header">
            <h4>Translation target</h4>
            <input
              type="search"
              class="translation-language-search"
              placeholder="Search languages"
              aria-label="Search translation languages"
              autocomplete="off"
              spellcheck="false"
            >
          </div>
          <div class="translation-language-list" role="listbox"></div>
          <div class="translation-language-empty">No languages found.</div>
        </div>
      `;
      document.body.appendChild(presentationOverlay);
      const presentationStage = presentationOverlay.querySelector('.presentation-stage');
      const presentationCounterEl = presentationOverlay.querySelector('.presentation-counter');
      const presentationSubtitleToggle = presentationOverlay.querySelector('.presentation-subtitle-toggle');
      const presentationSubtitlesEl = presentationOverlay.querySelector('.presentation-subtitles');
      presentationTranslationToggle = presentationOverlay.querySelector('.presentation-translation-toggle');
      presentationTranslationMenuButton = presentationOverlay.querySelector('.presentation-translation-menu-button');
      presentationTranslationMenu = presentationOverlay.querySelector('.presentation-translation-menu');
      presentationTranslationMenuSearch = presentationTranslationMenu ? presentationTranslationMenu.querySelector('.translation-language-search') : null;
      presentationTranslationMenuList = presentationTranslationMenu ? presentationTranslationMenu.querySelector('.translation-language-list') : null;
      translationLanguageEmptyState = presentationTranslationMenu ? presentationTranslationMenu.querySelector('.translation-language-empty') : null;
      presentationTranslationEl = presentationOverlay.querySelector('.presentation-translation');
      presentationSubtitleMenuButton = presentationOverlay.querySelector('.presentation-subtitle-menu-button');
      presentationSubtitleMenu = presentationOverlay.querySelector('.presentation-subtitle-menu');
      presentationSubtitleMenuSearch = presentationSubtitleMenu ? presentationSubtitleMenu.querySelector('.subtitle-language-search') : null;
      presentationSubtitleMenuList = presentationSubtitleMenu ? presentationSubtitleMenu.querySelector('.subtitle-language-list') : null;
      subtitleLanguageEmptyState = presentationSubtitleMenu ? presentationSubtitleMenu.querySelector('.subtitle-language-empty') : null;
      if (presentationSubtitlesEl) {
        presentationSubtitlesEl.addEventListener('pointermove', moveSubtitlesDrag);
        presentationSubtitlesEl.addEventListener('pointerup', endSubtitlesDrag);
        presentationSubtitlesEl.addEventListener('pointercancel', endSubtitlesDrag);
        presentationSubtitlesEl.addEventListener('pointerleave', (event) => {
          if (subtitlesDragState && event.pointerId === subtitlesDragState.pointerId) {
            endSubtitlesDrag(event);
          }
        });
        presentationSubtitlesEl.style.pointerEvents = 'none';
      }
      if (presentationSubtitleMenuButton) {
        presentationSubtitleMenuButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (!subtitlesSupported) {
            showNotification('Subtitles are not supported in this browser.');
            return;
          }
          toggleSubtitleLanguageMenu();
        });
        if (!subtitlesSupported) {
          presentationSubtitleMenuButton.disabled = true;
        }
      }
      if (presentationSubtitleMenuSearch) {
        presentationSubtitleMenuSearch.addEventListener('input', () => {
          filterSubtitleLanguageMenu(presentationSubtitleMenuSearch.value);
        });
      }
      if (presentationSubtitleMenuList) {
        buildSubtitleLanguageMenu();
      }
      if (presentationTranslationToggle) {
        presentationTranslationToggle.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (!subtitlesSupported) {
            showNotification('Live translation is not supported in this browser.');
            return;
          }
          toggleTranslation();
        });
        if (!subtitlesSupported) {
          presentationTranslationToggle.disabled = true;
          presentationTranslationToggle.title = 'Translation is not supported in this browser.';
          presentationTranslationToggle.setAttribute('aria-pressed', 'false');
        }
      }
      if (presentationTranslationMenuButton) {
        presentationTranslationMenuButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (!subtitlesSupported) {
            showNotification('Live translation is not supported in this browser.');
            return;
          }
          toggleTranslationLanguageMenu();
        });
        if (!subtitlesSupported) {
          presentationTranslationMenuButton.disabled = true;
        }
      }
      if (presentationTranslationMenuSearch) {
        presentationTranslationMenuSearch.addEventListener('input', () => {
          filterTranslationLanguageMenu(presentationTranslationMenuSearch.value);
        });
      }
      if (presentationTranslationMenuList) {
        buildTranslationLanguageMenu();
        updateTranslationMenuSelection();
      }
      updateSubtitleMenuButtonLabel();
      updateTranslationMenuButtonLabel();
      const transitionPreviewOverlay = document.createElement('div');
      transitionPreviewOverlay.id = 'transitionPreviewOverlay';
      transitionPreviewOverlay.className = 'transition-preview-overlay';
      transitionPreviewOverlay.innerHTML = '<div class="transition-preview-stage"></div>';
      document.body.appendChild(transitionPreviewOverlay);
      const transitionPreviewStage = transitionPreviewOverlay.querySelector('.transition-preview-stage');
      let transitionPreviewTimeout = null;
      let isPresenting = false;
      let presentationIndex = 0;
      let presentationReturnIndex = 0;
      let presentationControlsTimeout = null;
      const PRESENTATION_CONTROLS_AUTOHIDE_DELAY = 10000;
      let presentationControlsLocked = false;
      let slideContextMenuTarget = null;
      let slideContextMenuTitle = null;
      let slideContextMenuIndex = null;
      let currentAnimationQueue = [];
      let currentAnimationStep = 0;
      let subtitlesRecognition = null;
      let subtitlesActive = false;
      let subtitlesFinalText = '';
      const SUBTITLES_CLEAR_DELAY = 2000;
      const SUBTITLES_MAX_BUFFER = 400;
      updateSubtitleToggleLabel();
      updateTranslationToggleLabel();
      const TRANSITION_OPTIONS = Object.freeze([
        { value: 'none', label: 'None' },
        { value: 'fade', label: 'Fade' },
        { value: 'slide-left', label: 'Slide Left' },
        { value: 'slide-right', label: 'Slide Right' },
        { value: 'slide-up', label: 'Slide Up' },
        { value: 'slide-down', label: 'Slide Down' },
        { value: 'zoom-in', label: 'Zoom In' },
        { value: 'zoom-out', label: 'Zoom Out' },
        { value: 'flip', label: 'Flip' },
        { value: 'rotate', label: 'Rotate' }
      ]);
      const DEFAULT_TRANSITION = 'none';
      const TRANSITION_CLASS_NAMES = TRANSITION_OPTIONS
        .filter(opt => opt.value !== 'none')
        .map(opt => `transition-effect-${opt.value}`);
      const TRANSITION_VALUE_SET = new Set(TRANSITION_OPTIONS.map(opt => opt.value));
      let slideTransitionMenuIndex = null;
      let slideTransitionMenuAnchor = null;

      function renderSlideTransitionMenuOptions() {
        if (!slideTransitionMenu) return;
        slideTransitionMenu.innerHTML = '';
        TRANSITION_OPTIONS.forEach(opt => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.transition = opt.value;
          btn.innerHTML = `${getTransitionIconHtml(opt.value)}<span>${opt.label}</span>`;
          slideTransitionMenu.appendChild(btn);
        });
      }
      renderSlideTransitionMenuOptions();

      function showSaveAsMenu() {
        if (!saveAsMenu) return;
        saveAsMenu.classList.add('show');
      }

      function hideSaveAsMenu() {
        if (!saveAsMenu) return;
        saveAsMenu.classList.remove('show');
      }

      function toggleSaveAsMenu() {
        if (!saveAsMenu) return;
        if (saveAsMenu.classList.contains('show')) {
          hideSaveAsMenu();
        } else {
          showSaveAsMenu();
        }
      }

      const saveAsModal = document.getElementById('saveAsModal');
      const sectionNameModal = document.getElementById('sectionNameModal');
      const sectionNameModalClose = document.getElementById('sectionNameModalClose');
      const sectionNameModalCancel = document.getElementById('sectionNameModalCancel');
      const sectionNameModalSubmit = document.getElementById('sectionNameModalSubmit');
      const sectionNameInput = document.getElementById('sectionNameInput');
      
      const saveAsModalClose = document.getElementById('saveAsModalClose');
      const saveAsModalCancel = document.getElementById('saveAsModalCancel');
      const saveAsModalSave = document.getElementById('saveAsModalSave');
      const saveAsFormat = document.getElementById('saveAsFormat');
      const saveAsFileName = document.getElementById('saveAsFileName');

      function showSaveAsModal() {
        if (!saveAsModal) return;
        // Set default filename based on current slide title
        const currentSlide = slides[active] || slides[0] || {};
        const rawTitle = (currentSlide.title || '').trim();
        const sanitizedTitle = rawTitle
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_');
        const defaultName = sanitizedTitle || 'Presentation';
        saveAsFileName.value = defaultName;
        saveAsModal.classList.add('show');
        // Focus the filename input
        setTimeout(() => {
          saveAsFileName.focus();
          saveAsFileName.select();
        }, 100);
      }

      function hideSaveAsModal() {
        if (!saveAsModal) return;
        saveAsModal.classList.remove('show');
      }

      if (saveAsButton) {
        saveAsButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          showSaveAsModal();
        });
      }

      // Section name modal event listeners
      if (sectionNameModalClose) {
        sectionNameModalClose.addEventListener('click', () => {
          hideSectionNameModal();
        });
      }

      if (sectionNameModalCancel) {
        sectionNameModalCancel.addEventListener('click', () => {
          hideSectionNameModal();
        });
      }

      if (sectionNameModalSubmit) {
        sectionNameModalSubmit.addEventListener('click', () => {
          handleSectionNameSubmit();
        });
      }

      if (sectionNameInput) {
        sectionNameInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleSectionNameSubmit();
          } else if (event.key === 'Escape') {
            event.preventDefault();
            hideSectionNameModal();
          }
        });
      }

      // Delete section modal event listeners
      const deleteSectionModal = document.getElementById('deleteSectionModal');
      const deleteSectionModalCancel = document.getElementById('deleteSectionModalCancel');
      const deleteSectionModalConfirm = document.getElementById('deleteSectionModalConfirm');

      if (deleteSectionModalCancel) {
        deleteSectionModalCancel.addEventListener('click', () => {
          hideDeleteSectionModal();
        });
      }

      if (deleteSectionModalConfirm) {
        deleteSectionModalConfirm.addEventListener('click', () => {
          handleDeleteSectionConfirm();
        });
      }

      if (deleteSectionModal) {
        deleteSectionModal.addEventListener('click', (event) => {
          if (event.target === deleteSectionModal) {
            hideDeleteSectionModal();
          }
        });
      }

      // Close delete section modal on Escape key
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && deleteSectionModal && deleteSectionModal.classList.contains('show')) {
          hideDeleteSectionModal();
        }
      });

      if (sectionNameModal) {
        sectionNameModal.addEventListener('click', (event) => {
          if (event.target === sectionNameModal) {
            hideSectionNameModal();
          }
        });
      }

      if (saveAsModalClose) {
        saveAsModalClose.addEventListener('click', () => {
          hideSaveAsModal();
        });
      }

      if (saveAsModalCancel) {
        saveAsModalCancel.addEventListener('click', () => {
          hideSaveAsModal();
        });
      }

      if (saveAsModal) {
        saveAsModal.addEventListener('click', (event) => {
          if (event.target === saveAsModal) {
            hideSaveAsModal();
          }
        });
      }

      if (saveAsModalSave) {
        saveAsModalSave.addEventListener('click', async () => {
          const format = saveAsFormat ? saveAsFormat.value : 'pptx';
          const fileName = saveAsFileName ? saveAsFileName.value.trim() : '';
          if (!fileName) {
            alert('Please enter a file name');
            return;
          }
          hideSaveAsModal();
          await handleSaveAsExport(format, fileName);
        });
      }

      // Allow Enter key to save
      if (saveAsFileName) {
        saveAsFileName.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && saveAsModalSave) {
            event.preventDefault();
            saveAsModalSave.click();
          }
        });
      }

      // Keep old menu handlers for backward compatibility (hidden menu)
      if (saveAsMenu) {
        document.addEventListener('click', (event) => {
          if (!saveAsMenu.contains(event.target) && !saveAsButton.contains(event.target)) {
            hideSaveAsMenu();
          }
        });
        window.addEventListener('resize', hideSaveAsMenu);
        window.addEventListener('scroll', hideSaveAsMenu, true);
      }

      function prepareCanvasForPresentation(clone) {
        clone.removeAttribute('id');
        clone.classList.add('presentation-slide');
        clone.style.width = '100%';
        clone.style.height = '100%';
        clone.style.pointerEvents = 'none';
        clone.querySelectorAll('[id]').forEach(el => {
          if (el.id) {
            el.removeAttribute('id');
          }
        });
        clone.querySelectorAll('[contenteditable]').forEach(el => {
          el.removeAttribute('contenteditable');
          el.classList.remove('selected');
          el.removeAttribute('spellcheck');
        });
        clone.querySelectorAll('.resize-edge').forEach(el => el.remove());
        clone.querySelectorAll('[data-placeholder]').forEach(el => el.removeAttribute('data-placeholder'));
        clone.querySelectorAll('.shape-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.chart-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.video-element').forEach(el => {
          el.classList.remove('selected');
          const video = el.querySelector('video');
          if (video) {
            video.controls = true;
          }
        });
        clone.querySelectorAll('.image-element').forEach(el => {
          el.classList.remove('selected');
        });
        clone.querySelectorAll('.table-resize-handle').forEach(el => el.remove());
        clone.querySelectorAll('.table-cell-selected').forEach(el => el.classList.remove('table-cell-selected'));
        clone.querySelectorAll('.table-element').forEach(el => {
          el.style.border = '1px solid rgba(148, 232, 203, 0.35)';
          el.style.boxShadow = 'none';
        });
        clone.querySelectorAll('.table-element').forEach(el => {
          el.classList.remove('selected');
          el.style.border = '1px solid rgba(148, 232, 203, 0.35)';
          el.style.boxShadow = 'none';
        });
        clone.querySelectorAll('.title-box, .text-box, .additional-text-box').forEach(el => {
          el.style.border = 'none';
          el.style.boxShadow = 'none';
          el.style.backgroundColor = el.style.backgroundColor || 'transparent';
        });
        clone.querySelectorAll('.animation-order-badge').forEach(el => el.remove());
      }

      function cloneCanvasForPresentation(index, options = {}) {
        const originalActive = active;
        const restoreActiveIndex = Number.isInteger(options.restoreActiveIndex)
          ? options.restoreActiveIndex
          : (isPresenting ? presentationReturnIndex : originalActive);
        active = index;
        load();
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        const config = getSlideTransitionConfig(slides[index]);
        applySlideTransitionClass(clone, config.effect, config.duration, options);
        active = restoreActiveIndex;
        load();
        return clone;
      }

      function waitForNextFrame() {
        return new Promise((resolve) => requestAnimationFrame(() => resolve()));
      }

      function getCanvasBackgroundColor() {
        const computed = window.getComputedStyle(canvas);
        return computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)'
          ? computed.backgroundColor
          : '#ffffff';
      }

      async function renderSlideToImage() {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Export library html2canvas is not available.');
        }
        const clone = canvas.cloneNode(true);
        prepareCanvasForPresentation(clone);
        clone.style.width = `${canvas.offsetWidth}px`;
        clone.style.height = `${canvas.offsetHeight}px`;
        clone.style.pointerEvents = 'none';
        clone.style.transform = 'none';
        const wrapper = document.createElement('div');
        wrapper.className = 'export-slide-wrapper';
        wrapper.style.position = 'fixed';
        wrapper.style.top = '-12000px';
        wrapper.style.left = '-12000px';
        wrapper.style.width = `${canvas.offsetWidth}px`;
        wrapper.style.height = `${canvas.offsetHeight}px`;
        wrapper.style.pointerEvents = 'none';
        wrapper.style.opacity = '0';
        wrapper.style.background = getCanvasBackgroundColor();
        wrapper.appendChild(clone);
        document.body.appendChild(wrapper);
        try {
          const exportCanvas = await window.html2canvas(clone, {
            backgroundColor: wrapper.style.background || '#ffffff',
            scale: 2,
            useCORS: true,
            logging: false
          });
          return {
            dataUrl: exportCanvas.toDataURL('image/png'),
            width: exportCanvas.width,
            height: exportCanvas.height
          };
        } finally {
          document.body.removeChild(wrapper);
        }
      }

      async function captureSlidesAsImages() {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Export libraries are still loading.');
        }
        const originalActiveIndex = active;
        capture();
        const slideImages = [];
        try {
          for (let index = 0; index < slides.length; index += 1) {
            active = index;
            load();
            await waitForNextFrame();
            const image = await renderSlideToImage();
            slideImages.push(image);
          }
        } finally {
          active = originalActiveIndex;
          load();
        }
        return slideImages;
      }

      function getExportFileName(extension) {
        const currentSlide = slides[active] || slides[0] || {};
        const rawTitle = (currentSlide.title || '').trim();
        const sanitizedTitle = rawTitle
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_');
        const base = sanitizedTitle || 'Presentation';
        const dateStamp = new Date().toISOString().slice(0, 10);
        return `${base}_${dateStamp}.${extension}`;
      }

      async function exportSlidesToPdf(slideImages, fileName) {
        const jspdfNamespace = window.jspdf;
        if (!jspdfNamespace || typeof jspdfNamespace.jsPDF !== 'function') {
          throw new Error('PDF export library is not available.');
        }
        if (!slideImages.length) {
          throw new Error('No slides available to export.');
        }
        const { jsPDF } = jspdfNamespace;
        const pxToPt = 72 / 96;
        const firstSlide = slideImages[0];
        const firstOrientation = firstSlide.width >= firstSlide.height ? 'landscape' : 'portrait';
        const doc = new jsPDF({
          orientation: firstOrientation,
          unit: 'pt',
          format: [firstSlide.width * pxToPt, firstSlide.height * pxToPt]
        });
        doc.addImage(
          firstSlide.dataUrl,
          'PNG',
          0,
          0,
          firstSlide.width * pxToPt,
          firstSlide.height * pxToPt,
          undefined,
          'FAST'
        );
        for (let i = 1; i < slideImages.length; i += 1) {
          const slide = slideImages[i];
          const orientation = slide.width >= slide.height ? 'landscape' : 'portrait';
          doc.addPage([slide.width * pxToPt, slide.height * pxToPt], orientation);
          doc.addImage(
            slide.dataUrl,
            'PNG',
            0,
            0,
            slide.width * pxToPt,
            slide.height * pxToPt,
            undefined,
            'FAST'
          );
        }
        const pdfFileName = fileName ? getExportFileNameWithExtension(fileName, 'pdf') : getExportFileName('pdf');
        doc.save(pdfFileName);
      }

      async function waitForPptxGenJS(maxWait = 10000) {
        const startTime = Date.now();
        // Check if library is loaded - PptxGenJS can be global or on window
        const isLoaded = () => {
          // Check window.PptxGenJS (always safe)
          if (typeof window.PptxGenJS === 'function') {
            return true;
          }
          // Check if PptxGenJS exists in window (might be defined but not as function)
          if (window.PptxGenJS && typeof window.PptxGenJS === 'function') {
            return true;
          }
          // Check global scope using 'in' operator (safer than typeof for undefined vars)
          if ('PptxGenJS' in window && typeof window.PptxGenJS === 'function') {
            return true;
          }
          return false;
        };
        
        while (!isLoaded() && (Date.now() - startTime) < maxWait) {
          await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        // Final check
        if (!isLoaded()) {
          // Debug: log what's actually available
          const pptxKeys = Object.keys(window).filter(k => k.toLowerCase().includes('pptx') || k.toLowerCase().includes('ppt'));
          console.error('PptxGenJS not found after', maxWait, 'ms. Available PPTX-related globals:', pptxKeys);
          console.error('window.PptxGenJS type:', typeof window.PptxGenJS);
          throw new Error('PPTX export library failed to load. Please refresh the page and try again.');
        }
      }

      // Convert pixels to inches (assuming 96 DPI standard)
      function pixelsToInches(pixels) {
        return pixels / 96;
      }

      // Convert percentage/position to inches for 16:9 slide (10" x 5.625")
      function convertPositionToInches(value, isWidth = true, canvasWidth = 960, canvasHeight = 540) {
        const slideWidth = 10; // inches
        const slideHeight = 5.625; // inches
        if (typeof value === 'number') {
          // If it's a pixel value
          return pixelsToInches(value);
        } else if (typeof value === 'string' && value.includes('%')) {
          // If it's a percentage
          const percent = parseFloat(value) / 100;
          return isWidth ? slideWidth * percent : slideHeight * percent;
        }
        return value;
      }

      // Convert hex color to PowerPoint format
      function convertColor(color) {
        if (!color) return 'FFFFFF';
        
        // Handle hex colors
        if (color.startsWith('#')) {
          return color.substring(1).toUpperCase();
        }
        
        // Handle rgb/rgba colors (e.g., "rgb(255, 0, 0)" or "rgba(255, 0, 0, 0.5)")
        const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (rgbMatch) {
          const r = parseInt(rgbMatch[1], 10).toString(16).padStart(2, '0');
          const g = parseInt(rgbMatch[2], 10).toString(16).padStart(2, '0');
          const b = parseInt(rgbMatch[3], 10).toString(16).padStart(2, '0');
          return (r + g + b).toUpperCase();
        }
        
        // If it's already a 6-character hex without #, return uppercase
        if (/^[0-9A-Fa-f]{6}$/.test(color)) {
          return color.toUpperCase();
        }
        
        // Default fallback
        return 'FFFFFF';
      }

      async function exportSlidesToPptx(slideImages, fileName) {
        await waitForPptxGenJS();
        if (!slides || !slides.length) {
          throw new Error('No slides available to export.');
        }
        // Use PptxGenJS from window (after waitForPptxGenJS, it should be available)
        if (!window.PptxGenJS || typeof window.PptxGenJS !== 'function') {
          throw new Error('PptxGenJS is not available after waiting.');
        }
        
        // Save current slide content before exporting
        if (typeof capture === 'function') {
          capture();
        }
        
        const pptx = new window.PptxGenJS();
        pptx.layout = 'LAYOUT_16x9';
        
        // Get canvas dimensions for position conversion
        const canvas = document.getElementById('canvas');
        const canvasWidth = canvas ? canvas.offsetWidth : 960;
        const canvasHeight = canvas ? canvas.offsetHeight : 540;
        
        // Store original active slide index
        const originalActive = active;
        const titleBox = document.getElementById('titleBox');
        const textBox = document.getElementById('textBox');
        
        // Export each slide with individual elements
        for (let index = 0; index < slides.length; index++) {
          const slide = slides[index];
          const pptxSlide = pptx.addSlide();
          
          // Save current slide content before loading others
          if (index === 0 && typeof capture === 'function') {
            capture();
          }
          
          // Temporarily load this slide to get current text content
          const originalActive = active;
          active = index;
          if (typeof load === 'function') {
            load();
            // Wait a bit for DOM to update
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          
          // Re-query elements after load to get fresh references
          const currentTitleBox = document.getElementById('titleBox');
          const currentTextBox = document.getElementById('textBox');
          
          // Read text content - prefer DOM if available, otherwise use stored data
          let titleText = '';
          let contentText = '';
          let titleColor = '000000';
          let textColor = '000000';
          
          // Try to get from DOM first (most current)
          if (currentTitleBox && currentTitleBox.style.display !== 'none') {
            titleText = currentTitleBox.textContent || currentTitleBox.innerText || '';
            if (titleText) {
              const computedTitleColor = window.getComputedStyle(currentTitleBox).color;
              titleColor = convertColor(computedTitleColor);
            }
          }
          
          // Fallback to stored data if DOM is empty
          if (!titleText && slide.title) {
            titleText = slide.title;
          }
          
          // Try to get from DOM first (most current)
          if (currentTextBox && currentTextBox.style.display !== 'none') {
            contentText = currentTextBox.textContent || currentTextBox.innerText || '';
            if (contentText) {
              const computedTextColor = window.getComputedStyle(currentTextBox).color;
              textColor = convertColor(computedTextColor);
            }
          }
          
          // Fallback to stored data if DOM is empty
          if (!contentText && slide.content) {
            contentText = slide.content;
          }
          
          // Set background
          if (slide.background && slide.background.color) {
            pptxSlide.background = { color: convertColor(slide.background.color) };
          } else {
            pptxSlide.background = { color: 'FFFFFF' };
          }
          
          // Add title box if visible
          if (slide.titleBox && slide.titleBox.visible && titleText.trim()) {
            const titleTop = convertPositionToInches(slide.titleBox.top || 24, false, canvasWidth, canvasHeight);
            const titleLeft = convertPositionToInches(slide.titleBox.left || 24, true, canvasWidth, canvasHeight);
            const titleWidth = slide.titleBox.width ? convertPositionToInches(slide.titleBox.width, true, canvasWidth, canvasHeight) : 9.5;
            const titleHeight = slide.titleBox.height ? convertPositionToInches(slide.titleBox.height, false, canvasWidth, canvasHeight) : 0.8;
            
            pptxSlide.addText(titleText, {
              x: titleLeft,
              y: titleTop,
              w: titleWidth,
              h: titleHeight,
              fontSize: 36,
              bold: true,
              fontFace: slide.titleFontFamily || 'Arial',
              color: titleColor,
              align: 'left',
              valign: 'top'
            });
          }
          
          // Add main text box if visible
          if (slide.textBox && slide.textBox.visible && contentText.trim()) {
            const textTop = convertPositionToInches(slide.textBox.top || 100, false, canvasWidth, canvasHeight);
            const textLeft = convertPositionToInches(slide.textBox.left || 24, true, canvasWidth, canvasHeight);
            const textWidth = slide.textBox.width ? convertPositionToInches(slide.textBox.width, true, canvasWidth, canvasHeight) : 9.5;
            const textHeight = slide.textBox.height ? convertPositionToInches(slide.textBox.height, false, canvasWidth, canvasHeight) : 4;
            
            pptxSlide.addText(contentText, {
              x: textLeft,
              y: textTop,
              w: textWidth,
              h: textHeight,
              fontSize: 18,
              fontFace: slide.textFontFamily || 'Arial',
              color: textColor,
              align: 'left',
              valign: 'top'
            });
          }
          
          // Add additional text boxes
          if (slide.additionalTextBoxes && Array.isArray(slide.additionalTextBoxes)) {
            slide.additionalTextBoxes.forEach((textBox) => {
              if (textBox.visible && textBox.text) {
                const top = convertPositionToInches(textBox.top || 0, false, canvasWidth, canvasHeight);
                const left = convertPositionToInches(textBox.left || 0, true, canvasWidth, canvasHeight);
                const width = convertPositionToInches(textBox.width || 2, true, canvasWidth, canvasHeight);
                const height = convertPositionToInches(textBox.height || 0.5, false, canvasWidth, canvasHeight);
                
                pptxSlide.addText(textBox.text, {
                  x: left,
                  y: top,
                  w: width,
                  h: height,
                  fontSize: textBox.fontSize || 14,
                  fontFace: textBox.fontFamily || 'Arial',
                  color: convertColor(textBox.color || '000000'),
                  align: textBox.align || 'left',
                  valign: textBox.valign || 'top',
                  bold: textBox.bold || false,
                  italic: textBox.italic || false
                });
              }
            });
          }
          
          // Add images
          if (slide.images && Array.isArray(slide.images)) {
            slide.images.forEach((img) => {
              if (img.src) {
                const top = convertPositionToInches(img.top || 0, false, canvasWidth, canvasHeight);
                const left = convertPositionToInches(img.left || 0, true, canvasWidth, canvasHeight);
                const width = convertPositionToInches(img.width || 2, true, canvasWidth, canvasHeight);
                const height = convertPositionToInches(img.height || 1.5, false, canvasWidth, canvasHeight);
                
                try {
                  pptxSlide.addImage({
                    path: img.src,
                    x: left,
                    y: top,
                    w: width,
                    h: height
                  });
                } catch (e) {
                  // If path doesn't work, try data URL
                  if (img.dataUrl) {
                    pptxSlide.addImage({
                      data: img.dataUrl,
                      x: left,
                      y: top,
                      w: width,
                      h: height
                    });
                  }
                }
              }
            });
          }
          
          // Add shapes
          if (slide.shapes && Array.isArray(slide.shapes)) {
            slide.shapes.forEach((shape) => {
              const top = convertPositionToInches(shape.top || 0, false, canvasWidth, canvasHeight);
              const left = convertPositionToInches(shape.left || 0, true, canvasWidth, canvasHeight);
              const width = convertPositionToInches(shape.width || 1, true, canvasWidth, canvasHeight);
              const height = convertPositionToInches(shape.height || 1, false, canvasWidth, canvasHeight);
              
              // Get shape color - check shape.color first, then try to get from DOM element
              let shapeFillColor = shape.color || '#D3D3D3';
              let shapeStrokeColor = shape.strokeColor || shape.borderColor || '#000000';
              
              // Try to get color from DOM element if this is the current slide
              if (index === active) {
                const shapeElement = document.querySelector(`[data-element-id="${shape.id}"]`);
                if (shapeElement) {
                  const computedColor = window.getComputedStyle(shapeElement).color;
                  if (computedColor && computedColor !== 'rgba(0, 0, 0, 0)') {
                    shapeFillColor = computedColor;
                  }
                  // Also check dataset
                  if (shapeElement.dataset.color) {
                    shapeFillColor = shapeElement.dataset.color;
                  }
                }
              }
              
              const shapeOptions = {
                x: left,
                y: top,
                w: width,
                h: height,
                fill: { color: convertColor(shapeFillColor) },
                line: { color: convertColor(shapeStrokeColor), width: shape.strokeWidth || 1 }
              };
              
              // Map shape types to PptxGenJS shapes
              const shapeTypeMap = {
                'rectangle': 'rect',
                'circle': 'ellipse',
                'ellipse': 'ellipse',
                'triangle': 'triangle',
                'line': 'line',
                'arrow': 'line'
              };
              
              const pptxShapeType = shapeTypeMap[shape.type] || 'rect';
              // PptxGenJS shape API - try different API formats
              try {
                let shapeType;
                if (pptxShapeType === 'ellipse') {
                  shapeType = (pptx.ShapeType && pptx.ShapeType.oval) || (pptx.shapes && pptx.shapes.OVAL) || 'ellipse';
                } else if (pptxShapeType === 'triangle') {
                  shapeType = (pptx.ShapeType && pptx.ShapeType.triangle) || (pptx.shapes && pptx.shapes.TRIANGLE) || 'triangle';
                } else if (pptxShapeType === 'line') {
                  shapeType = (pptx.ShapeType && pptx.ShapeType.line) || (pptx.shapes && pptx.shapes.LINE) || 'line';
                } else {
                  shapeType = (pptx.ShapeType && pptx.ShapeType.rect) || (pptx.shapes && pptx.shapes.RECTANGLE) || 'rect';
                }
                pptxSlide.addShape(shapeType, shapeOptions);
              } catch (e) {
                // Fallback: try with string name directly
                try {
                  pptxSlide.addShape(pptxShapeType, shapeOptions);
                } catch (e2) {
                  console.warn('Could not export shape:', shape.type, e2);
                }
              }
            });
          }
          
          // Add tables
          if (slide.tables && Array.isArray(slide.tables)) {
            slide.tables.forEach((table) => {
              if (table.rows && table.rows.length > 0) {
                const top = convertPositionToInches(table.top || 0, false, canvasWidth, canvasHeight);
                const left = convertPositionToInches(table.left || 0, true, canvasWidth, canvasHeight);
                const width = convertPositionToInches(table.width || 4, true, canvasWidth, canvasHeight);
                
                const tableData = table.rows.map(row => 
                  row.cells ? row.cells.map(cell => cell.text || '') : []
                );
                
                pptxSlide.addTable(tableData, {
                  x: left,
                  y: top,
                  w: width,
                  colW: table.colWidths || [],
                  border: { type: 'solid', color: '000000', pt: 1 }
                });
              }
            });
          }
        }
        
        // Restore original active slide
        active = originalActive;
        if (typeof load === 'function') {
          load();
        }
        
        const pptxFileName = fileName ? getExportFileNameWithExtension(fileName, 'pptx') : getExportFileName('pptx');
        await pptx.writeFile({ fileName: pptxFileName });
      }

      function sanitizeFileName(fileName) {
        // Remove invalid characters and sanitize filename
        return fileName
          .replace(/[^\w\s-]/g, '')
          .trim()
          .replace(/\s+/g, '_')
          .substring(0, 100); // Limit length
      }

      function getExportFileNameWithExtension(baseName, extension) {
        const sanitized = sanitizeFileName(baseName);
        return `${sanitized}.${extension}`;
      }

      async function exportSlidesToPng(fileName) {
        if (typeof window.html2canvas !== 'function') {
          throw new Error('Image export tools are not available.');
        }
        
        // Sanitize the filename
        const sanitizedFileName = sanitizeFileName(fileName || 'presentation');
        
        const slideImages = await captureSlidesAsImages();
        
        if (!slideImages || slideImages.length === 0) {
          throw new Error('No slides to export.');
        }
        
        // Download each PNG file directly
        slideImages.forEach((slide, index) => {
          if (!slide || !slide.dataUrl) {
            console.warn(`Slide ${index + 1} has no image data, skipping.`);
            return;
          }
          
          const slideNumber = String(index + 1).padStart(2, '0');
          const slideFileName = `${sanitizedFileName}_slide_${slideNumber}.png`;
          
          // Convert data URL to blob
          const dataUrlParts = slide.dataUrl.split(',');
          if (dataUrlParts.length !== 2) {
            console.warn(`Slide ${index + 1} has invalid data URL format, skipping.`);
            return;
          }
          
          // Convert base64 to blob
          const byteCharacters = atob(dataUrlParts[1]);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: 'image/png' });
          
          // Create download link and trigger download
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = slideFileName;
          document.body.appendChild(a);
          
          // Add small delay between downloads to avoid browser blocking multiple downloads
          setTimeout(() => {
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, index * 100); // 100ms delay between each download
        });
      }

      function exportSlidesToJson(fileName) {
        const payload = {
          generatedAt: new Date().toISOString(),
          fileName: fileName,
          slides: slides.map(slide => ({
            id: slide.id,
            title: slide.title,
            content: slide.content,
            background: slide.background,
            titleBox: slide.titleBox,
            textBox: slide.textBox,
            titleFontFamily: slide.titleFontFamily,
            textFontFamily: slide.textFontFamily,
            shapes: slide.shapes,
            charts: slide.charts,
            images: slide.images,
            videos: slide.videos,
            tables: slide.tables,
            additionalTextBoxes: slide.additionalTextBoxes,
            comments: Array.isArray(slide.comments) ? JSON.parse(JSON.stringify(slide.comments)) : [],
            animations: slide.animations,
            transition: slide.transition,
            transitionDuration: slide.transitionDuration
          }))
        };
        const jsonString = JSON.stringify(payload, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = getExportFileNameWithExtension(fileName, 'json');
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function exportSlidesToHtml(fileName) {
        // Capture current state
        capture();
        const originalActiveIndex = active;
        
        // Collect all CSS styles from the document
        const collectStyles = () => {
          let styles = '';
          // Get all stylesheets
          for (let i = 0; i < document.styleSheets.length; i++) {
            try {
              const sheet = document.styleSheets[i];
              if (sheet.href && sheet.href.startsWith('http')) {
                // External stylesheet - include as link
                continue;
              }
              // Try to get rules
              try {
                const rules = sheet.cssRules || sheet.rules;
                if (rules) {
                  for (let j = 0; j < rules.length; j++) {
                    styles += rules[j].cssText + '\n';
                  }
                }
              } catch (e) {
                // Cross-origin or other issue, skip
              }
            } catch (e) {
              // Skip this stylesheet
            }
          }
          return styles;
        };
        
        // Generate a standalone HTML document with all slides
        let htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${fileName}</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 20px;
      background: #0f172a;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }
    .slide-container {
      max-width: 1200px;
      margin: 0 auto 40px;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    .slide-header {
      background: #0f172a;
      color: white;
      padding: 16px 24px;
      font-weight: 700;
      font-size: 18px;
      border-bottom: 2px solid #22c55e;
    }
    .slide-content {
      position: relative;
      width: 100%;
      min-height: 600px;
      background: white;
    }
    .slide-canvas {
      width: 100%;
      height: auto;
      position: relative;
      background: white;
    }
    /* Include essential canvas and element styles */
    .canvas {
      position: relative;
      width: 100%;
      height: 100%;
      background: white;
    }
    .text-box, .title-box, .additional-text-box {
      position: absolute;
      padding: 10px;
      outline: none;
      color: #000000;
    }
    .title-box {
      font-size: 28px;
      font-weight: bold;
    }
    .text-box {
      font-size: 16px;
    }
    .shape-element, .chart-element, .image-element, .video-element, .table-element {
      position: absolute;
    }
    img {
      max-width: 100%;
      height: auto;
    }
    video {
      max-width: 100%;
      height: auto;
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    td, th {
      border: 1px solid #ddd;
      padding: 8px;
    }
  </style>
</head>
<body>
  <h1 style="color: white; text-align: center; margin-bottom: 40px;">${fileName}</h1>
`;

        // Export each slide with its full content
        slides.forEach((slide, index) => {
          // Load the slide
          active = index;
          load();
          
          // Wait a moment for DOM to update
          // Clone the canvas and prepare it for export
          const slideClone = canvas.cloneNode(true);
          prepareCanvasForPresentation(slideClone);
          
          // Get the canvas background color
          const canvasBg = getCanvasBackgroundColor();
          slideClone.style.background = canvasBg;
          slideClone.style.width = '100%';
          slideClone.style.height = 'auto';
          slideClone.style.minHeight = '600px';
          
          // Preserve inline styles for all elements in the clone
          const preserveElementStyles = (element) => {
            if (!element || !element.nodeType || element.nodeType !== 1) return;
            
            // Get computed styles and apply as inline styles
            const computed = window.getComputedStyle(element);
            const existingStyle = element.getAttribute('style') || '';
            
            // List of important CSS properties to preserve
            const importantStyles = [
              'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 
              'transform', 'font-size', 'font-family', 'font-weight', 'color', 
              'background-color', 'border', 'border-radius', 'padding', 'margin', 
              'z-index', 'display', 'flex-direction', 'align-items', 'justify-content',
              'text-align', 'white-space', 'word-wrap', 'overflow', 'opacity',
              'box-shadow', 'border-color', 'border-width', 'border-style'
            ];
            
            let newStyles = existingStyle;
            
            importantStyles.forEach(prop => {
              const value = computed.getPropertyValue(prop);
              if (value && value !== 'none' && value !== 'auto' && value !== 'normal') {
                // Check if this property is already in the style attribute
                const propRegex = new RegExp(`${prop.replace(/-/g, '\\-')}\\s*:`, 'i');
                if (!propRegex.test(existingStyle)) {
                  newStyles += `${prop}: ${value}; `;
                }
              }
            });
            
            if (newStyles.trim() && newStyles !== existingStyle) {
              element.setAttribute('style', newStyles.trim());
            }
            
            // Recursively process children
            Array.from(element.children).forEach(child => {
              preserveElementStyles(child);
            });
          };
          
          // Preserve styles for all elements in the clone
          preserveElementStyles(slideClone);
          
          // Get the HTML content of the cloned canvas
          const slideHtml = slideClone.innerHTML;
          
          htmlContent += `
  <div class="slide-container">
    <div class="slide-header">Slide ${index + 1}: ${(slide.title || 'Untitled').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
    <div class="slide-content">
      <div class="slide-canvas" style="background: ${canvasBg}; width: 100%; position: relative; min-height: 600px;">
        ${slideHtml}
      </div>
    </div>
  </div>
`;
        });
        
        // Restore original active slide
        active = originalActiveIndex;
        load();

        htmlContent += `
</body>
</html>`;

        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = getExportFileNameWithExtension(fileName, 'html');
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      async function handleSaveAsExport(format, fileName) {
        if (!format || !fileName || isExportingPresentation) return;
        const validFormats = ['pdf', 'pptx', 'png', 'json', 'html'];
        if (!validFormats.includes(format)) {
          alert('Invalid file format selected.');
          return;
        }
        
        // Check for required libraries based on format
        if ((format === 'pdf' || format === 'pptx' || format === 'png') && typeof window.html2canvas !== 'function') {
          alert('Export tools are still loading. Please try again in a moment.');
          return;
        }
        if (format === 'pdf' && (!window.jspdf || typeof window.jspdf.jsPDF !== 'function')) {
          alert('PDF export tools are still loading. Please try again in a moment.');
          return;
        }
        // Wait for PPTX library to load if needed
        if (format === 'pptx') {
          try {
            await waitForPptxGenJS();
          } catch (error) {
            alert('PPTX export tools failed to load. Please refresh the page and try again.');
          return;
          }
        }
        // PNG export no longer requires JSZip - it downloads files directly

        isExportingPresentation = true;
        const previousCursor = document.body.style.cursor;
        document.body.style.cursor = 'wait';
        try {
          // Save current slide data before exporting to ensure latest content is captured
          if (typeof capture === 'function') {
            capture();
          }
          
          if (format === 'pdf') {
            const slideImages = await captureSlidesAsImages();
            await exportSlidesToPdf(slideImages, fileName);
            showNotification('Exported presentation as PDF');
          } else if (format === 'pptx') {
            // Export with individual editable elements (no need to capture images)
            await exportSlidesToPptx(null, fileName);
            showNotification('Exported presentation as PPTX');
          } else if (format === 'png') {
            await exportSlidesToPng(fileName);
            showNotification('Exported slides as PNG images');
          } else if (format === 'json') {
            exportSlidesToJson(fileName);
            showNotification('Exported presentation as JSON');
          } else if (format === 'html') {
            exportSlidesToHtml(fileName);
            showNotification('Exported presentation as HTML');
          }
        } catch (error) {
          console.error('Export failed:', error);
          alert(`Unable to export the presentation: ${error.message || 'Please try again.'}`);
        } finally {
          document.body.style.cursor = previousCursor || '';
          isExportingPresentation = false;
        }
      }

      function updatePresentationCounter() {
        if (presentationCounterEl) {
          presentationCounterEl.textContent = `${presentationIndex + 1} / ${slides.length}`;
        }
      }

      function resetPresentationAnimations() {
        currentAnimationQueue = [];
        currentAnimationStep = 0;
      }

      function setupPresentationAnimations(clone, slide) {
        resetPresentationAnimations();
        if (!clone || !slide) return;
        const animations = sortSlideAnimations(slide).filter(anim => anim && anim.targetId);
        animations.forEach((anim) => {
          const target = clone.querySelector(`[data-element-id="${escapeSelector(anim.targetId)}"]`);
          if (!target) return;
          const duration = clampAnimationDuration(anim.duration ?? DEFAULT_ANIMATION_DURATION);
          const effect = normalizeAnimationEffect(anim.effect);
          const computed = window.getComputedStyle(target);
          const baseTransform = computed.transform && computed.transform !== 'none'
            ? computed.transform
            : 'none';
          target.style.setProperty('--animation-base-transform', baseTransform);
          target.style.setProperty('--animation-duration', `${duration}s`);
          ANIMATION_EFFECT_CLASS_NAMES.forEach(cls => target.classList.remove(cls));
          target.classList.add('presentation-animation-hidden');
          currentAnimationQueue.push({
            element: target,
            effect,
            duration
          });
        });
      }

      function triggerPresentationAnimation(entry) {
        if (!entry || !entry.element) return;
        const { element, effect, duration } = entry;
        element.classList.remove('presentation-animation-hidden');
        ANIMATION_EFFECT_CLASS_NAMES.forEach(cls => element.classList.remove(cls));
        element.style.setProperty('--animation-duration', `${duration}s`);
        element.classList.add(`presentation-animation-effect-${effect}`);
      }

      function playNextSlideAnimation() {
        if (!currentAnimationQueue.length || currentAnimationStep >= currentAnimationQueue.length) {
          return false;
        }
        const entry = currentAnimationQueue[currentAnimationStep];
        currentAnimationStep += 1;
        triggerPresentationAnimation(entry);
        return true;
      }

      function showPresentationSlide(index) {
        if (index < 0 || index >= slides.length) return;
        presentationIndex = index;
        const clone = cloneCanvasForPresentation(index);
        if (presentationStage) {
          presentationStage.innerHTML = '';
          presentationStage.appendChild(clone);
          clone.querySelectorAll('video').forEach((videoEl) => {
            videoEl.controls = true;
            videoEl.addEventListener('click', (event) => {
              event.stopPropagation();
              if (videoEl.paused) {
                videoEl.play().catch(() => {});
              } else {
                videoEl.pause();
              }
            });
          });
          const config = getSlideTransitionConfig(slides[index]);
          applySlideTransitionClass(clone, config.effect, config.duration);
          setupPresentationAnimations(clone, slides[index]);
        }
        updatePresentationCounter();
      }

      function hidePresentationControls(lock = false) {
        if (!isPresenting) return;
        presentationOverlay.classList.remove('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (lock) {
          presentationControlsLocked = true;
        }
      }

      function showPresentationControls(autoHide = true) {
        if (!isPresenting || presentationControlsLocked) return;
        presentationOverlay.classList.add('show-controls');
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
        }
        if (autoHide) {
          presentationControlsTimeout = setTimeout(() => {
            presentationControlsTimeout = null;
            hidePresentationControls(true);
          }, PRESENTATION_CONTROLS_AUTOHIDE_DELAY);
        } else {
          presentationControlsTimeout = null;
        }
      }

      function startPresentation() {
        if (isPresenting) return;
        stopTranslation({ message: null });
        stopSubtitles({ message: null });
        capture();
        presentationReturnIndex = active;
        isPresenting = true;
        presentationOverlay.classList.add('visible');
        showPresentationSlide(active);
        document.body.classList.add('presenting');
        presentationControlsLocked = false;
        showPresentationControls(true);
        requestAnimationFrame(() => {
          try {
            presentationOverlay.focus({ preventScroll: true });
          } catch (err) {
            presentationOverlay.focus();
          }
          if (presentationOverlay.requestFullscreen) {
            presentationOverlay.requestFullscreen().catch(() => {});
          }
        });
      }

      function exitPresentation(fromFullscreenChange = false) {
        if (!isPresenting) return;
        stopTranslation({ message: null });
        stopSubtitles({ message: null });
        isPresenting = false;
        resetPresentationAnimations();
        presentationOverlay.classList.remove('visible');
        presentationOverlay.classList.remove('show-controls');
        document.body.classList.remove('presenting');
        presentationControlsLocked = false;
        if (presentationControlsTimeout) {
          clearTimeout(presentationControlsTimeout);
          presentationControlsTimeout = null;
        }
        if (presentationStage) {
          presentationStage.innerHTML = '';
        }
        active = presentationReturnIndex;
        load();
        renderSidebar();
        if (!fromFullscreenChange && document.fullscreenElement && document.exitFullscreen) {
          document.exitFullscreen().catch(() => {});
        }
      }

      function goToNextSlide() {
        if (isPresenting && playNextSlideAnimation()) {
          return;
        }
        if (presentationIndex < slides.length - 1) {
          showPresentationSlide(presentationIndex + 1);
        }
      }

      function goToPreviousSlide() {
        if (presentationIndex > 0) {
          showPresentationSlide(presentationIndex - 1);
        }
      }

      function hideTransitionPreview() {
        if (transitionPreviewTimeout) {
          clearTimeout(transitionPreviewTimeout);
          transitionPreviewTimeout = null;
        }
        transitionPreviewOverlay.classList.remove('show');
        if (transitionPreviewStage) {
          transitionPreviewStage.innerHTML = '';
        }
      }

      function showTransitionPreview(effect, duration) {
        if (!transitionPreviewOverlay || !transitionPreviewStage) return;
        if (isPresenting) {
          showPresentationSlide(presentationIndex);
          return;
        }
        const normalizedEffect = normalizeTransitionEffect(effect);
        const normalizedDuration = clampTransitionDuration(duration);
        const previewClone = cloneCanvasForPresentation(active, { force: true, restoreActiveIndex: active });
        transitionPreviewStage.innerHTML = '';
        transitionPreviewStage.appendChild(previewClone);
        if (normalizedEffect === DEFAULT_TRANSITION) {
          previewClone.classList.remove(...TRANSITION_CLASS_NAMES);
          previewClone.style.removeProperty('--transition-duration');
        }
        transitionPreviewOverlay.classList.add('show');
        const totalDurationMs = (normalizedEffect === DEFAULT_TRANSITION
          ? 1200
          : Math.min(normalizedDuration + 0.6, TRANSITION_DURATION_MAX + 0.6) * 1000);
        if (transitionPreviewTimeout) {
          clearTimeout(transitionPreviewTimeout);
        }
        transitionPreviewTimeout = window.setTimeout(() => {
          hideTransitionPreview();
        }, totalDurationMs);
      }

      transitionPreviewOverlay.addEventListener('click', (event) => {
        if (event.target === transitionPreviewOverlay) {
          hideTransitionPreview();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && transitionPreviewOverlay.classList.contains('show') && !isPresenting) {
          hideTransitionPreview();
        }
      });

      presentationOverlay.addEventListener('click', (event) => {
        if (!isPresenting) return;
        if (event.target.closest('.presentation-meta') || event.target.closest('.presentation-counter')) return;
        const stageRect = presentationStage ? presentationStage.getBoundingClientRect() : presentationOverlay.getBoundingClientRect();
        if (!stageRect || stageRect.width === 0) return;
        if (event.clientX > stageRect.left + stageRect.width / 2) {
          goToNextSlide();
        } else {
          goToPreviousSlide();
        }
      });

      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && isPresenting) {
          exitPresentation(true);
        }
      });


      shapeColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      shapeColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        shapeColorInput.click();
      });

      function updateShapeColorButtonAppearance(color) {
        shapeColorButton.style.background = color;
        const shadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
        shapeColorButton.style.boxShadow = shadow;
        const hex = color.replace('#', '');
        const bigint = parseInt(hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        shapeColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
      }

      const SHAPE_PICKER_MARGIN = 12;

      function positionShapeColorPicker(element) {
        if (!element || !shapeColorPicker.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const pickerRect = shapeColorPicker.getBoundingClientRect();
        let top = rect.top - pickerRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - pickerRect.width / 2;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }

        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }

        shapeColorPicker.style.top = `${top}px`;
        shapeColorPicker.style.left = `${left}px`;
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
      }

      function showShapeColorPicker(element) {
        if (!element) return;
        const color = normalizeColorHex(element.dataset.color || window.getComputedStyle(element).color || '#e8f5e9');
        shapeColorInput.value = color;
        updateShapeColorButtonAppearance(color);
        shapeColorPicker.classList.add('visible');
        positionShapeColorPicker(element);
        showRotationHandle(element);
      }

      function clearIconSelection() {
        if (selectedIcon) {
          const removedId = selectedIcon.dataset.elementId;
          selectedIcon.classList.remove('selected');
          selectedIcon = null;
          hideShapeColorPicker();
          hideShapeSizeBadge();
          hideRotationHandle();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
      }

      function selectIcon(element) {
        if (!element || !element.classList.contains('icon-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        clearShapeSelection();
        if (selectedIcon && selectedIcon !== element) {
          selectedIcon.classList.remove('selected');
        }
        selectedIcon = element;
        element.classList.add('selected');
        createResizeEdges(element);
        showShapeColorPicker(element);
        showRotationHandle(element);
        updateShapeSizeBadge(element, element.offsetWidth, element.offsetHeight);
        showShapeSizeBadge();
        handleAnimationSelectionChange(element);

        setTimeout(() => {
          document.addEventListener('click', function iconDeselectHandler(e) {
            if (!element.contains(e.target)) {
              if (selectedIcon === element) {
                clearIconSelection();
              }
              document.removeEventListener('click', iconDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function hideShapeColorPicker() {
        shapeColorPicker.classList.remove('visible');
        hideRotationHandle();
      }

      shapeColorInput.addEventListener('change', (event) => {
        if (selectedShape) {
          const color = normalizeColorHex(event.target.value);
          selectedShape.dataset.color = color;
          selectedShape.style.color = color;
          updateShapeColorButtonAppearance(color);
          positionShapeColorPicker(selectedShape);
          if (rotationTarget === selectedShape) {
            positionRotationHandle(selectedShape);
          }
          capture();
          saveEditorState('change_shape_color');
        } else if (selectedIcon) {
          const color = normalizeColorHex(event.target.value);
          selectedIcon.dataset.color = color;
          selectedIcon.style.color = color;
          updateShapeColorButtonAppearance(color);
          positionShapeColorPicker(selectedIcon);
          if (rotationTarget === selectedIcon) {
            positionRotationHandle(selectedIcon);
          }
          capture();
          saveEditorState('change_icon_color');
        }
      });

      const shapeRotationHandle = document.createElement('div');
      shapeRotationHandle.id = 'shapeRotationHandle';
      shapeRotationHandle.className = 'shape-rotation-handle';
      shapeRotationHandle.innerHTML = `
        <button type="button" class="shape-rotation-button" title="Rotate Shape">
          <i class="fas fa-sync-alt"></i>
        </button>
        <span class="shape-rotation-angle">0Â°</span>
      `;
      document.body.appendChild(shapeRotationHandle);
      const shapeRotationButton = shapeRotationHandle.querySelector('.shape-rotation-button');
      const shapeRotationAngle = shapeRotationHandle.querySelector('.shape-rotation-angle');

      let tableColumnColorPickerBusy = false;

      tableColumnColorPicker.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      tableColumnColorButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        tableColumnColorPickerBusy = true;
        tableColumnColorInput.click();
      });

      function handleTableColumnColorInputEvent(event, final = false) {
        if (!tableColumnColorTarget || tableColumnColorIndex == null) return;
        const color = normalizeColorHex(event.target.value);
        updateTableColumnColorButtonAppearance(color);
        applyColorToTableColumn(tableColumnColorTarget, tableColumnColorIndex, color, final);
        positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        tableColumnColorPickerBusy = false;
      }

      tableColumnColorInput.addEventListener('input', (event) => {
        handleTableColumnColorInputEvent(event, false);
      });

      tableColumnColorInput.addEventListener('change', (event) => {
        handleTableColumnColorInputEvent(event, true);
      });

      tableColumnColorInput.addEventListener('focus', () => {
        tableColumnColorPickerBusy = true;
      });

      tableColumnColorInput.addEventListener('blur', () => {
        tableColumnColorPickerBusy = false;
      });

      tableColumnColorPicker.addEventListener('mouseenter', () => {
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
          tableColumnHideTimeout = null;
        }
      });

      tableColumnColorPicker.addEventListener('mouseleave', () => {
        if (tableColumnColorPickerBusy) return;
        hideTableColumnColorPicker();
      });

      let rotationTarget = null;
      let isRotatingTarget = false;
      let rotationStartAngle = 0;
      let rotationInitial = 0;
      let rotationCenter = { x: 0, y: 0 };
      let activeResizeShape = null;
      let shapeResizeAnimating = false;

      function updateRotationAngleLabel(element, angleOverride) {
        if (!element || !shapeRotationAngle) return;
        const angle = angleOverride !== undefined ? angleOverride : (parseFloat(element.dataset.rotation || '0') || 0);
        shapeRotationAngle.textContent = `${Math.round(angle)}Â°`;
      }

      function positionRotationHandle(element) {
        if (!element || !shapeRotationHandle.classList.contains('visible')) return;
        const rect = element.getBoundingClientRect();
        const handleRect = shapeRotationHandle.getBoundingClientRect();
        const colorRect = shapeColorPicker.getBoundingClientRect();
        const horizontalOffset = shapeColorPicker.classList.contains('visible')
          ? (colorRect.width / 2 + 28)
          : 70;
        let top = rect.top - handleRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 + horizontalOffset;

        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + handleRect.width > window.innerWidth - 16) {
          left = window.innerWidth - handleRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + handleRect.height > window.innerHeight - 16) {
          top = window.innerHeight - handleRect.height - 16;
        }

        shapeRotationHandle.style.top = `${top}px`;
        shapeRotationHandle.style.left = `${left}px`;
      }

      function showRotationHandle(element) {
        if (!element) return;
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        const currentRotation = parseFloat(element.dataset.rotation || '0') || 0;
        element.style.transform = `rotate(${currentRotation}deg)`;
        rotationTarget = element;
        updateRotationAngleLabel(element);
        positionRotationHandle(element);
        shapeRotationHandle.classList.add('visible');
      }

      function hideRotationHandle() {
        shapeRotationHandle.classList.remove('visible');
        endRotation(false);
        rotationTarget = null;
      }

      function endRotation(save = true) {
        if (!isRotatingTarget) return;
        isRotatingTarget = false;
        shapeRotationButton.classList.remove('active');
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleRotationMove);
        document.removeEventListener('mouseup', handleRotationUp);
        if (save && rotationTarget) {
          updateRotationAngleLabel(rotationTarget);
          positionRotationHandle(rotationTarget);
          capture();
          saveEditorState('rotate_shape');
        }
      }

      function handleRotationMove(event) {
        if (!isRotatingTarget || !rotationTarget) return;
        const current = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        let delta = (current - rotationStartAngle) * (180 / Math.PI);
        let newRotation = rotationInitial + delta;
        newRotation = ((newRotation % 360) + 360) % 360;
        rotationTarget.dataset.rotation = String(newRotation);
        rotationTarget.style.transform = `rotate(${newRotation}deg)`;
        updateRotationAngleLabel(rotationTarget, newRotation);
        if (rotationTarget.classList.contains('shape-element')) {
          positionShapeColorPicker(rotationTarget);
        }
        positionRotationHandle(rotationTarget);
      }

      function handleRotationUp() {
        endRotation(true);
      }

      shapeRotationButton.addEventListener('mousedown', (event) => {
        if (!rotationTarget) return;
        event.preventDefault();
        event.stopPropagation();
        const rect = rotationTarget.getBoundingClientRect();
        rotationCenter = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        rotationStartAngle = Math.atan2(event.clientY - rotationCenter.y, event.clientX - rotationCenter.x);
        rotationInitial = parseFloat(rotationTarget.dataset.rotation || '0') || 0;
        isRotatingTarget = true;
        shapeRotationButton.classList.add('active');
        document.body.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleRotationMove);
        document.addEventListener('mouseup', handleRotationUp);
      });

      shapeRotationHandle.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      function updateShapeSizeBadge(element, width, height) {
        if (!element) return;
        shapeSizeBadge.textContent = `${Math.round(width)} Ã— ${Math.round(height)} px`;
        const rect = element.getBoundingClientRect();
        const badgeRect = shapeSizeBadge.getBoundingClientRect();
        let top = rect.top - badgeRect.height - SHAPE_PICKER_MARGIN;
        let left = rect.left + rect.width / 2 - badgeRect.width / 2;
        if (top < 16) {
          top = rect.bottom + SHAPE_PICKER_MARGIN;
        }
        if (left + badgeRect.width > window.innerWidth - 16) {
          left = window.innerWidth - badgeRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        shapeSizeBadge.style.top = `${top}px`;
        shapeSizeBadge.style.left = `${left}px`;
      }

      function showShapeSizeBadge() {
        if (!shapeSizeBadge.classList.contains('visible')) {
          shapeSizeBadge.classList.add('visible');
        }
      }

      function hideShapeSizeBadge() {
        shapeSizeBadge.classList.remove('visible');
      }

      let isFontDropdownVisible = false;

      function setActiveFontOption(fontFamily) {
        const normalized = normalizeFontStack(fontFamily);
        fontOptionButtons.forEach((button, key) => {
          const isActive = key === normalized;
          button.classList.toggle('active', isActive);
          if (isActive) {
            button.scrollIntoView({ block: 'nearest' });
          }
        });
      }

      function extractPrimaryFontName(fontFamily) {
        if (!fontFamily) return 'Inter';
        const primary = fontFamily.split(',')[0].replace(/['"]/g, '').trim();
        if (!primary) return 'Inter';
        return primary;
      }

      function positionFontDropdown() {
        if (!fontPickerButton) return;
        const rect = fontPickerButton.getBoundingClientRect();
        fontDropdown.style.top = '0px';
        fontDropdown.style.left = '0px';
        fontDropdown.classList.add('show');
        const dropdownRect = fontDropdown.getBoundingClientRect();
        let top = rect.bottom + 8;
        let left = rect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = rect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(rect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        fontDropdown.style.top = `${Math.max(16, top)}px`;
        fontDropdown.style.left = `${left}px`;
      }

      function showFontDropdown() {
        if (!fontPickerButton) return;
        const currentFont = getCurrentFontFamily(currentActiveElement);
        setActiveFontOption(currentFont);
        fontDropdown.classList.add('show');
        positionFontDropdown();
        isFontDropdownVisible = true;
        fontPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideFontDropdown() {
        fontDropdown.classList.remove('show');
        isFontDropdownVisible = false;
        if (fontPickerButton) {
          fontPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleFontDropdown() {
        if (isFontDropdownVisible) {
          hideFontDropdown();
        } else {
          showFontDropdown();
        }
      }

      if (fontPickerButton) {
        fontPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleFontDropdown();
        });
      }

      document.addEventListener('click', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target) || (fontPickerButton && fontPickerButton.contains(event.target))) {
          return;
        }
        hideFontDropdown();
      });

      window.addEventListener('resize', () => {
        if (isFontDropdownVisible) {
          positionFontDropdown();
        }
      });

      window.addEventListener('scroll', (event) => {
        if (!isFontDropdownVisible) return;
        if (fontDropdown.contains(event.target)) {
          return;
        }
        hideFontDropdown();
      }, true);

      let isShapeDropdownVisible = false;
      let isChartDropdownVisible = false;
      let isLogoDropdownVisible = false;
      let selectedShape = null;
      let selectedChart = null;
      let selectedImage = null;
      let selectedVideo = null;
      let selectedTable = null;
      let selectedIcon = null;
      let currentAnimationSelectedElementId = null;
      let lastCanvasInsertPosition = null;
      const TABLE_MIN_COLUMN_WIDTH = 48;
      const TABLE_MIN_ROW_HEIGHT = 28;
      const tableResizeObservers = new WeakMap();
      const tableMutationObservers = new WeakMap();
      const tableColumnHoverHandlers = new WeakMap();
      let activeTableResize = null;
      let isTablePanelVisible = false;
      let tableColumnColorTarget = null;
      let tableColumnColorIndex = null;
      let tableColumnHideTimeout = null;
      const GROUP_SELECTABLE_SELECTOR = '.shape-element, .chart-element, .image-element, .video-element, .table-element, .icon-element, .additional-text-box, #titleBox, #textBox';
      const MARQUEE_MIN_SIZE = 4;
      const groupSelectionState = {
        elements: [],
        frame: null,
        handles: [],
        metrics: [],
        dragState: null,
        resizeState: null
      };
      let marqueeState = null;

      function clearGroupSelection() {
        if (groupSelectionState.elements.length) {
          groupSelectionState.elements.forEach((element) => {
            element.classList.remove('group-selected');
          });
        }
        groupSelectionState.elements = [];
        groupSelectionState.metrics = [];
        groupSelectionState.dragState = null;
        groupSelectionState.resizeState = null;
        groupSelectionState.bounds = null;
        groupSelectionState.pendingBounds = null;
        groupSelectionState.minGroupWidth = 0;
        groupSelectionState.minGroupHeight = 0;
        if (groupSelectionState.frame && groupSelectionState.frame.parentElement) {
          groupSelectionState.frame.remove();
        }
        groupSelectionState.frame = null;
        groupSelectionState.handles = [];
        updateElementContextMenuState();
      }

      function clearAllSingleSelections() {
        clearShapeSelection();
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        clearIconSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
      }

      function collectGroupSelectableElements() {
        if (!canvas) return [];
        return Array.from(canvas.querySelectorAll(GROUP_SELECTABLE_SELECTOR))
          .filter((element) => element !== canvas && element.offsetParent !== null && element.style.display !== 'none');
      }

      function getElementCanvasBounds(element) {
        const rect = element.getBoundingClientRect();
        const topLeft = getCanvasPointFromClient(rect.left, rect.top);
        const bottomRight = getCanvasPointFromClient(rect.right, rect.bottom);
        return {
          left: Math.min(topLeft.x, bottomRight.x),
          top: Math.min(topLeft.y, bottomRight.y),
          right: Math.max(topLeft.x, bottomRight.x),
          bottom: Math.max(topLeft.y, bottomRight.y),
          width: Math.abs(bottomRight.x - topLeft.x),
          height: Math.abs(bottomRight.y - topLeft.y)
        };
      }

      function selectElementByType(element) {
        if (!element) return;
        if (element.classList.contains('shape-element')) {
          selectShape(element);
          return;
        }
        if (element.classList.contains('chart-element')) {
          selectChart(element);
          return;
        }
        if (element.classList.contains('image-element')) {
          selectImage(element);
          return;
        }
        if (element.classList.contains('video-element')) {
          selectVideo(element);
          return;
        }
        if (element.classList.contains('table-element')) {
          selectTableElement(element);
          return;
        }
        if (element.classList.contains('icon-element')) {
          selectIcon(element);
          return;
        }
        if (element.classList.contains('additional-text-box') || element.id === 'titleBox' || element.id === 'textBox') {
          selectTextBox(element);
        }
      }

      function ensureGroupSelectionFrame() {
        if (groupSelectionState.frame && groupSelectionState.frame.parentElement) {
          return groupSelectionState.frame;
        }
        const frame = document.createElement('div');
        frame.className = 'group-selection-frame';
        const handles = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
        handles.forEach((handle) => {
          const node = document.createElement('div');
          node.className = 'group-selection-handle';
          node.dataset.handle = handle;
          frame.appendChild(node);
        });
        canvas.appendChild(frame);
        frame.addEventListener('pointerdown', handleGroupFramePointerDown);
        Array.from(frame.querySelectorAll('.group-selection-handle')).forEach((handle) => {
          handle.addEventListener('pointerdown', handleGroupFramePointerDown);
        });
        groupSelectionState.frame = frame;
        groupSelectionState.handles = Array.from(frame.querySelectorAll('.group-selection-handle'));
        return frame;
      }

      function updateGroupSelectionFrame(bounds) {
        if (!bounds || !canvas) return;
        const frame = ensureGroupSelectionFrame();
        frame.style.left = `${bounds.left}px`;
        frame.style.top = `${bounds.top}px`;
        frame.style.width = `${bounds.width}px`;
        frame.style.height = `${bounds.height}px`;
      }

      function setGroupSelection(elements) {
        clearGroupSelection();
        const uniqueElements = Array.from(new Set(elements.filter(Boolean)));
        if (!uniqueElements.length) {
          return;
        }
        if (uniqueElements.length === 1) {
          clearAllSingleSelections();
          selectElementByType(uniqueElements[0]);
          return;
        }
        clearAllSingleSelections();
        hideRotationHandle();
        const boundsList = uniqueElements.map((element) => getElementCanvasBounds(element));
        const selectionBounds = boundsList.reduce((acc, bounds) => ({
          left: Math.min(acc.left, bounds.left),
          top: Math.min(acc.top, bounds.top),
          right: Math.max(acc.right, bounds.right),
          bottom: Math.max(acc.bottom, bounds.bottom)
        }), {
          left: boundsList[0].left,
          top: boundsList[0].top,
          right: boundsList[0].right,
          bottom: boundsList[0].bottom
        });
        selectionBounds.width = selectionBounds.right - selectionBounds.left;
        selectionBounds.height = selectionBounds.bottom - selectionBounds.top;
        uniqueElements.forEach((element) => {
          element.classList.add('group-selected');
        });
        groupSelectionState.elements = uniqueElements;
        groupSelectionState.metrics = uniqueElements.map((element, index) => {
          const bounds = boundsList[index];
          const baseWidth = selectionBounds.width || 1;
          const baseHeight = selectionBounds.height || 1;
          const minWidth = Number.parseFloat(element.dataset?.minWidth || element.style.minWidth || '0') || 0;
          const minHeight = Number.parseFloat(element.dataset?.minHeight || element.style.minHeight || '0') || 0;
          return {
            element,
            bounds,
            relLeft: (bounds.left - selectionBounds.left) / baseWidth,
            relTop: (bounds.top - selectionBounds.top) / baseHeight,
            relWidth: bounds.width / baseWidth,
            relHeight: bounds.height / baseHeight,
            minWidth,
            minHeight
          };
        });
        const minGroupWidth = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relWidth <= 0) return acc;
          const required = metric.minWidth / Math.max(metric.relWidth, 0.0001);
          return Math.max(acc, required);
        }, 20);
        const minGroupHeight = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relHeight <= 0) return acc;
          const required = metric.minHeight / Math.max(metric.relHeight, 0.0001);
          return Math.max(acc, required);
        }, 20);
        groupSelectionState.bounds = selectionBounds;
        groupSelectionState.minGroupWidth = minGroupWidth;
        groupSelectionState.minGroupHeight = minGroupHeight;
        groupSelectionState.pendingBounds = selectionBounds;
        updateGroupSelectionFrame(selectionBounds);
        updateElementContextMenuState();
      }

      // Track pointer down time for double-click detection
      let lastPointerDownTime = 0;
      let lastPointerDownX = 0;
      let lastPointerDownY = 0;
      let pendingMarqueeStart = null;
      let doubleClickTimeout = null;
      let isCreatingTextBox = false; // Lock to prevent multiple text boxes from being created rapidly

      function handleCanvasPointerDown(event) {
        if (!canvas || isPresenting) return;
        if (event.button !== 0) return;
        
        const pointerTarget = event.target;
        if (pointerTarget.closest('.group-selection-frame') || pointerTarget.closest('.group-selection-handle')) {
          return;
        }
        const interactiveTarget = pointerTarget.closest(CANVAS_INTERACTIVE_SELECTOR);
        if (interactiveTarget && interactiveTarget !== canvas) {
          if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
            clearGroupSelection();
          }
          return;
        }
        
        // Check if this might be a double-click (two pointerdowns close together)
        const now = Date.now();
        const { x: canvasX, y: canvasY } = getCanvasPointFromClient(event.clientX, event.clientY);
        const isPotentialDoubleClick = (now - lastPointerDownTime) < 400 &&
                                       Math.abs(canvasX - lastPointerDownX) < 20 &&
                                       Math.abs(canvasY - lastPointerDownY) < 20;
        
        if (isPotentialDoubleClick) {
          // Cancel any pending marquee start
          if (pendingMarqueeStart) {
            clearTimeout(pendingMarqueeStart);
            pendingMarqueeStart = null;
          }
          
          // Prevent multiple text boxes from being created rapidly
          if (isCreatingTextBox) {
            lastPointerDownTime = 0;
            return;
          }
          
          // Handle double-click directly here for Chrome compatibility
          event.preventDefault();
          event.stopPropagation();
          
          // Clear any active marquee
          if (marqueeState) {
            const { overlay } = marqueeState;
            if (overlay) overlay.remove();
            marqueeState = null;
          }
          
          // Process the double-click
          const clickedElement = event.target;
          const interactiveElement = clickedElement.closest 
            ? clickedElement.closest(CANVAS_INTERACTIVE_SELECTOR)
            : null;
          
          if (interactiveElement && interactiveElement !== canvas) {
            if (interactiveElement.classList && 
                (interactiveElement.classList.contains('text-box') || 
                 interactiveElement.classList.contains('title-box') || 
                 interactiveElement.classList.contains('additional-text-box'))) {
              interactiveElement.focus();
              try {
                const range = document.createRange();
                const sel = window.getSelection();
                if (interactiveElement.firstChild) {
                  range.setStart(interactiveElement.firstChild, 0);
                } else {
                  range.selectNodeContents(interactiveElement);
                }
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              } catch (e) {
                interactiveElement.focus();
              }
            }
            lastPointerDownTime = 0;
            return;
          }
          
          // Set lock to prevent rapid creation
          isCreatingTextBox = true;
          
          // Create new text box
          lastCanvasInsertPosition = { x: canvasX, y: canvasY };
          const newTextBox = addTextBoxAtCanvasPosition(canvasX, canvasY);
          if (newTextBox) {
            selectTextBox(newTextBox);
            setTimeout(() => {
              if (document.contains(newTextBox)) {
                newTextBox.focus();
                if (!newTextBox.textContent || !newTextBox.textContent.trim()) {
                  newTextBox.innerHTML = '';
                }
                try {
                  const range = document.createRange();
                  const sel = window.getSelection();
                  if (newTextBox.firstChild) {
                    range.setStart(newTextBox.firstChild, 0);
                  } else {
                    range.selectNodeContents(newTextBox);
                  }
                  range.collapse(true);
                  sel.removeAllRanges();
                  sel.addRange(range);
                } catch (e) {
                  newTextBox.focus();
                }
              }
              // Release lock after text box is created and focused
              setTimeout(() => {
                isCreatingTextBox = false;
              }, 500); // Wait 500ms before allowing another text box creation
            }, 50);
            capture();
            saveEditorState('add_textbox_doubleclick');
          } else {
            // Release lock if text box creation failed
            isCreatingTextBox = false;
          }
          
          lastPointerDownTime = 0;
          return;
        }
        
        // Store this pointerdown for potential double-click detection
        lastPointerDownTime = now;
        lastPointerDownX = canvasX;
        lastPointerDownY = canvasY;
        
        // Delay marquee start to allow double-click detection
        if (pendingMarqueeStart) {
          clearTimeout(pendingMarqueeStart);
        }
        pendingMarqueeStart = setTimeout(() => {
          if (!marqueeState && lastPointerDownTime > 0) {
            // Re-dispatch the event for marquee (we need to create a synthetic event)
            const syntheticEvent = new PointerEvent('pointerdown', {
              pointerId: event.pointerId,
              clientX: event.clientX,
              clientY: event.clientY,
              button: event.button,
              bubbles: true,
              cancelable: true
            });
            beginMarqueeSelection(syntheticEvent);
          }
          pendingMarqueeStart = null;
        }, 300); // Wait 300ms - if no second click, start marquee
      }

      function beginMarqueeSelection(event) {
        const container = canvasWrap || canvas.parentElement || document.body;
        const containerRect = container.getBoundingClientRect();
        const overlay = document.createElement('div');
        overlay.className = 'canvas-marquee';
        container.appendChild(overlay);
        marqueeState = {
          pointerId: event.pointerId,
          startClient: { x: event.clientX, y: event.clientY },
          startCanvas: getCanvasPointFromClient(event.clientX, event.clientY),
          overlay,
          containerRect
        };
        container.setPointerCapture?.(event.pointerId);
        document.addEventListener('pointermove', handleMarqueePointerMove);
        document.addEventListener('pointerup', handleMarqueePointerUp);
        document.addEventListener('pointercancel', handleMarqueePointerUp);
        event.preventDefault();
      }

      function handleMarqueePointerMove(event) {
        if (!marqueeState || event.pointerId !== marqueeState.pointerId) return;
        const current = { x: event.clientX, y: event.clientY };
        const { startClient, overlay, containerRect } = marqueeState;
        const left = Math.min(startClient.x, current.x) - containerRect.left;
        const top = Math.min(startClient.y, current.y) - containerRect.top;
        const width = Math.abs(current.x - startClient.x);
        const height = Math.abs(current.y - startClient.y);
        overlay.style.left = `${left}px`;
        overlay.style.top = `${top}px`;
        overlay.style.width = `${width}px`;
        overlay.style.height = `${height}px`;
      }

      function handleMarqueePointerUp(event) {
        if (!marqueeState || event.pointerId !== marqueeState.pointerId) return;
        const { overlay, startClient, startCanvas } = marqueeState;
        const container = canvasWrap || canvas.parentElement || document.body;
        container.releasePointerCapture?.(event.pointerId);
        overlay.remove();
        document.removeEventListener('pointermove', handleMarqueePointerMove);
        document.removeEventListener('pointerup', handleMarqueePointerUp);
        document.removeEventListener('pointercancel', handleMarqueePointerUp);
        const distance = Math.hypot(event.clientX - startClient.x, event.clientY - startClient.y);
        marqueeState = null;
        if (distance < MARQUEE_MIN_SIZE) {
          clearGroupSelection();
          clearAllSingleSelections();
          hideRotationHandle();
          updateElementContextMenuState();
          return;
        }
        const endCanvas = getCanvasPointFromClient(event.clientX, event.clientY);
        const rect = {
          left: Math.min(startCanvas.x, endCanvas.x),
          top: Math.min(startCanvas.y, endCanvas.y),
          right: Math.max(startCanvas.x, endCanvas.x),
          bottom: Math.max(startCanvas.y, endCanvas.y)
        };
        const selected = collectGroupSelectableElements().filter((element) => {
          const bounds = getElementCanvasBounds(element);
          return !(bounds.right < rect.left || bounds.left > rect.right || bounds.bottom < rect.top || bounds.top > rect.bottom);
        });
        if (!selected.length) {
          clearGroupSelection();
          clearAllSingleSelections();
          hideRotationHandle();
          updateElementContextMenuState();
          return;
        }
        setGroupSelection(selected);
      }

      function handleGroupFramePointerDown(event) {
        if (!groupSelectionState.elements.length) return;
        if (event.button !== 0) return;
        event.preventDefault();
        event.stopPropagation();
        const handleNode = event.target.closest('.group-selection-handle');
        const mode = handleNode ? 'resize' : 'move';
        const pointerId = event.pointerId;
        const startCanvas = getCanvasPointFromClient(event.clientX, event.clientY);
        const baseBounds = { ...groupSelectionState.bounds };
        const baseMetrics = groupSelectionState.metrics.map((metric) => ({
          element: metric.element,
          left: metric.bounds.left,
          top: metric.bounds.top,
          width: metric.bounds.width,
          height: metric.bounds.height,
          minWidth: metric.minWidth,
          minHeight: metric.minHeight,
          relLeft: metric.relLeft,
          relTop: metric.relTop,
          relWidth: metric.relWidth,
          relHeight: metric.relHeight
        }));
        groupSelectionState.dragState = {
          pointerId,
          mode,
          handle: handleNode ? handleNode.dataset.handle : null,
          startCanvas,
          baseBounds,
          baseMetrics
        };
        groupSelectionState.pendingBounds = baseBounds;
        document.addEventListener('pointermove', handleGroupPointerMove);
        document.addEventListener('pointerup', handleGroupPointerUp);
        document.addEventListener('pointercancel', handleGroupPointerUp);
        event.target.setPointerCapture?.(pointerId);
      }

      function handleGroupPointerMove(event) {
        const dragState = groupSelectionState.dragState;
        if (!dragState || event.pointerId !== dragState.pointerId) return;
        const current = getCanvasPointFromClient(event.clientX, event.clientY);
        const deltaX = current.x - dragState.startCanvas.x;
        const deltaY = current.y - dragState.startCanvas.y;
        if (dragState.mode === 'move') {
          applyGroupMove(deltaX, deltaY, dragState);
        } else if (dragState.mode === 'resize') {
          applyGroupResize(deltaX, deltaY, dragState);
        }
      }

      function applyGroupMove(deltaX, deltaY, dragState) {
        const { baseBounds, baseMetrics } = dragState;
        const newBounds = {
          left: baseBounds.left + deltaX,
          top: baseBounds.top + deltaY,
          width: baseBounds.width,
          height: baseBounds.height
        };
        updateGroupSelectionFrame(newBounds);
        groupSelectionState.elements.forEach((element, index) => {
          const metric = baseMetrics[index];
          const newLeft = metric.left + deltaX;
          const newTop = metric.top + deltaY;
          element.style.left = `${newLeft}px`;
          element.style.top = `${newTop}px`;
        });
        groupSelectionState.pendingBounds = newBounds;
      }

      function applyGroupResize(deltaX, deltaY, dragState) {
        const { baseBounds, baseMetrics, handle } = dragState;
        let newLeft = baseBounds.left;
        let newTop = baseBounds.top;
        let newWidth = baseBounds.width;
        let newHeight = baseBounds.height;
        if (handle === 'top' || handle === 'top-left' || handle === 'top-right') {
          newTop = baseBounds.top + deltaY;
          newHeight = baseBounds.height - deltaY;
        }
        if (handle === 'bottom' || handle === 'bottom-left' || handle === 'bottom-right') {
          newHeight = baseBounds.height + deltaY;
        }
        if (handle === 'left' || handle === 'top-left' || handle === 'bottom-left') {
          newLeft = baseBounds.left + deltaX;
          newWidth = baseBounds.width - deltaX;
        }
        if (handle === 'right' || handle === 'top-right' || handle === 'bottom-right') {
          newWidth = baseBounds.width + deltaX;
        }
        const minWidth = groupSelectionState.minGroupWidth || 20;
        const minHeight = groupSelectionState.minGroupHeight || 20;
        if (newWidth < minWidth) {
          if (handle === 'left' || handle === 'top-left' || handle === 'bottom-left') {
            newLeft = baseBounds.left + (baseBounds.width - minWidth);
          }
          newWidth = minWidth;
        }
        if (newHeight < minHeight) {
          if (handle === 'top' || handle === 'top-left' || handle === 'top-right') {
            newTop = baseBounds.top + (baseBounds.height - minHeight);
          }
          newHeight = minHeight;
        }
        if (newWidth <= 0 || newHeight <= 0) {
          return;
        }
        const newBounds = {
          left: newLeft,
          top: newTop,
          width: newWidth,
          height: newHeight
        };
        updateGroupSelectionFrame(newBounds);
        groupSelectionState.elements.forEach((element, index) => {
          const metric = baseMetrics[index];
          const relLeft = metric.relLeft;
          const relTop = metric.relTop;
          const relWidth = metric.relWidth;
          const relHeight = metric.relHeight;
          const desiredWidth = relWidth * newWidth;
          const desiredHeight = relHeight * newHeight;
          const elementLeft = newLeft + relLeft * newWidth;
          const elementTop = newTop + relTop * newHeight;
          element.style.left = `${elementLeft}px`;
          element.style.top = `${elementTop}px`;
          if (Number.isFinite(desiredWidth) && desiredWidth > 0) {
            const adjustedWidth = Math.max(metric.minWidth || 0, desiredWidth);
            element.style.width = `${adjustedWidth}px`;
          }
          if (Number.isFinite(desiredHeight) && desiredHeight > 0) {
            const adjustedHeight = Math.max(metric.minHeight || 0, desiredHeight);
            element.style.height = `${adjustedHeight}px`;
          }
        });
        groupSelectionState.pendingBounds = newBounds;
      }

      function handleGroupPointerUp(event) {
        const dragState = groupSelectionState.dragState;
        if (!dragState || event.pointerId !== dragState.pointerId) return;
        event.target.releasePointerCapture?.(dragState.pointerId);
        document.removeEventListener('pointermove', handleGroupPointerMove);
        document.removeEventListener('pointerup', handleGroupPointerUp);
        document.removeEventListener('pointercancel', handleGroupPointerUp);
        const finalBounds = groupSelectionState.pendingBounds || groupSelectionState.bounds;
        groupSelectionState.bounds = finalBounds;
        groupSelectionState.metrics = groupSelectionState.elements.map((element) => {
          const bounds = getElementCanvasBounds(element);
          const baseWidth = finalBounds.width || 1;
          const baseHeight = finalBounds.height || 1;
          const minWidth = Number.parseFloat(element.dataset?.minWidth || element.style.minWidth || '0') || 0;
          const minHeight = Number.parseFloat(element.dataset?.minHeight || element.style.minHeight || '0') || 0;
          return {
            element,
            bounds,
            relLeft: (bounds.left - finalBounds.left) / baseWidth,
            relTop: (bounds.top - finalBounds.top) / baseHeight,
            relWidth: bounds.width / baseWidth,
            relHeight: bounds.height / baseHeight,
            minWidth,
            minHeight
          };
        });
        const minGroupWidth = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relWidth <= 0) return acc;
          const required = metric.minWidth / Math.max(metric.relWidth, 0.0001);
          return Math.max(acc, required);
        }, 20);
        const minGroupHeight = groupSelectionState.metrics.reduce((acc, metric) => {
          if (metric.relHeight <= 0) return acc;
          const required = metric.minHeight / Math.max(metric.relHeight, 0.0001);
          return Math.max(acc, required);
        }, 20);
        groupSelectionState.minGroupWidth = minGroupWidth;
        groupSelectionState.minGroupHeight = minGroupHeight;
        groupSelectionState.dragState = null;
        groupSelectionState.pendingBounds = null;
        groupSelectionState.elements.forEach((element) => {
          createResizeEdges(element);
        });
        const action = dragState.mode === 'move' ? 'group_move' : 'group_resize';
        capture();
        renderSidebar();
        saveEditorState(action);
      }

      function positionShapeDropdown() {
        if (!shapePickerButton) return;
        shapeDropdown.style.top = '0px';
        shapeDropdown.style.left = '0px';
        shapeDropdown.classList.add('show');
        const buttonRect = shapePickerButton.getBoundingClientRect();
        const dropdownRect = shapeDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        shapeDropdown.style.top = `${Math.max(16, top)}px`;
        shapeDropdown.style.left = `${left}px`;
      }

      function showShapeDropdown() {
        if (!shapePickerButton) return;
        positionShapeDropdown();
        isShapeDropdownVisible = true;
        shapeDropdown.classList.add('show');
        shapePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideShapeDropdown() {
        shapeDropdown.classList.remove('show');
        isShapeDropdownVisible = false;
        if (shapePickerButton) {
          shapePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleShapeDropdown() {
        if (isShapeDropdownVisible) {
          hideShapeDropdown();
        } else {
          showShapeDropdown();
        }
      }

      function positionChartDropdown() {
        if (!chartPickerButton) return;
        chartDropdown.style.top = '0px';
        chartDropdown.style.left = '0px';
        chartDropdown.classList.add('show');
        const buttonRect = chartPickerButton.getBoundingClientRect();
        const dropdownRect = chartDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        chartDropdown.style.top = `${Math.max(16, top)}px`;
        chartDropdown.style.left = `${left}px`;
      }

      function showChartDropdown() {
        if (!chartPickerButton) return;
        positionChartDropdown();
        isChartDropdownVisible = true;
        chartDropdown.classList.add('show');
        chartPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideChartDropdown() {
        chartDropdown.classList.remove('show');
        isChartDropdownVisible = false;
        if (chartPickerButton) {
          chartPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleChartDropdown() {
        if (isChartDropdownVisible) {
          hideChartDropdown();
        } else {
          showChartDropdown();
        }
      }

      // Icon picker functionality
      let isIconDropdownVisible = false;
      let iconCache = new Map();
      let currentIconFolder = null; // 'solid' or 'outline'
      const iconGrid = document.getElementById('iconGrid');
      const iconSearchInput = document.getElementById('iconSearchInput');
      const iconFolderMenu = document.getElementById('iconFolderMenu');
      const iconView = document.getElementById('iconView');
      const iconBackButton = document.getElementById('iconBackButton');
      const iconFolderName = document.getElementById('iconFolderName');

      // List of heroicons (24 outline) - all 324 icons from heroicons-master
      const HEROICON_NAMES = [
        'academic-cap', 'adjustments-horizontal', 'adjustments-vertical', 'archive-box-arrow-down', 'archive-box-x-mark', 'archive-box', 'arrow-down-circle', 'arrow-down-left', 'arrow-down-on-square-stack', 'arrow-down-on-square',
        'arrow-down-right', 'arrow-down-tray', 'arrow-down', 'arrow-left-circle', 'arrow-left-end-on-rectangle', 'arrow-left-on-rectangle', 'arrow-left-start-on-rectangle', 'arrow-left', 'arrow-long-down', 'arrow-long-left',
        'arrow-long-right', 'arrow-long-up', 'arrow-path-rounded-square', 'arrow-path', 'arrow-right-circle', 'arrow-right-end-on-rectangle', 'arrow-right-on-rectangle', 'arrow-right-start-on-rectangle', 'arrow-right', 'arrow-small-down',
        'arrow-small-left', 'arrow-small-right', 'arrow-small-up', 'arrow-top-right-on-square', 'arrow-trending-down', 'arrow-trending-up', 'arrow-turn-down-left', 'arrow-turn-down-right', 'arrow-turn-left-down', 'arrow-turn-left-up',
        'arrow-turn-right-down', 'arrow-turn-right-up', 'arrow-turn-up-left', 'arrow-turn-up-right', 'arrow-up-circle', 'arrow-up-left', 'arrow-up-on-square-stack', 'arrow-up-on-square', 'arrow-up-right', 'arrow-up-tray',
        'arrow-up', 'arrow-uturn-down', 'arrow-uturn-left', 'arrow-uturn-right', 'arrow-uturn-up', 'arrows-pointing-in', 'arrows-pointing-out', 'arrows-right-left', 'arrows-up-down', 'at-symbol',
        'backspace', 'backward', 'banknotes', 'bars-2', 'bars-3-bottom-left', 'bars-3-bottom-right', 'bars-3-center-left', 'bars-3', 'bars-4', 'bars-arrow-down',
        'bars-arrow-up', 'battery-0', 'battery-100', 'battery-50', 'beaker', 'bell-alert', 'bell-slash', 'bell-snooze', 'bell', 'bold',
        'bolt-slash', 'bolt', 'book-open', 'bookmark-slash', 'bookmark-square', 'bookmark', 'briefcase', 'bug-ant', 'building-library', 'building-office-2',
        'building-office', 'building-storefront', 'cake', 'calculator', 'calendar-date-range', 'calendar-days', 'calendar', 'camera', 'chart-bar-square', 'chart-bar',
        'chart-pie', 'chat-bubble-bottom-center-text', 'chat-bubble-bottom-center', 'chat-bubble-left-ellipsis', 'chat-bubble-left-right', 'chat-bubble-left', 'chat-bubble-oval-left-ellipsis', 'chat-bubble-oval-left', 'check-badge', 'check-circle',
        'check', 'chevron-double-down', 'chevron-double-left', 'chevron-double-right', 'chevron-double-up', 'chevron-down', 'chevron-left', 'chevron-right', 'chevron-up-down', 'chevron-up',
        'circle-stack', 'clipboard-document-check', 'clipboard-document-list', 'clipboard-document', 'clipboard', 'clock', 'cloud-arrow-down', 'cloud-arrow-up', 'cloud', 'code-bracket-square',
        'code-bracket', 'cog-6-tooth', 'cog-8-tooth', 'cog', 'command-line', 'computer-desktop', 'cpu-chip', 'credit-card', 'cube-transparent', 'cube',
        'currency-bangladeshi', 'currency-dollar', 'currency-euro', 'currency-pound', 'currency-rupee', 'currency-yen', 'cursor-arrow-rays', 'cursor-arrow-ripple', 'device-phone-mobile', 'device-tablet',
        'divide', 'document-arrow-down', 'document-arrow-up', 'document-chart-bar', 'document-check', 'document-currency-bangladeshi', 'document-currency-dollar', 'document-currency-euro', 'document-currency-pound', 'document-currency-rupee',
        'document-currency-yen', 'document-duplicate', 'document-magnifying-glass', 'document-minus', 'document-plus', 'document-text', 'document', 'ellipsis-horizontal-circle', 'ellipsis-horizontal', 'ellipsis-vertical',
        'envelope-open', 'envelope', 'equals', 'exclamation-circle', 'exclamation-triangle', 'eye-dropper', 'eye-slash', 'eye', 'face-frown', 'face-smile',
        'film', 'finger-print', 'fire', 'flag', 'folder-arrow-down', 'folder-minus', 'folder-open', 'folder-plus', 'folder', 'forward',
        'funnel', 'gif', 'gift-top', 'gift', 'globe-alt', 'globe-americas', 'globe-asia-australia', 'globe-europe-africa', 'h1', 'h2',
        'h3', 'hand-raised', 'hand-thumb-down', 'hand-thumb-up', 'hashtag', 'heart', 'home-modern', 'home', 'identification', 'inbox-arrow-down',
        'inbox-stack', 'inbox', 'information-circle', 'italic', 'key', 'language', 'lifebuoy', 'light-bulb', 'link-slash', 'link',
        'list-bullet', 'lock-closed', 'lock-open', 'magnifying-glass-circle', 'magnifying-glass-minus', 'magnifying-glass-plus', 'magnifying-glass', 'map-pin', 'map', 'megaphone',
        'microphone', 'minus-circle', 'minus-small', 'minus', 'moon', 'musical-note', 'newspaper', 'no-symbol', 'numbered-list', 'paint-brush',
        'paper-airplane', 'paper-clip', 'pause-circle', 'pause', 'pencil-square', 'pencil', 'percent-badge', 'phone-arrow-down-left', 'phone-arrow-up-right', 'phone-x-mark',
        'phone', 'photo', 'play-circle', 'play-pause', 'play', 'plus-circle', 'plus-small', 'plus', 'power', 'presentation-chart-bar',
        'presentation-chart-line', 'printer', 'puzzle-piece', 'qr-code', 'question-mark-circle', 'queue-list', 'radio', 'receipt-percent', 'receipt-refund', 'rectangle-group',
        'rectangle-stack', 'rocket-launch', 'rss', 'scale', 'scissors', 'server-stack', 'server', 'share', 'shield-check', 'shield-exclamation',
        'shopping-bag', 'shopping-cart', 'signal-slash', 'signal', 'slash', 'sparkles', 'speaker-wave', 'speaker-x-mark', 'square-2-stack', 'square-3-stack-3d',
        'squares-2x2', 'squares-plus', 'star', 'stop-circle', 'stop', 'strikethrough', 'sun', 'swatch', 'table-cells', 'tag',
        'ticket', 'trash', 'trophy', 'truck', 'tv', 'underline', 'user-circle', 'user-group', 'user-minus', 'user-plus',
        'user', 'users', 'variable', 'video-camera-slash', 'video-camera', 'view-columns', 'viewfinder-circle', 'wallet', 'wifi', 'window',
        'wrench-screwdriver', 'wrench', 'x-circle', 'x-mark'
      ];

      async function loadIconSvg(iconName, folder = 'outline') {
        const cacheKey = `${folder}/${iconName}`;
        if (iconCache.has(cacheKey)) {
          return iconCache.get(cacheKey);
        }
        
        // Get base URL from current page location
        const currentPath = window.location.pathname;
        const basePath = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
        const baseUrl = window.location.origin + basePath;
        
        // Load from Icons folder (solid or outline) - try multiple path variations
        const paths = [
          `./Icons/${folder}/${iconName}.svg`,
          `Icons/${folder}/${iconName}.svg`,
          `/Icons/${folder}/${iconName}.svg`,
          `${baseUrl}Icons/${folder}/${iconName}.svg`,
          new URL(`Icons/${folder}/${iconName}.svg`, window.location.href).href
        ];
        
        let lastError = null;
        for (const path of paths) {
          try {
            const response = await fetch(path, {
              method: 'GET',
              cache: 'no-cache'
            });
            
            if (response.ok && response.status === 200) {
              const contentType = response.headers.get('content-type');
            const svg = await response.text();
              if (svg && svg.trim().length > 0) {
                // Verify it's actually SVG content
                if (svg.includes('<svg') || svg.includes('<?xml')) {
                  iconCache.set(cacheKey, svg);
                  console.log(`Successfully loaded icon: ${iconName} from ${path}`);
            return svg;
                } else {
                  console.warn(`Icon ${iconName} from ${path} doesn't appear to be valid SVG`);
                }
              }
            } else {
              lastError = `HTTP ${response.status}: ${response.statusText}`;
          }
        } catch (e) {
            lastError = e.message;
            // Try next path
            continue;
          }
        }
        
        // If all paths fail, try fallback
        try {
          const fallbackPaths = [
            `./assets/icons/${iconName}.svg`,
            `assets/icons/${iconName}.svg`
          ];
          for (const fallbackPath of fallbackPaths) {
            try {
              const fallbackResponse = await fetch(fallbackPath);
              if (fallbackResponse.ok) {
                const svg = await fallbackResponse.text();
                if (svg && svg.trim().length > 0 && (svg.includes('<svg') || svg.includes('<?xml'))) {
                  iconCache.set(cacheKey, svg);
                  console.log(`Successfully loaded icon: ${iconName} from fallback ${fallbackPath}`);
                  return svg;
                }
              }
            } catch (e2) {
              continue;
            }
          }
        } catch (e) {
          // Ignore fallback errors
        }
        
        // Return null if icon can't be loaded
        console.error(`Failed to load icon: ${iconName} from folder: ${folder}. Last error: ${lastError || 'All paths failed'}`);
        console.error(`Tried paths:`, paths);
        return null;
      }

      function getIconDisplayName(iconName) {
        return iconName
          .split('-')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
      }

      async function renderIconOptions(filter = '') {
        if (!iconGrid || !currentIconFolder) return;
        
        const searchTerm = filter.toLowerCase();
        const filteredIcons = HEROICON_NAMES.filter(name => 
          name.toLowerCase().includes(searchTerm) || 
          getIconDisplayName(name).toLowerCase().includes(searchTerm)
        );

        iconGrid.innerHTML = '';
        
        // Load a subset of icons for performance (first 100 matching)
        const iconsToLoad = filteredIcons.slice(0, 100);
        
        for (const iconName of iconsToLoad) {
          const option = document.createElement('button');
          option.type = 'button';
          option.className = 'icon-option';
          option.dataset.iconName = iconName;
          
          // Try to load the icon from the selected folder
          const svgContent = await loadIconSvg(iconName, currentIconFolder);
          
          // Store the SVG content in a data attribute so we can retrieve it on click
          if (svgContent) {
            option.dataset.svgContent = svgContent;
            option.innerHTML = `
              ${svgContent}
              <span class="icon-option-label">${getIconDisplayName(iconName)}</span>
            `;
          } else {
            // Fallback: create a placeholder SVG
            option.dataset.svgContent = '';
            option.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15"/>
              </svg>
              <span class="icon-option-label">${getIconDisplayName(iconName)}</span>
            `;
          }
          
          option.addEventListener('click', async (event) => {
            event.preventDefault();
            event.stopPropagation();
            
            // Try to get SVG from data attribute first (if it was loaded during rendering)
            let finalSvgContent = option.dataset.svgContent || null;
            
            // If we don't have it, try to load it
            if (!finalSvgContent && currentIconFolder) {
              finalSvgContent = await loadIconSvg(iconName, currentIconFolder);
            }
            
            if (finalSvgContent) {
              insertIcon(iconName, finalSvgContent, currentIconFolder);
            hideIconDropdown();
            } else {
              // Try to show a more helpful error message with debugging info
              const testPath = `./Icons/${currentIconFolder}/${iconName}.svg`;
              console.error(`Failed to load icon: ${iconName} from folder: ${currentIconFolder}`);
              console.error(`Test path would be: ${testPath}`);
              console.error(`Current page URL: ${window.location.href}`);
              console.error(`Base path: ${window.location.pathname}`);
              
              // Try to test the path directly
              fetch(testPath)
                .then(response => {
                  console.log(`Test fetch response status: ${response.status}`);
                  if (!response.ok) {
                    console.log(`Response not OK: ${response.status} ${response.statusText}`);
                  }
                  return response.text();
                })
                .then(text => {
                  console.log(`Test fetch got ${text.length} characters`);
                  if (text.includes('<svg')) {
                    console.log('SVG content detected in test fetch');
                  }
                })
                .catch(err => {
                  console.error('Test fetch error:', err);
                });
              
              showNotification(`Icon "${getIconDisplayName(iconName)}" could not be loaded. Check console for details.`);
            }
          });
          
          iconGrid.appendChild(option);
        }
      }

      function insertIcon(iconName, svgContent, folder = 'outline') {
        if (!svgContent) {
          // Try to load it one more time
          loadIconSvg(iconName, folder).then(svg => {
            if (svg) {
              insertIconElement(iconName, svg);
            } else {
              showNotification('Icon could not be loaded. Please ensure icons are in Icons folder.');
            }
          });
          return;
        }
        
        insertIconElement(iconName, svgContent);
      }

      function insertIconElement(iconName, svgContent) {
        if (!canvas) {
          console.error('Canvas not found');
          showNotification('Canvas not found. Cannot insert icon.');
          return;
        }
        
        if (!svgContent || svgContent.trim().length === 0) {
          console.error('Empty SVG content for icon:', iconName);
          showNotification('Icon content is empty. Cannot insert icon.');
          return;
        }
        
        const element = document.createElement('div');
        element.className = 'icon-element';
        const elementId = generateElementId('icon');
        element.dataset.elementId = elementId;
        element.dataset.iconName = iconName;
        
        // Default size for icons
        const defaultSize = 80;
        const minSize = 20;
        element.style.width = `${defaultSize}px`;
        element.style.height = `${defaultSize}px`;
        element.dataset.minWidth = String(minSize);
        element.dataset.minHeight = String(minSize);
        element.style.position = 'absolute';
        element.style.zIndex = 2;
        element.style.color = '#000000';
        
        // Parse SVG and set size
        try {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
          
          // Check for parsing errors
          const parserError = svgDoc.querySelector('parsererror');
          if (parserError) {
            console.error('SVG parsing error:', parserError.textContent);
            // Fallback: try to use the content directly
            element.innerHTML = svgContent;
          } else {
        const svg = svgDoc.querySelector('svg');
        if (svg) {
          svg.setAttribute('width', '100%');
          svg.setAttribute('height', '100%');
          svg.style.width = '100%';
          svg.style.height = '100%';
          svg.style.pointerEvents = 'none';
              
              // Make SVG paths use currentColor so they can be colored
              // Detect if this is an outline icon (has fill="none" and stroke) vs solid icon (has fill)
              const svgFill = svg.getAttribute('fill');
              const paths = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');
              
              // Check if this is an outline icon by looking at the first path
              let isOutlineIcon = false;
              if (paths.length > 0) {
                const firstPath = paths[0];
                const firstFill = firstPath.getAttribute('fill');
                const firstStroke = firstPath.getAttribute('stroke');
                const firstStrokeWidth = firstPath.getAttribute('stroke-width');
                
                // If fill is 'none' and there's a stroke, it's an outline icon
                if ((firstFill === 'none' || svgFill === 'none') && (firstStroke || firstStrokeWidth)) {
                  isOutlineIcon = true;
                }
              }
              
              paths.forEach(path => {
                const fill = path.getAttribute('fill');
                const stroke = path.getAttribute('stroke');
                const strokeWidth = path.getAttribute('stroke-width');
                
                if (isOutlineIcon) {
                  // For outline icons: keep fill as 'none', convert stroke to currentColor
                  path.setAttribute('fill', 'none');
                  if (strokeWidth || stroke) {
                    if (stroke !== 'none') {
                      path.setAttribute('stroke', 'currentColor');
                    }
                  }
                } else {
                  // For solid icons: convert fill to currentColor, handle stroke if present
                  if (fill !== 'none') {
                    path.setAttribute('fill', 'currentColor');
                  } else {
                    path.setAttribute('fill', 'none');
                  }
                  
                  // Also handle stroke for solid icons if it exists
                  if (stroke && stroke !== 'none') {
                    path.setAttribute('stroke', 'currentColor');
                  }
                }
              });
              
          element.appendChild(svg);
        } else {
              // Fallback: use innerHTML
          element.innerHTML = svgContent;
            }
          }
          
          // Ensure SVG is properly sized and colorable
          const innerSvg = element.querySelector('svg');
          if (innerSvg) {
            innerSvg.setAttribute('width', '100%');
            innerSvg.setAttribute('height', '100%');
            innerSvg.style.width = '100%';
            innerSvg.style.height = '100%';
            innerSvg.style.pointerEvents = 'none';
            
            // Make sure all paths use currentColor (for fallback case)
            const allPaths = innerSvg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');
            
            // Detect if this is an outline icon
            let isOutlineIcon = false;
            if (allPaths.length > 0) {
              const firstPath = allPaths[0];
              const firstFill = firstPath.getAttribute('fill');
              const firstStroke = firstPath.getAttribute('stroke');
              const firstStrokeWidth = firstPath.getAttribute('stroke-width');
              const svgFill = innerSvg.getAttribute('fill');
              
              if ((firstFill === 'none' || svgFill === 'none') && (firstStroke || firstStrokeWidth)) {
                isOutlineIcon = true;
              }
            }
            
            allPaths.forEach(path => {
              const fill = path.getAttribute('fill');
              const stroke = path.getAttribute('stroke');
              const strokeWidth = path.getAttribute('stroke-width');
              
              if (isOutlineIcon) {
                // For outline icons: keep fill as 'none', convert stroke to currentColor
                path.setAttribute('fill', 'none');
                if (strokeWidth || stroke) {
                  if (stroke !== 'none') {
                    path.setAttribute('stroke', 'currentColor');
                  }
                }
              } else {
                // For solid icons: convert fill to currentColor
                if (fill !== 'none') {
                  path.setAttribute('fill', 'currentColor');
                } else {
                  path.setAttribute('fill', 'none');
                }
                
                // Handle stroke for solid icons if present
                if (stroke && stroke !== 'none') {
                  path.setAttribute('stroke', 'currentColor');
                }
              }
            });
          }
        } catch (e) {
          console.error('Error parsing SVG:', e);
          // Fallback: try to use the content directly
          element.innerHTML = svgContent;
          const innerSvg = element.querySelector('svg');
          if (innerSvg) {
            innerSvg.setAttribute('width', '100%');
            innerSvg.setAttribute('height', '100%');
            innerSvg.style.width = '100%';
            innerSvg.style.height = '100%';
            innerSvg.style.pointerEvents = 'none';
          }
        }
        
        // Center on canvas
        const innerWidth = canvas.clientWidth;
        const innerHeight = canvas.clientHeight;
        const left = (innerWidth - defaultSize) / 2;
        const top = (innerHeight - defaultSize) / 2;
        
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        
        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);
        
        // Selection handler - only select on click to not interfere with dragging
        // makeDraggable handles mousedown for dragging
        element.addEventListener('click', (event) => {
          // Don't select if clicking on resize edge or if dragging just happened
          if (event.target.classList && event.target.classList.contains('resize-edge')) {
            return;
          }
          // Small delay to check if dragging occurred
          setTimeout(() => {
            if (!element.classList.contains('dragging')) {
              event.stopPropagation();
              selectIcon(element);
            }
          }, 10);
        });
        
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectIcon(element);
          showElementContextMenu(event, element);
        });
        
        // Select the icon initially
        selectIcon(element);
        capture();
        saveEditorState('add_icon');
        showNotification('Icon inserted');
      }

      function positionIconDropdown() {
        if (!iconPickerButton) return;
        iconDropdown.style.top = '0px';
        iconDropdown.style.left = '0px';
        iconDropdown.classList.add('show');
        const buttonRect = iconPickerButton.getBoundingClientRect();
        const dropdownRect = iconDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        iconDropdown.style.top = `${Math.max(16, top)}px`;
        iconDropdown.style.left = `${left}px`;
      }

      function showIconDropdown() {
        if (!iconPickerButton) return;
        positionIconDropdown();
        isIconDropdownVisible = true;
        iconDropdown.classList.add('show');
        iconPickerButton.setAttribute('aria-expanded', 'true');
        // Show folder menu first, hide icon view
        if (iconFolderMenu) iconFolderMenu.style.display = 'flex';
        if (iconView) iconView.style.display = 'none';
        currentIconFolder = null;
      }

      function showIconFolder(folder) {
        currentIconFolder = folder;
        if (iconFolderMenu) iconFolderMenu.style.display = 'none';
        if (iconView) iconView.style.display = 'flex';
        if (iconFolderName) {
          iconFolderName.textContent = folder.charAt(0).toUpperCase() + folder.slice(1);
        }
        if (iconSearchInput) iconSearchInput.value = '';
        // Load icons from the selected folder
          renderIconOptions();
        }

      function showIconFolderMenu() {
        currentIconFolder = null;
        if (iconFolderMenu) iconFolderMenu.style.display = 'flex';
        if (iconView) iconView.style.display = 'none';
        if (iconSearchInput) iconSearchInput.value = '';
      }

      function hideIconDropdown() {
        iconDropdown.classList.remove('show');
        isIconDropdownVisible = false;
        if (iconPickerButton) {
          iconPickerButton.setAttribute('aria-expanded', 'false');
        }
        // Reset to folder menu when hidden
        showIconFolderMenu();
      }

      function toggleIconDropdown() {
        if (isIconDropdownVisible) {
          hideIconDropdown();
        } else {
          showIconDropdown();
        }
      }

      if (shapePickerButton) {
        shapePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleShapeDropdown();
        });
      }

      if (chartPickerButton) {
        chartPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleChartDropdown();
        });
      }

      if (iconPickerButton) {
        iconPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleIconDropdown();
        });
      }

      // Layout dropdown functions
      const layoutButton = document.getElementById('layoutButton');
      let isLayoutDropdownVisible = false;

      function positionLayoutDropdown() {
        if (!layoutButton) return;
        layoutDropdown.style.top = '0px';
        layoutDropdown.style.left = '0px';
        layoutDropdown.classList.add('show');
        const buttonRect = layoutButton.getBoundingClientRect();
        const dropdownRect = layoutDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        layoutDropdown.style.top = `${Math.max(16, top)}px`;
        layoutDropdown.style.left = `${left}px`;
      }

      function showLayoutDropdown() {
        if (!layoutButton) return;
        positionLayoutDropdown();
        isLayoutDropdownVisible = true;
        layoutDropdown.classList.add('show');
        layoutButton.setAttribute('aria-expanded', 'true');
      }

      function hideLayoutDropdown() {
        layoutDropdown.classList.remove('show');
        isLayoutDropdownVisible = false;
        if (layoutButton) {
          layoutButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleLayoutDropdown() {
        if (isLayoutDropdownVisible) {
          hideLayoutDropdown();
        } else {
          showLayoutDropdown();
        }
      }

      // Layout insertion functions
      function insertTitleContentLayout() {
        if (!canvas) return;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const margin = 40;
        const centerX = canvasWidth / 2;
        
        // Title textbox (top, centered, wider)
        const titleWidth = Math.min(600, canvasWidth - margin * 2);
        const titleHeight = 60;
        const titleLeft = centerX - titleWidth / 2;
        const titleTop = margin + 60;
        
        const titleBox = addTextBoxAtCanvasPosition(titleLeft + titleWidth / 2, titleTop + titleHeight / 2);
        if (titleBox) {
          titleBox.style.width = `${titleWidth}px`;
          titleBox.style.height = `${titleHeight}px`;
          titleBox.style.fontSize = '32px';
          titleBox.style.fontWeight = 'bold';
          titleBox.textContent = 'Title';
        }
        
        // Content textbox (below title, centered, wider)
        const contentWidth = Math.min(600, canvasWidth - margin * 2);
        const contentHeight = 200;
        const contentLeft = centerX - contentWidth / 2;
        const contentTop = titleTop + titleHeight + 40;
        
        setTimeout(() => {
          const contentBox = addTextBoxAtCanvasPosition(contentLeft + contentWidth / 2, contentTop + contentHeight / 2);
          if (contentBox) {
            contentBox.style.width = `${contentWidth}px`;
            contentBox.style.height = `${contentHeight}px`;
            contentBox.textContent = 'Content';
          }
        }, 100);
        
        hideLayoutDropdown();
      }

      function insertTwoColumnLayout() {
        if (!canvas) return;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const margin = 40;
        const gap = 20;
        const columnWidth = (canvasWidth - margin * 2 - gap) / 2;
        const columnHeight = 300;
        const top = margin + 100;
        
        // Left column
        const leftX = margin + columnWidth / 2;
        const leftBox = addTextBoxAtCanvasPosition(leftX, top + columnHeight / 2);
        if (leftBox) {
          leftBox.style.width = `${columnWidth}px`;
          leftBox.style.height = `${columnHeight}px`;
          leftBox.textContent = 'Left Column';
        }
        
        // Right column
        setTimeout(() => {
          const rightX = margin + columnWidth + gap + columnWidth / 2;
          const rightBox = addTextBoxAtCanvasPosition(rightX, top + columnHeight / 2);
          if (rightBox) {
            rightBox.style.width = `${columnWidth}px`;
            rightBox.style.height = `${columnHeight}px`;
            rightBox.textContent = 'Right Column';
          }
        }, 100);
        
        hideLayoutDropdown();
      }

      function insertThreeColumnLayout() {
        if (!canvas) return;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const margin = 40;
        const gap = 15;
        const columnWidth = (canvasWidth - margin * 2 - gap * 2) / 3;
        const columnHeight = 300;
        const top = margin + 100;
        
        // Left column
        const leftX = margin + columnWidth / 2;
        const leftBox = addTextBoxAtCanvasPosition(leftX, top + columnHeight / 2);
        if (leftBox) {
          leftBox.style.width = `${columnWidth}px`;
          leftBox.style.height = `${columnHeight}px`;
          leftBox.textContent = 'Column 1';
        }
        
        // Middle column
        setTimeout(() => {
          const middleX = margin + columnWidth + gap + columnWidth / 2;
          const middleBox = addTextBoxAtCanvasPosition(middleX, top + columnHeight / 2);
          if (middleBox) {
            middleBox.style.width = `${columnWidth}px`;
            middleBox.style.height = `${columnHeight}px`;
            middleBox.textContent = 'Column 2';
          }
          
          // Right column
          setTimeout(() => {
            const rightX = margin + columnWidth * 2 + gap * 2 + columnWidth / 2;
            const rightBox = addTextBoxAtCanvasPosition(rightX, top + columnHeight / 2);
            if (rightBox) {
              rightBox.style.width = `${columnWidth}px`;
              rightBox.style.height = `${columnHeight}px`;
              rightBox.textContent = 'Column 3';
            }
          }, 100);
        }, 100);
        
        hideLayoutDropdown();
      }

      // Layout option event listeners
      if (layoutDropdown) {
        const layoutOptions = layoutDropdown.querySelectorAll('.layout-option');
        layoutOptions.forEach(option => {
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            const layoutType = option.getAttribute('data-layout');
            if (layoutType === 'title-content') {
              insertTitleContentLayout();
            } else if (layoutType === 'two-column') {
              insertTwoColumnLayout();
            } else if (layoutType === 'three-column') {
              insertThreeColumnLayout();
            }
          });
        });
      }

      // Folder selection buttons
      if (iconFolderMenu) {
        const folderOptions = iconFolderMenu.querySelectorAll('.icon-folder-option');
        folderOptions.forEach(option => {
          option.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            const folder = option.dataset.folder;
            if (folder === 'solid' || folder === 'outline') {
              showIconFolder(folder);
            }
          });
        });
      }

      // Back button
      if (iconBackButton) {
        iconBackButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          showIconFolderMenu();
        });
      }

      if (iconSearchInput) {
        iconSearchInput.addEventListener('input', (event) => {
          const searchTerm = event.target.value;
          renderIconOptions(searchTerm);
        });
      }

      if (imagePickerButton && imageFileInput) {
        imagePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          imageFileInput.value = '';
          imageFileInput.click();
        });
        imageFileInput.addEventListener('change', (event) => {
          const { files } = event.target;
          if (!files || !files.length) return;
          const file = files[0];
          if (!file.type || !file.type.startsWith('image/')) {
            alert('Please select a valid image file.');
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            insertImageFromDataUrl(reader.result);
          };
          reader.onerror = () => {
            alert('Unable to read the selected image.');
          };
          reader.readAsDataURL(file);
        });
      }

      if (videoPickerButton && videoFileInput) {
        videoPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          videoFileInput.value = '';
          videoFileInput.click();
        });
        videoFileInput.addEventListener('change', (event) => {
          const { files } = event.target;
          if (!files || !files.length) return;
          const file = files[0];
          if (!file.type || !file.type.startsWith('video/')) {
            alert('Please select a valid video file.');
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            insertVideoFromDataUrl(reader.result);
          };
          reader.onerror = () => {
            alert('Unable to read the selected video.');
          };
          reader.readAsDataURL(file);
        });
      }

      function positionTableInsertPanel() {
        if (!tablePickerButton) return;
        if (tablePanelDragState.isDragging) return;
        tableInsertPanel.classList.add('show');
        if (tablePanelManualPosition) {
          const { left, top } = clampTablePanelPosition(tablePanelManualPosition.left, tablePanelManualPosition.top);
          tableInsertPanel.style.top = `${top}px`;
          tableInsertPanel.style.left = `${left}px`;
          tablePanelManualPosition = { left, top };
          return;
        }
        tableInsertPanel.style.top = '0px';
        tableInsertPanel.style.left = '0px';
        const buttonRect = tablePickerButton.getBoundingClientRect();
        const panelRect = tableInsertPanel.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + panelRect.height > window.innerHeight - 16) {
          top = buttonRect.top - panelRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - panelRect.height - 16);
        }
        if (left + panelRect.width > window.innerWidth - 16) {
          left = window.innerWidth - panelRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        const clamped = clampTablePanelPosition(left, Math.max(16, top));
        tableInsertPanel.style.top = `${clamped.top}px`;
        tableInsertPanel.style.left = `${clamped.left}px`;
      }

      function showTableInsertPanel() {
        if (!tablePickerButton) return;
        positionTableInsertPanel();
        isTablePanelVisible = true;
        tablePickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideTableInsertPanel() {
        tableInsertPanel.classList.remove('show');
        isTablePanelVisible = false;
        if (tablePickerButton) {
          tablePickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleTableInsertPanel() {
        if (isTablePanelVisible) {
          hideTableInsertPanel();
        } else {
          showTableInsertPanel();
        }
      }

      // Logo dropdown functions
      function buildLogoPositionMenu() {
        if (!logoDropdown) return;
        logoDropdown.innerHTML = '';
        const positions = [
          { id: 'top-left', label: 'Top Left', icon: 'arrow-up-left' },
          { id: 'top-right', label: 'Top Right', icon: 'arrow-up-right' },
          { id: 'bottom-left', label: 'Bottom Left', icon: 'arrow-down-left' },
          { id: 'bottom-right', label: 'Bottom Right', icon: 'arrow-down-right' }
        ];
        positions.forEach((pos) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'logo-position-option';
          button.innerHTML = `
            <i class="fas fa-${pos.icon}"></i>
            <span>${pos.label}</span>
          `;
          button.addEventListener('click', () => {
            insertCompanyLogo(pos.id);
            hideLogoDropdown();
          });
          logoDropdown.appendChild(button);
        });
      }

      function positionLogoDropdown() {
        if (!logoPickerButton) return;
        logoDropdown.style.top = '0px';
        logoDropdown.style.left = '0px';
        logoDropdown.classList.add('show');
        const buttonRect = logoPickerButton.getBoundingClientRect();
        const dropdownRect = logoDropdown.getBoundingClientRect();
        let top = buttonRect.bottom + 8;
        let left = buttonRect.left;

        if (top + dropdownRect.height > window.innerHeight - 16) {
          top = buttonRect.top - dropdownRect.height - 8;
        }
        if (top < 16) {
          top = Math.min(buttonRect.bottom + 8, window.innerHeight - dropdownRect.height - 16);
        }
        if (left + dropdownRect.width > window.innerWidth - 16) {
          left = window.innerWidth - dropdownRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }

        logoDropdown.style.top = `${Math.max(16, top)}px`;
        logoDropdown.style.left = `${left}px`;
      }

      function showLogoDropdown() {
        if (!logoPickerButton) return;
        buildLogoPositionMenu();
        positionLogoDropdown();
        isLogoDropdownVisible = true;
        logoPickerButton.setAttribute('aria-expanded', 'true');
      }

      function hideLogoDropdown() {
        logoDropdown.classList.remove('show');
        isLogoDropdownVisible = false;
        if (logoPickerButton) {
          logoPickerButton.setAttribute('aria-expanded', 'false');
        }
      }

      function toggleLogoDropdown() {
        if (isLogoDropdownVisible) {
          hideLogoDropdown();
        } else {
          showLogoDropdown();
        }
      }

      // Logo insertion functions
      function findExistingLogo() {
        // First check for logo marker attribute
        const logoByMarker = canvas.querySelector('.image-element[data-is-logo="true"]');
        if (logoByMarker) return logoByMarker;
        
        // Fallback: check by filename in src
        const imageElements = canvas.querySelectorAll('.image-element');
        for (const element of imageElements) {
          const img = element.querySelector('img');
          if (img && img.src) {
            const src = img.src.toLowerCase();
            if (src.includes('logo')) {
              // Mark it as logo for future detection
              element.dataset.isLogo = 'true';
              return element;
            }
          }
        }
        return null;
      }

      async function findLogoImage() {
        // Use the specific Aramco Digital logo path
        // Try multiple path variations
        const possiblePaths = [
          './CURSOR-Project/public/aramco-digital.L.png',
          'CURSOR-Project/public/aramco-digital.L.png',
          '/CURSOR-Project/public/aramco-digital.L.png'
        ];
        
        // Try each path until one works
        for (const logoPath of possiblePaths) {
          try {
            const img = new Image();
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => reject(new Error('Timeout')), 2000);
              img.onload = () => {
                clearTimeout(timeout);
                resolve();
              };
              img.onerror = () => {
                clearTimeout(timeout);
                reject(new Error('Load failed'));
              };
              img.src = logoPath;
            });
            return logoPath;
          } catch (e) {
            continue;
          }
        }
        
        return null;
      }

      function insertCompanyLogo(position) {
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const padding = 24;
        
        // Check if logo already exists
        const existingLogo = findExistingLogo();
        
        // Create new logo if none exists
        (async () => {
          const logoPath = await findLogoImage();
          
          if (!logoPath) {
            showNotification('Logo image not found. Please rename your logo file to "logo.png", "logo.jpg", "company-logo.png", or "company-logo.jpg" and place it in the ./logo/ folder.');
            return;
          }
          
          // Default logo dimensions
          const defaultWidth = 200;
          const defaultHeight = 80;
          
          // Load the image to verify it exists and get aspect ratio for resizing
          const testImg = new Image();
          let imageLoaded = false;
          let naturalWidth = 0;
          let naturalHeight = 0;
          
          try {
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('Timeout'));
              }, 3000);
              testImg.onload = () => {
                clearTimeout(timeout);
                imageLoaded = true;
                naturalWidth = testImg.naturalWidth || testImg.width || defaultWidth;
                naturalHeight = testImg.naturalHeight || testImg.height || defaultHeight;
                resolve();
              };
              testImg.onerror = () => {
                clearTimeout(timeout);
                reject(new Error('Load failed'));
              };
              testImg.src = logoPath;
            });
          } catch (e) {
            showNotification('Logo image not found. Please check the file path.');
            return;
          }
          
          if (!imageLoaded) {
            showNotification('Logo image failed to load. Please check the file path.');
            return;
          }
          
          // Calculate aspect ratio from natural dimensions for resizing
          const aspectRatio = naturalWidth / naturalHeight;
          
          // Use default dimensions for logo
          const width = defaultWidth;
          const height = defaultHeight;
          
          // Calculate position based on default dimensions
          let left, top;
          switch (position) {
            case 'top-left':
              left = padding;
              top = padding;
              break;
            case 'top-right':
              left = canvasWidth - width - padding;
              top = padding;
              break;
            case 'bottom-left':
              left = padding;
              top = canvasHeight - height - padding;
              break;
            case 'bottom-right':
              left = canvasWidth - width - padding;
              top = canvasHeight - height - padding;
              break;
            default:
              left = padding;
              top = padding;
          }
          
          // If logo already exists, just move it to new position
          if (existingLogo) {
            existingLogo.style.left = `${left}px`;
            existingLogo.style.top = `${top}px`;
            existingLogo.dataset.isLogo = 'true';
            selectImage(existingLogo);
            capture();
            saveEditorState('move_logo');
            showNotification('Logo position updated.');
            return;
          }
          
          // Minimum size for resizing (allow user to resize as they want)
          const minWidth = 40;
          const minHeight = 16;
          
          const element = createImageElement({
            src: logoPath,
            left,
            top,
            width: width,
            height: height,
            minWidth: minWidth,
            minHeight: minHeight,
            aspectRatio: aspectRatio,
            animate: true,
            select: true
          });
          
          if (element) {
            // Mark element as company logo
            element.dataset.isLogo = 'true';
            const img = element.querySelector('img');
            if (img) {
              img.onerror = () => {
                showNotification('Logo image failed to load. Please check the file path and format.');
              };
            }
            capture();
            saveEditorState('insert_logo');
            showNotification('Company logo inserted.');
          }
        })();
      }

      if (tablePickerButton) {
        tablePickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleTableInsertPanel();
        });
      }

      if (logoPickerButton) {
        logoPickerButton.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          
          // Check if logo already exists
          const existingLogo = findExistingLogo();
          
          if (existingLogo) {
            // If logo exists, show dropdown to change position
          toggleLogoDropdown();
          } else {
            // If no logo exists, insert it in top-left corner by default
            insertCompanyLogo('top-left');
          }
        });
      }

      document.addEventListener('click', (event) => {
        if (!isShapeDropdownVisible) return;
        if (shapeDropdown.contains(event.target) || (shapePickerButton && shapePickerButton.contains(event.target))) {
          return;
        }
        hideShapeDropdown();
        
        if (isLayoutDropdownVisible) {
          if (layoutDropdown.contains(event.target) || (layoutButton && layoutButton.contains(event.target))) {
            return;
          }
          hideLayoutDropdown();
        }
      });

      document.addEventListener('click', (event) => {
        if (!isChartDropdownVisible) return;
        if (chartDropdown.contains(event.target) || (chartPickerButton && chartPickerButton.contains(event.target))) {
          return;
        }
        hideChartDropdown();
      });

      document.addEventListener('click', (event) => {
        if (!isIconDropdownVisible) return;
        if (iconDropdown.contains(event.target) || (iconPickerButton && iconPickerButton.contains(event.target))) {
          return;
        }
        hideIconDropdown();
      });

      document.addEventListener('click', (event) => {
        if (!isTablePanelVisible) return;
        if (tableInsertPanel.contains(event.target) || (tablePickerButton && tablePickerButton.contains(event.target))) {
          return;
        }
        hideTableInsertPanel();
      });

      document.addEventListener('click', (event) => {
        if (!isLogoDropdownVisible) return;
        if (logoDropdown.contains(event.target) || (logoPickerButton && logoPickerButton.contains(event.target))) {
          return;
        }
        hideLogoDropdown();
      });

      window.addEventListener('resize', () => {
        if (isShapeDropdownVisible) {
          positionShapeDropdown();
        }
        if (isChartDropdownVisible) {
          positionChartDropdown();
        }
        if (isTablePanelVisible) {
          positionTableInsertPanel();
        }
        if (isLogoDropdownVisible) {
          positionLogoDropdown();
        }
        if (isLayoutDropdownVisible) {
          positionLayoutDropdown();
        }
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget) {
          positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        }
      });

      window.addEventListener('scroll', (event) => {
        if (isShapeDropdownVisible && !shapeDropdown.contains(event.target)) {
          hideShapeDropdown();
        }
        if (isChartDropdownVisible && !chartDropdown.contains(event.target)) {
          hideChartDropdown();
        }
        if (isTablePanelVisible && !tableInsertPanel.contains(event.target)) {
          hideTableInsertPanel();
        }
        if (isLogoDropdownVisible && !logoDropdown.contains(event.target)) {
          hideLogoDropdown();
        }
        if (isLayoutDropdownVisible) {
          positionLayoutDropdown();
        }
      }, true);

      window.addEventListener('scroll', () => {
        if (selectedShape && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedShape);
        }
        if (selectedIcon && shapeColorPicker.classList.contains('visible')) {
          positionShapeColorPicker(selectedIcon);
        }
        if (isChartDropdownVisible) {
          positionChartDropdown();
        }
        if (rotationTarget && shapeRotationHandle.classList.contains('visible')) {
          positionRotationHandle(rotationTarget);
        }
        if (isTablePanelVisible) {
          positionTableInsertPanel();
        }
        if (isLogoDropdownVisible) {
          positionLogoDropdown();
        }
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget) {
          positionTableColumnColorPicker(tableColumnColorTarget, tableColumnColorIndex);
        }
      }, true);

      function clearShapeSelection() {
        if (selectedShape) {
          const removedId = selectedShape.dataset.elementId;
          selectedShape.classList.remove('selected');
          selectedShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
        hideShapeColorPicker();
        hideShapeSizeBadge();
        hideRotationHandle();
        activeResizeShape = null;
      }

      function clearChartSelection() {
        if (selectedChart) {
          const removedId = selectedChart.dataset.elementId;
          selectedChart.classList.remove('selected');
          if (rotationTarget === selectedChart) {
            hideRotationHandle();
          }
          selectedChart = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
        hideChartDataEditor();
      }

      function clearImageSelection() {
        if (selectedImage) {
          const removedId = selectedImage.dataset.elementId;
          selectedImage.classList.remove('selected');
          if (rotationTarget === selectedImage) {
            hideRotationHandle();
          }
          selectedImage = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
      }

      function clearVideoSelection() {
        if (selectedVideo) {
          const removedId = selectedVideo.dataset.elementId;
          selectedVideo.classList.remove('selected');
          if (rotationTarget === selectedVideo) {
            hideRotationHandle();
          }
          selectedVideo = null;
          hideShapeSizeBadge();
          activeResizeShape = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
      }

      function clearSelectedTableElement() {
        if (selectedTable) {
          const removedId = selectedTable.dataset.elementId;
          clearTableSelection(selectedTable);
          selectedTable.classList.remove('selected');
          selectedTable = null;
          if (removedId && currentAnimationSelectedElementId === removedId) {
            handleAnimationSelectionChange(null);
          }
        }
        if (rotationTarget && rotationTarget.classList && rotationTarget.classList.contains('table-element')) {
          hideRotationHandle();
        }
        hideTableColumnColorPicker(true);
        clearChartSelection();
        clearVideoSelection();
      }

      function selectShape(element) {
        if (!element || !element.classList.contains('shape-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        clearIconSelection();
        if (selectedShape && selectedShape !== element) {
          selectedShape.classList.remove('selected');
        }
        selectedShape = element;
        element.classList.add('selected');
        showShapeColorPicker(element);
        handleAnimationSelectionChange(element);

        setTimeout(() => {
          document.addEventListener('click', function shapeDeselectHandler(e) {
            if (!element.contains(e.target)) {
              if (selectedShape === element) {
                clearShapeSelection();
              }
              document.removeEventListener('click', shapeDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteShape(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedShape === element) {
          selectedShape = null;
          hideShapeColorPicker();
          hideRotationHandle();
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_shape');
        updateElementContextMenuState();
      }

      function deleteChart(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedChart === element) {
          selectedChart = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        if (activeChartDataElement === element) {
          hideChartDataEditor();
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_chart');
        updateElementContextMenuState();
      }

      function selectChart(element) {
        if (!element || !element.classList.contains('chart-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        if (selectedChart && selectedChart !== element) {
          selectedChart.classList.remove('selected');
        }
        clearShapeSelection();
        clearImageSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        clearIconSelection();
        selectedChart = element;
        element.classList.add('selected');
        showChartDataEditor(element);
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function chartDeselectHandler(event) {
            // Don't close if clicking inside the chart data editor (including variant buttons)
            if (event.target.closest('#chartDataEditor')) {
              return;
            }
            // Don't close if clicking on the chart element itself
            if (element.contains(event.target)) {
              return;
            }
            // Close only if clicking outside both the chart and the editor
            if (selectedChart === element) {
              clearChartSelection();
            }
            document.removeEventListener('click', chartDeselectHandler);
          }, { once: true });
        }, 0);
      }

      function selectImage(element) {
        if (!element || !element.classList.contains('image-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearShapeSelection();
        clearVideoSelection();
        clearSelectedTableElement();
        clearIconSelection();
        if (selectedImage && selectedImage !== element) {
          selectedImage.classList.remove('selected');
        }
        selectedImage = element;
        element.classList.add('selected');
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function imageDeselectHandler(event) {
            if (!element.contains(event.target)) {
              if (selectedImage === element) {
                clearImageSelection();
              }
              document.removeEventListener('click', imageDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteImage(element, options = {}) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        const { skipCapture = false, skipHistory = false } = options;
        if (selectedImage === element) {
          selectedImage = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        if (!skipCapture) {
          capture();
        }
        if (!skipHistory) {
          saveEditorState('delete_image');
        }
        updateElementContextMenuState();
      }

      function selectVideo(element) {
        if (!element || !element.classList.contains('video-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearChartSelection();
        clearShapeSelection();
        clearImageSelection();
        clearSelectedTableElement();
        clearIconSelection();
        if (selectedVideo && selectedVideo !== element) {
          selectedVideo.classList.remove('selected');
        }
        selectedVideo = element;
        element.classList.add('selected');
        createResizeEdges(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function videoDeselectHandler(event) {
            if (!element.contains(event.target)) {
              if (selectedVideo === element) {
                clearVideoSelection();
              }
              document.removeEventListener('click', videoDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteVideo(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedVideo === element) {
          selectedVideo = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        const video = element.querySelector('video');
        if (video) {
          video.pause();
        }
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_video');
        updateElementContextMenuState();
      }

      function selectTableElement(element) {
        if (!element || !element.classList.contains('table-element')) return;
        clearGroupSelection();
        if (selectedTextBox) {
          selectedTextBox.classList.remove('selected');
          selectedTextBox = null;
        }
        clearShapeSelection();
        clearImageSelection();
        clearChartSelection();
        clearIconSelection();
        if (selectedTable && selectedTable !== element) {
          clearTableSelection(selectedTable);
          selectedTable.classList.remove('selected');
          if (rotationTarget === selectedTable) {
            hideRotationHandle();
          }
        }
        selectedTable = element;
        element.classList.add('selected');
        showRotationHandle(element);
        handleAnimationSelectionChange(element);
        setTimeout(() => {
          document.addEventListener('click', function tableDeselectHandler(event) {
            if (!element.contains(event.target) && event.target !== element) {
              if (selectedTable === element) {
                clearSelectedTableElement();
              }
              document.removeEventListener('click', tableDeselectHandler);
            }
          }, { once: true });
        }, 0);
      }

      function deleteTable(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        if (selectedTable === element) {
          selectedTable = null;
          if (rotationTarget === element) {
            hideRotationHandle();
          }
        }
        if (tableColumnColorTarget === element) {
          hideTableColumnColorPicker(true);
        }
        clearTableSelection(element);
        teardownTableResizing(element);
        handleElementAnimationRemoval(element.dataset.elementId);
        element.remove();
        capture();
        saveEditorState('delete_table');
        updateElementContextMenuState();
      }

      function renderShapeSvg(shape) {
        const strokeWidth = typeof shape.strokeWidth === 'number' ? shape.strokeWidth : 0;
        return `
          <svg class="shape-svg" viewBox="${shape.viewBox}" preserveAspectRatio="none">
            <g class="shape-geometry" fill="currentColor" stroke="currentColor"
               stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round">
              ${shape.svg}
            </g>
          </svg>
        `;
      }

      function escapeHtml(value) {
        if (value == null) return '';
        return String(value).replace(/[&<>"']/g, (char) => {
          switch (char) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            case "'": return '&#39;';
            default: return char;
          }
        });
      }

      function normalizeNumberArray(value, fallback = []) {
        if (Array.isArray(value)) {
          return value
            .map((num) => Number(num))
            .filter((num) => Number.isFinite(num));
        }
        if (typeof value === 'string' && value.trim()) {
          try {
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) {
              return parsed
                .map((num) => Number(num))
                .filter((num) => Number.isFinite(num));
            }
          } catch (error) {
            // ignore
          }
        }
        return Array.isArray(fallback)
          ? fallback.map((num) => Number(num)).filter((num) => Number.isFinite(num))
          : [];
      }

      function normalizeChartLegend(value, fallback = []) {
        let source = fallback;
        if (Array.isArray(value)) {
          source = value;
        } else if (typeof value === 'string' && value.trim()) {
          try {
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) {
              source = parsed;
            }
          } catch (error) {
            source = fallback;
          }
        }
        return (Array.isArray(source) ? source : [])
          .map((item) => ({
            label: typeof item?.label === 'string' ? item.label : '',
            color: item?.color || '#60a5fa'
          }));
      }

      function renderChartLegendHtml(legend, values = [], { showValues = false } = {}) {
        if (!Array.isArray(legend) || !legend.length) return '';
        const items = legend.map((item, index) => {
          const swatchColor = normalizeColorHex(item.color || '#60a5fa');
          const swatch = `<span class="chart-legend-swatch" style="background:${escapeHtml(swatchColor)};"></span>`;
          const label = escapeHtml(item.label || '');
          let valueMarkup = '';
          if (showValues && Array.isArray(values)) {
            const value = values[index];
            const numericValue = Number(value);
            const displayValue = Number.isFinite(numericValue) ? numericValue.toString() : (value != null ? String(value) : '');
            if (displayValue) {
              valueMarkup = ` <span class="chart-legend-value">${escapeHtml(displayValue)}</span>`;
            }
          }
          return `
          <div class="chart-legend-item">
            ${swatch}
            ${label}${valueMarkup}
          </div>`;
        }).join('');
        return `<div class="chart-legend">${items}</div>`;
      }

      function normalizeLineCategories(value, fallback = [], desiredLength = 0) {
        let categories = normalizeChartLegend(value, fallback);
        const baseFallback = Array.isArray(fallback) ? fallback : [];
        if (desiredLength > 0) {
          if (categories.length > desiredLength) {
            categories = categories.slice(0, desiredLength);
          }
          while (categories.length < desiredLength) {
            const index = categories.length;
            const fallbackItem = baseFallback[index] || {};
            categories.push({
              label: typeof fallbackItem.label === 'string' && fallbackItem.label.trim()
                ? fallbackItem.label.trim()
                : `Point ${index + 1}`,
              color: normalizeColorHex(
                fallbackItem.color || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
              )
            });
          }
        }
        return categories;
      }

      function adjustNumberArrayLength(values, desiredLength, fallbackValues = []) {
        if (!Number.isFinite(desiredLength) || desiredLength <= 0) {
          return values.slice();
        }
        const result = values.slice(0, desiredLength);
        const fallbackArray = Array.isArray(fallbackValues) ? fallbackValues : [];
        while (result.length < desiredLength) {
          const fallbackValue = Number(fallbackArray[result.length]);
          if (Number.isFinite(fallbackValue)) {
            result.push(fallbackValue);
          } else if (result.length) {
            result.push(result[result.length - 1]);
          } else {
            result.push(0);
          }
        }
        return result;
      }

      function normalizeLineSeries(value, fallback = [], pointCount = 0) {
        let source = value;
        if (typeof source === 'string' && source.trim()) {
          try {
            const parsed = JSON.parse(source);
            if (Array.isArray(parsed)) {
              source = parsed;
            }
          } catch (error) {
            source = [];
          }
        }
        if (!Array.isArray(source) || !source.length) {
          source = Array.isArray(fallback) ? fallback : [];
        }
        const fallbackArray = Array.isArray(fallback) ? fallback : [];
        const length = Math.max(Array.isArray(source) ? source.length : 0, 1);
        const normalized = [];
        for (let index = 0; index < length; index += 1) {
          const baseItem = Array.isArray(source) ? source[index] : null;
          const fallbackItem = fallbackArray[index] || {};
          const baseLabel = typeof baseItem?.label === 'string' && baseItem.label.trim()
            ? baseItem.label.trim()
            : '';
          const fallbackLabel = typeof fallbackItem.label === 'string' && fallbackItem.label.trim()
            ? fallbackItem.label.trim()
            : `Line ${index + 1}`;
          const label = baseLabel || fallbackLabel;
          const color = normalizeColorHex(
            baseItem?.color
            || fallbackItem.color
            || CHART_COLOR_SEQUENCE[index % CHART_COLOR_SEQUENCE.length]
          );
          const rawValues = Array.isArray(baseItem?.values) && baseItem.values.length
            ? baseItem.values
            : (Array.isArray(fallbackItem.values) ? fallbackItem.values : []);
          const numericValues = rawValues
            .map((num) => {
              const parsed = Number(num);
              return Number.isFinite(parsed) ? parsed : 0;
            });
          const adjustedValues = pointCount > 0
            ? adjustNumberArrayLength(numericValues, pointCount, fallbackItem.values || [])
            : numericValues.slice();
          normalized.push({
            label,
            color,
            values: adjustedValues
          });
        }
        if (!normalized.length) {
          const defaultLength = pointCount > 0 ? pointCount : 1;
          normalized.push({
            label: 'Line 1',
            color: normalizeColorHex(CHART_COLOR_SEQUENCE[0]),
            values: Array.from({ length: defaultLength }, () => 50)
          });
        }
        return normalized;
      }

      function getLineChartState(element, chartConfig, { ensureDataset = false } = {}) {
        if (!element) {
          return { categories: [], series: [] };
        }
        const fallbackCategories = chartConfig?.legend || [];
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        const legacyPoints = normalizeNumberArray(element.dataset.points, chartConfig?.points || []);
        let pointCount = 0;
        let categories = normalizeLineCategories(element.dataset.legend, fallbackCategories);
        pointCount = categories.length;
        if (!pointCount) {
          pointCount = fallbackSeries[0]?.values?.length
            || legacyPoints.length
            || (chartConfig?.points?.length || 5);
        }
        categories = normalizeLineCategories(element.dataset.legend, fallbackCategories, pointCount);
        let series = normalizeLineSeries(element.dataset.lineSeries, fallbackSeries, pointCount);
        if (!series.length && legacyPoints.length) {
          const fallbackColor = fallbackSeries[0]?.color
            || fallbackCategories[0]?.color
            || CHART_COLOR_SEQUENCE[0];
          series = normalizeLineSeries(
            [{
              label: fallbackSeries[0]?.label || 'Line 1',
              color: fallbackColor,
              values: legacyPoints
            }],
            fallbackSeries,
            pointCount
          );
        }
        if (!series.length) {
          series = normalizeLineSeries(fallbackSeries, fallbackSeries, pointCount);
        }
        const normalizedCategories = normalizeLineCategories(categories, fallbackCategories, pointCount);
        const normalizedSeries = normalizeLineSeries(series, fallbackSeries, pointCount);
        if (ensureDataset && (!element.dataset.lineSeries || !element.dataset.lineSeries.length)) {
          setLineChartState(element, chartConfig, {
            categories: normalizedCategories,
            series: normalizedSeries,
            title: element.dataset.title || '',
            showValues: element.dataset.showValues === 'true'
          });
        }
        return {
          categories: normalizedCategories,
          series: normalizedSeries
        };
      }

      function setLineChartState(element, chartConfig, state = {}) {
        if (!element) return;
        const fallbackCategories = chartConfig?.legend || [];
        const fallbackSeries = Array.isArray(chartConfig?.series) ? chartConfig.series : [];
        const categoriesInput = Array.isArray(state.categories) ? state.categories : [];
        const seriesInput = Array.isArray(state.series) ? state.series : [];
        const inferredLength = Math.max(
          categoriesInput.length,
          seriesInput.reduce((max, series) => Math.max(max, Array.isArray(series?.values) ? series.values.length : 0), 0),
          1
        );
        const normalizedCategories = normalizeLineCategories(categoriesInput, fallbackCategories, inferredLength);
        const normalizedSeries = normalizeLineSeries(seriesInput, fallbackSeries, inferredLength);
        element.dataset.legend = JSON.stringify(normalizedCategories);
        element.dataset.lineSeries = JSON.stringify(normalizedSeries);
        delete element.dataset.points;
        delete element.dataset.bars;
        delete element.dataset.slices;
        if (typeof state.title === 'string') {
          element.dataset.title = state.title;
        }
        if (typeof state.showValues === 'boolean') {
          element.dataset.showValues = state.showValues ? 'true' : 'false';
        }
        const payload = {
          legend: normalizedCategories,
          lineSeries: normalizedSeries,
          title: element.dataset.title || chartConfig?.name || 'Chart',
          showValues: element.dataset.showValues === 'true'
        };
        element.innerHTML = renderChartMarkup(chartConfig, payload);
        createResizeEdges(element);
      }

      function buildPieGradient(slices, legend) {
        const colors = (Array.isArray(legend) && legend.length
          ? legend.map((item) => item.color || '#60a5fa')
          : ['#60a5fa', '#34d399', '#f97316', '#fbbf24']);
        const validSlices = (Array.isArray(slices) && slices.length ? slices : [1, 1, 1])
          .map((value) => Math.max(0, Number(value) || 0));
        const total = validSlices.reduce((sum, value) => sum + value, 0) || 1;
        let start = 0;
        const segments = validSlices.map((value, index) => {
          const angle = (value / total) * 360;
          const end = start + angle;
          const color = colors[index % colors.length];
          const segment = `${color} ${start}deg ${end}deg`;
          start = end;
          return segment;
        });
        return `conic-gradient(${segments.join(', ')})`;
      }

      function renderChartMarkup(chart, data = {}) {
        const legend = normalizeChartLegend(data.legend, chart.legend || []);
        const title = escapeHtml(data.title || chart.name || 'Chart');
        const chartType = chart.type || chart.id;
        const showValues = Boolean(data.showValues);
        if (chartType === 'bar') {
          const bars = normalizeNumberArray(data.bars, chart.bars || [60, 80, 50]);
          const maxBar = Math.max(...bars, 1);
          const colors = legend.length ? legend.map((item) => item.color || '#60a5fa') : ['#60a5fa', '#34d399', '#fbbf24', '#f97316'];
          const variantClass = chart.variant ? ` chart-bars--${chart.variant}` : '';
          const barsHtml = bars.map((value, index) => {
            const heightPercent = Math.max(8, Math.min(100, (value / maxBar) * 100));
            const color = escapeHtml(colors[index % colors.length]);
            let barStyle = `height:${heightPercent}%;`;
            if (chart.variant === 'gradient') {
              barStyle += `background: linear-gradient(180deg, rgba(255,255,255,0.35) 0%, rgba(0,0,0,0.12) 100%), ${color};`;
            } else {
              barStyle += `background:${color};`;
            }
            if (chart.variant === 'rounded') {
              barStyle += 'border-radius:16px 16px 6px 6px;';
            } else {
              barStyle += 'border-radius:10px 10px 4px 4px;';
            }
            if (showValues) {
              const numericValue = Number(value);
              const displayValue = Number.isFinite(numericValue) ? numericValue.toString() : (value != null ? String(value) : '');
              const valueBadge = displayValue ? `<span class="chart-bar-value">${escapeHtml(displayValue)}</span>` : '';
              return `
                <div class="chart-bar-wrapper">
                  <div class="chart-bar" style="${barStyle}"></div>
                  ${valueBadge}
                </div>
              `;
            }
            return `<div class="chart-bar" style="${barStyle}"></div>`;
          }).join('');
          return `
            <div class="chart-title">${title}</div>
            <div class="chart-visual">
              <div class="chart-bars${variantClass}">
                ${barsHtml}
              </div>
            </div>
            ${renderChartLegendHtml(legend, bars, { showValues })}
          `;
        }
        if (chartType === 'line') {
          const width = 240;
          const height = 140;
          const paddingX = 24;
          const paddingY = 16;
          const innerWidth = width - paddingX * 2;
          const innerHeight = height - paddingY * 2;
          const fallbackSeries = Array.isArray(chart.series) ? chart.series : [];
          const legacyPoints = normalizeNumberArray(data.points, chart.points || []);
          let categories = normalizeChartLegend(data.legend, chart.legend || []);
          let pointCount = categories.length;
          if (!pointCount) {
            pointCount = fallbackSeries[0]?.values?.length
              || legacyPoints.length
              || (chart.points?.length || 5);
          }
          let lineSeries = normalizeLineSeries(data.lineSeries, fallbackSeries, pointCount);
          if (!lineSeries.length && legacyPoints.length) {
            const fallbackColor = fallbackSeries[0]?.color || categories[0]?.color || CHART_COLOR_SEQUENCE[0];
            lineSeries = normalizeLineSeries(
              [{
                label: fallbackSeries[0]?.label || 'Line 1',
                color: fallbackColor,
                values: legacyPoints
              }],
              fallbackSeries,
              pointCount
            );
          }
          if (!lineSeries.length) {
            lineSeries = normalizeLineSeries(fallbackSeries, fallbackSeries, pointCount);
          }
          const finalPointCount = Math.max(
            pointCount,
            lineSeries.reduce((max, series) => Math.max(max, Array.isArray(series.values) ? series.values.length : 0), 0),
            1
          );
          const normalizedCategories = normalizeLineCategories(categories, chart.legend || [], finalPointCount);
          const normalizedSeries = normalizeLineSeries(lineSeries, fallbackSeries, finalPointCount);
          const xCoords = [];
          for (let index = 0; index < finalPointCount; index += 1) {
            const x = paddingX + (finalPointCount <= 1
              ? innerWidth / 2
              : (innerWidth / Math.max(finalPointCount - 1, 1)) * index);
            xCoords.push(x);
          }
          const allValues = normalizedSeries.reduce((acc, series) => {
            if (Array.isArray(series.values)) {
              series.values.forEach((value) => {
                const numeric = Number(value);
                if (Number.isFinite(numeric)) {
                  acc.push(numeric);
                }
              });
            }
            return acc;
          }, []);
          const maxValue = allValues.length ? Math.max(...allValues, 1) : 1;
          const minValue = allValues.length ? Math.min(...allValues, 0) : 0;
          const range = Math.max(maxValue - minValue, 1);
          const pathClass = chart.variant === 'dotted'
            ? 'chart-line-path line-dotted'
            : (chart.variant === 'smooth' ? 'chart-line-path line-smooth' : 'chart-line-path');
          const seriesPaths = [];
          const seriesPoints = [];
          const seriesBadges = [];
          normalizedSeries.forEach((series, seriesIndex) => {
            const color = normalizeColorHex(series.color || CHART_COLOR_SEQUENCE[seriesIndex % CHART_COLOR_SEQUENCE.length]);
            const coords = (Array.isArray(series.values) ? series.values : []).map((value, pointIndex) => {
              const numericValue = Number(value);
              const safeValue = Number.isFinite(numericValue) ? numericValue : 0;
              const x = xCoords[pointIndex] ?? xCoords[xCoords.length - 1] ?? paddingX;
              const y = paddingY + innerHeight - ((safeValue - minValue) / range) * innerHeight;
              return { x, y, value: safeValue };
            });
            if (coords.length) {
              let pathD = '';
              coords.forEach((point, index) => {
                pathD += index === 0 ? `M ${point.x} ${point.y}` : ` L ${point.x} ${point.y}`;
              });
              seriesPaths.push(`<path class="${pathClass}" d="${pathD}" stroke="${escapeHtml(color)}"></path>`);
              seriesPoints.push(coords.map((point) => (
                `<circle class="chart-line-point" cx="${point.x}" cy="${point.y}" r="5" fill="${escapeHtml(color)}"></circle>`
              )).join(''));
              if (showValues) {
                seriesBadges.push(coords.map((point) => (
                  `<span class="chart-line-value" style="left:${point.x}px; top:${point.y}px; transform: translate(-50%, calc(-120% - ${seriesIndex * 14}px));">${escapeHtml(String(point.value))}</span>`
                )).join(''));
              }
            }
          });
          const axisLabels = normalizedCategories.map((item, index) => {
            const x = xCoords[index] ?? xCoords[xCoords.length - 1] ?? paddingX;
            return `<span class="chart-line-axis-label" style="left:${x}px;">${escapeHtml(item.label || `Point ${index + 1}`)}</span>`;
          }).join('');
          const axisMarkup = `<div class="chart-line-axis">${axisLabels}</div>`;
          const valueBadgesMarkup = showValues ? seriesBadges.join('') : '';
          return `
            <div class="chart-title">${title}</div>
            <div class="chart-visual">
              <div class="chart-line-wrapper">
                <svg class="chart-line-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                  ${seriesPaths.join('')}
                  ${seriesPoints.join('')}
                </svg>
                ${axisMarkup}
                ${valueBadgesMarkup}
              </div>
            </div>
            ${renderChartLegendHtml(normalizedSeries)}
          `;
        }
        const slices = normalizeNumberArray(data.slices, chart.slices || [40, 35, 25]);
        const positiveSlices = slices.map((value) => Math.max(0, Number(value) || 0));
        const totalSlices = positiveSlices.reduce((sum, value) => sum + value, 0);
        const gradient = buildPieGradient(slices, legend);
        const variantClass = chart.variant ? ` chart-pie--${chart.variant}` : '';
        let pieMarkup;
        if (showValues && totalSlices > 0) {
          let cumulative = 0;
          const radius = 70;
          const innerRadius = chart.variant === 'donut' ? radius * 0.75 : radius * 0.6;
          const labels = positiveSlices.map((value, index) => {
            if (value <= 0) return '';
            const startAngle = cumulative / totalSlices * Math.PI * 2;
            const sliceAngle = value / totalSlices * Math.PI * 2;
            cumulative += value;
            const midAngle = startAngle + sliceAngle / 2;
            const labelRadius = chart.variant === 'donut' ? (radius + innerRadius) / 2 : radius * 0.65;
            let x = radius + Math.cos(midAngle) * labelRadius;
            let y = radius + Math.sin(midAngle) * labelRadius;
            const padding = 14;
            x = Math.min(Math.max(padding, x), radius * 2 - padding);
            y = Math.min(Math.max(padding, y), radius * 2 - padding);
            const numericValue = Number(slices[index]);
            const displayValue = Number.isFinite(numericValue) ? numericValue.toString() : (slices[index] != null ? String(slices[index]) : value.toString());
            return `<span class="chart-pie-label" style="left:${x}px; top:${y}px;">${escapeHtml(displayValue)}</span>`;
          }).join('');
          const backgroundStyle = chart.variant === 'gradient' 
            ? `background: radial-gradient(circle at 50% 25%, rgba(255, 255, 255, 0.45) 0%, rgba(255, 255, 255, 0.15) 35%, rgba(0, 0, 0, 0.15) 100%), ${gradient};`
            : `background:${gradient};`;
          pieMarkup = `
            <div class="chart-pie-wrapper">
              <div class="chart-pie${variantClass}" style="${backgroundStyle}"></div>
              <div class="chart-pie-labels">${labels}</div>
            </div>
          `;
        } else {
          const backgroundStyle = chart.variant === 'gradient' 
            ? `background: radial-gradient(circle at 50% 25%, rgba(255, 255, 255, 0.45) 0%, rgba(255, 255, 255, 0.15) 35%, rgba(0, 0, 0, 0.15) 100%), ${gradient};`
            : `background:${gradient};`;
          pieMarkup = `<div class="chart-pie${variantClass}" style="${backgroundStyle}"></div>`;
        }
        return `
          <div class="chart-title">${title}</div>
          <div class="chart-visual">
            ${pieMarkup}
          </div>
          ${renderChartLegendHtml(legend, slices, { showValues })}
        `;
      }

      function createChartElement(chart, options = {}) {
        if (!chart) return null;
        const element = document.createElement('div');
        element.className = 'chart-element';
        const elementId = options.id || generateElementId('chart');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        element.dataset.chartType = chart.id;
        if (chart.variant) {
          element.dataset.chartVariant = chart.variant;
        } else {
          delete element.dataset.chartVariant;
        }

        const minWidth = options.minWidth || chart.minWidth || 220;
        const minHeight = options.minHeight || chart.minHeight || 160;
        element.dataset.minWidth = String(minWidth);
        element.dataset.minHeight = String(minHeight);

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;

        const parsedWidth = Number(options.width);
        const parsedHeight = Number(options.height);
        const width = Number.isFinite(parsedWidth) && parsedWidth > 0 ? parsedWidth : chart.defaultWidth || 320;
        const height = Number.isFinite(parsedHeight) && parsedHeight > 0 ? parsedHeight : chart.defaultHeight || 220;
        const actualWidth = Math.max(minWidth, width);
        const actualHeight = Math.max(minHeight, height);
        element.style.width = `${actualWidth}px`;
        element.style.height = `${actualHeight}px`;

        const parsedLeft = Number(options.left);
        const parsedTop = Number(options.top);
        const left = Number.isFinite(parsedLeft) ? parsedLeft : (canvasWidth - actualWidth) / 2;
        const top = Number.isFinite(parsedTop) ? parsedTop : (canvasHeight - actualHeight) / 2;

        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        const rotation = Number.isFinite(Number(options.rotation)) ? Number(options.rotation) : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;

        const legend = normalizeChartLegend(options.legend, chart.legend || []);
        const chartType = chart.type || chart.id;
        const bars = chartType === 'bar' ? normalizeNumberArray(options.bars, chart.bars || []) : [];
        const slices = chartType === 'pie' ? normalizeNumberArray(options.slices, chart.slices || []) : [];
        let lineSeries = [];
        if (chartType === 'line') {
          const fallbackSeries = Array.isArray(chart.series) ? chart.series : [];
          const legacyPoints = normalizeNumberArray(options.points, chart.points || []);
          const pointCount = Math.max(
            legend.length,
            legacyPoints.length,
            fallbackSeries.reduce((max, series) => Math.max(max, Array.isArray(series?.values) ? series.values.length : 0), 0),
            1
          );
          if (Array.isArray(options.lineSeries) && options.lineSeries.length) {
            lineSeries = normalizeLineSeries(options.lineSeries, fallbackSeries, pointCount);
          } else if (legacyPoints.length) {
            const fallbackColor = fallbackSeries[0]?.color || legend[0]?.color || CHART_COLOR_SEQUENCE[0];
            lineSeries = normalizeLineSeries(
              [{
                label: fallbackSeries[0]?.label || 'Line 1',
                color: fallbackColor,
                values: legacyPoints
              }],
              fallbackSeries,
              pointCount
            );
          } else {
            lineSeries = normalizeLineSeries(fallbackSeries, fallbackSeries, pointCount);
          }
          legend.splice(0, legend.length, ...normalizeLineCategories(legend, chart.legend || [], pointCount));
        }
        const chartTitle = typeof options.title === 'string' ? options.title : '';

        element.dataset.legend = JSON.stringify(legend);
        if (chartType === 'bar') {
          element.dataset.bars = JSON.stringify(bars);
        } else if (chartType === 'line') {
          element.dataset.lineSeries = JSON.stringify(lineSeries);
          delete element.dataset.points;
          delete element.dataset.bars;
          delete element.dataset.slices;
        } else {
          element.dataset.slices = JSON.stringify(slices);
          delete element.dataset.bars;
          delete element.dataset.points;
          delete element.dataset.lineSeries;
        }
        element.dataset.title = chartTitle;
        const showValues = options.showValues === true || element.dataset.showValues === 'true';
        element.dataset.showValues = showValues ? 'true' : 'false';

        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '6';
        const payload = {
          legend,
          title: chartTitle,
          showValues
        };
        if (chartType === 'line') {
          payload.lineSeries = lineSeries;
        } else if (chartType === 'bar') {
          payload.bars = bars;
        } else if (chartType === 'pie') {
          payload.slices = slices;
        }
        element.innerHTML = renderChartMarkup(chart, payload);

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectChart(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectChart(element);
        });

        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectChart(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectChart(element);
        }

        return element;
      }

      function instantiateChart(chartData) {
        if (!chartData) return null;
        let chartId = chartData.chartType;
        if ((!chartId || !CHART_OPTION_MAP.has(chartId)) && chartData.chartVariant) {
          chartId = `pie-${chartData.chartVariant}`;
        }
        const chart = getChartOptionById(chartId);
        if (!chart) return null;
        const element = createChartElement(chart, {
          id: chartData.id,
          left: chartData.left,
          top: chartData.top,
          width: chartData.width,
          height: chartData.height,
          rotation: chartData.rotation,
          minWidth: chartData.minWidth,
          minHeight: chartData.minHeight,
          bars: chartData.bars,
          slices: chartData.slices,
          lineSeries: chartData.lineSeries,
          legend: chartData.legend,
          title: chartData.title,
          showValues: chartData.showValues === true || chartData.showValues === 'true',
          zIndex: chartData.zIndex,
          select: false
        });
        return element;
      }

      function insertChart(chartId) {
        const chart = getChartOptionById(chartId);
        if (!chart) return;
        const element = createChartElement(chart, { select: true });
        if (element) {
          capture();
          saveEditorState('add_chart');
        }
      }

      function createShapeElement(shape, options = {}) {
        if (!shape) return null;
        const element = document.createElement('div');
        element.className = 'shape-element';
        const elementId = options.id || generateElementId('shape');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        element.dataset.shape = shape.id;
        const minWidth = options.minWidth || shape.minWidth || 60;
        const minHeight = options.minHeight || shape.minHeight || 60;
        element.dataset.minWidth = String(minWidth);
        element.dataset.minHeight = String(minHeight);
        const color = normalizeColorHex(options.color || shape.defaultColor || '#e8f5e9');
        element.dataset.color = color;
        element.style.color = color;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? options.zIndex : 2;

        const parsedWidth = Number(options.width);
        const parsedHeight = Number(options.height);
        const width = Number.isFinite(parsedWidth) && parsedWidth > 0 ? parsedWidth : (shape.defaultWidth || 160);
        const height = Number.isFinite(parsedHeight) && parsedHeight > 0 ? parsedHeight : (shape.defaultHeight || 140);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        const innerWidth = canvas.clientWidth;
        const innerHeight = canvas.clientHeight;
        const defaultLeft = (innerWidth - width) / 2;
        const defaultTop = (innerHeight - height) / 2;
        const parsedLeft = Number(options.left);
        const parsedTop = Number(options.top);
        const left = Number.isFinite(parsedLeft) ? parsedLeft : defaultLeft;
        const top = Number.isFinite(parsedTop) ? parsedTop : defaultTop;

        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        const rotation = Number.isFinite(Number(options.rotation)) ? Number(options.rotation) : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.innerHTML = renderShapeSvg(shape);
        const svg = element.querySelector('.shape-svg');
        if (svg) {
          svg.style.width = '100%';
          svg.style.height = '100%';
        }

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectShape(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectShape(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectShape(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectShape(element);
        }

        return element;
      }

      function instantiateShape(shapeData) {
        if (!shapeData) return;
        const shape = SHAPE_OPTION_MAP.get(shapeData.shapeId) || SHAPE_OPTIONS[0];
        if (!shape) return;
        const element = createShapeElement(shape, {
          id: shapeData.id,
          left: shapeData.left,
          top: shapeData.top,
          width: shapeData.width,
          height: shapeData.height,
          color: shapeData.color,
          zIndex: shapeData.zIndex,
          minWidth: shapeData.minWidth,
          minHeight: shapeData.minHeight,
          rotation: shapeData.rotation
        });
        if (element && shapeData.color) {
          const normalizedColor = normalizeColorHex(shapeData.color);
          element.dataset.color = normalizedColor;
          element.style.color = normalizedColor;
        }
        return element;
      }

      function insertShape(shapeId) {
        const shape = SHAPE_OPTION_MAP.get(shapeId);
        if (!shape) return;
        const element = createShapeElement(shape, { select: true });
        if (element) {
          capture();
          saveEditorState('add_shape');
        }
      }

      function createImageElement(options = {}) {
        if (!options || !options.src) return null;
        const element = document.createElement('div');
        const shouldAnimate = options.animate !== false;
        element.className = shouldAnimate ? 'image-element image-insert-animation' : 'image-element';
        const elementId = options.id || generateElementId('image');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        const img = document.createElement('img');
        img.src = options.src;
        img.alt = options.alt || 'Slide image';
        img.draggable = false;
        element.appendChild(img);
        const aspectRatio = Number.isFinite(options.aspectRatio)
          ? options.aspectRatio
          : (() => {
              const width = Number(options.width);
              const height = Number(options.height);
              if (Number.isFinite(width) && Number.isFinite(height) && height !== 0) {
                return width / height;
              }
              return 1;
            })();
        const minWidthValue = Number.isFinite(options.minWidth) ? options.minWidth : 80;
        const minHeightValue = Number.isFinite(options.minHeight) ? options.minHeight : Math.max(60, minWidthValue / Math.max(aspectRatio, 0.01));
        element.dataset.aspectRatio = String(aspectRatio || 1);
        element.dataset.minWidth = String(minWidthValue);
        element.dataset.minHeight = String(minHeightValue);
        const rotation = Number.isFinite(options.rotation) ? options.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '4';

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        let width = Number(options.width);
        let height = Number(options.height);
        if (!Number.isFinite(width) || width <= 0) {
          if (Number.isFinite(height) && height > 0) {
            width = height * (aspectRatio || 1);
          } else {
            width = Math.min(canvasWidth - 96, Math.max(240, minWidthValue));
          }
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = width / Math.max(aspectRatio || 1, 0.01);
        }
        width = Math.max(minWidthValue, width);
        height = Math.max(minHeightValue, height);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        let left = Number(options.left);
        let top = Number(options.top);
        if (!Number.isFinite(left)) {
          if (lastCanvasInsertPosition) {
            left = lastCanvasInsertPosition.x - width / 2;
          } else {
            left = (canvasWidth - width) / 2;
          }
        }
        if (!Number.isFinite(top)) {
          if (lastCanvasInsertPosition) {
            top = lastCanvasInsertPosition.y - height / 2;
          } else {
            top = (canvasHeight - height) / 2;
          }
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          selectImage(element);
        });

        element.addEventListener('click', (event) => {
          event.stopPropagation();
          selectImage(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectImage(element);
          showElementContextMenu(event, element);
        });

        if (shouldAnimate) {
          setTimeout(() => {
            element.classList.remove('image-insert-animation');
          }, 320);
        }

        if (options.select) {
          selectImage(element);
        }

        return element;
      }

      function instantiateImage(imageData) {
        if (!imageData || !imageData.src) return;
        createImageElement({
          src: imageData.src,
          id: imageData.id,
          left: imageData.left,
          top: imageData.top,
          width: imageData.width,
          height: imageData.height,
          rotation: imageData.rotation,
          minWidth: imageData.minWidth,
          minHeight: imageData.minHeight,
          aspectRatio: imageData.aspectRatio,
          zIndex: imageData.zIndex,
          animate: false
        });
      }

      function insertImageFromDataUrl(dataUrl) {
        if (!dataUrl) return;
        const tempImage = new Image();
        tempImage.onload = () => {
          const intrinsicWidth = tempImage.naturalWidth || tempImage.width || 1;
          const intrinsicHeight = tempImage.naturalHeight || tempImage.height || 1;
          const aspectRatio = intrinsicWidth / intrinsicHeight;
          const maxWidth = canvas.clientWidth - 96;
          const maxHeight = canvas.clientHeight - 96;
          const scale = Math.min(1, maxWidth / intrinsicWidth, maxHeight / intrinsicHeight);
          const width = Math.max(160, intrinsicWidth * scale);
          const height = width / aspectRatio;
          const element = createImageElement({
            src: dataUrl,
            width,
            height,
            aspectRatio,
            minWidth: 80,
            minHeight: 80 / Math.max(aspectRatio, 0.01),
            select: true
          });
          if (element) {
            capture();
            saveEditorState('add_image');
          }
        };
        tempImage.onerror = () => {
          alert('Unable to load the selected image. Please try a different file.');
        };
        tempImage.src = dataUrl;
      }

      function createVideoElement(options = {}) {
        if (!options || !options.src) return null;
        const element = document.createElement('div');
        const shouldAnimate = options.animate !== false;
        element.className = shouldAnimate ? 'video-element image-insert-animation' : 'video-element';
        const elementId = options.id || generateElementId('video');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        const video = document.createElement('video');
        video.src = options.src;
        video.setAttribute('src', options.src);
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.preload = 'metadata';
        video.controls = true;
        video.draggable = false;
        element.appendChild(video);

        const aspectRatio = Number.isFinite(options.aspectRatio)
          ? options.aspectRatio
          : (() => {
              const width = Number(options.width);
              const height = Number(options.height);
              if (Number.isFinite(width) && Number.isFinite(height) && height !== 0) {
                return width / height;
              }
              return 16 / 9;
            })();
        const minWidthValue = Number.isFinite(options.minWidth) ? options.minWidth : 160;
        const minHeightValue = Number.isFinite(options.minHeight) ? options.minHeight : Math.max(90, minWidthValue / Math.max(aspectRatio, 0.01));
        element.dataset.aspectRatio = String(aspectRatio || 1);
        element.dataset.minWidth = String(minWidthValue);
        element.dataset.minHeight = String(minHeightValue);
        const rotation = Number.isFinite(options.rotation) ? options.rotation : 0;
        element.dataset.rotation = String(rotation);
        element.style.transform = `rotate(${rotation}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '5';

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        let width = Number(options.width);
        let height = Number(options.height);
        if (!Number.isFinite(width) || width <= 0) {
          if (Number.isFinite(height) && height > 0) {
            width = height * (aspectRatio || 1);
          } else {
            width = Math.min(canvasWidth - 120, Math.max(320, minWidthValue));
          }
        }
        if (!Number.isFinite(height) || height <= 0) {
          height = width / Math.max(aspectRatio || 1, 0.01);
        }
        width = Math.max(minWidthValue, width);
        height = Math.max(minHeightValue, height);
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;

        let left = Number(options.left);
        let top = Number(options.top);
        if (!Number.isFinite(left)) {
          if (lastCanvasInsertPosition) {
            left = lastCanvasInsertPosition.x - width / 2;
          } else {
            left = (canvasWidth - width) / 2;
          }
        }
        if (!Number.isFinite(top)) {
          if (lastCanvasInsertPosition) {
            top = lastCanvasInsertPosition.y - height / 2;
          } else {
            top = (canvasHeight - height) / 2;
          }
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;

        canvas.appendChild(element);
        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          if (event.target === video) return;
          event.stopPropagation();
          selectVideo(element);
        });

        element.addEventListener('click', (event) => {
          if (event.target === video) return;
          event.stopPropagation();
          selectVideo(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectVideo(element);
          showElementContextMenu(event, element);
        });

        video.addEventListener('mousedown', (event) => {
          if (event.button !== 0) return;
          selectVideo(element);
        });
        video.addEventListener('click', (event) => {
          if (event.button !== 0) return;
          selectVideo(element);
        });
        video.addEventListener('dragstart', (event) => {
          event.preventDefault();
        });

        if (shouldAnimate) {
          setTimeout(() => {
            element.classList.remove('image-insert-animation');
          }, 320);
        }

        if (options.select) {
          selectVideo(element);
        }

        return element;
      }

      function instantiateVideo(videoData) {
        if (!videoData || !videoData.src) return;
        createVideoElement({
          src: videoData.src,
          id: videoData.id,
          left: videoData.left,
          top: videoData.top,
          width: videoData.width,
          height: videoData.height,
          rotation: videoData.rotation,
          minWidth: videoData.minWidth,
          minHeight: videoData.minHeight,
          aspectRatio: videoData.aspectRatio,
          zIndex: videoData.zIndex,
          animate: false
        });
      }

      function insertVideoFromDataUrl(dataUrl) {
        if (!dataUrl) return;
        const tempVideo = document.createElement('video');
        tempVideo.preload = 'metadata';
        tempVideo.src = dataUrl;
        tempVideo.addEventListener('loadedmetadata', () => {
          const intrinsicWidth = tempVideo.videoWidth || 640;
          const intrinsicHeight = tempVideo.videoHeight || 360;
          const aspectRatio = intrinsicWidth / Math.max(intrinsicHeight, 0.01);
          const maxWidth = canvas.clientWidth - 96;
          const maxHeight = canvas.clientHeight - 96;
          const scale = Math.min(1, maxWidth / intrinsicWidth, maxHeight / intrinsicHeight);
          const width = Math.max(240, intrinsicWidth * scale);
          const height = width / aspectRatio;
          const element = createVideoElement({
            src: dataUrl,
            width,
            height,
            aspectRatio,
            minWidth: 200,
            minHeight: 120,
            select: true
          });
          if (element) {
            capture();
            saveEditorState('add_video');
          }
        }, { once: true });
        tempVideo.addEventListener('error', () => {
          alert('Unable to load the selected video. Please try a different file.');
        }, { once: true });
      }

      function instantiateTable(tableData) {
        if (!tableData) return;
        const element = createTableElement(
          tableData.rows || 1,
          tableData.cols || 1,
          {
            id: tableData.id,
            width: tableData.width,
            height: tableData.height,
            left: tableData.left,
            top: tableData.top,
            html: tableData.html,
            rotation: tableData.rotation,
            minWidth: tableData.minWidth,
            minHeight: tableData.minHeight,
            zIndex: tableData.zIndex
          }
        );
        if (element) {
          element.dataset.rows = String(tableData.rows || 1);
          element.dataset.cols = String(tableData.cols || 1);
          element.dataset.minWidth = String(tableData.minWidth || 240);
          element.dataset.minHeight = String(tableData.minHeight || 160);
          element.dataset.rotation = String(Number.isFinite(tableData.rotation) ? tableData.rotation : 0);
          element.style.transform = `rotate(${parseFloat(element.dataset.rotation || '0')}deg)`;
        }
        return element;
      }

      function buildTableMarkup(rows, cols) {
        const safeRows = Math.max(1, Math.min(20, rows));
        const safeCols = Math.max(1, Math.min(20, cols));
        let html = '<table>';
        html += '<colgroup>';
        const defaultWidthPercent = 100 / safeCols;
        for (let c = 0; c < safeCols; c += 1) {
          html += `<col style="width:${defaultWidthPercent}%">`;
        }
        html += '</colgroup><tbody>';
        for (let r = 0; r < safeRows; r += 1) {
          html += '<tr>';
          for (let c = 0; c < safeCols; c += 1) {
            html += '<td contenteditable="true"></td>';
          }
          html += '</tr>';
        }
        html += '</tbody></table>';
        return html;
      }

      function setupTableCell(cell, container) {
        if (!cell) return;
        cell.contentEditable = 'true';
        applySpellCheckStateToElement(cell);
        setupFontSizeTracking(cell);
        setupFontFamilyTracking(cell);
        cell.addEventListener('focus', () => {
          currentActiveElement = cell;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
          if (container) {
            selectTableElement(container);
          }
        });
        cell.addEventListener('click', (event) => {
          event.stopPropagation();
          if (container) {
            selectTableElement(container);
          }
        });
      }

      function initializeTableElement(element) {
        if (!element) return;
        const cells = element.querySelectorAll('td, th');
        cells.forEach((cell) => {
          setupTableCell(cell, element);
        });
        ensureTableDragHandle(element);
      }

      function ensureTableDragHandle(element) {
        if (!element || element.querySelector('.table-drag-handle')) return;
        const dragHandle = document.createElement('div');
        dragHandle.className = 'table-drag-handle';
        dragHandle.innerHTML = `<i class="fas fa-arrows-alt"></i>`;
        dragHandle.title = 'Drag table';
        dragHandle.setAttribute('role', 'button');
        dragHandle.setAttribute('tabindex', '0');
        dragHandle.setAttribute('aria-label', 'Drag table');
        dragHandle.addEventListener('pointerdown', () => {
          selectTableElement(element);
        });
        dragHandle.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectTableElement(element);
          }
        });
        element.appendChild(dragHandle);
      }

      function ensureTableColGroup(table) {
        if (!table) return [];
        const firstRow = table.rows[0];
        const columnCount = firstRow ? firstRow.cells.length : 0;
        if (!columnCount) return [];
        let colgroup = table.querySelector('colgroup');
        if (!colgroup) {
          colgroup = document.createElement('colgroup');
          table.insertBefore(colgroup, table.firstChild);
        }
        const currentCols = Array.from(colgroup.children);
        if (currentCols.length !== columnCount) {
          while (colgroup.firstChild) {
            colgroup.removeChild(colgroup.firstChild);
          }
          for (let index = 0; index < columnCount; index += 1) {
            const col = document.createElement('col');
            colgroup.appendChild(col);
          }
        }
        return Array.from(colgroup.children);
      }

      function teardownTableResizing(container) {
        if (!container) return;
        container.querySelectorAll('.table-resize-handle').forEach((handle) => handle.remove());
        const resizeObserver = tableResizeObservers.get(container);
        if (resizeObserver) {
          resizeObserver.disconnect();
          tableResizeObservers.delete(container);
        }
        const mutationObserver = tableMutationObservers.get(container);
        if (mutationObserver) {
          mutationObserver.disconnect();
          tableMutationObservers.delete(container);
        }
        unbindTableColumnHover(container);
      }

      function scheduleTableResizeUpdate(container) {
        if (!container) return;
        if (container.__tableResizePending) return;
        container.__tableResizePending = true;
        requestAnimationFrame(() => {
          container.__tableResizePending = false;
          setupTableResizing(container);
        });
      }

      function positionTableResizeHandles(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table) return;
        const containerRect = container.getBoundingClientRect();
        const tableRect = table.getBoundingClientRect();
        const rows = table.rows;
        if (!rows.length) return;
        
        // Position column resize handles
        const colHandles = container.querySelectorAll('.table-resize-handle.table-resize-col');
        if (colHandles.length > 0) {
          const referenceRow = rows[0];
          const cells = referenceRow.cells;
          if (cells.length) {
            colHandles.forEach((handle) => {
              const columnIndex = parseInt(handle.dataset.col, 10);
              const cell = cells[columnIndex];
              if (!cell) return;
              const cellRect = cell.getBoundingClientRect();
              const boundaryLeft = cellRect.right - containerRect.left;
              handle.style.left = `${boundaryLeft}px`;
              handle.style.top = `${tableRect.top - containerRect.top}px`;
              handle.style.height = `${tableRect.height}px`;
            });
          }
        }
        
        // Position row resize handles
        const rowHandles = container.querySelectorAll('.table-resize-handle.table-resize-row');
        if (rowHandles.length > 0) {
          rowHandles.forEach((handle) => {
            const rowIndex = parseInt(handle.dataset.row, 10);
            const row = rows[rowIndex];
            if (!row) return;
            const rowRect = row.getBoundingClientRect();
            const boundaryTop = rowRect.bottom - containerRect.top;
            handle.style.top = `${boundaryTop}px`;
            handle.style.left = `${tableRect.left - containerRect.left}px`;
            handle.style.width = `${tableRect.width}px`;
          });
        }
        
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget === container) {
          positionTableColumnColorPicker(container, tableColumnColorIndex);
        }
      }

      function updateAllTableResizeHandles() {
        document.querySelectorAll('.table-element').forEach((tableEl) => {
          positionTableResizeHandles(tableEl);
          // Also update selection border handle if cells are selected
          const selectedCells = getTableSelectedCells(tableEl);
          if (selectedCells.length >= 2) {
            updateSelectionBorderResizeHandle(tableEl, selectedCells);
          }
        });
      }

      function setupTableResizing(container) {
        if (!container) return;
        teardownTableResizing(container);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        const columnCount = rows[0].cells.length;
        if (!columnCount) return;
        ensureTableColGroup(table);
        // Create column resize handles
        if (columnCount >= 2) {
          for (let index = 0; index < columnCount - 1; index += 1) {
            const handle = document.createElement('div');
            handle.className = 'table-resize-handle table-resize-col';
            handle.dataset.col = String(index);
            handle.addEventListener('mousedown', (event) => {
              startTableColumnResize(event, container, index);
            });
            container.appendChild(handle);
          }
        }
        // Create row resize handles
        if (rows.length >= 2) {
          for (let index = 0; index < rows.length - 1; index += 1) {
            const handle = document.createElement('div');
            handle.className = 'table-resize-handle table-resize-row';
            handle.dataset.row = String(index);
            handle.addEventListener('mousedown', (event) => {
              startTableRowResize(event, container, index);
            });
            container.appendChild(handle);
          }
        }
        positionTableResizeHandles(container);
        const resizeObserver = new ResizeObserver(() => {
          positionTableResizeHandles(container);
        });
        resizeObserver.observe(container);
        tableResizeObservers.set(container, resizeObserver);
        const mutationObserver = new MutationObserver(() => {
          scheduleTableResizeUpdate(container);
        });
        mutationObserver.observe(table, { childList: true, subtree: true });
        tableMutationObservers.set(container, mutationObserver);
        bindTableColumnHover(container);
        ensureTableSelectionHandlers(container);
      }

      function startTableColumnResize(event, container, columnIndex) {
        event.preventDefault();
        event.stopPropagation();
        hideTableColumnColorPicker(true);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        ensureTableColGroup(table);
        const colgroup = table.querySelector('colgroup');
        if (!colgroup) return;
        const columns = Array.from(colgroup.children);
        if (columns.length <= columnIndex + 1) return;
        const firstRow = rows[0];
        const zoom = getCanvasZoom();
        const widths = Array.from(firstRow.cells).map((cell, idx) => {
          const rect = cell.getBoundingClientRect();
          const width = rect.width / zoom;
          columns[idx].style.width = `${width}px`;
          return width;
        });
        activeTableResize = {
          container,
          table,
          columns,
          columnIndex,
          nextIndex: columnIndex + 1,
          initialWidths: widths,
          startX: event.clientX,
          type: 'column'
        };
        container.classList.add('table-resizing');
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', handleTableResizeMove);
        document.addEventListener('mouseup', handleTableResizeEnd, { once: true });
      }

      function handleTableResizeMove(event) {
        if (!activeTableResize) return;
        const { type } = activeTableResize;
        const zoom = getCanvasZoom();
        
        if (type === 'row') {
          const {
            container,
            rows,
            rowIndex,
            nextIndex,
            initialHeights,
            startY
          } = activeTableResize;
          const delta = (event.clientY - startY) / zoom;
          const currentHeight = initialHeights[rowIndex];
          const neighborHeight = initialHeights[nextIndex];
          const minDelta = TABLE_MIN_ROW_HEIGHT - currentHeight;
          const maxDelta = neighborHeight - TABLE_MIN_ROW_HEIGHT;
          const clampedDelta = Math.max(minDelta, Math.min(delta, maxDelta));
          const newHeight = currentHeight + clampedDelta;
          const newNeighborHeight = neighborHeight - clampedDelta;
          rows[rowIndex].style.height = `${newHeight}px`;
          rows[nextIndex].style.height = `${newNeighborHeight}px`;
        } else {
          const {
            container,
            columns,
            columnIndex,
            nextIndex,
            initialWidths,
            startX
          } = activeTableResize;
          const delta = (event.clientX - startX) / zoom;
          const currentWidth = initialWidths[columnIndex];
          const neighborWidth = initialWidths[nextIndex];
          const minDelta = TABLE_MIN_COLUMN_WIDTH - currentWidth;
          const maxDelta = neighborWidth - TABLE_MIN_COLUMN_WIDTH;
          const clampedDelta = Math.max(minDelta, Math.min(delta, maxDelta));
          const newWidth = currentWidth + clampedDelta;
          const newNeighborWidth = neighborWidth - clampedDelta;
          columns[columnIndex].style.width = `${newWidth}px`;
          columns[nextIndex].style.width = `${newNeighborWidth}px`;
        }
        positionTableResizeHandles(activeTableResize.container);
      }

      function handleTableResizeEnd() {
        if (!activeTableResize) return;
        document.removeEventListener('mousemove', handleTableResizeMove);
        document.body.style.cursor = '';
        const { container, type } = activeTableResize;
        container.classList.remove('table-resizing');
        positionTableResizeHandles(container);
        if (tableColumnColorPicker.classList.contains('visible') && tableColumnColorTarget === container) {
          positionTableColumnColorPicker(container, tableColumnColorIndex);
        }
        const actionType = type === 'row' ? 'resize_table_row' : 'resize_table_column';
        activeTableResize = null;
        capture();
        saveEditorState(actionType);
      }

      function startTableRowResize(event, container, rowIndex) {
        event.preventDefault();
        event.stopPropagation();
        hideTableColumnColorPicker(true);
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        if (rows.length <= rowIndex + 1) return;
        const zoom = getCanvasZoom();
        const heights = Array.from(rows).map((row, idx) => {
          const rect = row.getBoundingClientRect();
          const height = rect.height / zoom;
          // Store height in row style if not already set
          if (!row.style.height) {
            row.style.height = `${height}px`;
          }
          return height;
        });
        activeTableResize = {
          container,
          table,
          rows: Array.from(rows),
          rowIndex,
          nextIndex: rowIndex + 1,
          initialHeights: heights,
          startY: event.clientY,
          type: 'row'
        };
        container.classList.add('table-resizing');
        document.body.style.cursor = 'row-resize';
        document.addEventListener('mousemove', handleTableResizeMove);
        document.addEventListener('mouseup', handleTableResizeEnd, { once: true });
      }

      function updateTableColumnColorButtonAppearance(color) {
        tableColumnColorButton.style.background = color;
        const hex = color.replace('#', '');
        const safeHex = hex.length === 3 ? hex.split('').map(ch => ch + ch).join('') : hex;
        const bigint = parseInt(safeHex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        tableColumnColorButton.style.color = luminance < 140 ? '#f8fafc' : '#0f172a';
        tableColumnColorButton.style.boxShadow = '0 0 0 1px rgba(15, 23, 42, 0.2)';
      }

      function hideTableColumnColorPicker(immediate = false) {
        if (!tableColumnColorPicker.classList.contains('visible')) return;
        if (tableColumnColorPickerBusy && !immediate) return;
        const performHide = () => {
          tableColumnColorPicker.classList.remove('visible');
          tableColumnColorTarget = null;
          tableColumnColorIndex = null;
          tableColumnColorPickerBusy = false;
        };
        if (immediate) {
          performHide();
          return;
        }
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
        }
        tableColumnHideTimeout = setTimeout(performHide, 120);
      }

      function showTableColumnColorPicker(container, columnIndex, cell) {
        if (!container || !container.contains(cell)) return;
        tableColumnColorTarget = container;
        tableColumnColorIndex = columnIndex;
        if (tableColumnHideTimeout) {
          clearTimeout(tableColumnHideTimeout);
          tableColumnHideTimeout = null;
        }
        const computed = window.getComputedStyle(cell);
        let color = normalizeColorHex(computed.backgroundColor || cell.style.backgroundColor || '#ffffff');
        if (!color || color === '#000000' && computed.backgroundColor === 'rgba(0, 0, 0, 0)') {
          color = '#ffffff';
        }
        tableColumnColorInput.value = color;
        updateTableColumnColorButtonAppearance(color);
        tableColumnColorPicker.classList.add('visible');
        positionTableColumnColorPicker(container, columnIndex);
      }

      function positionTableColumnColorPicker(container, columnIndex) {
        if (!tableColumnColorPicker.classList.contains('visible')) return;
        if (!container || columnIndex == null) return;
        const table = container.querySelector('table');
        if (!table) return;
        const rows = table.rows;
        if (!rows.length) return;
        const referenceRow = rows[0];
        const cell = referenceRow.cells[columnIndex];
        if (!cell) return;
        const cellRect = cell.getBoundingClientRect();
        const pickerRect = tableColumnColorPicker.getBoundingClientRect();
        let top = cellRect.top - pickerRect.height - 12;
        let left = cellRect.left + (cellRect.width / 2) - (pickerRect.width / 2);
        if (top < 16) {
          top = cellRect.bottom + 12;
        }
        if (left + pickerRect.width > window.innerWidth - 16) {
          left = window.innerWidth - pickerRect.width - 16;
        }
        if (left < 16) {
          left = 16;
        }
        if (top + pickerRect.height > window.innerHeight - 16) {
          top = window.innerHeight - pickerRect.height - 16;
        }
        tableColumnColorPicker.style.top = `${top}px`;
        tableColumnColorPicker.style.left = `${left}px`;
      }

      function applyColorToTableColumn(container, columnIndex, color, final = true) {
        const table = container.querySelector('table');
        if (!table) return;
        const selectedCells = getTableSelectedCells(container);
        if (selectedCells.length) {
          selectedCells.forEach((cell) => {
            cell.style.backgroundColor = color;
          });
          if (final) {
            capture();
            saveEditorState('color_table_cells');
          }
          return;
        }
        Array.from(table.rows).forEach((row) => {
          const cell = row.cells[columnIndex];
          if (cell) {
            cell.style.backgroundColor = color;
          }
        });
        if (final) {
          capture();
          saveEditorState('color_table_column');
        }
      }

      function bindTableColumnHover(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table || tableColumnHoverHandlers.has(table)) return;
        const moveHandler = (event) => {
          if (activeTableResize) return;
          const cell = event.target.closest('td, th');
          if (!cell || !container.contains(cell)) {
            hideTableColumnColorPicker(true);
            return;
          }
          const columnIndex = cell.cellIndex;
          if (columnIndex === -1) {
            hideTableColumnColorPicker(true);
            return;
          }
          showTableColumnColorPicker(container, columnIndex, cell);
        };
        const leaveHandler = () => {
          hideTableColumnColorPicker();
        };
        table.addEventListener('mousemove', moveHandler);
        table.addEventListener('mouseleave', leaveHandler);
        tableColumnHoverHandlers.set(table, { moveHandler, leaveHandler });
      }

      function unbindTableColumnHover(container) {
        if (!container) return;
        const table = container.querySelector('table');
        if (!table) return;
        const handlers = tableColumnHoverHandlers.get(table);
        if (!handlers) return;
        table.removeEventListener('mousemove', handlers.moveHandler);
        table.removeEventListener('mouseleave', handlers.leaveHandler);
        tableColumnHoverHandlers.delete(table);
      }

      function getCellCoordinates(cell) {
        if (!cell) return null;
        const row = cell.parentElement;
        if (!row) return null;
        const section = row.parentElement;
        if (!section) return null;
        const rowIndex = Array.prototype.indexOf.call(section.children, row);
        const colIndex = cell.cellIndex;
        return { row: rowIndex, col: colIndex };
      }

      function getTableSelectedCells(container) {
        if (!container || !container.__selectedCellsSet) return [];
        return Array.from(container.__selectedCellsSet);
      }

      function setTableSelection(container, cells) {
        if (!container) return;
        const previous = getTableSelectedCells(container);
        previous.forEach((cell) => cell.classList.remove('table-cell-selected'));
        if (!cells || !cells.length) {
          container.__selectedCellsSet = null;
          // Remove selection border handle when clearing selection
          const borderHandle = container.querySelector('.table-selection-border-handle');
          if (borderHandle) {
            borderHandle.remove();
          }
          return;
        }
        const set = new Set();
        cells.forEach((cell) => {
          if (!cell) return;
          cell.classList.add('table-cell-selected');
          set.add(cell);
        });
        container.__selectedCellsSet = set;
        // Update selection border handle
        updateSelectionBorderResizeHandle(container, cells);
      }

      function clearTableSelection(container) {
        setTableSelection(container, null);
      }

      function isEditingTableCell() {
        const active = document.activeElement;
        if (active && active.isContentEditable && active.closest && active.closest('.table-element')) {
          return true;
        }
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          const anchorElement = anchorNode && (anchorNode.nodeType === Node.ELEMENT_NODE ? anchorNode : anchorNode.parentElement);
          if (anchorElement && anchorElement.closest && anchorElement.closest('.table-element') && anchorElement.closest('[contenteditable="true"]')) {
            return true;
          }
        }
        return false;
      }

      function updateTableSelectionRange(container, startCoords, endCoords) {
        if (!container || !startCoords || !endCoords) return;
        const table = container.querySelector('table');
        if (!table) return;
        const minRow = Math.min(startCoords.row, endCoords.row);
        const maxRow = Math.max(startCoords.row, endCoords.row);
        const minCol = Math.min(startCoords.col, endCoords.col);
        const maxCol = Math.max(startCoords.col, endCoords.col);
        const selectedCells = [];
        Array.from(table.rows).forEach((row, rowIndex) => {
          if (rowIndex < minRow || rowIndex > maxRow) return;
          Array.from(row.cells).forEach((cell, colIndex) => {
            if (colIndex >= minCol && colIndex <= maxCol) {
              selectedCells.push(cell);
            }
          });
        });
        setTableSelection(container, selectedCells);
        if (selectedCells.length) {
          selectTableElement(container);
          // Update selection border resize handle
          updateSelectionBorderResizeHandle(container, selectedCells);
        }
      }
      
      function updateSelectionBorderResizeHandle(container, selectedCells) {
        if (!container || !selectedCells || selectedCells.length < 2) {
          // Remove any existing selection border handle
          const existingHandle = container.querySelector('.table-selection-border-handle');
          if (existingHandle) {
            existingHandle.remove();
          }
          return;
        }
        
        // Check if cells form a contiguous horizontal or vertical range
        const coords = selectedCells.map(cell => getCellCoordinates(cell)).filter(Boolean);
        if (coords.length < 2) return;
        
        // Check if all cells are in the same row (horizontal selection)
        const allSameRow = coords.every(coord => coord.row === coords[0].row);
        const allSameCol = coords.every(coord => coord.col === coords[0].col);
        
        // Find the border between selected cells
        let borderHandle = container.querySelector('.table-selection-border-handle');
        if (!borderHandle) {
          borderHandle = document.createElement('div');
          borderHandle.className = 'table-selection-border-handle';
          container.appendChild(borderHandle);
        }
        
        const table = container.querySelector('table');
        if (!table) return;
        
        if (allSameRow) {
          // Horizontal selection - show vertical border handle
          const sortedCols = coords.map(c => c.col).sort((a, b) => a - b);
          const minCol = sortedCols[0];
          const maxCol = sortedCols[sortedCols.length - 1];
          
          // Check if there's a gap (non-contiguous)
          let isContiguous = true;
          for (let i = minCol; i <= maxCol; i++) {
            if (!sortedCols.includes(i)) {
              isContiguous = false;
              break;
            }
          }
          
          if (isContiguous && maxCol < table.rows[0].cells.length - 1) {
            // Show handle on the right edge of the selection
            const row = table.rows[coords[0].row];
            const rightCell = row.cells[maxCol];
            const rightCellRect = rightCell.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            borderHandle.className = 'table-selection-border-handle table-selection-border-vertical';
            borderHandle.style.left = `${rightCellRect.right - containerRect.left}px`;
            borderHandle.style.top = `${rightCellRect.top - containerRect.top}px`;
            borderHandle.style.height = `${rightCellRect.height}px`;
            borderHandle.style.width = '6px';
            borderHandle.style.display = 'block';
            borderHandle.dataset.col = String(maxCol);
            borderHandle.dataset.type = 'vertical';
            
            // Remove old event listeners and add new one
            const newHandle = borderHandle.cloneNode(true);
            borderHandle.parentNode.replaceChild(newHandle, borderHandle);
            newHandle.addEventListener('mousedown', (event) => {
              startTableColumnResize(event, container, maxCol);
            });
          } else {
            borderHandle.style.display = 'none';
          }
        } else if (allSameCol) {
          // Vertical selection - show horizontal border handle
          const sortedRows = coords.map(c => c.row).sort((a, b) => a - b);
          const minRow = sortedRows[0];
          const maxRow = sortedRows[sortedRows.length - 1];
          
          // Check if contiguous
          let isContiguous = true;
          for (let i = minRow; i <= maxRow; i++) {
            if (!sortedRows.includes(i)) {
              isContiguous = false;
              break;
            }
          }
          
          if (isContiguous && maxRow < table.rows.length - 1) {
            // Show handle on the bottom edge of the selection
            const row = table.rows[maxRow];
            const bottomCell = row.cells[coords[0].col];
            const bottomCellRect = bottomCell.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            borderHandle.className = 'table-selection-border-handle table-selection-border-horizontal';
            borderHandle.style.top = `${bottomCellRect.bottom - containerRect.top}px`;
            borderHandle.style.left = `${bottomCellRect.left - containerRect.left}px`;
            borderHandle.style.width = `${bottomCellRect.width}px`;
            borderHandle.style.height = '6px';
            borderHandle.style.display = 'block';
            borderHandle.dataset.row = String(maxRow);
            borderHandle.dataset.type = 'horizontal';
            
            // Remove old event listeners and add new one
            const newHandle = borderHandle.cloneNode(true);
            borderHandle.parentNode.replaceChild(newHandle, borderHandle);
            newHandle.addEventListener('mousedown', (event) => {
              startTableRowResize(event, container, maxRow);
            });
          } else {
            borderHandle.style.display = 'none';
          }
        } else {
          // Not a simple horizontal or vertical selection
          borderHandle.style.display = 'none';
        }
      }

      function ensureTableSelectionHandlers(container) {
        if (!container || container.__tableSelectionBound) return;
        const table = container.querySelector('table');
        if (!table) return;
        table.addEventListener('mousedown', handleTableCellMouseDown);
        container.__tableSelectionBound = true;
      }

      const tableSelectionState = {
        isMouseDown: false,
        table: null,
        anchorCoords: null,
        startCell: null,
        startX: 0,
        startY: 0,
        hasDragged: false
      };

      function handleTableCellMouseDown(event) {
        if (event.button !== 0) return;
        const cell = event.target.closest('td, th');
        if (!cell) return;
        const container = cell.closest('.table-element');
        if (!container) return;
        
        // Prevent text selection during drag
        event.preventDefault();
        
        tableSelectionState.isMouseDown = true;
        tableSelectionState.table = container;
        tableSelectionState.startCell = cell;
        tableSelectionState.anchorCoords = getCellCoordinates(cell);
        tableSelectionState.startX = event.clientX;
        tableSelectionState.startY = event.clientY;
        tableSelectionState.hasDragged = false;
        
        // Select the initial cell immediately
        const coords = getCellCoordinates(cell);
        if (coords) {
          updateTableSelectionRange(container, coords, coords);
        }
        
        // Prevent text selection
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
        }
      }

      function handleTableMouseMove(event) {
        if (!tableSelectionState.isMouseDown) return;
        const { table, startX, startY, anchorCoords } = tableSelectionState;
        if (!table || !anchorCoords) return;
        
        const deltaX = Math.abs(event.clientX - startX);
        const deltaY = Math.abs(event.clientY - startY);
        const threshold = 3; // Lower threshold for more responsive selection
        
        if (!tableSelectionState.hasDragged && (deltaX > threshold || deltaY > threshold)) {
          tableSelectionState.hasDragged = true;
          // Prevent text selection when dragging starts
          event.preventDefault();
        }
        
        if (!tableSelectionState.hasDragged) return;
        
        // Find the cell under the cursor
        const hoveredElement = document.elementFromPoint(event.clientX, event.clientY);
        const cell = hoveredElement ? hoveredElement.closest('td, th') : null;
        
        if (!cell || !table.contains(cell)) {
          return;
        }
        
        const coords = getCellCoordinates(cell);
        if (!coords) return;
        
        // Update selection range
        updateTableSelectionRange(table, anchorCoords, coords);
        
        // Prevent text selection
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
        }
        
        // Prevent default to avoid text selection
        event.preventDefault();
      }

      function handleTableMouseUp(event) {
        if (!tableSelectionState.isMouseDown) return;
        const { table, startCell, anchorCoords, hasDragged } = tableSelectionState;
        
        // Reset state
        tableSelectionState.isMouseDown = false;
        const wasDragging = hasDragged;
        tableSelectionState.hasDragged = false;
        
        if (!table || !startCell || !anchorCoords) {
          // Clean up if incomplete
          tableSelectionState.table = null;
          tableSelectionState.startCell = null;
          tableSelectionState.anchorCoords = null;
          return;
        }
        
        // If we didn't drag, just select the single cell
        if (!wasDragging) {
          const coords = getCellCoordinates(startCell);
          if (coords) {
            updateTableSelectionRange(table, coords, coords);
          }
        }
        
        // Clean up state
        tableSelectionState.table = null;
        tableSelectionState.startCell = null;
        tableSelectionState.anchorCoords = null;
        
        // Prevent text selection
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
        }
      }

      document.addEventListener('mousemove', handleTableMouseMove);
      document.addEventListener('mouseup', handleTableMouseUp);

      document.addEventListener('mousedown', (event) => {
        const target = event.target;
        if (!target.closest('.table-element') && !target.closest('#tableColumnColorPicker')) {
          document.querySelectorAll('.table-element').forEach((tableEl) => {
            clearTableSelection(tableEl);
          });
          clearSelectedTableElement();
          hideTableColumnColorPicker(true);
        }
        if (!target.closest('.image-element') && !target.closest('#shapeRotationHandle')) {
          clearImageSelection();
        }
        if (!target.closest('.video-element') && !target.closest('#shapeRotationHandle')) {
          clearVideoSelection();
        }
        if (!target.closest('.chart-element') && !target.closest('#shapeRotationHandle') && !target.closest('#chartDataEditor')) {
          clearChartSelection();
        }
      });

      function createTableElement(rows, cols, options = {}) {
        const element = document.createElement('div');
        element.className = 'table-element';
        const elementId = options.id || generateElementId('table');
        element.dataset.elementId = elementId;
        if (!options.id) {
          options.id = elementId;
        }
        element.dataset.rows = String(rows);
        element.dataset.cols = String(cols);
        element.dataset.minWidth = String(options.minWidth || 240);
        element.dataset.minHeight = String(options.minHeight || 160);
        element.dataset.rotation = String(Number.isFinite(options.rotation) ? options.rotation : 0);
        element.style.transform = `rotate(${parseFloat(element.dataset.rotation || '0')}deg)`;
        element.style.position = 'absolute';
        element.style.zIndex = options.zIndex !== undefined ? String(options.zIndex) : '3';

        const defaultWidth = options.width || 360;
        const defaultHeight = options.height || 240;
        element.style.width = `${defaultWidth}px`;
        element.style.height = `${defaultHeight}px`;
        element.innerHTML = options.html || buildTableMarkup(rows, cols);

        canvas.appendChild(element);
        initializeTableElement(element);
        ensureTableSelectionHandlers(element);
        setupTableResizing(element);
        clearTableSelection(element);
        const internalTable = element.querySelector('table');
        if (internalTable) {
          const tableRows = internalTable.rows.length || rows;
          const tableCols = internalTable.rows[0] ? internalTable.rows[0].cells.length : cols;
          element.dataset.rows = String(tableRows);
          element.dataset.cols = String(tableCols);
        }

        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const initialLeft = options.left !== undefined ? options.left : ((canvasWidth - defaultWidth) / 2);
        const initialTop = options.top !== undefined ? options.top : ((canvasHeight - defaultHeight) / 2);
        element.style.left = `${initialLeft}px`;
        element.style.top = `${initialTop}px`;

        createResizeEdges(element);
        makeDraggable(element);
        makeResizable(element);

        element.addEventListener('mousedown', (event) => {
          if (event.target.closest('td') || event.target.closest('th')) {
            return;
          }
          event.stopPropagation();
          selectTableElement(element);
        });

        element.addEventListener('click', (event) => {
          if (event.target.closest('td') || event.target.closest('th')) {
            return;
          }
          event.stopPropagation();
          selectTableElement(element);
        });
        element.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTableElement(element);
          showElementContextMenu(event, element);
        });

        if (options.select) {
          selectTableElement(element);
        }

        return element;
      }

      function insertTable(rows, cols) {
        const safeRows = Math.max(1, Math.min(12, parseInt(rows, 10) || 1));
        const safeCols = Math.max(1, Math.min(12, parseInt(cols, 10) || 1));
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const defaultWidth = Math.min(canvasWidth - 48, safeCols * 120);
        const defaultHeight = Math.min(canvasHeight - 48, safeRows * 80);

        let left = (canvasWidth - defaultWidth) / 2;
        let top = (canvasHeight - defaultHeight) / 2;
        if (lastCanvasInsertPosition) {
          left = lastCanvasInsertPosition.x - defaultWidth / 2;
          top = lastCanvasInsertPosition.y - defaultHeight / 2;
        }

        const tableElement = createTableElement(safeRows, safeCols, {
          width: defaultWidth,
          height: defaultHeight,
          left,
          top,
          select: true
        });
        if (tableElement) {
          selectTableElement(tableElement);
          capture();
          saveEditorState('add_table');
        }
      }

      function handleTableInsert() {
        if (!tableRowsInput || !tableColsInput) return;
        insertTable(tableRowsInput.value, tableColsInput.value);
        hideTableInsertPanel();
      }

      if (tableInsertConfirm) {
        tableInsertConfirm.addEventListener('click', (event) => {
          event.preventDefault();
          handleTableInsert();
        });
      }

      [tableRowsInput, tableColsInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleTableInsert();
          }
        });
      });
      function collectAdditionalTextBoxesData() {
        return Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
          const elementId = ensureElementHasId(box, 'textbox');
          const coords = getElementCanvasCoordinates(box);
          const computed = window.getComputedStyle(box);
          const sanitizedClone = box.cloneNode(true);
          sanitizedClone.querySelectorAll('.animation-order-badge').forEach(badge => badge.remove());
          return {
            id: elementId,
            html: sanitizedClone.innerHTML,
            top: coords.top,
            left: coords.left,
            width: box.offsetWidth,
            height: box.offsetHeight,
            fontSize: box.style.fontSize || computed.fontSize,
            fontFamily: computed.fontFamily,
            display: box.style.display || '',
            rotation: parseFloat(box.dataset.rotation || '0') || 0,
            minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
            minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50),
            backgroundColor: box.style.backgroundColor || '',
            color: box.style.color || '',
            zIndex: box.style.zIndex ? parseInt(box.style.zIndex, 10) : undefined
          };
        });
      }

      function collectTablesData() {
        return Array.from(document.querySelectorAll('.table-element')).map(element => {
          const elementId = ensureElementHasId(element, 'table');
          const table = element.querySelector('table');
          const rowCount = table ? table.rows.length : parseInt(element.dataset.rows || '1', 10) || 1;
          const colCount = table && table.rows[0] ? table.rows[0].cells.length : parseInt(element.dataset.cols || '1', 10) || 1;
          const coords = getElementCanvasCoordinates(element);
          const clone = element.cloneNode(true);
          clone.querySelectorAll('.table-resize-handle').forEach(handle => handle.remove());
          clone.querySelectorAll('.table-cell-selected').forEach(cell => cell.classList.remove('table-cell-selected'));
          clone.querySelectorAll('.animation-order-badge').forEach(badge => badge.remove());
          clone.querySelectorAll('.table-drag-handle').forEach(handle => handle.remove());
          const sanitizedHtml = clone.innerHTML;
          return {
            id: elementId,
            rows: rowCount,
            cols: colCount,
            html: sanitizedHtml,
            left: coords.left,
            top: coords.top,
            width: element.offsetWidth,
            height: element.offsetHeight,
            minWidth: parseFloat(element.dataset.minWidth || '240'),
            minHeight: parseFloat(element.dataset.minHeight || '160'),
            rotation: parseFloat(element.dataset.rotation || '0') || 0,
            zIndex: element.style.zIndex ? parseInt(element.style.zIndex, 10) : undefined
          };
        });
      }

      function createAdditionalTextBox(baseOptions = {}) {
        const newTextBox = document.createElement('div');
        newTextBox.className = 'text-box additional-text-box';
        const existingId = baseOptions.id;
        const elementId = existingId || generateElementId('textbox');
        newTextBox.dataset.elementId = elementId;
        if (!baseOptions.id) {
          baseOptions.id = elementId;
        }
        newTextBox.contentEditable = true;
        applySpellCheckStateToElement(newTextBox);
        newTextBox.dataset.placeholder = 'Click to add text';
        newTextBox.style.position = 'absolute';
        newTextBox.style.top = (baseOptions.top !== undefined ? baseOptions.top : (canvas.clientHeight / 2 - 100)) + 'px';
        newTextBox.style.left = (baseOptions.left !== undefined ? baseOptions.left : (canvas.clientWidth / 2 - 150)) + 'px';
        newTextBox.style.width = (baseOptions.width !== undefined ? baseOptions.width : 150) + 'px';
        newTextBox.style.height = (baseOptions.height !== undefined ? baseOptions.height : 40) + 'px';
        const minWidthValue = baseOptions.minWidth !== undefined ? baseOptions.minWidth : 80;
        const minHeightValue = baseOptions.minHeight !== undefined ? baseOptions.minHeight : 30;
        newTextBox.style.minWidth = minWidthValue + 'px';
        newTextBox.style.minHeight = minHeightValue + 'px';
        newTextBox.dataset.minWidth = String(minWidthValue);
        newTextBox.dataset.minHeight = String(minHeightValue);
        newTextBox.style.border = baseOptions.border || '1px dashed transparent';
        newTextBox.style.padding = '10px';
        newTextBox.style.outline = 'none';
        newTextBox.style.overflow = 'visible';
        newTextBox.style.display = 'block';
        newTextBox.style.textAlign = 'left';
        newTextBox.style.color = baseOptions.color || '#000000';
        const backgroundColor = baseOptions.backgroundColor ?? 'transparent';
        newTextBox.style.backgroundColor = backgroundColor;
        newTextBox.style.fontSize = baseOptions.fontSize || '16px';
        newTextBox.style.fontFamily = baseOptions.fontFamily || DEFAULT_FONT_FAMILY;
        // Always use block display for text boxes, never flex (to prevent vertical text stacking)
        // Ignore baseOptions.display if it's flex or inline-flex
        if (baseOptions.display !== undefined && baseOptions.display !== 'flex' && baseOptions.display !== 'inline-flex') {
          newTextBox.style.display = baseOptions.display;
        } else {
          newTextBox.style.display = 'block';
        }
        const rotation = Number.isFinite(baseOptions.rotation) ? baseOptions.rotation : 0;
        newTextBox.dataset.rotation = String(rotation);
        newTextBox.style.transform = `rotate(${rotation}deg)`;
        if (baseOptions.zIndex !== undefined) {
          newTextBox.style.zIndex = String(baseOptions.zIndex);
        }
        if (baseOptions.html) {
          newTextBox.innerHTML = baseOptions.html;
        }
        const placeholder = newTextBox.dataset.placeholder;
        // Force correct styles immediately on creation - AGGRESSIVE FIX
        const fixTextBoxStyles = (element) => {
          if (!element) return;
          
          // Force display to block with maximum priority
          element.style.setProperty('display', 'block', 'important');
          element.style.setProperty('flex-direction', 'row', 'important');
          element.style.setProperty('flex-wrap', 'wrap', 'important');
          element.style.setProperty('writing-mode', 'horizontal-tb', 'important');
          element.style.setProperty('text-orientation', 'mixed', 'important');
          
          // CRITICAL: Ensure adequate width - if width is too narrow, characters wrap vertically
          const computed = window.getComputedStyle(element);
          const computedWidth = parseFloat(computed.width);
          const minWidth = parseFloat(element.dataset.minWidth) || 200;
          
          // Force minimum width of 200px to prevent vertical character wrapping
          if (computedWidth < 100 || isNaN(computedWidth) || !computedWidth) {
            element.style.setProperty('width', Math.max(minWidth, 200) + 'px', 'important');
            element.style.setProperty('min-width', Math.max(minWidth, 200) + 'px', 'important');
          }
          
          // Check computed style and fix if needed
          if (computed.display === 'flex' || computed.display === 'inline-flex') {
            element.style.setProperty('display', 'block', 'important');
          }
          
          // Prevent word-break from breaking too aggressively
          element.style.setProperty('word-break', 'normal', 'important');
          element.style.setProperty('overflow-wrap', 'normal', 'important');
          element.style.setProperty('word-wrap', 'normal', 'important');
          
          // Ensure white-space allows horizontal flow
          const currentWhiteSpace = computed.whiteSpace;
          if (currentWhiteSpace === 'pre' || currentWhiteSpace === 'pre-line') {
            element.style.setProperty('white-space', 'normal', 'important');
          } else if (!element.getAttribute('data-manually-resized')) {
            element.style.setProperty('white-space', 'nowrap', 'important');
          }
        };
        fixTextBoxStyles(newTextBox);
        
        newTextBox.addEventListener('focus', function() {
          fixTextBoxStyles(this);
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        
        // Fix styles on EVERY keystroke to prevent vertical typing
        newTextBox.addEventListener('keydown', function(e) {
          fixTextBoxStyles(this);
          // Force fix after a tiny delay to catch any style changes
          setTimeout(() => fixTextBoxStyles(this), 0);
        });
        
        newTextBox.addEventListener('input', function() {
          fixTextBoxStyles(this);
          // Double-check after input is processed
          requestAnimationFrame(() => {
            fixTextBoxStyles(this);
            // Ensure width is adequate
            const computed = window.getComputedStyle(this);
            const width = parseFloat(computed.width);
            if (width < 100) {
              this.style.setProperty('width', '200px', 'important');
              this.style.setProperty('min-width', '200px', 'important');
            }
          });
        });
        
        // Also fix on paste
        newTextBox.addEventListener('paste', function() {
          setTimeout(() => {
            fixTextBoxStyles(this);
          }, 0);
        });
        
        newTextBox.addEventListener('blur', function() {
          fixTextBoxStyles(this);
          if (!this.textContent.trim()) {
            this.innerHTML = '';
          }
        });
        canvas.appendChild(newTextBox);
        
        // Ensure display is block immediately after appending
        newTextBox.style.display = 'block';
        
        // Ensure display is block immediately after appending and after DOM update
        requestAnimationFrame(() => {
          fixTextBoxStyles(newTextBox);
        });
        
        // Add MutationObserver to watch for any style changes and fix display property
        const styleObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              fixTextBoxStyles(newTextBox);
            }
          });
        });
        styleObserver.observe(newTextBox, {
          attributes: true,
          attributeFilter: ['style']
        });
        
        // Periodic check while element exists to ensure styles stay correct
        const periodicCheck = setInterval(() => {
          if (document.contains(newTextBox)) {
            const computed = window.getComputedStyle(newTextBox);
            if (computed.display === 'flex' || computed.display === 'inline-flex') {
              fixTextBoxStyles(newTextBox);
            }
          } else {
            clearInterval(periodicCheck);
          }
        }, 200);
        
        createResizeEdges(newTextBox);
        makeDraggable(newTextBox);
        makeResizable(newTextBox);
        setupFontSizeTracking(newTextBox);
        setupFontFamilyTracking(newTextBox);
        elementFontSizes.set(newTextBox, parseFloat(newTextBox.style.fontSize) || 16);
        elementFontFamilies.set(newTextBox, newTextBox.style.fontFamily || DEFAULT_FONT_FAMILY);
        
        // If width/height are explicitly set (from saved data), mark as manually resized
        if (baseOptions.width !== undefined || baseOptions.height !== undefined) {
          newTextBox.setAttribute('data-manually-resized', 'true');
        }
        
        // Setup auto-resize for additional text boxes
        setupAutoResize(newTextBox);
        
        newTextBox.addEventListener('click', (e) => {
          if (e.target === newTextBox || !newTextBox.textContent.trim()) {
            selectTextBox(newTextBox);
          }
        });
        newTextBox.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          event.stopPropagation();
          selectTextBox(newTextBox);
          showElementContextMenu(event, newTextBox);
        });
        return newTextBox;
      }

      function instantiateAdditionalTextBox(boxData) {
        if (!boxData) return;
        createAdditionalTextBox(boxData);
      }

      function collectShapesData() {
        return Array.from(document.querySelectorAll('.shape-element')).map(el => {
          const elementId = ensureElementHasId(el, 'shape');
          const coords = getElementCanvasCoordinates(el);
          return {
            id: elementId,
            shapeId: el.dataset.shape,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            color: normalizeColorHex(el.dataset.color || el.style.color || '#e8f5e9'),
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined,
            minWidth: el.dataset.minWidth ? parseFloat(el.dataset.minWidth) : undefined,
            minHeight: el.dataset.minHeight ? parseFloat(el.dataset.minHeight) : undefined,
            rotation: parseFloat(el.dataset.rotation || '0') || 0
          };
        });
      }

      function collectChartsData() {
        return Array.from(document.querySelectorAll('.chart-element')).map(el => {
          const elementId = ensureElementHasId(el, 'chart');
          const coords = getElementCanvasCoordinates(el);
          const chartType = el.dataset.chartType || 'bar';
          const bars = normalizeNumberArray(el.dataset.bars, []);
          const slices = normalizeNumberArray(el.dataset.slices, []);
          const legend = normalizeChartLegend(el.dataset.legend, []);
          return {
            id: elementId,
            chartType,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation: parseFloat(el.dataset.rotation || '0') || 0,
            minWidth: parseFloat(el.dataset.minWidth || '220'),
            minHeight: parseFloat(el.dataset.minHeight || '160'),
            bars,
            slices,
            legend,
            title: el.dataset.title || '',
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        });
      }

      function collectImagesData() {
        return Array.from(document.querySelectorAll('.image-element')).map(el => {
          const elementId = ensureElementHasId(el, 'image');
          const coords = getElementCanvasCoordinates(el);
          const img = el.querySelector('img');
          const src = img ? img.getAttribute('src') : '';
          if (!src) return null;
          const rotation = parseFloat(el.dataset.rotation || '0') || 0;
          const minWidthValue = parseFloat(el.dataset.minWidth || '80');
          const minHeightValue = parseFloat(el.dataset.minHeight || '60');
          const aspectRatioValue = parseFloat(el.dataset.aspectRatio || (el.offsetWidth / Math.max(el.offsetHeight, 0.01)));
          return {
            id: elementId,
            src,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation,
            minWidth: minWidthValue,
            minHeight: minHeightValue,
            aspectRatio: aspectRatioValue,
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        }).filter(Boolean);
      }

      function collectVideosData() {
        return Array.from(document.querySelectorAll('.video-element')).map(el => {
          const elementId = ensureElementHasId(el, 'video');
          const coords = getElementCanvasCoordinates(el);
          const video = el.querySelector('video');
          const src = video ? video.getAttribute('src') : '';
          if (!src) return null;
          const rotation = parseFloat(el.dataset.rotation || '0') || 0;
          const minWidthValue = parseFloat(el.dataset.minWidth || '160');
          const minHeightValue = parseFloat(el.dataset.minHeight || '90');
          const aspectRatioValue = parseFloat(el.dataset.aspectRatio || (el.offsetWidth / Math.max(el.offsetHeight, 0.01)));
          return {
            id: elementId,
            src,
            left: coords.left,
            top: coords.top,
            width: el.offsetWidth,
            height: el.offsetHeight,
            rotation,
            minWidth: minWidthValue,
            minHeight: minHeightValue,
            aspectRatio: aspectRatioValue,
            zIndex: el.style.zIndex ? parseInt(el.style.zIndex, 10) : undefined
          };
        }).filter(Boolean);
      }

      function ensureSlideAnimations(slide) {
        if (!slide) return [];
        if (!Array.isArray(slide.animations)) {
          slide.animations = [];
        }
        return slide.animations;
      }

      function sortSlideAnimations(slide) {
        const animations = ensureSlideAnimations(slide);
        animations.sort((a, b) => {
          const orderA = Number.isFinite(a?.order) ? a.order : animations.indexOf(a);
          const orderB = Number.isFinite(b?.order) ? b.order : animations.indexOf(b);
          return orderA - orderB;
        });
        animations.forEach((anim, index) => {
          anim.order = index + 1;
        });
        return animations;
      }

      function getSlideElementIdSet(slide) {
        const ids = new Set();
        if (!slide) return ids;
        if (slide.titleBox?.id) ids.add(slide.titleBox.id);
        if (slide.textBox?.id) ids.add(slide.textBox.id);
        if (Array.isArray(slide.additionalTextBoxes)) {
          slide.additionalTextBoxes.forEach(tb => {
            if (tb?.id) ids.add(tb.id);
          });
        }
        if (Array.isArray(slide.shapes)) {
          slide.shapes.forEach(shape => {
            if (shape?.id) ids.add(shape.id);
          });
        }
        if (Array.isArray(slide.charts)) {
          slide.charts.forEach(chart => {
            if (chart?.id) ids.add(chart.id);
          });
        }
        if (Array.isArray(slide.images)) {
          slide.images.forEach(image => {
            if (image?.id) ids.add(image.id);
          });
        }
        if (Array.isArray(slide.tables)) {
          slide.tables.forEach(table => {
            if (table?.id) ids.add(table.id);
          });
        }
        if (Array.isArray(slide.videos)) {
          slide.videos.forEach(video => {
            if (video?.id) ids.add(video.id);
          });
        }
        return ids;
      }

      function pruneSlideAnimations(slide) {
        if (!slide) return;
        const animations = ensureSlideAnimations(slide);
        if (!animations.length) return;
        const validIds = getSlideElementIdSet(slide);
        const filtered = animations.filter(anim => validIds.has(anim.targetId));
        if (filtered.length !== animations.length) {
          slide.animations = filtered;
          sortSlideAnimations(slide);
        }
      }

      function getAnimationEntryByTarget(slide, targetId) {
        const animations = ensureSlideAnimations(slide);
        return animations.find(anim => anim.targetId === targetId);
      }

      function findCanvasElementById(elementId) {
        if (!elementId || !canvas) return null;
        try {
          return canvas.querySelector(`[data-element-id="${escapeSelector(elementId)}"]`);
        } catch (error) {
          return null;
        }
      }

      function describeAnimationTarget(slide, targetId) {
        const descriptor = {
          element: null,
          label: 'Object',
          type: 'object'
        };
        if (!targetId) {
          return descriptor;
        }
        const element = findCanvasElementById(targetId);
        descriptor.element = element;
        if (element) {
          if (element === titleBox) {
            descriptor.label = 'Title';
            descriptor.type = 'title';
            return descriptor;
          }
          if (element === textBox) {
            descriptor.label = 'Body Text';
            descriptor.type = 'body';
            return descriptor;
          }
          if (element.classList.contains('additional-text-box')) {
            const text = truncateText(element.textContent, 28);
            descriptor.label = text ? `Text: ${text}` : 'Text Box';
            descriptor.type = 'textbox';
            return descriptor;
          }
          if (element.classList.contains('shape-element')) {
            const shapeId = element.dataset.shape;
            const shape = SHAPE_OPTION_MAP.get(shapeId);
            descriptor.label = shape ? `Shape: ${shape.name}` : 'Shape';
            descriptor.type = 'shape';
            return descriptor;
          }
          if (element.classList.contains('chart-element')) {
            const chartId = element.dataset.chartType;
            const chart = CHART_OPTION_MAP.get(chartId);
            descriptor.label = chart ? `Chart: ${chart.name}` : 'Chart';
            descriptor.type = 'chart';
            return descriptor;
          }
          if (element.classList.contains('image-element')) {
            descriptor.label = 'Image';
            descriptor.type = 'image';
            return descriptor;
          }
          if (element.classList.contains('video-element')) {
            descriptor.label = 'Video';
            descriptor.type = 'video';
            return descriptor;
          }
          if (element.classList.contains('table-element')) {
            descriptor.label = 'Table';
            descriptor.type = 'table';
            return descriptor;
          }
        }
        if (slide?.titleBox?.id === targetId) {
          descriptor.label = 'Title';
          descriptor.type = 'title';
          return descriptor;
        }
        if (slide?.textBox?.id === targetId) {
          descriptor.label = 'Body Text';
          descriptor.type = 'body';
          return descriptor;
        }
        const additional = slide?.additionalTextBoxes?.find(tb => tb?.id === targetId);
        if (additional) {
          const text = truncateText(additional.html?.replace(/<[^>]+>/g, ' ') || '', 28);
          descriptor.label = text ? `Text: ${text}` : 'Text Box';
          descriptor.type = 'textbox';
          return descriptor;
        }
        const shapeData = slide?.shapes?.find(shape => shape?.id === targetId);
        if (shapeData) {
          const shape = SHAPE_OPTION_MAP.get(shapeData.shapeId);
          descriptor.label = shape ? `Shape: ${shape.name}` : 'Shape';
          descriptor.type = 'shape';
          return descriptor;
        }
        const chartData = slide?.charts?.find(chart => chart?.id === targetId);
        if (chartData) {
          const chart = CHART_OPTION_MAP.get(chartData.chartType);
          descriptor.label = chart ? `Chart: ${chart.name}` : 'Chart';
          descriptor.type = 'chart';
          return descriptor;
        }
        if (slide?.images?.some(image => image?.id === targetId)) {
          descriptor.label = 'Image';
          descriptor.type = 'image';
          return descriptor;
        }
        const tableData = slide?.tables?.find(table => table?.id === targetId);
        if (tableData) {
          if (Number.isFinite(tableData.rows) && Number.isFinite(tableData.cols)) {
            descriptor.label = `Table (${tableData.rows}Ã—${tableData.cols})`;
          } else {
            descriptor.label = 'Table';
          }
          descriptor.type = 'table';
          return descriptor;
        }
        if (slide?.videos?.some(video => video?.id === targetId)) {
          descriptor.label = 'Video';
          descriptor.type = 'video';
          return descriptor;
        }
        return descriptor;
      }

      function clearAnimationBadges() {
        if (!canvas) return;
        canvas.querySelectorAll('.animation-order-badge').forEach((badge) => badge.remove());
      }

      function showAnimationSequencePanel() {
        if (!animationSequenceContainer) return;
        if (isAnimationSequencePanelVisible) return;
        animationSequenceContainer.classList.remove('hidden');
        isAnimationSequencePanelVisible = true;
      }

      function hideAnimationSequencePanel() {
        if (!animationSequenceContainer) return;
        if (!isAnimationSequencePanelVisible) return;
        animationSequenceContainer.classList.add('hidden');
        isAnimationSequencePanelVisible = false;
      }

      function openAnimationSequencePanel(targetId = null) {
        if (animationTabButton && !animationTabButton.classList.contains('active')) {
          animationTabButton.click();
        }
        if (targetId) {
          currentAnimationSelectedElementId = targetId;
        }
        renderAnimationSequenceList();
        if (targetId) {
          const descriptor = describeAnimationTarget(slides[active], targetId);
          if (descriptor.element) {
            handleAnimationSelectionChange(descriptor.element);
          } else {
            const entry = getAnimationEntryByTarget(slides[active], targetId);
            if (entry) {
              animationEffectSelect.value = normalizeAnimationEffect(entry.effect);
              animationDurationInput.value = clampAnimationDuration(entry.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1);
            }
            highlightAnimationListSelection(targetId);
          }
        }
        showAnimationSequencePanel();
        if (animationSequenceList) {
          animationSequenceList.scrollTop = 0;
        }
      }

      function refreshAnimationBadges() {
        clearAnimationBadges();
        const slide = slides[active];
        if (!slide) return;
        pruneSlideAnimations(slide);
        const animations = sortSlideAnimations(slide);
        animations.forEach((animation) => {
          const element = findCanvasElementById(animation.targetId);
          if (!element) return;
          const badge = document.createElement('button');
          badge.type = 'button';
          badge.className = 'animation-order-badge';
          badge.textContent = animation.order;
          badge.dataset.targetId = animation.targetId;
          badge.setAttribute('aria-label', `Animation order ${animation.order}`);
          badge.tabIndex = -1;
          badge.setAttribute('contenteditable', 'false');
          badge.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            openAnimationSequencePanel(animation.targetId);
          });
          element.appendChild(badge);
        });
      }

      function removeAnimationById(slide, animationId) {
        if (!slide || !animationId) return false;
        const animations = ensureSlideAnimations(slide);
        const index = animations.findIndex(anim => anim.id === animationId);
        if (index === -1) return false;
        animations.splice(index, 1);
        sortSlideAnimations(slide);
        return true;
      }

      function removeAnimationByTargetId(slide, targetId) {
        if (!slide || !targetId) return false;
        const animations = ensureSlideAnimations(slide);
        const initialLength = animations.length;
        slide.animations = animations.filter(anim => anim.targetId !== targetId);
        const removed = slide.animations.length !== initialLength;
        if (removed) {
          sortSlideAnimations(slide);
        }
        return removed;
      }

      function renderAnimationSequenceList() {
        if (!animationSequenceList) return;
        const slide = slides[active];
        pruneSlideAnimations(slide);
        const animations = sortSlideAnimations(slide);
        animationSequenceList.innerHTML = '';
        if (!animations.length) {
          const empty = document.createElement('div');
          empty.className = 'animation-sequence-empty';
          empty.textContent = 'No animations assigned yet';
          animationSequenceList.appendChild(empty);
          clearAnimationBadges();
          return;
        }
        animations.forEach((animation) => {
          const item = document.createElement('div');
          item.className = 'animation-sequence-item';
          item.setAttribute('role', 'listitem');
          item.draggable = true;
          item.dataset.animationId = animation.id;
          item.dataset.targetId = animation.targetId;

          const orderBadge = document.createElement('span');
          orderBadge.className = 'animation-item-order';
          orderBadge.textContent = animation.order;
          item.appendChild(orderBadge);

          const infoWrap = document.createElement('div');
          infoWrap.className = 'animation-item-info';
          const descriptor = describeAnimationTarget(slide, animation.targetId);
          const title = document.createElement('span');
          title.className = 'animation-item-title';
          title.textContent = descriptor.label || 'Object';
          infoWrap.appendChild(title);

          const meta = document.createElement('span');
          meta.className = 'animation-item-meta';
          const effectLabel = ANIMATION_EFFECT_LABEL_MAP.get(animation.effect) || animation.effect;
          const durationLabel = `${(animation.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1)}s`;
          meta.textContent = `${effectLabel} â€¢ ${durationLabel}`;
          infoWrap.appendChild(meta);
          item.appendChild(infoWrap);

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'animation-item-remove';
          removeBtn.setAttribute('title', 'Remove animation');
          removeBtn.innerHTML = '<i class="fas fa-times"></i>';
          removeBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (removeAnimationById(slide, animation.id)) {
              capture();
              saveEditorState('remove_animation');
              renderAnimationSequenceList();
              if (currentAnimationSelectedElementId === animation.targetId) {
                currentAnimationSelectedElementId = null;
              }
              showNotification('Removed animation');
            }
          });
          item.appendChild(removeBtn);

          item.addEventListener('click', () => {
            highlightAnimationListSelection(animation.targetId);
            focusAnimationTarget(animation.targetId);
          });

          item.addEventListener('dragstart', (event) => {
            animationDragState.sourceId = animation.id;
            animationDragState.targetId = null;
            item.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', animation.id);
          });
          item.addEventListener('dragenter', (event) => {
            if (!animationDragState.sourceId || animationDragState.sourceId === animation.id) return;
            event.preventDefault();
            item.classList.add('drop-target');
            animationDragState.targetId = animation.id;
          });
          item.addEventListener('dragover', (event) => {
            if (!animationDragState.sourceId || animationDragState.sourceId === animation.id) return;
            event.preventDefault();
            animationDragState.targetId = animation.id;
          });
          item.addEventListener('dragleave', () => {
            item.classList.remove('drop-target');
            animationDragState.targetId = null;
          });
          item.addEventListener('drop', (event) => {
            event.preventDefault();
            item.classList.remove('drop-target');
            const sourceId = animationDragState.sourceId;
            const targetId = animation.id;
            animationDragState = { sourceId: null, targetId: null };
            if (!sourceId || sourceId === targetId) return;
            ensureSlideAnimations(slide);
            const ordered = sortSlideAnimations(slide);
            const sourceIndex = ordered.findIndex(anim => anim.id === sourceId);
            const targetRect = item.getBoundingClientRect();
            const dropAfter = event.clientY > targetRect.top + targetRect.height / 2;
            if (sourceIndex === -1) return;
            const [moved] = ordered.splice(sourceIndex, 1);
            let insertionIndex = ordered.findIndex(anim => anim.id === targetId);
            if (insertionIndex === -1) {
              ordered.push(moved);
            } else {
              if (dropAfter) {
                insertionIndex += 1;
              }
              if (insertionIndex < 0) insertionIndex = 0;
              if (insertionIndex > ordered.length) insertionIndex = ordered.length;
              ordered.splice(insertionIndex, 0, moved);
            }
            ordered.forEach((anim, idx) => {
              anim.order = idx + 1;
            });
            renderAnimationSequenceList();
            capture();
            saveEditorState('reorder_animation');
          });
          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            animationDragState = { sourceId: null, targetId: null };
          });

          if (currentAnimationSelectedElementId && animation.targetId === currentAnimationSelectedElementId) {
            item.classList.add('selected');
          }

          animationSequenceList.appendChild(item);
        });
        highlightAnimationListSelection(currentAnimationSelectedElementId);
        refreshAnimationBadges();
      }

      function getAnimationIdPrefixForElement(element) {
        if (!element) return 'element';
        if (element === titleBox) return 'title';
        if (element === textBox) return 'body';
        if (element.classList.contains('additional-text-box')) return 'textbox';
        if (element.classList.contains('shape-element')) return 'shape';
        if (element.classList.contains('chart-element')) return 'chart';
        if (element.classList.contains('image-element')) return 'image';
        if (element.classList.contains('video-element')) return 'video';
        if (element.classList.contains('table-element')) return 'table';
        return 'element';
      }

      function highlightAnimationListSelection(targetId) {
        if (!animationSequenceList) return;
        currentAnimationSelectedElementId = targetId || null;
        Array.from(animationSequenceList.children).forEach((child) => {
          if (!(child instanceof HTMLElement)) return;
          if (!child.classList.contains('animation-sequence-item')) return;
          child.classList.toggle('selected', !!targetId && child.dataset.targetId === targetId);
        });
      }

      function focusAnimationTarget(targetId) {
        if (!targetId) return;
        const descriptor = describeAnimationTarget(slides[active], targetId);
        const element = descriptor.element || findCanvasElementById(targetId);
        if (!element) {
          if (descriptor.type === 'title' && titleBox) {
            selectTextBox(titleBox);
          } else if (descriptor.type === 'body' && textBox) {
            selectTextBox(textBox);
          }
          return;
        }
        if (element === titleBox || element === textBox || element.classList.contains('additional-text-box')) {
          selectTextBox(element);
          return;
        }
        if (element.classList.contains('shape-element')) {
          selectShape(element);
          return;
        }
        if (element.classList.contains('chart-element')) {
          selectChart(element);
          return;
        }
        if (element.classList.contains('image-element')) {
          selectImage(element);
          return;
        }
        if (element.classList.contains('video-element')) {
          selectVideo(element);
          return;
        }
        if (element.classList.contains('table-element')) {
          selectTableElement(element);
        }
      }

      function handleAnimationSelectionChange(element) {
        if (!animationEffectSelect || !animationDurationInput) return;
        if (!element) {
          highlightAnimationListSelection(null);
          animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
          animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
          return;
        }
        const prefix = getAnimationIdPrefixForElement(element);
        const targetId = ensureElementHasId(element, prefix);
        highlightAnimationListSelection(targetId);
        const slide = slides[active];
        const entry = getAnimationEntryByTarget(slide, targetId);
        if (entry) {
          animationEffectSelect.value = normalizeAnimationEffect(entry.effect);
          animationDurationInput.value = clampAnimationDuration(entry.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1);
        } else {
          animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
          animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
        }
      }

      function syncAnimationControlsWithSlide() {
        renderAnimationSequenceList();
        const context = getSelectedElementContext();
        if (context?.element) {
          handleAnimationSelectionChange(context.element);
          return;
        }
        if (currentAnimationSelectedElementId) {
          const slide = slides[active];
          const entry = getAnimationEntryByTarget(slide, currentAnimationSelectedElementId);
          if (entry) {
            animationEffectSelect.value = normalizeAnimationEffect(entry.effect);
            animationDurationInput.value = clampAnimationDuration(entry.duration ?? DEFAULT_ANIMATION_DURATION).toFixed(1);
            highlightAnimationListSelection(currentAnimationSelectedElementId);
            return;
          }
        }
        highlightAnimationListSelection(null);
        animationEffectSelect.value = DEFAULT_ANIMATION_EFFECT;
        animationDurationInput.value = DEFAULT_ANIMATION_DURATION.toFixed(1);
      }

      function assignAnimationToSelectedElement() {
        if (!animationEffectSelect || !animationDurationInput) return;
        const context = getSelectedElementContext();
        if (!context || !context.element) {
          showNotification('Select an object to animate');
          return;
        }
        const slide = slides[active];
        const element = context.element;
        const prefix = getAnimationIdPrefixForElement(element);
        const targetId = ensureElementHasId(element, prefix);
        const effectValue = normalizeAnimationEffect(animationEffectSelect.value);
        const durationValue = clampAnimationDuration(animationDurationInput.value);
        animationDurationInput.value = durationValue.toFixed(1);

        const animations = ensureSlideAnimations(slide);
        let entry = getAnimationEntryByTarget(slide, targetId);
        const isNew = !entry;
        if (!entry) {
          entry = {
            id: generateElementId('anim'),
            targetId,
            effect: effectValue,
            duration: durationValue,
            order: animations.length + 1
          };
          animations.push(entry);
        } else {
          entry.effect = effectValue;
          entry.duration = durationValue;
        }

        sortSlideAnimations(slide);
        highlightAnimationListSelection(targetId);
        renderAnimationSequenceList();
        handleAnimationSelectionChange(element);
        capture();
        saveEditorState(isNew ? 'add_animation' : 'update_animation');
        showNotification(isNew ? 'Added animation' : 'Updated animation');
      }

      function removeAnimationFromSelection() {
        const slide = slides[active];
        if (!slide) return;
        let targetId = null;
        const context = getSelectedElementContext();
        if (context?.element) {
          targetId = ensureElementHasId(context.element, getAnimationIdPrefixForElement(context.element));
        } else if (currentAnimationSelectedElementId) {
          targetId = currentAnimationSelectedElementId;
        }
        if (!targetId) {
          showNotification('Select an animated object to remove');
          return;
        }
        if (!removeAnimationByTargetId(slide, targetId)) {
          showNotification('No animation assigned to remove');
          return;
        }
        renderAnimationSequenceList();
        highlightAnimationListSelection(null);
        if (context?.element) {
          handleAnimationSelectionChange(context.element);
        } else {
          handleAnimationSelectionChange(null);
        }
        capture();
        saveEditorState('remove_animation');
        showNotification('Removed animation');
      }

      function handleElementAnimationRemoval(elementId) {
        if (!elementId) return;
        const slide = slides[active];
        if (!slide) return;
        if (removeAnimationByTargetId(slide, elementId)) {
          if (currentAnimationSelectedElementId === elementId) {
            highlightAnimationListSelection(null);
          }
          renderAnimationSequenceList();
        }
      }
      
      // Template Background Detection and Application
      (function() {
        // Get template from query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const templateParam = urlParams.get('template');
        
        // Also check sessionStorage for backward compatibility
        const templateFromStorage = sessionStorage.getItem('selectedTemplate');
        const templateName = templateParam || templateFromStorage;
        
        if (templateName) {
          // Map template names to CSS classes
          const templateMap = {
            'marketing': 'marketing-template',
            'business': 'business-template',
            'education': 'education-template',
            'project': 'project-template',
            'business-pro': 'business-template',
            'creative-bold': 'marketing-template',
            'corporate-clean': 'business-template'
          };
          
          const templateClass = templateMap[templateName.toLowerCase()];
          
          if (templateClass) {
            // Remove any existing template classes
            canvas.classList.remove('marketing-template', 'business-template', 'education-template', 'project-template');
            
            // Add the new template class
            canvas.classList.add(templateClass);
          }
        }
      })();
      
      // Track selected text box for keyboard deletion
      let selectedTextBox = null;
      
      // Undo/Redo history stack
      let actionHistory = [];
      let redoStack = [];
      const MAX_HISTORY = 50; // Limit history size
      
      // Save current editor state to history
      function saveEditorState(action) {
        const state = {
          action: action,
          timestamp: Date.now(),
          slides: JSON.parse(JSON.stringify(slides)), // Deep copy
          active: active,
          canvasState: {
            titleBoxVisible: titleBox.style.display !== 'none',
            textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
              const coords = getElementCanvasCoordinates(box);
              return {
                element: box,
                html: box.innerHTML,
                style: {
                  top: coords.top,
                  left: coords.left,
                  width: box.offsetWidth,
                  height: box.offsetHeight,
                  fontSize: box.style.fontSize,
                  fontFamily: window.getComputedStyle(box).fontFamily,
                display: box.style.display,
                rotation: parseFloat(box.dataset.rotation || '0') || 0
                }
              };
            }),
            shapes: collectShapesData(),
            charts: collectChartsData(),
            tables: collectTablesData(),
            images: collectImagesData(),
            videos: collectVideosData()
          }
        };
        
        actionHistory.push(state);
        
        // Limit history size
        if (actionHistory.length > MAX_HISTORY) {
          actionHistory.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update undo button state
        updateUndoButton();
      }
      
      // Restore editor state from history
      function restoreEditorState(state) {
        // Restore slides data
        slides.length = 0;
        slides.push(...JSON.parse(JSON.stringify(state.slides)));
        active = state.active;
        
        // Restore title and text box visibility
        if (state.canvasState) {
          titleBox.style.display = state.canvasState.titleBoxVisible ? '' : 'none';
          textBox.style.display = state.canvasState.textBoxVisible ? '' : 'none';
        }
        
        // Restore slide content
        load();
        renderSidebar();
        
        // Restore additional text boxes
        if (state.canvasState && state.canvasState.additionalTextBoxes) {
          // Remove existing additional text boxes
          document.querySelectorAll('.additional-text-box').forEach(box => {
            if (!state.canvasState.additionalTextBoxes.some(saved => saved.element === box)) {
              box.remove();
            }
          });
          
          // Restore saved additional text boxes
          state.canvasState.additionalTextBoxes.forEach(savedBox => {
            let existingBox = null;
            if (savedBox.element && document.contains(savedBox.element)) {
              existingBox = savedBox.element;
            } else {
              // Create new box if it doesn't exist
              existingBox = document.createElement('div');
              existingBox.className = 'text-box additional-text-box';
              existingBox.contentEditable = true;
              existingBox.dataset.placeholder = 'Click to add text';
              canvas.appendChild(existingBox);
              
              // Setup the new box
              createResizeEdges(existingBox);
              makeDraggable(existingBox);
              makeResizable(existingBox);
              setupFontSizeTracking(existingBox);
              setupFontFamilyTracking(existingBox);
              elementFontSizes.set(existingBox, parseFloat(savedBox.style.fontSize) || 16);
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily || DEFAULT_FONT_FAMILY);
              
              // Add selection handler
              existingBox.addEventListener('click', (e) => {
                if (e.target === existingBox || !existingBox.textContent.trim()) {
                  selectTextBox(existingBox);
                }
              });
            }
            
            // Restore content and style
            existingBox.innerHTML = savedBox.html;
            existingBox.style.top = savedBox.style.top + 'px';
            existingBox.style.left = savedBox.style.left + 'px';
            existingBox.style.width = savedBox.style.width + 'px';
            existingBox.style.height = savedBox.style.height + 'px';
            existingBox.style.fontSize = savedBox.style.fontSize;
            if (savedBox.style.fontFamily) {
              existingBox.style.fontFamily = savedBox.style.fontFamily;
              elementFontFamilies.set(existingBox, savedBox.style.fontFamily);
            }
            // Ensure text boxes always use block display, never flex (to prevent vertical text stacking)
            const isTextBoxElement = existingBox.classList.contains('text-box') || existingBox.classList.contains('title-box') || existingBox.classList.contains('additional-text-box');
            if (isTextBoxElement) {
              existingBox.style.display = 'block';
            } else {
            existingBox.style.display = savedBox.style.display || '';
            }
            const savedRotation = Number.isFinite(savedBox.style.rotation) ? savedBox.style.rotation : 0;
            existingBox.dataset.rotation = String(savedRotation);
            existingBox.style.transform = `rotate(${savedRotation}deg)`;
            const savedMinWidth = Number.isFinite(savedBox.style.minWidth) ? savedBox.style.minWidth : 200;
            const savedMinHeight = Number.isFinite(savedBox.style.minHeight) ? savedBox.style.minHeight : 50;
            existingBox.dataset.minWidth = String(savedMinWidth);
            existingBox.dataset.minHeight = String(savedMinHeight);
          });
        }

        if (state.canvasState && state.canvasState.shapes) {
          document.querySelectorAll('.shape-element').forEach(shapeEl => shapeEl.remove());
          state.canvasState.shapes.forEach(shapeData => instantiateShape(shapeData));
        }
        document.querySelectorAll('.chart-element').forEach(chartEl => chartEl.remove());
        if (state.canvasState && state.canvasState.charts) {
          state.canvasState.charts.forEach(chartData => instantiateChart(chartData));
        }
        if (state.canvasState && state.canvasState.tables) {
          document.querySelectorAll('.table-element').forEach(tableEl => tableEl.remove());
          state.canvasState.tables.forEach(tableData => instantiateTable(tableData));
        }
        document.querySelectorAll('.image-element').forEach(imageEl => imageEl.remove());
        if (state.canvasState && state.canvasState.images) {
          state.canvasState.images.forEach(imageData => instantiateImage(imageData));
        }
        document.querySelectorAll('.video-element').forEach(videoEl => {
          const vid = videoEl.querySelector('video');
          if (vid) vid.pause();
          videoEl.remove();
        });
        if (state.canvasState && state.canvasState.videos) {
          state.canvasState.videos.forEach(videoData => instantiateVideo(videoData));
        }
        
        updateUndoButton();
        updateSlideCanvasMenuState();
      }
      
      // Undo last action
      function undoLastAction() {
        if (actionHistory.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
            additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const coords = getElementCanvasCoordinates(box);
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: coords.top,
                    left: coords.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                  display: box.style.display,
                  rotation: parseFloat(box.dataset.rotation || '0') || 0,
                  minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                  minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData(),
            charts: collectChartsData(),
              tables: collectTablesData(),
              images: collectImagesData(),
              videos: collectVideosData()
            }
          };
          
          // Save current state to redo stack
          redoStack.push(currentState);
          
          // Get previous state from history
          const previousState = actionHistory.pop();
          restoreEditorState(previousState);
        }
      }
      
      // Update undo/redo button states
      function updateUndoButton() {
        const backBtn = document.getElementById('btnBack');
        const forwardBtn = document.getElementById('btnForward');
        if (backBtn) {
          backBtn.disabled = actionHistory.length === 0;
          backBtn.style.opacity = actionHistory.length === 0 ? '0.5' : '1';
        }
        if (forwardBtn) {
          forwardBtn.disabled = redoStack.length === 0;
          forwardBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
        }
      }
      
      // Initialize with initial state
      saveEditorState('initial');

      function clearSlideDragIndicators() {
        sidebar.querySelectorAll('.slide-preview.drop-target, .slide-preview.drop-target-before, .slide-preview.drop-target-after').forEach(preview => {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        });
      }

      // SortableJS handler for slide reordering
      function handleSortableReorder(event) {
        const { oldIndex, newIndex, item } = event;
        if (oldIndex === newIndex || oldIndex === null || newIndex === null) return;
        
        const oldSlideIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(oldSlideIndex) || oldSlideIndex < 0 || oldSlideIndex >= slides.length) return;
        
        const container = item.parentElement;
        const isInSection = container.classList.contains('section-slides');
        
        // Get all items in the container - data-index still has original values
        // but DOM order has changed. We need to reconstruct the original order first.
        const allItems = Array.from(container.querySelectorAll('.slide-item[data-index]'));
        
        // Reconstruct original order: Sort by data-index to get original positions
        const itemsWithIndices = allItems.map(item => ({
          element: item,
          index: parseInt(item.dataset.index, 10)
        }));
        itemsWithIndices.sort((a, b) => a.index - b.index);
        const originalIndices = itemsWithIndices.map(item => item.index);
        
        // Now calculate the new order based on oldIndex and newIndex
        const reorderedIndices = originalIndices.slice();
        const [movedIndex] = reorderedIndices.splice(oldIndex, 1);
        reorderedIndices.splice(newIndex, 0, movedIndex);
        
        if (isInSection) {
          // Reordering within a section
          const sectionId = container.dataset.sectionId;
          const section = sections.find(s => s.id === sectionId);
          if (section && originalIndices.length > 0) {
            // Get the slides in the new order
            const reorderedSlides = reorderedIndices.map(idx => slides[idx]);
            
            // Remove all section slides (in reverse order to avoid index shifting)
            const sortedForRemoval = originalIndices.slice().sort((a, b) => b - a);
            sortedForRemoval.forEach(idx => {
              slides.splice(idx, 1);
            });
            
            // Insert slides in new order at the original position
            const insertPos = Math.min(...originalIndices);
            reorderedSlides.forEach((slide, i) => {
              slides.splice(insertPos + i, 0, slide);
            });
            
            // Update section indices
            section.slideIndices = Array.from({ length: reorderedIndices.length }, (_, i) => insertPos + i);
            
            // Update active index
            const movedSlideOriginalIndex = originalIndices[oldIndex];
            const newActiveIndex = insertPos + newIndex;
            if (active === movedSlideOriginalIndex) {
              active = newActiveIndex;
            } else {
              const activePosInSection = originalIndices.indexOf(active);
              if (activePosInSection !== -1) {
                // Active slide is in this section
                let newPosInSection = activePosInSection;
                if (activePosInSection > oldIndex && activePosInSection <= newIndex) {
                  newPosInSection = activePosInSection - 1;
                } else if (activePosInSection < oldIndex && activePosInSection >= newIndex) {
                  newPosInSection = activePosInSection + 1;
                }
                active = insertPos + newPosInSection;
              }
            }
            
            capture();
            renderSidebar();
            load();
            saveEditorState('reorder_slide_in_section');
            return;
          }
        }
        
        // Reordering standalone slides
        if (originalIndices.length > 0) {
          // Get slides in the new order
          const reorderedSlides = reorderedIndices.map(idx => slides[idx]);
          
          // Remove all these slides (in reverse order)
          const sortedForRemoval = originalIndices.slice().sort((a, b) => b - a);
          sortedForRemoval.forEach(idx => {
            slides.splice(idx, 1);
          });
          
          // Insert slides in new order
          const insertPos = Math.min(...originalIndices);
          reorderedSlides.forEach((slide, i) => {
            slides.splice(insertPos + i, 0, slide);
          });
          
          // Update active index
          const movedSlideOriginalIndex = originalIndices[oldIndex];
          const newActiveIndex = insertPos + newIndex;
          if (active === movedSlideOriginalIndex) {
            active = newActiveIndex;
          } else {
            const activePosInList = originalIndices.indexOf(active);
            if (activePosInList !== -1) {
              // Active slide was in this list
              let newPosInList = activePosInList;
              if (activePosInList > oldIndex && activePosInList <= newIndex) {
                newPosInList = activePosInList - 1;
              } else if (activePosInList < oldIndex && activePosInList >= newIndex) {
                newPosInList = activePosInList + 1;
              }
              active = insertPos + newPosInList;
            }
          }
          
          // Update section slideIndices
          sections.forEach(section => {
            section.slideIndices = section.slideIndices.map(idx => {
              const posInOriginal = originalIndices.indexOf(idx);
              if (posInOriginal !== -1) {
                // This slide was in the reordered list
                let newPosInList = posInOriginal;
                if (posInOriginal > oldIndex && posInOriginal <= newIndex) {
                  newPosInList = posInOriginal - 1;
                } else if (posInOriginal < oldIndex && posInOriginal >= newIndex) {
                  newPosInList = posInOriginal + 1;
                }
                return insertPos + newPosInList;
              }
              return idx;
            }).filter(idx => idx >= 0 && idx < slides.length);
          });
          
          // Update section anchorSlideIndex
          sections.forEach(section => {
            const posInOriginal = originalIndices.indexOf(section.anchorSlideIndex);
            if (posInOriginal !== -1) {
              let newPosInList = posInOriginal;
              if (posInOriginal > oldIndex && posInOriginal <= newIndex) {
                newPosInList = posInOriginal - 1;
              } else if (posInOriginal < oldIndex && posInOriginal >= newIndex) {
                newPosInList = posInOriginal + 1;
              }
              section.anchorSlideIndex = insertPos + newPosInList;
            }
          });
          
          capture();
          load(); // Re-render the active slide
          renderSidebar(); // Re-render sidebar with updated indices
          saveEditorState('reorder_slide');
        }
      }

      function handleSlideDragStart(event) {
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        slideDragSourceIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(slideDragSourceIndex)) {
          slideDragSourceIndex = null;
          return;
        }
        item.classList.add('dragging');
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(slideDragSourceIndex));
        }
      }

      function handleSlideDragOver(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const preview = item.querySelector('.slide-preview');
        if (!preview) return;
        clearSlideDragIndicators();
        preview.classList.add('drop-target');
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        if (isAfter) {
          preview.classList.add('drop-target-after');
          preview.classList.remove('drop-target-before');
        } else {
          preview.classList.add('drop-target-before');
          preview.classList.remove('drop-target-after');
        }
        item.dataset.dropPosition = isAfter ? 'after' : 'before';
      }

      function handleSlideDragLeave(event) {
        const item = event.currentTarget;
        if (!item) return;
        const preview = item.querySelector('.slide-preview');
        if (preview) {
          preview.classList.remove('drop-target', 'drop-target-before', 'drop-target-after');
        }
        delete item.dataset.dropPosition;
      }

      function finalizeSlideReorder(fromIndex, insertIndex, targetSectionId = null) {
        if (fromIndex === null || insertIndex === null) return;
        if (fromIndex < 0 || fromIndex >= slides.length) return;
        if (insertIndex < 0) insertIndex = 0;
        if (insertIndex > slides.length) insertIndex = slides.length;
        
        // Check if we need to move the slide
        const needsMove = insertIndex !== fromIndex && insertIndex !== fromIndex + 1;
        
        // If no move needed but we have a target section, just add to section
        if (!needsMove && targetSectionId) {
          const targetSection = sections.find(s => s.id === targetSectionId);
          if (targetSection && !targetSection.slideIndices.includes(fromIndex)) {
            // Remove from source section if it exists
            const sourceSection = sections.find(section => 
              section.slideIndices.includes(fromIndex) && section.id !== targetSectionId
            );
            if (sourceSection) {
              const indexInSection = sourceSection.slideIndices.indexOf(fromIndex);
              if (indexInSection !== -1) {
                sourceSection.slideIndices.splice(indexInSection, 1);
                if (sourceSection.slideIndices.length === 0) {
                  sections = sections.filter(s => s.id !== sourceSection.id);
                }
              }
            }
            // Add to target section
            targetSection.slideIndices.push(fromIndex);
            targetSection.slideIndices.sort((a, b) => a - b);
        capture();
            renderSidebar();
            saveEditorState('add_slide_to_section');
            return;
          }
        }
        
        // If no move needed and no section change, do nothing
        if (!needsMove && !targetSectionId) {
          return;
        }
        
        // If we reach here, we need to move the slide
        capture();

        // Find which section (if any) contains the source slide
        const sourceSection = sections.find(section => 
          section.slideIndices.includes(fromIndex)
        );

        // Remove slide from source section if it exists
        if (sourceSection) {
          const indexInSection = sourceSection.slideIndices.indexOf(fromIndex);
          if (indexInSection !== -1) {
            sourceSection.slideIndices.splice(indexInSection, 1);
            // Remove empty sections
            if (sourceSection.slideIndices.length === 0) {
              sections = sections.filter(s => s.id !== sourceSection.id);
            }
          }
        }

        // Move the slide in the slides array
        const [movedSlide] = slides.splice(fromIndex, 1);
        let adjustedInsertIndex = insertIndex;
        if (insertIndex > fromIndex) {
          adjustedInsertIndex = insertIndex - 1;
        }
        if (adjustedInsertIndex < 0) adjustedInsertIndex = 0;
        slides.splice(adjustedInsertIndex, 0, movedSlide);

        // Update all section slideIndices that are affected by the move
        sections.forEach(section => {
          section.slideIndices = section.slideIndices.map(idx => {
            if (idx === fromIndex) {
              return adjustedInsertIndex;
            } else if (fromIndex < idx && idx < insertIndex) {
              return idx - 1;
            } else if (insertIndex <= idx && idx < fromIndex) {
              return idx + 1;
            }
            return idx;
          });
          // Update anchorSlideIndex if needed
          if (section.anchorSlideIndex === fromIndex) {
            section.anchorSlideIndex = adjustedInsertIndex;
          } else if (fromIndex < section.anchorSlideIndex && section.anchorSlideIndex < insertIndex) {
            section.anchorSlideIndex -= 1;
          } else if (insertIndex <= section.anchorSlideIndex && section.anchorSlideIndex < fromIndex) {
            section.anchorSlideIndex += 1;
          }
        });

        // Add slide to target section if specified
        if (targetSectionId) {
          const targetSection = sections.find(s => s.id === targetSectionId);
          if (targetSection && !targetSection.slideIndices.includes(adjustedInsertIndex)) {
            targetSection.slideIndices.push(adjustedInsertIndex);
            // Sort slide indices within the section
            targetSection.slideIndices.sort((a, b) => a - b);
          }
        }

        let newActive = active;
        if (fromIndex === active) {
          newActive = adjustedInsertIndex;
        } else {
          if (fromIndex < active) {
            newActive -= 1;
          }
          if (adjustedInsertIndex <= newActive) {
            newActive += 1;
          }
        }
        active = Math.max(0, Math.min(slides.length - 1, newActive));
        load();
        renderSidebar();
        saveEditorState('reorder_slides');
      }

      function handleSlideDrop(event) {
        if (slideDragSourceIndex === null) return;
        event.preventDefault();
        const item = event.currentTarget;
        if (!item || typeof item.dataset.index === 'undefined') return;
        const targetIndex = parseInt(item.dataset.index, 10);
        if (Number.isNaN(targetIndex)) return;
        const rect = item.getBoundingClientRect();
        const isAfter = (event.clientY - rect.top) > rect.height / 2;
        const insertIndex = targetIndex + (isAfter ? 1 : 0);
        
        // Find if the target slide is in a section
        const targetSection = sections.find(section => 
          section.slideIndices.includes(targetIndex)
        );
        const targetSectionId = targetSection ? targetSection.id : null;
        
        clearSlideDragIndicators();
        delete item.dataset.dropPosition;
        finalizeSlideReorder(slideDragSourceIndex, insertIndex, targetSectionId);
      }

      function handleSlideDragEnd(event) {
        const item = event.currentTarget;
        if (item) {
          item.classList.remove('dragging');
          delete item.dataset.dropPosition;
        }
        clearSlideDragIndicators();
        slideDragSourceIndex = null;
      }

      function selectEditableText(element) {
        const range = document.createRange();
        range.selectNodeContents(element);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function refreshSidebarSoon() {
        requestAnimationFrame(() => renderSidebar());
      }

      function moveSlideByOffset(index, offset) {
        if (!Number.isInteger(index) || !Number.isInteger(offset)) return;
        const targetIndex = index + offset;
        if (targetIndex < 0 || targetIndex >= slides.length) return;
        finalizeSlideReorder(index, targetIndex + (offset > 0 ? 1 : 0));
      }

      function normalizeTransitionEffect(value) {
        if (typeof value !== 'string') {
          return DEFAULT_TRANSITION;
        }
        const normalized = value.toLowerCase();
        return TRANSITION_VALUE_SET.has(normalized) ? normalized : DEFAULT_TRANSITION;
      }

      function clampTransitionDuration(value) {
        const numeric = Number.parseFloat(value);
        if (!Number.isFinite(numeric)) {
          return DEFAULT_TRANSITION_DURATION;
        }
        const clamped = Math.min(TRANSITION_DURATION_MAX, Math.max(TRANSITION_DURATION_MIN, numeric));
        return Math.round(clamped * 10) / 10;
      }

      function getSlideTransitionConfig(slide) {
        const effect = normalizeTransitionEffect(slide?.transition);
        const duration = clampTransitionDuration(slide?.transitionDuration);
        return { effect, duration };
      }

      function applyTransitionConfigToSlide(slide, config) {
        if (!slide) {
          return { changed: false, effect: DEFAULT_TRANSITION, duration: DEFAULT_TRANSITION_DURATION };
        }
        const targetEffect = normalizeTransitionEffect(config?.effect ?? slide.transition);
        const targetDuration = clampTransitionDuration(config?.duration ?? slide.transitionDuration);
        const current = getSlideTransitionConfig(slide);
        const changed = current.effect !== targetEffect || current.duration !== targetDuration;
        slide.transition = targetEffect;
        slide.transitionDuration = targetDuration;
        return { changed, effect: targetEffect, duration: targetDuration };
      }

      function applySlideTransitionClass(element, transition, durationSeconds, options = {}) {
        if (!element) return;
        const normalized = normalizeTransitionEffect(transition);
        const duration = clampTransitionDuration(durationSeconds);
        TRANSITION_CLASS_NAMES.forEach(cls => element.classList.remove(cls));
        element.style.removeProperty('--transition-duration');
        const shouldAnimate = options.force === true || isPresenting;
        if (!shouldAnimate || normalized === DEFAULT_TRANSITION) {
          return;
        }
        element.style.setProperty('--transition-duration', `${duration}s`);
        void element.offsetWidth;
        element.classList.add(`transition-effect-${normalized}`);
      }

      function getTransitionLabel(type) {
        const option = TRANSITION_OPTIONS.find(opt => opt.value === normalizeTransitionEffect(type)) || TRANSITION_OPTIONS[0];
        return option.label;
      }

      function getTransitionIconHtml(type) {
        const normalized = normalizeTransitionEffect(type || DEFAULT_TRANSITION);
        switch (normalized) {
          case 'fade':
            return '<i class="fas fa-water"></i>';
          case 'slide-left':
            return '<i class="fas fa-arrow-left"></i>';
          case 'slide-right':
            return '<i class="fas fa-arrow-right"></i>';
          case 'slide-up':
            return '<i class="fas fa-arrow-up"></i>';
          case 'slide-down':
            return '<i class="fas fa-arrow-down"></i>';
          case 'zoom-in':
            return '<i class="fas fa-search-plus"></i>';
          case 'zoom-out':
            return '<i class="fas fa-search-minus"></i>';
          case 'flip':
            return '<i class="fas fa-sync-alt"></i>';
          case 'rotate':
            return '<i class="fas fa-sync"></i>';
          case 'none':
          default:
            return `
              <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="15" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.8"/>
                <rect x="11" y="9" width="10" height="8" rx="1.6" ry="1.6" fill="none" stroke="currentColor" stroke-width="1.6"/>
                <path d="M3 8h15M3 11h7M3 14h7" stroke="currentColor" stroke-width="1.2" />
              </svg>
            `;
        }
      }

      function updateTransitionButtonAppearance(button, slideIndex) {
        if (!button) return;
        const slide = slides[slideIndex];
        const { effect, duration } = getSlideTransitionConfig(slide);
        const iconHtml = getTransitionIconHtml(effect);
        button.innerHTML = `<span class="transition-icon">${iconHtml}</span><span class="transition-caret"><i class="fas fa-caret-down"></i></span>`;
        const targetSlideNumber = slideIndex === slides.length - 1 ? 'End' : `Slide ${slideIndex + 2}`;
        const label = getTransitionLabel(effect);
        const durationLabel = duration.toFixed(1).replace(/\.0$/, '');
        button.title = `Transition (${label}, ${durationLabel}s) â†’ ${targetSlideNumber}`;
        button.setAttribute('aria-label', button.title);
      }

      function syncTransitionControlsWithSlide() {
        if (!transitionEffectSelect || !transitionDurationInput) return;
        const { effect, duration } = getSlideTransitionConfig(slides[active]);
        if (transitionEffectSelect.value !== effect) {
          transitionEffectSelect.value = effect;
        }
        transitionDurationInput.value = duration.toFixed(1);
      }

      function refreshSidebarTransitionButton(index) {
        if (!sidebar) return;
        const button = sidebar.querySelector(`.transition-control-button[data-slide-index="${index}"]`);
        if (button) {
          updateTransitionButtonAppearance(button, index);
        }
      }

      function refreshAllTransitionButtons() {
        if (!sidebar) return;
        sidebar.querySelectorAll('.transition-control-button').forEach((button) => {
          const slideIndex = Number.parseInt(button.getAttribute('data-slide-index') || '', 10);
          if (Number.isInteger(slideIndex)) {
            updateTransitionButtonAppearance(button, slideIndex);
          }
        });
      }

      function updateActiveSlideTransition(effect, duration, { recordHistory = true } = {}) {
        const slide = slides[active];
        if (!slide) return false;
        const normalizedEffect = normalizeTransitionEffect(effect);
        const normalizedDuration = clampTransitionDuration(duration);
        const current = getSlideTransitionConfig(slide);
        const hasChanged = current.effect !== normalizedEffect || current.duration !== normalizedDuration;
        if (!hasChanged) {
          syncTransitionControlsWithSlide();
          return false;
        }
        if (recordHistory) {
          capture();
        }
        applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: normalizedDuration });
        syncTransitionControlsWithSlide();
        refreshSidebarTransitionButton(active);
        refreshSidebarSoon();
        if (recordHistory) {
          saveEditorState('change_transition');
        }
        return true;
      }

      function hideSlideContextMenu() {
        if (!slideContextMenu || !slideContextMenu.classList.contains('show')) {
          slideContextMenuTarget = null;
          slideContextMenuTitle = null;
          slideContextMenuIndex = null;
          return;
        }
        slideContextMenu.classList.remove('show');
        slideContextMenu.style.top = '';
        slideContextMenu.style.left = '';
        slideContextMenuTarget = null;
        slideContextMenuTitle = null;
        slideContextMenuIndex = null;
      }

      function showSlideContextMenu(event, index, titleElement, slideItem) {
        if (!slideContextMenu || !titleElement || !slideItem) return;
        event.preventDefault();
        hideSlideCanvasContextMenu();
        slideContextMenuIndex = index;
        slideContextMenuTitle = titleElement;
        slideContextMenuTarget = slideItem;

        // Enable cut and copy buttons when right-clicking on a slide
        const cutBtn = slideContextMenu.querySelector('[data-action="cut-slide"]');
        const copyBtn = slideContextMenu.querySelector('[data-action="copy-slide"]');
        if (cutBtn) {
          cutBtn.disabled = false;
        }
        if (copyBtn) {
          copyBtn.disabled = false;
        }

        slideContextMenu.classList.add('show');
        const menuRect = slideContextMenu.getBoundingClientRect();
        const padding = 8;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        top = Math.max(padding, top);
        left = Math.max(padding, left);
        slideContextMenu.style.top = `${top}px`;
        slideContextMenu.style.left = `${left}px`;
      }

      function hideSlideTransitionMenu() {
        if (!slideTransitionMenu || !slideTransitionMenu.classList.contains('show')) {
          slideTransitionMenuIndex = null;
          slideTransitionMenuAnchor = null;
          return;
        }
        slideTransitionMenu.classList.remove('show');
        slideTransitionMenu.style.top = '';
        slideTransitionMenu.style.left = '';
        slideTransitionMenuIndex = null;
        slideTransitionMenuAnchor = null;
      }

      function showSlideTransitionMenu(event, index, anchorElement) {
        if (!slideTransitionMenu || !anchorElement) return;
        event.preventDefault();
        event.stopPropagation();
        hideSlideCanvasContextMenu();
        slideTransitionMenuIndex = index;
        slideTransitionMenuAnchor = anchorElement;
        slideTransitionMenu.classList.add('show');
        const buttons = slideTransitionMenu.querySelectorAll('button');
        const currentTransition = normalizeTransitionEffect(slides[index]?.transition);
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.transition === currentTransition);
        });
        const menuRect = slideTransitionMenu.getBoundingClientRect();
        const anchorRect = anchorElement.getBoundingClientRect();
        const padding = 8;
        let top = anchorRect.top + window.scrollY - menuRect.height - 6;
        let left = anchorRect.left + window.scrollX - menuRect.width / 2 + anchorRect.width / 2;
        if (top < padding) {
          top = anchorRect.bottom + window.scrollY + 6;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        if (left < padding) {
          left = padding;
        }
        slideTransitionMenu.style.top = `${top}px`;
        slideTransitionMenu.style.left = `${left}px`;
      }

      if (slideContextRenameBtn) {
        slideContextRenameBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const titleElement = slideContextMenuTitle;
          const slideIndex = slideContextMenuIndex;
          const slideItem = slideContextMenuTarget;
          hideSlideContextMenu();
          if (titleElement && slideItem && Number.isInteger(slideIndex)) {
            startSlideTitleEditing(titleElement, slideIndex, slideItem);
          }
        });
      }

      if (slideContextAddSectionBtn) {
        slideContextAddSectionBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const slideIndex = slideContextMenuIndex;
          hideSlideContextMenu();
          if (Number.isInteger(slideIndex)) {
            // When right-clicking on a slide, replace its position
            addSectionAtSlide(slideIndex, true);
          }
        });
      }

      // Sidebar context menu handlers
      function showSidebarContextMenu(event) {
        if (!sidebarContextMenu) return;
        event.preventDefault();
        event.stopPropagation();
        hideSlideContextMenu();
        hideSlideCanvasContextMenu();
        
        // Disable cut and copy buttons when right-clicking on empty sidebar
        const cutBtn = sidebarContextMenu.querySelector('[data-action="cut-slide"]');
        const copyBtn = sidebarContextMenu.querySelector('[data-action="copy-slide"]');
        if (cutBtn) {
          cutBtn.disabled = true;
        }
        if (copyBtn) {
          copyBtn.disabled = true;
        }
        
        sidebarContextMenu.classList.add('show');
        const menuRect = sidebarContextMenu.getBoundingClientRect();
        const padding = 8;
        let top = event.clientY;
        let left = event.clientX;
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        top = Math.max(padding, top);
        left = Math.max(padding, left);
        sidebarContextMenu.style.top = `${top}px`;
        sidebarContextMenu.style.left = `${left}px`;
      }

      function hideSidebarContextMenu() {
        if (!sidebarContextMenu || !sidebarContextMenu.classList.contains('show')) {
          return;
        }
        sidebarContextMenu.classList.remove('show');
        sidebarContextMenu.style.top = '';
        sidebarContextMenu.style.left = '';
      }

      // Event listeners for slide context menu actions
      slideContextMenu.querySelector('[data-action="cut-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const slideIndex = slideContextMenuIndex;
        hideSlideContextMenu();
        if (Number.isInteger(slideIndex)) {
          cutSlideAt(slideIndex);
        }
      });

      slideContextMenu.querySelector('[data-action="copy-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const slideIndex = slideContextMenuIndex;
        hideSlideContextMenu();
        if (Number.isInteger(slideIndex)) {
          copySlideAt(slideIndex);
          showNotification('Slide copied');
        }
      });

      slideContextMenu.querySelector('[data-action="paste-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const slideIndex = slideContextMenuIndex;
        hideSlideContextMenu();
        if (Number.isInteger(slideIndex)) {
          pasteSlideAfter(slideIndex);
        }
      });

      slideContextMenu.querySelector('[data-action="select-all-slides"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSlideContextMenu();
        // Select all functionality can be implemented later
        showNotification('Select all slides - feature coming soon');
      });

      slideContextMenu.querySelector('[data-action="new-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const slideIndex = slideContextMenuIndex;
        hideSlideContextMenu();
        if (Number.isInteger(slideIndex)) {
          createNewSlide(slideIndex);
        }
      });

      slideContextMenu.querySelector('[data-action="rename-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const titleElement = slideContextMenuTitle;
        const slideIndex = slideContextMenuIndex;
        const slideItem = slideContextMenuTarget;
        hideSlideContextMenu();
        if (titleElement && Number.isInteger(slideIndex)) {
          startSlideTitleEditing(titleElement, slideIndex, slideItem);
        }
      });

      slideContextMenu.querySelector('[data-action="duplicate-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const slideIndex = slideContextMenuIndex;
        hideSlideContextMenu();
        if (Number.isInteger(slideIndex)) {
          duplicateCurrentSlide(slideIndex);
        }
      });

      slideContextMenu.querySelector('[data-action="delete-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const slideIndex = slideContextMenuIndex;
        hideSlideContextMenu();
        if (Number.isInteger(slideIndex)) {
          if (confirm('Delete this slide?')) {
            deleteSlide(slideIndex);
          }
        }
      });

      // Event listeners for sidebar context menu actions
      sidebarContextMenu.querySelector('[data-action="cut-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSidebarContextMenu();
        if (Number.isInteger(active)) {
          cutSlideAt(active);
        }
      });

      sidebarContextMenu.querySelector('[data-action="copy-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSidebarContextMenu();
        if (Number.isInteger(active)) {
          copySlideAt(active);
          showNotification('Slide copied');
        }
      });

      sidebarContextMenu.querySelector('[data-action="paste-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSidebarContextMenu();
        if (Number.isInteger(active)) {
          pasteSlideAfter(active);
        }
      });

      sidebarContextMenu.querySelector('[data-action="select-all-slides"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSidebarContextMenu();
        showNotification('Select all slides - feature coming soon');
      });

      sidebarContextMenu.querySelector('[data-action="new-slide"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSidebarContextMenu();
        if (Number.isInteger(active)) {
          createNewSlide(active);
        }
      });

      sidebarContextMenu.querySelector('[data-action="add-section"]')?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideSidebarContextMenu();
        if (Number.isInteger(active)) {
          // When right-clicking on empty sidebar, place section after the active slide
          addSectionAtSlide(active, false);
        }
      });

      // Add context menu listener to sidebar
      if (sidebar) {
        sidebar.addEventListener('contextmenu', (event) => {
          // Only show sidebar menu if clicking on empty area (not on a slide item)
          const target = event.target;
          if (!target.closest('.slide-item') && !target.closest('.section-header')) {
            showSidebarContextMenu(event);
          }
        });
      }

      // Section context menu event listeners
      const sectionContextMenuEl = document.getElementById('sectionContextMenu');
      if (sectionContextMenuEl) {
        sectionContextMenuEl.querySelector('[data-action="rename-section"]')?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const targetId = sectionContextMenuTargetId; // Save before hiding
          hideSectionContextMenu();
          if (targetId) {
            renameSection(targetId);
            sectionContextMenuTargetId = null;
          }
        });

        sectionContextMenuEl.querySelector('[data-action="remove-section"]')?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const targetId = sectionContextMenuTargetId; // Save before hiding
          hideSectionContextMenu();
          if (targetId) {
            const section = sections.find(s => s.id === targetId);
            if (section) {
              showSectionConfirmModal(
                'Remove Section',
                `Remove section "${section.name}"? This will not delete the slides.`,
                'Remove Section',
                () => {
                  removeSection(targetId);
                  sectionContextMenuTargetId = null;
                }
              );
            }
          }
        });

        sectionContextMenuEl.querySelector('[data-action="remove-section-and-slides"]')?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const targetId = sectionContextMenuTargetId; // Save before hiding
          hideSectionContextMenu();
          if (targetId) {
            const section = sections.find(s => s.id === targetId);
            if (section) {
              showSectionConfirmModal(
                'Remove Section and Slides',
                `Remove section "${section.name}" and all its ${section.slideIndices.length} slide(s)? This action cannot be undone.`,
                'Remove Section and Slides',
                () => {
                  removeSectionAndSlides(targetId);
                  sectionContextMenuTargetId = null;
                }
              );
            }
          }
        });

        sectionContextMenuEl.querySelector('[data-action="remove-all-sections"]')?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          hideSectionContextMenu();
          const sectionCount = sections.length;
          if (sectionCount === 0) {
            showNotification('No sections to remove');
            return;
          }
          showSectionConfirmModal(
            'Remove All Sections',
            `Remove all ${sectionCount} section(s)? This will not delete the slides.`,
            'Remove All Sections',
            () => {
              removeAllSections();
              sectionContextMenuTargetId = null;
            }
          );
        });

        sectionContextMenuEl.querySelector('[data-action="move-section-up"]')?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const targetId = sectionContextMenuTargetId; // Save before hiding
          hideSectionContextMenu();
          if (targetId) {
            moveSectionUp(targetId);
            sectionContextMenuTargetId = null;
          }
        });

        sectionContextMenuEl.querySelector('[data-action="move-section-down"]')?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const targetId = sectionContextMenuTargetId; // Save before hiding
          hideSectionContextMenu();
          if (targetId) {
            moveSectionDown(targetId);
            sectionContextMenuTargetId = null;
          }
        });
      }

      // Hide context menus when clicking outside
      document.addEventListener('click', (event) => {
        if (sidebarContextMenu && sidebarContextMenu.classList.contains('show') && !sidebarContextMenu.contains(event.target)) {
          hideSidebarContextMenu();
        }
        if (slideContextMenu && slideContextMenu.classList.contains('show') && !slideContextMenu.contains(event.target)) {
          hideSlideContextMenu();
        }
        const sectionContextMenu = document.getElementById('sectionContextMenu');
        if (sectionContextMenu && sectionContextMenu.classList.contains('show') && !sectionContextMenu.contains(event.target)) {
          hideSectionContextMenu();
        }
      });

      if (slideTransitionMenu) {
        slideTransitionMenu.querySelectorAll('button').forEach(btn => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (slideTransitionMenuIndex === null) {
              hideSlideTransitionMenu();
              return;
            }
            const value = btn.dataset.transition || DEFAULT_TRANSITION;
            const slide = slides[slideTransitionMenuIndex];
            hideSlideTransitionMenu();
            if (!slide) return;
            const priorConfig = getSlideTransitionConfig(slide);
            const normalizedEffect = normalizeTransitionEffect(value);
            if (priorConfig.effect === normalizedEffect) {
              return;
            }
            capture();
            applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: priorConfig.duration });
            if (slideTransitionMenuIndex === active) {
              syncTransitionControlsWithSlide();
            }
            if (slideTransitionMenuAnchor) {
              updateTransitionButtonAppearance(slideTransitionMenuAnchor, slideTransitionMenuIndex);
            } else {
              refreshSidebarTransitionButton(slideTransitionMenuIndex);
            }
            saveEditorState('change_transition');
            refreshSidebarSoon();
          });
        });
      }

      document.addEventListener('click', (event) => {
        if (slideContextMenu && slideContextMenu.classList.contains('show') && !slideContextMenu.contains(event.target)) {
          hideSlideContextMenu();
        }
        if (sidebarContextMenu && sidebarContextMenu.classList.contains('show') && !sidebarContextMenu.contains(event.target)) {
          hideSidebarContextMenu();
        }
        if (slideTransitionMenu && slideTransitionMenu.classList.contains('show') && !slideTransitionMenu.contains(event.target)) {
          hideSlideTransitionMenu();
        }
        const sectionContextMenu = document.getElementById('sectionContextMenu');
        if (sectionContextMenu && sectionContextMenu.classList.contains('show') && !sectionContextMenu.contains(event.target)) {
          hideSectionContextMenu();
        }
      });

      window.addEventListener('resize', hideSlideContextMenu);
      window.addEventListener('scroll', hideSlideContextMenu, true);
      window.addEventListener('resize', hideSlideTransitionMenu);
      window.addEventListener('scroll', hideSlideTransitionMenu, true);

      function startSlideTitleEditing(titleElement, slideIndex, slideItem) {
        if (!titleElement) return;
        const originalTitle = titleElement.textContent.trim();
        titleElement.contentEditable = 'true';
        titleElement.classList.add('editing');
        titleElement.focus({ preventScroll: true });
        selectEditableText(titleElement);
        if (slideItem) {
          slideItem.setAttribute('draggable', 'false');
        }

        function cleanup() {
          titleElement.contentEditable = 'false';
          titleElement.classList.remove('editing');
          if (slideItem) {
            slideItem.setAttribute('draggable', 'true');
          }
          titleElement.removeEventListener('blur', handleBlur);
          titleElement.removeEventListener('keydown', handleKeyDown);
        }

        function applyTitleChange(shouldPersist) {
          const trimmed = titleElement.textContent.trim();
          // Use slide.name for sidebar, fallback to slide.title for backward compatibility
          const currentName = slides[slideIndex].name || slides[slideIndex].title || '';
          const fallback = originalTitle || currentName || `Slide ${slideIndex + 1}`;
          const finalName = shouldPersist ? (trimmed || fallback) : fallback;
          cleanup();
          titleElement.textContent = finalName;
          if (shouldPersist && finalName !== originalTitle) {
            // Only update the slide name (for sidebar identification), NOT the title content
            slides[slideIndex].name = finalName;
            // Do NOT update titleBox - it should remain independent
            capture();
            saveEditorState('rename_slide');
          }
          refreshSidebarSoon();
        }

        function handleBlur() {
          applyTitleChange(true);
        }

        function handleKeyDown(event) {
          if (event.key === 'Enter') {
            event.preventDefault();
            applyTitleChange(true);
          } else if (event.key === 'Escape') {
            event.preventDefault();
            titleElement.textContent = originalTitle;
            applyTitleChange(false);
          }
        }

        titleElement.addEventListener('blur', handleBlur);
        titleElement.addEventListener('keydown', handleKeyDown);
      }

      // Section management functions
      function getSectionForSlide(slideIndex) {
        return sections.find(section => section.slideIndices.includes(slideIndex));
      }

      // Section name modal functions
      let sectionNameModalCallback = null;
      let sectionNameModalMode = 'create'; // 'create' or 'rename'
      let sectionNameModalSectionId = null;

      function showSectionNameModal(mode = 'create', defaultValue = '', sectionId = null, callback = null) {
        const modal = document.getElementById('sectionNameModal');
        const input = document.getElementById('sectionNameInput');
        const titleText = document.getElementById('sectionNameModalTitleText');
        const submitBtn = document.getElementById('sectionNameModalSubmit');
        
        if (!modal || !input) return;
        
        sectionNameModalMode = mode;
        sectionNameModalSectionId = sectionId;
        sectionNameModalCallback = callback;
        
        if (mode === 'rename') {
          titleText.textContent = 'Rename Section';
          submitBtn.textContent = 'Rename';
        } else {
          titleText.textContent = 'New Section';
          submitBtn.textContent = 'Create';
        }
        
        input.value = defaultValue;
        modal.classList.add('show');
        
        // Focus and select text after modal animation
        setTimeout(() => {
          input.focus();
          input.select();
        }, 100);
      }

      function hideSectionNameModal() {
        const modal = document.getElementById('sectionNameModal');
        const input = document.getElementById('sectionNameInput');
        if (modal) {
          modal.classList.remove('show');
        }
        if (input) {
          input.value = '';
        }
        sectionNameModalCallback = null;
        sectionNameModalSectionId = null;
      }

      let deleteSectionModalSectionId = null;

      function showDeleteSectionModal(sectionId, sectionName) {
        const modal = document.getElementById('deleteSectionModal');
        const message = document.getElementById('deleteSectionModalMessage');
        if (modal && message) {
          deleteSectionModalSectionId = sectionId;
          message.textContent = `Delete section "${sectionName}"?`;
          modal.classList.add('show');
        }
      }

      function hideDeleteSectionModal() {
        const modal = document.getElementById('deleteSectionModal');
        if (modal) {
          modal.classList.remove('show');
        }
        deleteSectionModalSectionId = null;
      }

      function handleDeleteSectionConfirm() {
        if (deleteSectionModalSectionId) {
          removeSection(deleteSectionModalSectionId);
          hideDeleteSectionModal();
        }
      }

      function handleSectionNameSubmit() {
        const input = document.getElementById('sectionNameInput');
        if (!input) return;
        
        const sectionName = input.value.trim();
        if (!sectionName) {
          input.focus();
          return;
        }
        
        if (sectionNameModalCallback) {
          sectionNameModalCallback(sectionName);
        } else if (sectionNameModalMode === 'rename' && sectionNameModalSectionId) {
          renameSectionWithName(sectionNameModalSectionId, sectionName);
        } else {
          // Default: create new section at active slide
          if (Number.isInteger(active)) {
            createSectionWithName(active, sectionName);
          }
        }
        
        hideSectionNameModal();
      }

      function createSectionWithName(slideIndex, sectionName, replaceSlidePosition = false) {
        const sectionId = `section-${nextSectionId++}`;
        
        let anchorSlideIndex;
        let slideIndicesForNewSection = [];
        
        if (replaceSlidePosition) {
          // Remove slide from any existing section
          removeSlideFromSection(slideIndex);
          // The section appears at the slideIndex position
          // The slide at slideIndex becomes the first slide in the section
          anchorSlideIndex = slideIndex;
          slideIndicesForNewSection = [slideIndex];
        } else {
          // Create section below without affecting the current slide
          // Find the section containing this slide (if any)
          const containingSection = sections.find(section => 
            section.slideIndices.includes(slideIndex)
          );
          
          if (containingSection) {
            // Position the new section after the containing section
            // Use the max slide index in the section + 1, or slideIndex + 1 if that's the last slide
            const maxSlideIndex = Math.max(...containingSection.slideIndices);
            anchorSlideIndex = Math.max(maxSlideIndex + 1, slideIndex + 1);
          } else {
            // Slide is not in a section, create section after it
            anchorSlideIndex = slideIndex + 1;
          }
          // New section starts empty (no slides)
          slideIndicesForNewSection = [];
        }
        
        const newSection = {
          id: sectionId,
          name: sectionName,
          slideIndices: slideIndicesForNewSection,
          collapsed: false,
          anchorSlideIndex: anchorSlideIndex
        };
        
        // Find where to insert the section based on anchorSlideIndex
        // Sections are ordered by their anchorSlideIndex
        let insertIndex = 0;
        for (let i = 0; i < sections.length; i++) {
          const section = sections[i];
          const anchor = section.anchorSlideIndex !== undefined ? section.anchorSlideIndex : 
                        (section.slideIndices.length > 0 ? section.slideIndices[0] : 0);
          if (anchor < anchorSlideIndex) {
            insertIndex = i + 1;
          } else {
            break;
          }
        }
        
        sections.splice(insertIndex, 0, newSection);
        
        capture();
        renderSidebar();
        saveEditorState('add_section');
        showNotification(`Section "${sectionName}" created`);
      }

      function renameSectionWithName(sectionId, newName) {
        const section = sections.find(s => s.id === sectionId);
        if (!section) return;
        section.name = newName;
        capture();
        renderSidebar();
        saveEditorState('rename_section');
        showNotification(`Section renamed to "${newName}"`);
      }

      function addSectionAtSlide(slideIndex, replaceSlidePosition = false) {
        const defaultValue = `Section ${nextSectionId}`;
        showSectionNameModal('create', defaultValue, null, (sectionName) => {
          createSectionWithName(slideIndex, sectionName, replaceSlidePosition);
        });
      }

      function removeSection(sectionId) {
        sections = sections.filter(s => s.id !== sectionId);
        capture();
        renderSidebar();
        saveEditorState('remove_section');
        showNotification('Section removed');
        hideSectionConfirmModal();
      }

      function removeSectionAndSlides(sectionId) {
        const section = sections.find(s => s.id === sectionId);
        if (!section) return;
        
        // Sort slide indices in descending order to delete from end to start
        const sortedIndices = [...section.slideIndices].sort((a, b) => b - a);
        sortedIndices.forEach(slideIndex => {
          if (slideIndex >= 0 && slideIndex < slides.length) {
            deleteSlide(slideIndex);
          }
        });
        
        // Remove the section
        sections = sections.filter(s => s.id !== sectionId);
        
        capture();
        renderSidebar();
        saveEditorState('remove_section_and_slides');
        showNotification(`Section "${section.name}" and its slides removed`);
        hideSectionConfirmModal();
      }

      function removeAllSections() {
        const sectionCount = sections.length;
        if (sectionCount === 0) {
          showNotification('No sections to remove');
          hideSectionConfirmModal();
          return;
        }
        
        sections = [];
        capture();
        renderSidebar();
        saveEditorState('remove_all_sections');
        showNotification(`All ${sectionCount} section(s) removed`);
        hideSectionConfirmModal();
      }

      function moveSectionUp(sectionId) {
        const sectionIndex = sections.findIndex(s => s.id === sectionId);
        if (sectionIndex <= 0) return; // Already at top or not found
        
        // Swap with previous section
        const temp = sections[sectionIndex];
        sections[sectionIndex] = sections[sectionIndex - 1];
        sections[sectionIndex - 1] = temp;
        
        // Update anchorSlideIndex for both sections
        const currentAnchor = sections[sectionIndex].anchorSlideIndex !== undefined 
          ? sections[sectionIndex].anchorSlideIndex 
          : (sections[sectionIndex].slideIndices.length > 0 ? sections[sectionIndex].slideIndices[0] : 0);
        
        const prevAnchor = sections[sectionIndex - 1].anchorSlideIndex !== undefined 
          ? sections[sectionIndex - 1].anchorSlideIndex 
          : (sections[sectionIndex - 1].slideIndices.length > 0 ? sections[sectionIndex - 1].slideIndices[0] : 0);
        
        sections[sectionIndex].anchorSlideIndex = prevAnchor;
        sections[sectionIndex - 1].anchorSlideIndex = currentAnchor;
        
        capture();
        renderSidebar();
        saveEditorState('move_section_up');
        const movedSection = sections[sectionIndex - 1];
        if (movedSection) {
          showNotification(`Section "${movedSection.name}" moved up`);
        }
      }

      function moveSectionDown(sectionId) {
        const sectionIndex = sections.findIndex(s => s.id === sectionId);
        if (sectionIndex < 0 || sectionIndex >= sections.length - 1) return; // Already at bottom or not found
        
        // Swap with next section
        const temp = sections[sectionIndex];
        sections[sectionIndex] = sections[sectionIndex + 1];
        sections[sectionIndex + 1] = temp;
        
        // Update anchorSlideIndex for both sections
        const currentAnchor = sections[sectionIndex].anchorSlideIndex !== undefined 
          ? sections[sectionIndex].anchorSlideIndex 
          : (sections[sectionIndex].slideIndices.length > 0 ? sections[sectionIndex].slideIndices[0] : 0);
        
        const nextAnchor = sections[sectionIndex + 1].anchorSlideIndex !== undefined 
          ? sections[sectionIndex + 1].anchorSlideIndex 
          : (sections[sectionIndex + 1].slideIndices.length > 0 ? sections[sectionIndex + 1].slideIndices[0] : 0);
        
        sections[sectionIndex].anchorSlideIndex = nextAnchor;
        sections[sectionIndex + 1].anchorSlideIndex = currentAnchor;
        
        capture();
        renderSidebar();
        saveEditorState('move_section_down');
        const movedSection = sections[sectionIndex + 1];
        if (movedSection) {
          showNotification(`Section "${movedSection.name}" moved down`);
        }
      }

      function renameSection(sectionId) {
        const section = sections.find(s => s.id === sectionId);
        if (!section) return;
        showSectionNameModal('rename', section.name, sectionId);
      }

      function toggleSectionCollapse(sectionId) {
        const section = sections.find(s => s.id === sectionId);
        if (!section) return;
        section.collapsed = !section.collapsed;
        renderSidebar();
      }
      
      // Section context menu functions
      let sectionContextMenuTargetId = null;
      
      function showSectionContextMenu(event, sectionId) {
        const sectionContextMenu = document.getElementById('sectionContextMenu');
        if (!sectionContextMenu) return;
        
        // Hide other menus
        hideSlideContextMenu();
        hideSlideCanvasContextMenu();
        hideElementContextMenu();
        
        sectionContextMenuTargetId = sectionId;
        const section = sections.find(s => s.id === sectionId);
        if (!section) return;
        
        // Update button states
        const moveUpBtn = sectionContextMenu.querySelector('[data-action="move-section-up"]');
        const moveDownBtn = sectionContextMenu.querySelector('[data-action="move-section-down"]');
        
        const sectionIndex = sections.findIndex(s => s.id === sectionId);
        if (moveUpBtn) {
          moveUpBtn.disabled = sectionIndex <= 0;
        }
        if (moveDownBtn) {
          moveDownBtn.disabled = sectionIndex < 0 || sectionIndex >= sections.length - 1;
        }
        
        sectionContextMenu.classList.add('show');
        sectionContextMenu.style.top = '0px';
        sectionContextMenu.style.left = '0px';
        
        const menuRect = sectionContextMenu.getBoundingClientRect();
        const padding = 12;
        let top = event.clientY;
        let left = event.clientX;
        
        if (top + menuRect.height > window.innerHeight - padding) {
          top = window.innerHeight - menuRect.height - padding;
        }
        if (left + menuRect.width > window.innerWidth - padding) {
          left = window.innerWidth - menuRect.width - padding;
        }
        
        sectionContextMenu.style.top = `${Math.max(padding, top)}px`;
        sectionContextMenu.style.left = `${Math.max(padding, left)}px`;
      }
      
      function hideSectionContextMenu() {
        const sectionContextMenu = document.getElementById('sectionContextMenu');
        if (!sectionContextMenu) return;
        sectionContextMenu.classList.remove('show');
        sectionContextMenu.style.top = '';
        sectionContextMenu.style.left = '';
        // Only clear if not showing confirmation modal
        const confirmModal = document.getElementById('sectionConfirmModal');
        if (!confirmModal || !confirmModal.classList.contains('show')) {
          sectionContextMenuTargetId = null;
        }
      }
      
      // Section confirmation modal functions
      let sectionConfirmCallback = null;
      
      function showSectionConfirmModal(title, message, confirmText = 'Confirm', callback) {
        const modal = document.getElementById('sectionConfirmModal');
        const titleEl = document.getElementById('sectionConfirmModalTitleText');
        const messageEl = document.getElementById('sectionConfirmModalMessage');
        const confirmBtn = document.getElementById('sectionConfirmModalConfirm');
        
        if (!modal || !titleEl || !messageEl || !confirmBtn) return;
        
        titleEl.textContent = title;
        messageEl.textContent = message;
        confirmBtn.textContent = confirmText;
        sectionConfirmCallback = callback;
        
        // Hide section name modal if open
        hideSectionNameModal();
        modal.classList.add('show');
      }
      
      function hideSectionConfirmModal() {
        const modal = document.getElementById('sectionConfirmModal');
        if (modal) {
          modal.classList.remove('show');
        }
        sectionConfirmCallback = null;
        sectionContextMenuTargetId = null;
      }
      
      // Section confirmation modal event listeners
      const sectionConfirmModal = document.getElementById('sectionConfirmModal');
      const sectionConfirmModalClose = document.getElementById('sectionConfirmModalClose');
      const sectionConfirmModalCancel = document.getElementById('sectionConfirmModalCancel');
      const sectionConfirmModalConfirm = document.getElementById('sectionConfirmModalConfirm');
      
      if (sectionConfirmModalClose) {
        sectionConfirmModalClose.addEventListener('click', () => {
          hideSectionConfirmModal();
        });
      }
      
      if (sectionConfirmModalCancel) {
        sectionConfirmModalCancel.addEventListener('click', () => {
          hideSectionConfirmModal();
        });
      }
      
      if (sectionConfirmModalConfirm) {
        sectionConfirmModalConfirm.addEventListener('click', () => {
          if (sectionConfirmCallback && typeof sectionConfirmCallback === 'function') {
            sectionConfirmCallback();
          }
        });
      }
      
      if (sectionConfirmModal) {
        sectionConfirmModal.addEventListener('click', (e) => {
          if (e.target === sectionConfirmModal) {
            hideSectionConfirmModal();
          }
        });
        
      }
      
      // Close confirmation modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const sectionConfirmModal = document.getElementById('sectionConfirmModal');
          if (sectionConfirmModal && sectionConfirmModal.classList.contains('show')) {
            hideSectionConfirmModal();
          }
        }
      });

      function addSlideToSection(slideIndex, sectionId) {
        const section = sections.find(s => s.id === sectionId);
        if (!section) return;
        if (!section.slideIndices.includes(slideIndex)) {
          section.slideIndices.push(slideIndex);
          section.slideIndices.sort((a, b) => a - b);
          capture();
          renderSidebar();
          saveEditorState('add_slide_to_section');
        }
      }

      function removeSlideFromSection(slideIndex) {
        sections.forEach(section => {
          const index = section.slideIndices.indexOf(slideIndex);
          if (index !== -1) {
            section.slideIndices.splice(index, 1);
            // Remove section if empty
            if (section.slideIndices.length === 0) {
              sections = sections.filter(s => s.id !== section.id);
            }
          }
        });
        capture();
        renderSidebar();
        saveEditorState('remove_slide_from_section');
      }

      function createSlideItem(s, i, isThumbnailMode) {
          // Skip invalid slides
          if (!s || typeof s !== 'object') {
            console.error(`Slide ${i} is invalid, skipping...`);
            return;
          }
          
          try {
            // Create slide-item container
            const slideItem = document.createElement('div');
            slideItem.className = 'slide-item' + (isThumbnailMode ? ' thumbnail' : '');
            slideItem.dataset.index = String(i);
          
        // Create slide preview
        const preview = document.createElement('div');
        preview.className = 'slide-preview' + (i === active ? ' active' : '');
        if (isThumbnailMode) {
          preview.classList.add('thumbnail');
          const frame = document.createElement('div');
          frame.className = 'slide-thumbnail-frame';
          // Always show an image - blank placeholder if no thumbnail yet
          const thumbnailUrl = thumbnailManager 
            ? thumbnailManager.getThumbnail(i) // getThumbnail now returns blank slide if not available
            : 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="320" height="180"%3E%3Crect width="320" height="180" fill="%23ffffff" stroke="%23e5e7eb"/%3E%3C/svg%3E';
          
          const img = document.createElement('img');
          img.src = thumbnailUrl;
          const slideName = s.name || s.title || '';
          img.alt = slideName ? `Preview of ${slideName}` : `Preview of slide ${i + 1}`;
          frame.appendChild(img);
          preview.appendChild(frame);
        }

        const titleSpan = document.createElement('span');
        titleSpan.className = 'slide-preview-title';
        // Use slide.name for sidebar display, fallback to slide.title for backward compatibility
        titleSpan.textContent = s.name || s.title || `Slide ${i + 1}`;
        preview.appendChild(titleSpan);

        preview.addEventListener('click', () => {
          if (thumbnailManager) {
            thumbnailManager.markActivity(); // Pause thumbnail generation when switching slides
          }
          capture();
          active = i;
          load();
          renderSidebar();
        });

        titleSpan.addEventListener('click', (event) => {
          if (titleSpan.isContentEditable) {
            event.stopPropagation();
          }
        });

        titleSpan.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          startSlideTitleEditing(titleSpan, i, slideItem);
        });

        titleSpan.addEventListener('dragstart', (event) => {
          if (titleSpan.isContentEditable) {
            event.preventDefault();
          }
        });
          
        slideItem.appendChild(preview);
        slideItem.addEventListener('contextmenu', (event) => {
          hideSlideTransitionMenu();
          showSlideContextMenu(event, i, titleSpan, slideItem);
        });
          
          return slideItem;
          } catch (error) {
            console.error(`Error rendering slide ${i}:`, error);
            return null;
          }
      }

      function renderSidebar() {
        if (!sidebar) return;
        hideSlideContextMenu();
        hideSlideTransitionMenu();
        const isThumbnailMode = sidebarViewMode === 'thumbnail';
        sidebar.classList.toggle('thumbnail-view', isThumbnailMode);
        sidebar.classList.toggle('list-view', !isThumbnailMode);
        if (isThumbnailMode) {
          ensureSidebarThumbnails();
        }
        sidebar.innerHTML = '';
        
        // Track which slides are in sections
        const slidesInSections = new Set();
        sections.forEach(section => {
          section.slideIndices.forEach(idx => slidesInSections.add(idx));
        });
        
        // Create a sorted list of all items (sections and standalone slides) by position
        const items = [];
        
        // Add sections with their anchor positions
        sections.forEach(section => {
          // Use anchorSlideIndex if available, otherwise use first slide index
          // Also ensure existing sections without anchorSlideIndex get one
          if (section.anchorSlideIndex === undefined) {
            section.anchorSlideIndex = section.slideIndices.length > 0 ? section.slideIndices[0] : 0;
          }
          items.push({ type: 'section', section: section, position: section.anchorSlideIndex });
        });
        
        // Add standalone slides (not in any section)
        slides.forEach((s, i) => {
          if (!slidesInSections.has(i)) {
            items.push({ type: 'slide', slideIndex: i, position: i });
          }
        });
        
        // Sort items by position
        items.sort((a, b) => {
          if (a.position !== b.position) {
            return a.position - b.position;
          }
          // If positions are equal, sections come before slides
          return a.type === 'section' ? -1 : 1;
        });
        
        // Render items in order
        items.forEach(item => {
          if (item.type === 'section') {
            const section = item.section;
            
            // Create section header
            const sectionHeader = document.createElement('div');
            sectionHeader.className = 'section-header' + (section.collapsed ? ' collapsed' : '');
            sectionHeader.dataset.sectionId = section.id;
            
            const chevron = document.createElement('i');
            chevron.className = 'fas fa-chevron-down section-chevron';
            sectionHeader.appendChild(chevron);
            
            const sectionName = document.createElement('span');
            sectionName.className = 'section-name';
            sectionName.textContent = section.name;
            sectionHeader.appendChild(sectionName);
            
            const sectionActions = document.createElement('div');
            sectionActions.className = 'section-actions';
            
            const renameBtn = document.createElement('button');
            renameBtn.className = 'section-action-btn';
            renameBtn.title = 'Rename Section';
            renameBtn.innerHTML = '<i class="fas fa-pen"></i>';
            renameBtn.addEventListener('click', (e) => {
            e.stopPropagation();
              renameSection(section.id);
            });
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'section-action-btn';
            deleteBtn.title = 'Delete Section';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
              showDeleteSectionModal(section.id, section.name);
            });
            
            sectionActions.appendChild(renameBtn);
            sectionActions.appendChild(deleteBtn);
            sectionHeader.appendChild(sectionActions);
            
            sectionHeader.addEventListener('click', (e) => {
              if (!e.target.closest('.section-actions')) {
                toggleSectionCollapse(section.id);
              }
            });
            
            // Add right-click context menu
            sectionHeader.addEventListener('contextmenu', (e) => {
              e.preventDefault();
            e.stopPropagation();
              showSectionContextMenu(e, section.id);
            });
            
            // Add drop handlers to section header
            sectionHeader.addEventListener('dragover', (e) => {
              if (slideDragSourceIndex !== null) {
            e.preventDefault();
                e.stopPropagation();
                if (e.dataTransfer) {
                  e.dataTransfer.dropEffect = 'move';
                }
                sectionHeader.classList.add('drop-target');
              }
            });
            
            sectionHeader.addEventListener('dragleave', (e) => {
              sectionHeader.classList.remove('drop-target');
            });
            
            sectionHeader.addEventListener('drop', (e) => {
              if (slideDragSourceIndex === null) return;
              e.preventDefault();
              e.stopPropagation();
              sectionHeader.classList.remove('drop-target');
              
              // Determine insert position
              let insertIndex;
              if (section.slideIndices.length > 0) {
                // Insert before the first slide in the section
                const firstSlideIndex = Math.min(...section.slideIndices);
                insertIndex = firstSlideIndex;
              } else {
                // Empty section, insert at anchor position or at the end
                insertIndex = section.anchorSlideIndex !== undefined ? section.anchorSlideIndex : slides.length;
              }
              
              // Always call finalizeSlideReorder - it will handle the logic
              finalizeSlideReorder(slideDragSourceIndex, insertIndex, section.id);
            });
            
            sidebar.appendChild(sectionHeader);
            
            // Create section slides container
            const sectionSlides = document.createElement('div');
            sectionSlides.className = 'section-slides';
            sectionSlides.dataset.sectionId = section.id;
            if (!section.collapsed) {
              // Sort slides within section by their index
              const sortedSlideIndices = [...section.slideIndices].sort((a, b) => a - b);
              sortedSlideIndices.forEach(slideIndex => {
                if (slideIndex >= 0 && slideIndex < slides.length) {
                  const slideItem = createSlideItem(slides[slideIndex], slideIndex, isThumbnailMode);
                  if (slideItem) {
                    sectionSlides.appendChild(slideItem);
                  }
                }
              });
            }
            
            // Add drop handlers to section slides container
            sectionSlides.addEventListener('dragover', (e) => {
          if (slideDragSourceIndex !== null) {
                e.preventDefault();
                e.stopPropagation();
                if (e.dataTransfer) {
                  e.dataTransfer.dropEffect = 'move';
                }
                sectionSlides.classList.add('drop-target');
              }
            });
            
            sectionSlides.addEventListener('dragleave', (e) => {
              sectionSlides.classList.remove('drop-target');
            });
            
            sectionSlides.addEventListener('drop', (e) => {
              if (slideDragSourceIndex === null) return;
              e.preventDefault();
              e.stopPropagation();
              sectionSlides.classList.remove('drop-target');
              
              // Determine insert position - append at the end of the section
              let insertIndex;
              if (section.slideIndices.length > 0) {
                // Insert after the last slide in the section
                const lastSlideIndex = Math.max(...section.slideIndices);
                insertIndex = lastSlideIndex + 1;
              } else {
                // Empty section, insert at anchor position
                insertIndex = section.anchorSlideIndex !== undefined ? section.anchorSlideIndex : slides.length;
              }
              
              // Always call finalizeSlideReorder - it will handle the logic
              finalizeSlideReorder(slideDragSourceIndex, insertIndex, section.id);
            });
            
            sidebar.appendChild(sectionSlides);
          } else {
            // Render standalone slide
            const slideItem = createSlideItem(slides[item.slideIndex], item.slideIndex, isThumbnailMode);
            if (slideItem) {
              sidebar.appendChild(slideItem);
            }
          }
        });
        
        updateSidebarViewButtons();
        
        if (sidebarResizer && typeof sidebarResizer.recreateResizer === 'function') {
          sidebarResizer.recreateResizer();
        }
        
        // Initialize SortableJS for drag-and-drop reordering
        initializeSortable();
      }
      
      // Initialize SortableJS on sidebar containers
      function initializeSortable() {
        if (typeof Sortable === 'undefined') {
          // SortableJS not loaded yet, try again later
          setTimeout(initializeSortable, 100);
          return;
        }
        
        // Destroy existing Sortable instances if any
        if (window.sidebarSortables) {
          window.sidebarSortables.forEach(sortable => {
            if (sortable && typeof sortable.destroy === 'function') {
              sortable.destroy();
            }
          });
          window.sidebarSortables = [];
        }
        
        window.sidebarSortables = [];
        
        // Initialize SortableJS on each section's slides container
        const sectionSlidesContainers = sidebar.querySelectorAll('.section-slides');
        sectionSlidesContainers.forEach(container => {
          // Only initialize if section is not collapsed
          const sectionHeader = sidebar.querySelector(`[data-section-id="${container.dataset.sectionId}"]`);
          if (sectionHeader && !sectionHeader.classList.contains('collapsed')) {
            const sortable = new Sortable(container, {
              animation: 200,
              handle: '.slide-item',
              ghostClass: 'sortable-ghost',
              chosenClass: 'sortable-chosen',
              dragClass: 'sortable-drag',
              group: 'slides',
              onEnd: handleSortableReorder
            });
            window.sidebarSortables.push(sortable);
          }
        });
        
        // Handle standalone slides - find direct children that are slide-items
        const standaloneItems = [];
        Array.from(sidebar.children).forEach(child => {
          if (child.classList.contains('slide-item') && !child.closest('.section-slides')) {
            standaloneItems.push(child);
          }
        });
        
        if (standaloneItems.length > 0) {
          // Create a wrapper container for standalone slides if it doesn't exist
          let standaloneContainer = sidebar.querySelector('.standalone-slides-sortable');
          if (!standaloneContainer) {
            standaloneContainer = document.createElement('div');
            standaloneContainer.className = 'standalone-slides-sortable';
            // Find where to insert (before first section or at the end)
            const firstSection = sidebar.querySelector('.section-header');
            if (firstSection) {
              sidebar.insertBefore(standaloneContainer, firstSection);
            } else {
              sidebar.appendChild(standaloneContainer);
            }
          }
          
          // Move standalone items into container if they're not already there
          standaloneItems.forEach(item => {
            if (item.parentElement !== standaloneContainer) {
              standaloneContainer.appendChild(item);
            }
          });
          
          const sortable = new Sortable(standaloneContainer, {
            animation: 200,
            handle: '.slide-item',
            ghostClass: 'sortable-ghost',
            chosenClass: 'sortable-chosen',
            dragClass: 'sortable-drag',
            group: 'slides',
            onEnd: handleSortableReorder
          });
          window.sidebarSortables.push(sortable);
        }
      }

      function createResizeEdges(element) {
        // Remove existing edges
        element.querySelectorAll('.resize-edge').forEach(el => el.remove());
        
        const isShapeLike = element.classList && (
          element.classList.contains('shape-element') ||
          element.classList.contains('chart-element') ||
          element.classList.contains('text-box') ||
          element.classList.contains('title-box') ||
          element.classList.contains('additional-text-box') ||
          element.classList.contains('table-element')
        );
        const isImageElement = element.classList && element.classList.contains('image-element');
        const isVideoElement = element.classList && element.classList.contains('video-element');
        let edges;
        if (isImageElement) {
          edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        } else if (isVideoElement) {
          edges = ['bottom-right'];
        } else if (isShapeLike) {
          edges = ['top', 'bottom', 'left', 'right', 'bottom-right'];
        } else {
          edges = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];
        }
        edges.forEach(edge => {
          const edgeEl = document.createElement('div');
          edgeEl.className = `resize-edge ${edge}`;
          edgeEl.dataset.edge = edge;
          if (isImageElement) {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          } else if (isVideoElement) {
            edgeEl.classList.add('corner');
          } else if (isShapeLike) {
            edgeEl.classList.add(edge === 'bottom-right' ? 'corner' : 'side');
          } else {
            if (['top', 'bottom', 'left', 'right'].includes(edge)) {
              edgeEl.classList.add('side');
            } else {
              edgeEl.classList.add('corner');
            }
          }
          element.appendChild(edgeEl);
        });
      }

      function load() {
        clearGroupSelection();
        hideElementContextMenu();
        hideSlideCanvasContextMenu();
        closeImageCropper();
        const slide = slides[active];
        if (slide && !Array.isArray(slide.animations)) {
          slide.animations = [];
        }
        const backgroundConfig = slide && slide.background ? slide.background : { image: '', size: '', position: '', repeat: '', color: DEFAULT_SLIDE_BACKGROUND_COLOR };
        const backgroundColor = backgroundConfig && backgroundConfig.color
          ? normalizeColorHex(backgroundConfig.color)
          : DEFAULT_SLIDE_BACKGROUND_COLOR;
        canvas.style.backgroundColor = backgroundColor;
        if (backgroundColorInput) {
          backgroundColorInput.value = backgroundColor;
        }
        canvas.style.backgroundImage = backgroundConfig.image || '';
        canvas.style.backgroundSize = backgroundConfig.size || '';
        canvas.style.backgroundPosition = backgroundConfig.position || '';
        canvas.style.backgroundRepeat = backgroundConfig.repeat || '';
        const titleFont = slide.titleFontFamily || DEFAULT_FONT_FAMILY;
        const textFont = slide.textFontFamily || DEFAULT_FONT_FAMILY;
        elementFontFamilies.set(titleBox, titleFont);
        elementFontFamilies.set(textBox, textFont);
        titleBox.style.fontFamily = titleFont;
        textBox.style.fontFamily = textFont;

        const titleBoxData = slide.titleBox || {};
        if (!titleBoxData.id) {
          titleBoxData.id = ensureElementHasId(titleBox, 'title');
        }
        titleBox.dataset.elementId = titleBoxData.id;
        const textBoxData = slide.textBox || {};
        if (!textBoxData.id) {
          textBoxData.id = ensureElementHasId(textBox, 'body');
        }
        textBox.dataset.elementId = textBoxData.id;
        const showTitleBox = titleBoxData.visible !== undefined ? titleBoxData.visible : false;
        if (showTitleBox) {
          titleBox.style.display = 'block';
          titleBox.textContent = slide.title || '';
          if (slide.titleBox) {
            titleBox.style.top = slide.titleBox.top + 'px';
            titleBox.style.left = slide.titleBox.left + 'px';
            // Ensure title box stays within slide borders
            if (slide.titleBox.width) {
              titleBox.style.width = slide.titleBox.width + 'px';
              titleBox.style.right = 'auto';
            } else if (slide.titleBox.right !== undefined) {
              titleBox.style.right = slide.titleBox.right + 'px';
            } else {
              titleBox.style.right = '24px'; // Default right margin
            }
            if (slide.titleBox.height) {
              titleBox.style.height = slide.titleBox.height + 'px';
            }
            // Apply fontSize if available
            if (slide.titleBox.fontSize) {
              titleBox.style.fontSize = slide.titleBox.fontSize;
            }
            // Apply color if available
            if (slide.titleBox.color) {
              titleBox.style.color = slide.titleBox.color;
            }
            const titleRotation = Number.isFinite(slide.titleBox.rotation) ? slide.titleBox.rotation : 0;
            titleBox.dataset.rotation = String(titleRotation);
            titleBox.style.transform = `rotate(${titleRotation}deg)`;
          }
        } else {
          titleBox.style.display = 'none';
          titleBox.textContent = '';
        }

        const showTextBox = textBoxData.visible !== undefined ? textBoxData.visible : false;
        if (showTextBox) {
          textBox.style.display = 'block';
          // Clean HTML tags and markdown formatting before displaying
          let contentToDisplay = slide.content || '';
          if (contentToDisplay) {
            contentToDisplay = cleanTextContent(contentToDisplay);
          }
          textBox.textContent = contentToDisplay;
          // Preserve line breaks and structure for AI-generated content
          if (slide.content && slide.content.includes('\n')) {
            textBox.style.whiteSpace = 'pre-wrap';
            textBox.style.wordWrap = 'break-word';
            textBox.style.overflowWrap = 'break-word';
          }
          // Ensure text box stays within slide borders - especially for first slide
          if (slide.textBox) {
            textBox.style.top = slide.textBox.top + 'px';
            textBox.style.left = slide.textBox.left + 'px';
            if (slide.textBox.width) {
              textBox.style.width = slide.textBox.width + 'px';
              textBox.style.right = 'auto';
            } else if (slide.textBox.right !== undefined) {
              textBox.style.right = slide.textBox.right + 'px';
            } else {
              textBox.style.right = '24px'; // Default right margin
            }
            if (slide.textBox.height) {
              textBox.style.height = slide.textBox.height + 'px';
              textBox.style.bottom = 'auto';
            } else if (slide.textBox.bottom !== undefined) {
              textBox.style.bottom = slide.textBox.bottom + 'px';
            } else {
              textBox.style.bottom = '24px'; // Default bottom margin
            }
            // Apply fontSize if available
            if (slide.textBox.fontSize) {
              textBox.style.fontSize = slide.textBox.fontSize;
            }
            // Apply color if available
            if (slide.textBox.color) {
              textBox.style.color = slide.textBox.color;
            }
            const textRotation = Number.isFinite(slide.textBox.rotation) ? slide.textBox.rotation : 0;
            textBox.dataset.rotation = String(textRotation);
            textBox.style.transform = `rotate(${textRotation}deg)`;
          }
        } else {
          textBox.style.display = 'none';
          textBox.textContent = '';
        }

        if (!slide.titleBox) {
          titleBox.dataset.rotation = titleBox.dataset.rotation || '0';
        }
        if (!slide.textBox) {
          textBox.dataset.rotation = textBox.dataset.rotation || '0';
        }

        // Create resize edges
        createResizeEdges(titleBox);
        createResizeEdges(textBox);

        document.querySelectorAll('.additional-text-box').forEach(el => el.remove());
        if (!Array.isArray(slide.additionalTextBoxes)) {
          slide.additionalTextBoxes = [];
        }
        slide.additionalTextBoxes.forEach(textBoxData => instantiateAdditionalTextBox(textBoxData));

        document.querySelectorAll('.shape-element').forEach(el => el.remove());
        document.querySelectorAll('.table-element').forEach(el => el.remove());
        document.querySelectorAll('.image-element').forEach(el => el.remove());
        document.querySelectorAll('.video-element').forEach(el => {
          const video = el.querySelector('video');
          if (video) {
            video.pause();
          }
          el.remove();
        });
        selectedShape = null;
        selectedChart = null;
        selectedImage = null;
        selectedVideo = null;
        selectedTable = null;
        hideShapeColorPicker();
        hideRotationHandle();
        document.querySelectorAll('.chart-element').forEach(chartEl => chartEl.remove());
        if (!Array.isArray(slide.charts)) {
          slide.charts = [];
        }
        slide.charts.forEach(chartData => instantiateChart(chartData));
        if (!Array.isArray(slide.shapes)) {
          slide.shapes = [];
        }
        slide.shapes.forEach(shapeData => instantiateShape(shapeData));
        if (!Array.isArray(slide.tables)) {
          slide.tables = [];
        }
        slide.tables.forEach(tableData => instantiateTable(tableData));
        if (!Array.isArray(slide.images)) {
          slide.images = [];
        }
        slide.images.forEach(imageData => instantiateImage(imageData));

        // Fix all text boxes after restoring all elements
        requestAnimationFrame(() => {
          fixAllTextBoxStyles();
        });

        updateFontPickerSelectedFont();
        const transitionConfig = getSlideTransitionConfig(slide);
        applyTransitionConfigToSlide(slide, transitionConfig);
        if (!isPresenting) {
          TRANSITION_CLASS_NAMES.forEach(cls => canvas.classList.remove(cls));
          canvas.style.removeProperty('--transition-duration');
        }
        syncTransitionControlsWithSlide();
        syncAnimationControlsWithSlide();
        renderComments();
        
        // Fix all text boxes after loading to ensure they have correct display styles
        fixAllTextBoxStyles();
      }
      
      // Function to fix styles for all text boxes on the canvas - AGGRESSIVE FIX
      function fixAllTextBoxStyles() {
        const fixTextBoxStyles = (element) => {
          if (!element || !document.contains(element)) return;
          
          // Force display to block with maximum priority
          element.style.setProperty('display', 'block', 'important');
          element.style.setProperty('flex-direction', 'row', 'important');
          element.style.setProperty('flex-wrap', 'wrap', 'important');
          element.style.setProperty('writing-mode', 'horizontal-tb', 'important');
          element.style.setProperty('text-orientation', 'mixed', 'important');
          
          // CRITICAL: Check computed styles and fix width immediately
          const computed = window.getComputedStyle(element);
          
          // Fix display if flex
          if (computed.display === 'flex' || computed.display === 'inline-flex') {
            element.style.setProperty('display', 'block', 'important');
          }
          
          // CRITICAL: Force adequate width to prevent vertical character wrapping
          const computedWidth = parseFloat(computed.width);
          const minWidth = parseFloat(element.dataset.minWidth) || 200;
          
          if (computedWidth < 100 || isNaN(computedWidth) || !computedWidth) {
            element.style.setProperty('width', Math.max(minWidth, 200) + 'px', 'important');
            element.style.setProperty('min-width', Math.max(minWidth, 200) + 'px', 'important');
          }
          
          // Prevent aggressive word-breaking
          element.style.setProperty('word-break', 'normal', 'important');
          element.style.setProperty('overflow-wrap', 'normal', 'important');
          element.style.setProperty('word-wrap', 'normal', 'important');
          
          // Ensure white-space is correct
          if (!element.getAttribute('data-manually-resized')) {
            element.style.setProperty('white-space', 'nowrap', 'important');
          }
        };
        
        // Fix all text boxes
        [titleBox, textBox].forEach(box => {
          if (box) {
            fixTextBoxStyles(box);
            // Also add event listeners if not already added
            if (!box.dataset.fixed) {
              box.addEventListener('input', function() {
                fixTextBoxStyles(this);
                const computed = window.getComputedStyle(this);
                const width = parseFloat(computed.width);
                if (width < 100) {
                  this.style.setProperty('width', '200px', 'important');
                }
              });
              box.dataset.fixed = 'true';
            }
          }
        });
        
        // Fix all additional text boxes
        document.querySelectorAll('.additional-text-box').forEach(box => {
          fixTextBoxStyles(box);
        });
      }

      function capture() {
        const slide = slides[active];
        if (!slide) return;
        const titleVisible = titleBox.style.display !== 'none';
        const textVisible = textBox.style.display !== 'none';
        if (titleVisible) {
          slide.title = titleBox.textContent.trim();
        }
        if (textVisible) {
          slide.content = textBox.textContent.trim();
        }
        
        // Save positions and sizes
        const titleElementId = ensureElementHasId(titleBox, 'title');
        const titleCoords = getElementCanvasCoordinates(titleBox);
        slide.titleBox = {
          id: titleElementId,
          top: titleCoords.top,
          left: titleCoords.left,
          width: titleBox.offsetWidth,
          height: titleBox.offsetHeight,
          visible: titleVisible,
          rotation: parseFloat(titleBox.dataset.rotation || '0') || 0
        };
        
        const textElementId = ensureElementHasId(textBox, 'body');
        const textCoords = getElementCanvasCoordinates(textBox);
        slide.textBox = {
          id: textElementId,
          top: textCoords.top,
          left: textCoords.left,
          width: textBox.offsetWidth,
          height: textBox.offsetHeight,
          visible: textVisible,
          rotation: parseFloat(textBox.dataset.rotation || '0') || 0
        };

        slide.titleFontFamily = getCurrentFontFamily(titleBox);
        slide.textFontFamily = getCurrentFontFamily(textBox);
        slide.additionalTextBoxes = collectAdditionalTextBoxesData();
        slide.charts = collectChartsData();
        slide.shapes = collectShapesData();
        slide.tables = collectTablesData();
        slide.images = collectImagesData();
        slide.videos = collectVideosData();
        pruneSlideAnimations(slide);
        // Invalidate thumbnail for current slide
        if (thumbnailManager) {
          thumbnailManager.invalidateSlide(active);
        }
      }

      // Drag functionality - only when clicking on empty space
      let alignmentGuides = null;
      const ALIGNMENT_THRESHOLD = 6;

      function ensureAlignmentGuides() {
        if (alignmentGuides && alignmentGuides.horizontal && alignmentGuides.vertical) {
          return alignmentGuides;
        }
        const horizontal = document.createElement('div');
        horizontal.className = 'alignment-guide horizontal';
        const vertical = document.createElement('div');
        vertical.className = 'alignment-guide vertical';
        canvas.appendChild(horizontal);
        canvas.appendChild(vertical);
        alignmentGuides = { horizontal, vertical };
        return alignmentGuides;
      }

      function hideAlignmentGuides() {
        if (!alignmentGuides) return;
        alignmentGuides.horizontal.style.display = 'none';
        alignmentGuides.vertical.style.display = 'none';
      }

      function updateAlignmentGuides({
        showHorizontal,
        showVertical,
        horizontalPosition,
        verticalPosition,
        horizontalStart,
        horizontalEnd,
        verticalStart,
        verticalEnd
      } = {}) {
        if (!alignmentGuides) {
          ensureAlignmentGuides();
        }
        const { horizontal, vertical } = ensureAlignmentGuides();
        if (showHorizontal) {
          horizontal.style.display = 'block';
          horizontal.style.top = `${horizontalPosition}px`;
          const start = Math.min(horizontalStart, horizontalEnd);
          const end = Math.max(horizontalStart, horizontalEnd);
          horizontal.style.left = `${start}px`;
          horizontal.style.width = `${Math.max(1, end - start)}px`;
        } else {
          horizontal.style.display = 'none';
        }
        if (showVertical) {
          vertical.style.display = 'block';
          vertical.style.left = `${verticalPosition}px`;
          const start = Math.min(verticalStart, verticalEnd);
          const end = Math.max(verticalStart, verticalEnd);
          vertical.style.top = `${start}px`;
          vertical.style.height = `${Math.max(1, end - start)}px`;
        } else {
          vertical.style.display = 'none';
        }
      }

      function calculateAlignmentGuides(element, proposedLeft, proposedTop) {
        const snap = {
          snapX: null,
          snapY: null,
          showVertical: false,
          showHorizontal: false,
          verticalPosition: 0,
          horizontalPosition: 0,
          verticalStart: 0,
          verticalEnd: 0,
          horizontalStart: 0,
          horizontalEnd: 0
        };
        if (!canvas || !element) {
          return snap;
        }
        const zoom = getCanvasZoom();
        const canvasWidth = canvas.clientWidth / zoom;
        const canvasHeight = canvas.clientHeight / zoom;
        const elements = getLayerManagedElements().filter(el => el !== element);
        const targetRect = {
          left: proposedLeft,
          right: proposedLeft + element.offsetWidth,
          top: proposedTop,
          bottom: proposedTop + element.offsetHeight,
          centerX: proposedLeft + element.offsetWidth / 2,
          centerY: proposedTop + element.offsetHeight / 2
        };
        const guides = [];
        elements.forEach((el) => {
          const rect = {
            left: parseFloat(el.style.left || el.offsetLeft),
            top: parseFloat(el.style.top || el.offsetTop),
            width: el.offsetWidth,
            height: el.offsetHeight,
            type: 'element'
          };
          rect.right = rect.left + rect.width;
          rect.bottom = rect.top + rect.height;
          rect.centerX = rect.left + rect.width / 2;
          rect.centerY = rect.top + rect.height / 2;
          guides.push(rect);
        });
        guides.push({
          left: 0,
          right: canvasWidth,
          top: 0,
          bottom: canvasHeight,
          centerX: canvasWidth / 2,
          centerY: canvasHeight / 2,
          type: 'canvas'
        });

        const bestVertical = { delta: Infinity };
        const bestHorizontal = { delta: Infinity };

        const considerVertical = (delta, snapLeft, position, start, end) => {
          if (delta <= ALIGNMENT_THRESHOLD / zoom && delta < bestVertical.delta) {
            bestVertical.delta = delta;
            bestVertical.snapLeft = snapLeft;
            bestVertical.position = position;
            bestVertical.start = start;
            bestVertical.end = end;
          }
        };

        const considerHorizontal = (delta, snapTop, position, start, end) => {
          if (delta <= ALIGNMENT_THRESHOLD / zoom && delta < bestHorizontal.delta) {
            bestHorizontal.delta = delta;
            bestHorizontal.snapTop = snapTop;
            bestHorizontal.position = position;
            bestHorizontal.start = start;
            bestHorizontal.end = end;
          }
        };

        guides.forEach((rect) => {
          const isCanvas = rect.type === 'canvas';
          const verticalRangeStart = isCanvas ? 0 : Math.min(targetRect.top, rect.top);
          const verticalRangeEnd = isCanvas ? canvasHeight : Math.max(targetRect.bottom, rect.bottom);
          const horizontalRangeStart = isCanvas ? 0 : Math.min(targetRect.left, rect.left);
          const horizontalRangeEnd = isCanvas ? canvasWidth : Math.max(targetRect.right, rect.right);

          const deltaLeft = Math.abs(targetRect.left - rect.left);
          considerVertical(deltaLeft, rect.left, rect.left, verticalRangeStart, verticalRangeEnd);

          const deltaRight = Math.abs(targetRect.right - rect.right);
          considerVertical(deltaRight, rect.right - element.offsetWidth, rect.right, verticalRangeStart, verticalRangeEnd);

          const deltaCenterX = Math.abs(targetRect.centerX - rect.centerX);
          considerVertical(deltaCenterX, rect.centerX - element.offsetWidth / 2, rect.centerX, verticalRangeStart, verticalRangeEnd);

          const deltaTop = Math.abs(targetRect.top - rect.top);
          considerHorizontal(deltaTop, rect.top, rect.top, horizontalRangeStart, horizontalRangeEnd);

          const deltaBottom = Math.abs(targetRect.bottom - rect.bottom);
          considerHorizontal(deltaBottom, rect.bottom - element.offsetHeight, rect.bottom, horizontalRangeStart, horizontalRangeEnd);

          const deltaCenterY = Math.abs(targetRect.centerY - rect.centerY);
          considerHorizontal(deltaCenterY, rect.centerY - element.offsetHeight / 2, rect.centerY, horizontalRangeStart, horizontalRangeEnd);
        });

        if (bestVertical.delta !== Infinity) {
          snap.snapX = bestVertical.snapLeft;
          snap.showVertical = true;
          snap.verticalPosition = bestVertical.position;
          snap.verticalStart = bestVertical.start;
          snap.verticalEnd = bestVertical.end;
        }
        if (bestHorizontal.delta !== Infinity) {
          snap.snapY = bestHorizontal.snapTop;
          snap.showHorizontal = true;
          snap.horizontalPosition = bestHorizontal.position;
          snap.horizontalStart = bestHorizontal.start;
          snap.horizontalEnd = bestHorizontal.end;
        }
        return snap;
      }

      function makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;
        let dragThreshold = 5;
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        
        element.addEventListener('mousedown', (e) => {
          if (element.classList.contains('table-element') && (e.target.closest('td') || e.target.closest('th'))) {
            return;
          }
          // Don't drag if clicking on resize edge
          if (e.target.classList && e.target.classList.contains('resize-edge')) {
            return;
          }
          
          // Allow dragging when clicking on SVG children of icon elements
          if (element.classList.contains('icon-element')) {
            // Allow dragging if clicking on the element or any child (like SVG)
            if (e.target === element || element.contains(e.target)) {
              // Stop propagation to prevent canvas marquee selection from starting
              e.stopPropagation();
              // Continue to drag setup below
            } else {
              return;
            }
          } else {
            // Don't drag if clicking on text content (for other elements)
            if (e.target !== element && e.target.nodeType !== Node.ELEMENT_NODE) {
              return;
            }
          }
          
          const isEditableBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
          if (isEditableBox) {
            // Only drag if clicking on empty space or border area
            const selection = window.getSelection();
            if (selection.toString().length > 0) {
              return;
            }

            // Check if element is empty or clicking on border
            const isEmpty = !element.textContent.trim() || element.textContent.trim() === element.dataset.placeholder;
            const isBorderClick = e.target === element || (e.target === element && element.contains(e.target));

            if (!isEmpty && !isBorderClick) {
              return; // Allow text editing
            }
          }
          
          startX = e.clientX;
          startY = e.clientY;
          const startCoords = getElementCanvasCoordinates(element);
          initialLeft = startCoords.left;
          initialTop = startCoords.top;
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
          
          // Select icon when dragging starts if not already selected
          if (element.classList.contains('icon-element') && !element.classList.contains('selected')) {
            selectIcon(element);
          }
        });
        
        document.addEventListener('mousemove', (e) => {
          if (startX === undefined || startY === undefined) return;
          
          const deltaX = Math.abs(e.clientX - startX);
          const deltaY = Math.abs(e.clientY - startY);
          
          if (!isDragging && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            isDragging = true;
            element.classList.add('dragging');
            if (hadEditableAttr || wasContentEditable) {
              element.setAttribute('contenteditable', 'false');
            }
          }
          
          if (!isDragging) return;
          
          // Prevent canvas marquee selection when dragging
          e.preventDefault();
          e.stopPropagation();
          
          const zoom = getCanvasZoom();
          const moveX = (e.clientX - startX) / zoom;
          const moveY = (e.clientY - startY) / zoom;
          
          let newLeft = initialLeft + moveX;
          let newTop = initialTop + moveY;
          const guides = calculateAlignmentGuides(element, newLeft, newTop);
          if (guides.snapX !== null) {
            newLeft = guides.snapX;
          }
          if (guides.snapY !== null) {
            newTop = guides.snapY;
          }
          updateAlignmentGuides(guides);
          
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          capture();
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (element.classList.contains('icon-element') && selectedIcon === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
              element.setAttribute('contenteditable', 'true');
            }
            capture();
            // Save state for undo after dragging
            saveEditorState('move_element');
          }
          if (element.classList.contains('shape-element') && selectedShape === element) {
            positionShapeColorPicker(element);
          }
          if (element.classList.contains('icon-element') && selectedIcon === element) {
            positionShapeColorPicker(element);
          }
          if (rotationTarget === element) {
            positionRotationHandle(element);
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
          hideAlignmentGuides();
        });
      }
      
      // Resize functionality using edges
      function makeResizable(element) {
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        let resizeEdge = '';
        let hadEditableAttr = false;
        let previousEditableValue = null;
        let wasContentEditable = false;
        let minWidth = 200;
        let minHeight = 50;
        let aspectRatio = 1;
        
        element.addEventListener('mousedown', (e) => {
          if (!e.target.classList.contains('resize-edge')) return;
          
          resizeEdge = e.target.dataset.edge;
          isResizing = true;
          element.classList.add('resizing');
          hadEditableAttr = element.hasAttribute('contenteditable');
          previousEditableValue = element.getAttribute('contenteditable');
          wasContentEditable = element.isContentEditable;
          if (hadEditableAttr || wasContentEditable) {
            element.setAttribute('contenteditable', 'false');
          }
          
          startX = e.clientX;
          startY = e.clientY;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
          const startCoords = getElementCanvasCoordinates(element);
          startLeft = startCoords.left;
          startTop = startCoords.top;
          minWidth = parseFloat(element.dataset.minWidth) || 200;
          minHeight = parseFloat(element.dataset.minHeight) || 50;
          aspectRatio = startWidth / startHeight || 1;
        const isShape = element.classList.contains('shape-element');
        const isChart = element.classList.contains('chart-element');
        const isImage = element.classList.contains('image-element');
        const isVideo = element.classList.contains('video-element');
        const isTable = element.classList.contains('table-element');
        const isIcon = element.classList.contains('icon-element');
        const isTextBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        if (isImage && selectedImage !== element) {
          selectImage(element);
        }
        if (isVideo && selectedVideo !== element) {
          selectVideo(element);
        }
        if (isChart && selectedChart !== element) {
          selectChart(element);
        }
        if (isIcon && selectedIcon !== element) {
          selectIcon(element);
        }
        if (isShape || isChart || isTextBox || isTable || isImage || isVideo || isIcon) {
          activeResizeShape = element;
          updateShapeSizeBadge(element, startWidth, startHeight);
          showShapeSizeBadge();
        }
          
          e.preventDefault();
          e.stopPropagation();
        });
        
        document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const zoom = getCanvasZoom();
        const deltaX = (e.clientX - startX) / zoom;
        const deltaY = (e.clientY - startY) / zoom;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        
        const isShape = element.classList.contains('shape-element');
        const isChart = element.classList.contains('chart-element');
        const isImage = element.classList.contains('image-element');
        const isVideo = element.classList.contains('video-element');
        const isTable = element.classList.contains('table-element');
        const isShapeLike = isShape || isChart || isTable || isImage || isVideo || element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        
        if (isImage || isVideo) {
          const bounds = {
            left: 24,
            top: 24,
            right: canvasWidth - 24,
            bottom: canvasHeight - 24
          };
          const isCornerHandle = ['top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeEdge);
          const storedAspect = parseFloat(element.dataset.aspectRatio || '0');
          const aspect = storedAspect > 0 ? storedAspect : (startWidth / Math.max(startHeight, 0.01));
          
          if (resizeEdge.includes('right')) {
            const maxWidth = bounds.right - startLeft;
            newWidth = Math.max(minWidth, Math.min(startWidth + deltaX, maxWidth));
          }
          if (resizeEdge.includes('left')) {
            const proposedLeft = startLeft + deltaX;
            const maxLeft = startLeft + startWidth - minWidth;
            newLeft = Math.max(bounds.left, Math.min(proposedLeft, maxLeft));
            newWidth = Math.max(minWidth, startWidth + (startLeft - newLeft));
          }
          if (resizeEdge.includes('bottom')) {
            const maxHeight = bounds.bottom - startTop;
            newHeight = Math.max(minHeight, Math.min(startHeight + deltaY, maxHeight));
          }
          if (resizeEdge.includes('top')) {
            const proposedTop = startTop + deltaY;
            const maxTop = startTop + startHeight - minHeight;
            newTop = Math.max(bounds.top, Math.min(proposedTop, maxTop));
            newHeight = Math.max(minHeight, startHeight + (startTop - newTop));
          }
          
          if (!resizeEdge.includes('left') && !resizeEdge.includes('right')) {
            newLeft = startLeft;
          }
          if (!resizeEdge.includes('top') && !resizeEdge.includes('bottom')) {
            newTop = startTop;
          }
          
          if (!isCornerHandle) {
            if (resizeEdge === 'left' || resizeEdge === 'right') {
              newHeight = startHeight;
              newTop = startTop;
            }
            if (resizeEdge === 'top' || resizeEdge === 'bottom') {
              newWidth = startWidth;
              newLeft = startLeft;
            }
          } else {
            const clampedAspect = Math.max(aspect, 0.01);
            const widthDelta = Math.abs(newWidth - startWidth);
            const heightDelta = Math.abs(newHeight - startHeight);
            if (widthDelta >= heightDelta) {
              newHeight = newWidth / clampedAspect;
              if (resizeEdge.includes('top')) {
                newTop = startTop + (startHeight - newHeight);
              }
            } else {
              newWidth = newHeight * clampedAspect;
              if (resizeEdge.includes('left')) {
                newLeft = startLeft + (startWidth - newWidth);
              }
            }
            
            if (newLeft < bounds.left) {
              const overflow = bounds.left - newLeft;
              newLeft = bounds.left;
              newWidth = Math.max(minWidth, newWidth - overflow);
            }
            if (newTop < bounds.top) {
              const overflow = bounds.top - newTop;
              newTop = bounds.top;
              newHeight = Math.max(minHeight, newHeight - overflow);
            }
            if (newLeft + newWidth > bounds.right) {
              const overflow = (newLeft + newWidth) - bounds.right;
              if (resizeEdge.includes('left')) {
                newLeft = Math.max(bounds.left, newLeft - overflow);
              } else {
                newWidth = Math.max(minWidth, newWidth - overflow);
              }
            }
            if (newTop + newHeight > bounds.bottom) {
              const overflow = (newTop + newHeight) - bounds.bottom;
              if (resizeEdge.includes('top')) {
                newTop = Math.max(bounds.top, newTop - overflow);
              } else {
                newHeight = Math.max(minHeight, newHeight - overflow);
              }
            }
          }
          
          newWidth = Math.max(minWidth, Math.min(newWidth, bounds.right - newLeft));
          newHeight = Math.max(minHeight, Math.min(newHeight, bounds.bottom - newTop));
          
          element.style.width = `${newWidth}px`;
          element.style.height = `${newHeight}px`;
          element.style.left = `${newLeft}px`;
          element.style.top = `${newTop}px`;
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          element.dataset.aspectRatio = String(newWidth / Math.max(newHeight, 0.01));
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else if (isShapeLike) {
          const minScale = Math.max(minWidth / startWidth, minHeight / startHeight);
          const bounds = {
            left: 24,
            top: 24,
            right: canvasWidth - 24,
            bottom: canvasHeight - 24
          };
          
          if (resizeEdge === 'bottom-right') {
            const centerX = startLeft + startWidth / 2;
            const centerY = startTop + startHeight / 2;
            let widthCandidate = Math.max(minWidth, startWidth + deltaX);
            let heightCandidate = Math.max(minHeight, startHeight + deltaY);
            let scale = Math.max(widthCandidate / startWidth, heightCandidate / startHeight);
            scale = Math.max(scale, minScale);
            newWidth = startWidth * scale;
            newHeight = startHeight * scale;
            newLeft = centerX - newWidth / 2;
            newTop = centerY - newHeight / 2;
          } else if (resizeEdge === 'left') {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(bounds.left, startLeft + deltaX);
            if (newLeft === bounds.left) {
              newWidth = startLeft + startWidth - bounds.left;
            }
          } else if (resizeEdge === 'right') {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, bounds.right - startLeft);
          } else if (resizeEdge === 'top') {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(bounds.top, startTop + deltaY);
            if (newTop === bounds.top) {
              newHeight = startTop + startHeight - bounds.top;
            }
          } else if (resizeEdge === 'bottom') {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, bounds.bottom - startTop);
          }
          
          newWidth = Math.max(newWidth, minWidth);
          newHeight = Math.max(newHeight, minHeight);
          if (resizeEdge === 'bottom-right') {
            if (newLeft < bounds.left) newLeft = bounds.left;
            if (newTop < bounds.top) newTop = bounds.top;
            if (newLeft + newWidth > bounds.right) newLeft = bounds.right - newWidth;
            if (newTop + newHeight > bounds.bottom) newTop = bounds.bottom - newHeight;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          
          activeResizeShape = element;
          updateShapeSizeBadge(element, newWidth, newHeight);
          showShapeSizeBadge();
        } else {
          if (resizeEdge.includes('right')) {
            newWidth = Math.max(minWidth, startWidth + deltaX);
            newWidth = Math.min(newWidth, canvasWidth - newLeft - 48);
          }
          if (resizeEdge.includes('left')) {
            newWidth = Math.max(minWidth, startWidth - deltaX);
            newLeft = Math.max(24, startLeft + deltaX);
            if (newLeft === 24) newWidth = startLeft + startWidth - 24;
          }
          if (resizeEdge.includes('bottom')) {
            newHeight = Math.max(minHeight, startHeight + deltaY);
            newHeight = Math.min(newHeight, canvasHeight - newTop - 48);
          }
          if (resizeEdge.includes('top')) {
            newHeight = Math.max(minHeight, startHeight - deltaY);
            newTop = Math.max(24, startTop + deltaY);
            if (newTop === 24) newHeight = startTop + startHeight - 24;
          }
          
          element.style.width = newWidth + 'px';
          element.style.height = newHeight + 'px';
          element.style.left = newLeft + 'px';
          element.style.top = newTop + 'px';
          element.style.right = 'auto';
          element.style.bottom = 'auto';
          
          // Mark text boxes as manually resized
          if (element.classList.contains('text-box') || 
              element.classList.contains('title-box') || 
              element.classList.contains('additional-text-box')) {
            element.setAttribute('data-manually-resized', 'true');
          }
        }
          
        capture();
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (element.classList.contains('icon-element') && selectedIcon === element) {
          positionShapeColorPicker(element);
          updateShapeSizeBadge(element, newWidth, newHeight);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        });
        
        document.addEventListener('mouseup', () => {
          if (isResizing) {
            isResizing = false;
            element.classList.remove('resizing');
            if (hadEditableAttr) {
              if (previousEditableValue === null) {
                element.removeAttribute('contenteditable');
              } else {
                element.setAttribute('contenteditable', previousEditableValue);
              }
            } else if (wasContentEditable) {
              element.setAttribute('contenteditable', 'true');
            }
            
            // Mark text boxes as manually resized after resize completes
            if (element.classList.contains('text-box') || 
                element.classList.contains('title-box') || 
                element.classList.contains('additional-text-box')) {
              element.setAttribute('data-manually-resized', 'true');
            }
            
            resizeEdge = '';
            capture();
            // Save state for undo after resizing
            saveEditorState('resize_element');
          }
          startX = undefined;
          startY = undefined;
          hadEditableAttr = false;
          previousEditableValue = null;
          wasContentEditable = false;
        if (element.classList.contains('shape-element') && selectedShape === element) {
          positionShapeColorPicker(element);
        }
        if (rotationTarget === element) {
          positionRotationHandle(element);
        }
        if (shapeSizeBadge.classList.contains('visible')) {
          hideShapeSizeBadge();
          activeResizeShape = null;
        }
        });
      }
      
      // Auto-resize function for text boxes
      function autoResizeTextBox(textBoxElement) {
        // Only auto-resize if not manually resized
        if (textBoxElement.getAttribute('data-manually-resized') === 'true') {
          return;
        }
        
        // Create a temporary clone to measure content accurately
        const clone = textBoxElement.cloneNode(true);
        clone.style.visibility = 'hidden';
        clone.style.position = 'absolute';
        clone.style.top = '-9999px';
        clone.style.left = '-9999px';
        clone.style.width = 'auto';
        clone.style.height = 'auto';
        clone.style.whiteSpace = 'nowrap';
        clone.style.wordWrap = 'normal';
        clone.style.overflowWrap = 'normal';
        clone.style.display = 'inline-block';
        clone.style.right = 'auto';
        clone.style.bottom = 'auto';
        
        document.body.appendChild(clone);
        
        // Get the natural size from the clone
        const contentWidth = clone.offsetWidth;
        const contentHeight = clone.offsetHeight;
        
        // Remove clone
        document.body.removeChild(clone);
        
        // Apply measured size with minimum constraints and padding
        const minWidth = parseInt(window.getComputedStyle(textBoxElement).minWidth) || 200;
        const minHeight = parseInt(window.getComputedStyle(textBoxElement).minHeight) || 40;
        const padding = 20; // Account for padding
        
        textBoxElement.style.width = Math.max(minWidth, contentWidth + padding) + 'px';
        textBoxElement.style.height = Math.max(minHeight, contentHeight + padding) + 'px';
        textBoxElement.style.right = 'auto';
        textBoxElement.style.bottom = 'auto';
      }
      
      // Setup auto-resize for text boxes
      function setupAutoResize(textBoxElement) {
        if (!textBoxElement) return;
        
        // Auto-resize on input
        textBoxElement.addEventListener('input', () => {
          autoResizeTextBox(textBoxElement);
          capture();
        });
        
        // Auto-resize on paste
        textBoxElement.addEventListener('paste', () => {
          setTimeout(() => {
            autoResizeTextBox(textBoxElement);
            capture();
          }, 0);
        });
        
        // Initial auto-resize
        requestAnimationFrame(() => {
          autoResizeTextBox(textBoxElement);
        });
      }
      
      // Make boxes draggable and resizable
      makeDraggable(titleBox);
      makeDraggable(textBox);
      makeResizable(titleBox);
      makeResizable(textBox);
      
      // Initialize resize edges
      createResizeEdges(titleBox);
      createResizeEdges(textBox);
      
      // Setup auto-resize for title and text boxes
      setupAutoResize(titleBox);
      setupAutoResize(textBox);
      
      // Add selection handlers for title and text boxes
      titleBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === titleBox || !titleBox.textContent.trim()) {
          selectTextBox(titleBox);
        }
      });
      
      textBox.addEventListener('click', (e) => {
        // Select if clicking on border or empty space
        if (e.target === textBox || !textBox.textContent.trim()) {
          selectTextBox(textBox);
        }
      });

      // Toolbar interactions per Editor.json
      function getActiveElement() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
        return document.activeElement === titleBox ? titleBox : textBox;
      }

      function addTextBoxAtCanvasPosition(canvasX, canvasY) {
        if (!canvas) return null;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;
        const defaultWidth = 150;
        const defaultHeight = 40;
        const margin = 24;
        const clampPosition = (value, elementSize, canvasSize) => {
          const maxWithMargin = canvasSize - elementSize - margin;
          if (maxWithMargin <= margin) {
            return Math.max(0, Math.min(value, canvasSize - elementSize));
          }
          return Math.max(margin, Math.min(value, maxWithMargin));
        };
        let left = canvasX - defaultWidth / 2;
        let top = canvasY - defaultHeight / 2;
        left = clampPosition(left, defaultWidth, canvasWidth);
        top = clampPosition(top, defaultHeight, canvasHeight);
        const newTextBox = createAdditionalTextBox({
          top,
          left,
          width: defaultWidth,
          height: defaultHeight,
          fontSize: '16px',
          fontFamily: DEFAULT_FONT_FAMILY,
          color: '#000000'
        });
        if (!newTextBox) return null;
        lastCanvasInsertPosition = {
          x: left + defaultWidth / 2,
          y: top + defaultHeight / 2
        };
        selectTextBox(newTextBox);
        requestAnimationFrame(() => {
          if (!document.contains(newTextBox)) {
            return;
          }
          try {
            newTextBox.focus({ preventScroll: true });
          } catch (error) {
            newTextBox.focus();
          }
          const selection = window.getSelection();
          if (!selection) return;
          const range = document.createRange();
          range.selectNodeContents(newTextBox);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        });
        capture();
        saveEditorState('add_textbox');
        return newTextBox;
      }

      // Add Text Box functionality
      function addTextBox() {
        if (!canvas) return;
        addTextBoxAtCanvasPosition(canvas.clientWidth / 2, canvas.clientHeight / 2);
      }
      
      // Function to select/deselect text boxes
      function selectTextBox(element) {
        // Can select any text box or title box
        if (!element || (!element.classList.contains('text-box') && element.id !== 'titleBox')) {
          return;
        }
        
        // Fix styles immediately when selecting
        const fixTextBoxStyles = (el) => {
          if (!el) return;
          el.style.setProperty('display', 'block', 'important');
          el.style.setProperty('flex-direction', 'row', 'important');
          el.style.setProperty('flex-wrap', 'wrap', 'important');
          el.style.setProperty('writing-mode', 'horizontal-tb', 'important');
          const computed = window.getComputedStyle(el);
          if (computed.display === 'flex' || computed.display === 'inline-flex') {
            el.style.setProperty('display', 'block', 'important');
          }
        };
        fixTextBoxStyles(element);
        
        clearGroupSelection();
        clearShapeSelection();
        clearChartSelection();
        clearImageSelection();
        clearVideoSelection();
        
        // Deselect all other boxes
        document.querySelectorAll('.text-box.selected, .title-box.selected').forEach(box => {
          box.classList.remove('selected');
        });
        
        // Select this box
        element.classList.add('selected');
        createResizeEdges(element);
        selectedTextBox = element;
        handleAnimationSelectionChange(element);
        if (!element.dataset.rotation) {
          element.dataset.rotation = '0';
        }
        showRotationHandle(element);
        
        // Double-check styles after selection
        requestAnimationFrame(() => {
          fixTextBoxStyles(element);
        });
        
        // Deselect when clicking elsewhere
        setTimeout(() => {
          document.addEventListener('click', function deselectHandler(e) {
            if (!element.contains(e.target) && e.target !== element) {
              element.classList.remove('selected');
              selectedTextBox = null;
              if (rotationTarget === element) {
                hideRotationHandle();
              }
              handleAnimationSelectionChange(null);
              document.removeEventListener('click', deselectHandler);
            }
          }, { once: true });
        }, 150);
      }
      
      // Function to delete text box
      function deleteTextBox(element) {
        if (!element) return;
        if (groupSelectionState.elements.includes(element)) {
          clearGroupSelection();
        }
        const elementId = element.dataset ? element.dataset.elementId : null;
        if (elementId) {
          handleElementAnimationRemoval(elementId);
        }
        
        // Handle title box deletion - hide it and update slide data
        if (element.id === 'titleBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          // Update slide data to mark titleBox as not visible
          if (slides[active] && slides[active].titleBox) {
            slides[active].titleBox.visible = false;
          }
          capture();
          updateElementContextMenuState();
          return;
        }
        
        // Handle main text box deletion - hide it and update slide data
        if (element.id === 'textBox') {
          element.style.display = 'none';
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = titleBox;
            updateFontSizeInput();
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          // Update slide data to mark textBox as not visible
          if (slides[active] && slides[active].textBox) {
            slides[active].textBox.visible = false;
          }
          capture();
          updateElementContextMenuState();
          return;
        }
        
        // Handle additional text boxes - remove completely
        if (element.classList.contains('additional-text-box')) {
          // Remove from font size tracking
          elementFontSizes.delete(element);
          // Remove selection
          element.classList.remove('selected');
          if (selectedTextBox === element) {
            selectedTextBox = null;
          }
          if (rotationTarget === element) {
            hideRotationHandle();
          }
          // Remove from DOM
          element.remove();
          // Update active element if this was active
          if (currentActiveElement === element) {
            currentActiveElement = textBox;
            updateFontSizeInput();
          }
          capture();
          updateElementContextMenuState();
        }
      }
      
      // Global keyboard listener for Delete/Backspace and Undo
      document.addEventListener('keydown', (e) => {
        if (!isPresenting && slideTransitionMenu && slideTransitionMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideTransitionMenu();
          return;
        }
        if (!isPresenting && slideContextMenu && slideContextMenu.classList.contains('show') && e.key === 'Escape') {
          hideSlideContextMenu();
          return;
        }
        if (!isPresenting && saveAsModal && saveAsModal.classList.contains('show') && e.key === 'Escape') {
          hideSaveAsModal();
        }
        if (!isPresenting && saveAsMenu && saveAsMenu.classList.contains('show') && e.key === 'Escape') {
          hideSaveAsMenu();
          return;
        }
        if (isPresenting) {
          if (e.key === 'Escape') {
            e.preventDefault();
            exitPresentation();
            return;
          }
          if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            goToNextSlide();
            return;
          }
          if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            e.preventDefault();
            goToPreviousSlide();
            return;
          }
          const keyLower = typeof e.key === 'string' ? e.key.toLowerCase() : '';
          if (!e.metaKey && !e.ctrlKey && keyLower === 's') {
            e.preventDefault();
            toggleSubtitles();
            return;
          }
          return;
        }
        const selection = window.getSelection();
        const editingTableCell = isEditingTableCell();
        const selectedContext = getSelectedElementContext();
        const selectedElement = selectedContext ? selectedContext.element : null;
        const hasSelectionRange = selection && selection.rangeCount > 0;
        const activeRange = hasSelectionRange ? selection.getRangeAt(0) : null;
        const hasNonCollapsedSelection = activeRange ? !activeRange.collapsed : false;
        const rangeContainer = activeRange ? activeRange.commonAncestorContainer : null;
        const selectionWithinSelectedElement = Boolean(
          selectedElement &&
          rangeContainer &&
          selectedElement.contains(rangeContainer)
        );
        const editableShortcutTarget = isEditableShortcutTarget(e.target);
        const editingSelectedElement = editableShortcutTarget && selectionWithinSelectedElement;

        if (!editingTableCell && (e.metaKey || e.ctrlKey)) {
          const key = typeof e.key === 'string' ? e.key.toLowerCase() : '';
          let handledShortcut = false;

          const allowElementCopyCut = selectedElement && (!editingSelectedElement || !hasNonCollapsedSelection);
          if (allowElementCopyCut && !e.shiftKey && !e.altKey) {
            if (key === 'c') {
              handledShortcut = copySelectedElements(selectedElement);
            } else if (key === 'x') {
              handledShortcut = cutSelectedElements(selectedElement);
            }
          }

          const allowElementPaste = !editableShortcutTarget || (selectedElement && !selectionWithinSelectedElement);
          if (allowElementPaste && !e.shiftKey && !e.altKey && key === 'v') {
            handledShortcut = pasteElementsFromClipboard({
              referenceElement: selectedElement || null
            }) || handledShortcut;
          }

          const allowTextFormatting = editableShortcutTarget || editingSelectedElement;
          if (allowTextFormatting && !e.altKey) {
            switch (key) {
              case 'b':
                document.execCommand('bold');
                handledShortcut = true;
                break;
              case 'i':
                document.execCommand('italic');
                handledShortcut = true;
                break;
              case 'u':
                document.execCommand('underline');
                handledShortcut = true;
                break;
              case 's':
                document.execCommand('strikeThrough');
                handledShortcut = true;
                break;
              default:
                break;
            }
          }

          if (handledShortcut) {
            e.preventDefault();
            return;
          }
        }

        // Undo keyboard shortcut (Cmd+Z on Mac, Ctrl+Z on Windows)
        if (!editingTableCell && (e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undoLastAction();
          return;
        }
        
        // Redo keyboard shortcut (Cmd+Shift+Z on Mac, Ctrl+Shift+Z on Windows)
        if (!editingTableCell && (e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          redoLastAction();
          return;
        }
        
        // Handle Delete/Backspace for group-selected items (multiple items selected via drag)
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && groupSelectionState.elements && groupSelectionState.elements.length > 0) {
          // Check if user is actively editing text inside any text box in the selection
          const activeElement = document.activeElement;
          const textBoxInSelection = groupSelectionState.elements.find((element) => {
            return (element.classList.contains('additional-text-box') || element.id === 'titleBox' || element.id === 'textBox') &&
                   element.contains(activeElement) && activeElement.isContentEditable;
          });
          
          if (textBoxInSelection) {
            // User is typing in a text box - check if we should delete or allow text editing
            const hasTextSelection = selection && selection.toString().length > 0;
            const isEmpty = !textBoxInSelection.textContent.trim();
            
            // Only delete if no text is selected or box is empty (matching single element behavior)
            if (!hasTextSelection || isEmpty) {
              e.preventDefault();
              e.stopPropagation();
              // Create a copy of the array to avoid issues while iterating
              const elementsToDelete = [...groupSelectionState.elements];
              elementsToDelete.forEach((element) => {
                if (element.classList.contains('shape-element')) {
                  deleteShape(element);
                } else if (element.classList.contains('chart-element')) {
                  deleteChart(element);
                } else if (element.classList.contains('image-element')) {
                  deleteImage(element);
                } else if (element.classList.contains('video-element')) {
                  deleteVideo(element);
                } else if (element.classList.contains('table-element')) {
                  deleteTable(element);
                } else if (element.classList.contains('additional-text-box') || element.id === 'titleBox' || element.id === 'textBox') {
                  deleteTextBox(element);
                }
              });
              saveEditorState('delete_group_selection');
            }
            // If hasTextSelection is true and box is not empty, allow normal text editing (don't prevent default)
          } else {
            // Not typing in any selected element, delete all group-selected items
            e.preventDefault();
            e.stopPropagation();
            // Create a copy of the array to avoid issues while iterating
            const elementsToDelete = [...groupSelectionState.elements];
            elementsToDelete.forEach((element) => {
              if (element.classList.contains('shape-element')) {
                deleteShape(element);
              } else if (element.classList.contains('chart-element')) {
                deleteChart(element);
              } else if (element.classList.contains('image-element')) {
                deleteImage(element);
              } else if (element.classList.contains('video-element')) {
                deleteVideo(element);
              } else if (element.classList.contains('table-element')) {
                deleteTable(element);
              } else if (element.classList.contains('additional-text-box') || element.id === 'titleBox' || element.id === 'textBox') {
                deleteTextBox(element);
              }
            });
            saveEditorState('delete_group_selection');
          }
          return;
        }
        
        // Only handle Delete/Backspace if a text box is selected
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
          // Check if user is typing (cursor is inside the text box)
          const isTyping = selection.rangeCount > 0 && 
                          selection.getRangeAt(0).startOffset !== selection.getRangeAt(0).endOffset;
          
          // Only delete if not typing (no text selection) or if box is empty
          const isEmpty = !selectedTextBox.textContent.trim();
          const hasTextSelection = selection.toString().length > 0;
          
          if (!hasTextSelection || isEmpty) {
            e.preventDefault();
            e.stopPropagation();
            deleteTextBox(selectedTextBox);
            saveEditorState('delete_textbox');
          }
        }

        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedShape) {
          e.preventDefault();
          e.stopPropagation();
          deleteShape(selectedShape);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedChart) {
          // Check if user is actively editing chart data (in chart data editor inputs)
          const activeElement = document.activeElement;
          const chartDataEditor = document.getElementById('chartDataEditor');
          const isEditingChartData = chartDataEditor && (
            chartDataEditor.contains(activeElement) || 
            activeElement.tagName === 'INPUT' || 
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.classList.contains('chart-data-input') ||
            activeElement.classList.contains('chart-data-title-input') ||
            activeElement.classList.contains('chart-data-color-input')
          );
          
          // Only delete chart if not editing chart data
          if (!isEditingChartData) {
          e.preventDefault();
          e.stopPropagation();
          deleteChart(selectedChart);
          }
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedImage) {
          e.preventDefault();
          e.stopPropagation();
          deleteImage(selectedImage);
        }
        if (!editingTableCell && (e.key === 'Delete' || e.key === 'Backspace') && selectedVideo) {
          e.preventDefault();
          e.stopPropagation();
          deleteVideo(selectedVideo);
        }
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTable) {
          // Check if any table cells are selected
          const selectedCells = getTableSelectedCells(selectedTable);
          if (selectedCells && selectedCells.length > 0) {
            // Check if user is actively editing text within a selected cell
            const activeElement = document.activeElement;
            const isActivelyEditing = activeElement && 
                                     activeElement.isContentEditable && 
                                     activeElement.closest('.table-element') &&
                                     selectedCells.includes(activeElement);
            
            if (isActivelyEditing) {
              // Check if there's text selection or if cell is empty
              const selection = window.getSelection();
              const hasTextSelection = selection && selection.toString().length > 0;
              const isEmpty = !activeElement.textContent.trim();
              
              // Only clear cell if no text is selected or cell is empty
              if (!hasTextSelection || isEmpty) {
                e.preventDefault();
                e.stopPropagation();
                selectedCells.forEach((cell) => {
                  cell.textContent = '';
                  if (document.activeElement === cell) {
                    cell.blur();
                  }
                });
                clearTableSelection(selectedTable);
                capture();
                saveEditorState('delete_table_cell');
                return;
              }
              // Otherwise, allow normal text editing (don't prevent default)
            } else {
              // Cell is selected but not being edited - clear it
              e.preventDefault();
              e.stopPropagation();
              selectedCells.forEach((cell) => {
                cell.textContent = '';
                if (document.activeElement === cell) {
                  cell.blur();
                }
              });
              clearTableSelection(selectedTable);
              capture();
              saveEditorState('delete_table_cell');
              return;
            }
          }
          // If no cells selected and not editing, delete the entire table
          if (!editingTableCell) {
            e.preventDefault();
            e.stopPropagation();
            deleteTable(selectedTable);
          }
        }
      });
      
      // Back (Undo) button click handler
      document.getElementById('btnBack').addEventListener('click', () => {
        undoLastAction();
      });
      
      // Forward (Redo) button click handler
      document.getElementById('btnForward').addEventListener('click', () => {
        redoLastAction();
      });
      
      // Redo functionality
      function redoLastAction() {
        if (redoStack.length > 0) {
          const currentState = {
            slides: JSON.parse(JSON.stringify(slides)),
            active: active,
            canvasState: {
              titleBoxVisible: titleBox.style.display !== 'none',
              textBoxVisible: textBox.style.display !== 'none',
              additionalTextBoxes: Array.from(document.querySelectorAll('.additional-text-box')).map(box => {
                const coords = getElementCanvasCoordinates(box);
                return {
                  element: box,
                  html: box.innerHTML,
                  style: {
                    top: coords.top,
                    left: coords.left,
                    width: box.offsetWidth,
                    height: box.offsetHeight,
                    fontSize: box.style.fontSize,
                    fontFamily: window.getComputedStyle(box).fontFamily,
                    display: box.style.display,
                    rotation: parseFloat(box.dataset.rotation || '0') || 0,
                    minWidth: parseFloat(box.dataset.minWidth || box.style.minWidth || 200),
                    minHeight: parseFloat(box.dataset.minHeight || box.style.minHeight || 50)
                  }
                };
              }),
              shapes: collectShapesData(),
            charts: collectChartsData(),
              tables: collectTablesData(),
              images: collectImagesData(),
              videos: collectVideosData()
            }
          };
          
          // Save current state to undo stack
          actionHistory.push(currentState);
          
          // Get next state from redo stack
          const nextState = redoStack.pop();
          restoreEditorState(nextState);
        }
      }
      
      const initializeToolbarTabs = () => {
        const toolbar = document.getElementById('toolbar');
        if (!toolbar) return;

        const tabButtons = Array.from(toolbar.querySelectorAll('[data-tab-target]'));
        const panels = Array.from(toolbar.querySelectorAll('[data-tab-panel]'));

        if (!tabButtons.length || !panels.length) {
          return;
        }

        const activateTab = (targetName) => {
          const fallback = tabButtons[0]?.dataset.tabTarget;
          const tabToActivate = targetName || fallback || null;

          if (!tabToActivate) {
            return;
          }

          tabButtons.forEach((button) => {
            const isActive = button.dataset.tabTarget === tabToActivate;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-selected', String(isActive));
            button.setAttribute('tabindex', isActive ? '0' : '-1');
          });

          panels.forEach((panel) => {
            const isActive = panel.dataset.tabPanel === tabToActivate;
            panel.classList.toggle('active', isActive);
            if (isActive) {
              panel.removeAttribute('hidden');
            } else {
              panel.setAttribute('hidden', '');
            }
            panel.setAttribute('aria-hidden', String(!isActive));
          });
          if (typeof hideAnimationSequencePanel === 'function' && tabToActivate !== 'animations') {
            hideAnimationSequencePanel();
          }
        };

        const focusTabByOffset = (currentButton, offset) => {
          if (!tabButtons.length) return;
          const currentIndex = tabButtons.indexOf(currentButton);
          if (currentIndex === -1) return;
          const nextIndex = (currentIndex + offset + tabButtons.length) % tabButtons.length;
          const nextButton = tabButtons[nextIndex];
          if (!nextButton) return;
          nextButton.focus();
          activateTab(nextButton.dataset.tabTarget);
        };

        tabButtons.forEach((button) => {
          button.addEventListener('click', () => {
            activateTab(button.dataset.tabTarget);
          });

          button.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
              event.preventDefault();
              focusTabByOffset(button, 1);
              return;
            }

            if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
              event.preventDefault();
              focusTabByOffset(button, -1);
              return;
            }

            if (event.key === 'Home') {
              event.preventDefault();
              const firstTab = tabButtons[0];
              if (firstTab) {
                firstTab.focus();
                activateTab(firstTab.dataset.tabTarget);
              }
              return;
            }

            if (event.key === 'End') {
              event.preventDefault();
              const lastTab = tabButtons[tabButtons.length - 1];
              if (lastTab) {
                lastTab.focus();
                activateTab(lastTab.dataset.tabTarget);
              }
            }
          });
        });

        activateTab('home');
      };

      initializeToolbarTabs();
      initializeSpellCheckControls();

      if (backgroundColorButton && backgroundColorInput) {
        backgroundColorButton.addEventListener('click', (event) => {
          event.preventDefault();
          previousBackgroundColorValue = getCanvasBackgroundColor();
          backgroundColorInput.click();
        });
        const handleBackgroundColorPreview = (event) => {
          applySlideBackgroundColor(event.target.value, { recordHistory: false, showNotificationMessage: false });
        };
        const handleBackgroundColorCommit = (event) => {
          applySlideBackgroundColor(event.target.value, { recordHistory: true, showNotificationMessage: true });
          previousBackgroundColorValue = null;
        };
        const handleBackgroundColorCancel = () => {
          if (previousBackgroundColorValue) {
            applySlideBackgroundColor(previousBackgroundColorValue, { recordHistory: false, showNotificationMessage: false });
            if (backgroundColorInput) {
              backgroundColorInput.value = normalizeColorHex(previousBackgroundColorValue);
            }
            previousBackgroundColorValue = null;
          }
        };
        backgroundColorInput.addEventListener('input', handleBackgroundColorPreview);
        backgroundColorInput.addEventListener('change', handleBackgroundColorCommit);
        backgroundColorInput.addEventListener('cancel', handleBackgroundColorCancel);
      }

      if (dictateButton) {
        if (!SpeechRecognitionConstructor) {
          dictateButton.disabled = true;
          dictateButton.title = 'Dictation is not supported in this browser.';
        }
        dictateButton.addEventListener('click', (event) => {
          event.preventDefault();
          if (isDictating) {
            stopDictation({ commit: true, message: 'Dictation stopped.' });
            return;
          }
          if (!SpeechRecognitionConstructor) {
            showNotification('Speech recognition is not supported in this browser.');
            return;
          }
          toggleDictationLanguageMenu();
        });
        updateDictationButtonLabel();
      }

      if (presentationSubtitleToggle) {
        if (!subtitlesSupported) {
          presentationSubtitleToggle.disabled = true;
          presentationSubtitleToggle.title = 'Subtitles are not supported in this browser.';
        } else {
          presentationSubtitleToggle.addEventListener('click', (event) => {
            event.preventDefault();
            toggleSubtitles();
          });
        }
      }

      if (insertNewSlideButton) {
        insertNewSlideButton.addEventListener('click', (event) => {
          event.preventDefault();
          createNewSlide(active);
        });
      }

      if (transitionEffectSelect) {
        transitionEffectSelect.addEventListener('change', () => {
          const durationValue = transitionDurationInput
            ? clampTransitionDuration(transitionDurationInput.value)
            : DEFAULT_TRANSITION_DURATION;
          if (transitionDurationInput) {
            transitionDurationInput.value = durationValue.toFixed(1);
          }
          updateActiveSlideTransition(transitionEffectSelect.value, durationValue, { recordHistory: true });
        });
      }

      if (transitionDurationInput) {
        const commitDurationChange = () => {
          const durationValue = clampTransitionDuration(transitionDurationInput.value);
          transitionDurationInput.value = durationValue.toFixed(1);
          const effectValue = transitionEffectSelect ? transitionEffectSelect.value : slides[active]?.transition;
          updateActiveSlideTransition(effectValue, durationValue, { recordHistory: true });
        };
        transitionDurationInput.addEventListener('change', commitDurationChange);
        transitionDurationInput.addEventListener('blur', commitDurationChange);
      }

      const applyTransitionButton = document.getElementById('applyTransitionButton');
      if (applyTransitionButton) {
        applyTransitionButton.addEventListener('click', () => {
          const slide = slides[active];
          if (!slide) return;
          
          const effectValue = transitionEffectSelect ? transitionEffectSelect.value : DEFAULT_TRANSITION;
          const durationValue = transitionDurationInput
            ? clampTransitionDuration(transitionDurationInput.value)
            : DEFAULT_TRANSITION_DURATION;
          if (transitionDurationInput) {
            transitionDurationInput.value = durationValue.toFixed(1);
          }
          const normalizedEffect = normalizeTransitionEffect(effectValue);
          const config = getSlideTransitionConfig(slide);
          
          if (config.effect === normalizedEffect && config.duration === durationValue) {
            showNotification('Current slide already uses this transition');
            return;
          }
          
          capture();
          applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: durationValue });
          saveEditorState('change_transition');
          refreshAllTransitionButtons();
          syncTransitionControlsWithSlide();
          refreshSidebarSoon();
          showNotification('Applied transition to current slide');
        });
      }

      if (applyTransitionAllButton) {
        applyTransitionAllButton.addEventListener('click', () => {
          const effectValue = transitionEffectSelect ? transitionEffectSelect.value : DEFAULT_TRANSITION;
          const durationValue = transitionDurationInput
            ? clampTransitionDuration(transitionDurationInput.value)
            : DEFAULT_TRANSITION_DURATION;
          if (transitionDurationInput) {
            transitionDurationInput.value = durationValue.toFixed(1);
          }
          const normalizedEffect = normalizeTransitionEffect(effectValue);
          const hasChanges = slides.some((slide) => {
            const config = getSlideTransitionConfig(slide);
            return config.effect !== normalizedEffect || config.duration !== durationValue;
          });
          if (!hasChanges) {
            showNotification('All slides already use this transition');
            return;
          }
          capture();
          slides.forEach((slide) => applyTransitionConfigToSlide(slide, { effect: normalizedEffect, duration: durationValue }));
          saveEditorState('change_transition_all');
          refreshAllTransitionButtons();
          syncTransitionControlsWithSlide();
          refreshSidebarSoon();
          showNotification('Applied transition to all slides');
        });
      }

      if (assignAnimationButton) {
        assignAnimationButton.addEventListener('click', (event) => {
          event.preventDefault();
          assignAnimationToSelectedElement();
        });
      }

      if (removeAnimationButton) {
        removeAnimationButton.addEventListener('click', (event) => {
          event.preventDefault();
          removeAnimationFromSelection();
        });
      }

      if (animationSequenceCloseButton) {
        animationSequenceCloseButton.addEventListener('click', (event) => {
          event.preventDefault();
          hideAnimationSequencePanel();
        });
      }

      // Formatting tools
      document.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const action = btn.getAttribute('data-action');
          
          // Handle addTextBox action
          if (action === 'addTextBox') {
            addTextBox();
            return;
          }
          // Handle layout action
          if (action === 'layout') {
            toggleLayoutDropdown();
            return;
          }
          if (action === 'present') {
            startPresentation();
            return;
          }
          
          const activeEl = getActiveElement();
          
          // Focus on the active element if needed
          if (activeEl === titleBox || activeEl === textBox || titleBox.contains(activeEl) || textBox.contains(activeEl)) {
            if (titleBox.contains(activeEl) || activeEl === titleBox) {
              titleBox.focus();
            } else {
              textBox.focus();
            }
          }

          // Execute command
          if (action === 'bold') document.execCommand('bold', false);
          else if (action === 'italic') document.execCommand('italic', false);
          else if (action === 'underline') document.execCommand('underline', false);
          else if (action === 'strikeThrough') document.execCommand('strikeThrough', false);
          else if (action === 'superscript') document.execCommand('superscript', false);
          else if (action === 'subscript') document.execCommand('subscript', false);
          else if (action === 'justifyLeft') document.execCommand('justifyLeft', false);
          else if (action === 'justifyCenter') document.execCommand('justifyCenter', false);
          else if (action === 'justifyRight') document.execCommand('justifyRight', false);
          else if (action === 'justifyFull') document.execCommand('justifyFull', false);
          else if (action === 'insertUnorderedList') document.execCommand('insertUnorderedList', false);
          else if (action === 'insertOrderedList') document.execCommand('insertOrderedList', false);
        });
      });

      // Store font sizes for elements
      let titleFontSize = 28;
      let textFontSize = 16;
      let elementFontSizes = new Map(); // Store font sizes for dynamically created elements
      let elementFontFamilies = new Map();
      let currentActiveElement = textBox;

      // Initialize default font sizes
      titleBox.style.fontSize = titleFontSize + 'px';
      textBox.style.fontSize = textFontSize + 'px';
      elementFontSizes.set(titleBox, titleFontSize);
      elementFontSizes.set(textBox, textFontSize);
      titleBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      textBox.style.fontFamily = DEFAULT_FONT_FAMILY;
      elementFontFamilies.set(titleBox, DEFAULT_FONT_FAMILY);
      elementFontFamilies.set(textBox, DEFAULT_FONT_FAMILY);

      // Function to get current font size from an element
      function getCurrentFontSize(element) {
        if (elementFontSizes.has(element)) {
          return elementFontSizes.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseFloat(computedStyle.fontSize);
        return Math.round(fontSize);
      }

      function getCurrentFontFamily(element) {
        if (!element) return DEFAULT_FONT_FAMILY;
        if (elementFontFamilies.has(element)) {
          return elementFontFamilies.get(element);
        }
        const computedStyle = window.getComputedStyle(element);
        return computedStyle.fontFamily || DEFAULT_FONT_FAMILY;
      }

      // Function to apply font size to an element
      function applyFontSize(element, size) {
        const selection = window.getSelection();
        
        // If there's selected text in the element, apply font size to selection
        if (selection.rangeCount > 0 && !selection.isCollapsed && 
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = size + 'px';
          span.style.setProperty('font-size', size + 'px', 'important');
          
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
          } catch (e) {
            document.execCommand("fontSize", false, "7");
            setTimeout(() => {
              const fonts = element.getElementsByTagName("font");
              for (let i = fonts.length - 1; i >= 0; i--) {
                if (fonts[i].size === "7") {
                  const newSpan = document.createElement('span');
                  newSpan.style.fontSize = size + 'px';
                  newSpan.style.setProperty('font-size', size + 'px', 'important');
                  newSpan.innerHTML = fonts[i].innerHTML;
                  fonts[i].parentNode.replaceChild(newSpan, fonts[i]);
                }
              }
            }, 10);
          }
        } else {
          // No selection - apply font size to the entire element
          element.style.fontSize = size + 'px';
          element.style.setProperty('font-size', size + 'px', 'important');
          
          // Update the stored font size
          elementFontSizes.set(element, size);
          
          // Wrap existing text nodes in spans to preserve formatting
          const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
          const textNodes = [];
          let node;
          while (node = walker.nextNode()) {
            const parent = node.parentElement;
            if (!parent || !parent.style.fontSize) {
              textNodes.push(node);
            }
          }
          
          textNodes.forEach(textNode => {
            if (textNode.textContent.trim()) {
              const span = document.createElement('span');
              span.style.fontSize = size + 'px';
              span.style.setProperty('font-size', size + 'px', 'important');
              span.textContent = textNode.textContent;
              textNode.parentNode.replaceChild(span, textNode);
            }
          });
        }
        
        // Store the font size for this element
        elementFontSizes.set(element, size);
      }

      function applyFontFamily(element, family) {
        const selection = window.getSelection();
        const normalizedFamily = family || DEFAULT_FONT_FAMILY;

        if (selection.rangeCount > 0 && !selection.isCollapsed &&
            (element.contains(selection.anchorNode) || selection.anchorNode === element)) {
          document.execCommand('fontName', false, normalizedFamily);
        } else {
          element.style.fontFamily = normalizedFamily;
        }

        elementFontFamilies.set(element, normalizedFamily);
      }

      // Update font size input when focus changes
      function updateFontSizeInput() {
        const fontSizeInput = document.getElementById('fontSize');
        if (currentActiveElement) {
          const currentSize = getCurrentFontSize(currentActiveElement);
          fontSizeInput.value = currentSize;
        }
      }

      function updateFontPickerSelectedFont() {
        if (!fontPickerButton || !fontPickerLabel) return;
        const fontFamily = getCurrentFontFamily(currentActiveElement);
        const normalized = normalizeFontStack(fontFamily);
        const name = fontStackToName.get(normalized) || extractPrimaryFontName(fontFamily);
        fontPickerButton.style.fontFamily = fontFamily;
        fontPickerLabel.style.fontFamily = fontFamily;
        fontPickerLabel.textContent = name;
        fontPickerButton.setAttribute('title', `Font Family: ${name}`);
        fontPickerButton.setAttribute('aria-label', `Font Family: ${name}`);
        setActiveFontOption(fontFamily);
      }

      // Track focus changes for any contenteditable element
      function setupFontSizeTracking(element) {
        element.addEventListener('focus', () => {
          // Ensure text boxes always use block display, never flex (to prevent vertical text stacking)
          const isTextBox = element.classList.contains('text-box') || element.classList.contains('title-box') || element.classList.contains('additional-text-box');
          if (isTextBox) {
            // Force display to block immediately
            element.style.setProperty('display', 'block', 'important');
            // Also check computed style in case inline style was set
            const computedDisplay = window.getComputedStyle(element).display;
            if (computedDisplay === 'flex' || computedDisplay === 'inline-flex') {
              element.style.setProperty('display', 'block', 'important');
            }
            // Set up a periodic check while focused to ensure it stays block
            const checkInterval = setInterval(() => {
              const currentDisplay = element.style.display || window.getComputedStyle(element).display;
              if (currentDisplay === 'flex' || currentDisplay === 'inline-flex') {
                element.style.setProperty('display', 'block', 'important');
              }
            }, 100);
            // Clear interval when element loses focus
            element.addEventListener('blur', () => {
              clearInterval(checkInterval);
            }, { once: true });
          }
          currentActiveElement = element;
          updateFontSizeInput();
          updateFontPickerSelectedFont();
        });
        
        // Initialize font size if not set
        if (!elementFontSizes.has(element)) {
          const currentSize = parseFloat(window.getComputedStyle(element).fontSize) || 16;
          elementFontSizes.set(element, Math.round(currentSize));
        }
      }

      function setupFontFamilyTracking(element) {
        element.addEventListener('focus', () => {
          currentActiveElement = element;
          if (!elementFontFamilies.has(element)) {
            elementFontFamilies.set(element, getCurrentFontFamily(element));
          }
          updateFontPickerSelectedFont();
        });

        if (!elementFontFamilies.has(element)) {
          elementFontFamilies.set(element, getCurrentFontFamily(element));
        }
      }

      function applyFontFamilyToCurrent(fontFamily) {
        if (!currentActiveElement) {
          currentActiveElement = textBox;
        }
        applyFontFamily(currentActiveElement, fontFamily);
        updateFontPickerSelectedFont();
        capture();
        saveEditorState('change_font_family');
      }

      // Track focus changes for existing elements
      setupFontSizeTracking(titleBox);
      setupFontSizeTracking(textBox);
      setupFontFamilyTracking(titleBox);
      setupFontFamilyTracking(textBox);

      // Also check on selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const anchorNode = selection.anchorNode;
          
          // Find which contenteditable element contains the selection
          let activeEl = null;
          if (titleBox.contains(anchorNode) || anchorNode === titleBox) {
            activeEl = titleBox;
          } else if (textBox.contains(anchorNode) || anchorNode === textBox) {
            activeEl = textBox;
          } else {
            // Check additional text boxes
            const allTextBoxes = document.querySelectorAll('.additional-text-box, .text-box');
            allTextBoxes.forEach(box => {
              if (box.contains(anchorNode) || anchorNode === box) {
                activeEl = box;
              }
            });
          }
          
          if (activeEl && currentActiveElement !== activeEl) {
            currentActiveElement = activeEl;
            updateFontSizeInput();
            updateFontPickerSelectedFont();
          }
        }
      });

      // Font size input change handler
      const fontSizeInput = document.getElementById('fontSize');
      fontSizeInput.addEventListener('change', (e) => {
        const size = parseInt(e.target.value);
        if (!isNaN(size) && size >= 8 && size <= 72 && currentActiveElement) {
          applyFontSize(currentActiveElement, size);
          
          // Update stored sizes for title and main text box
          if (currentActiveElement === titleBox) {
            titleFontSize = size;
          } else if (currentActiveElement === textBox) {
            textFontSize = size;
          }
        }
      });
      
      // Validate input on blur
      fontSizeInput.addEventListener('blur', (e) => {
        if (!currentActiveElement) return;
        
        const size = parseInt(e.target.value);
        const currentSize = getCurrentFontSize(currentActiveElement);
        
        if (isNaN(size) || size < 8) {
          e.target.value = currentSize;
        } else if (size > 72) {
          e.target.value = 72;
          applyFontSize(currentActiveElement, 72);
          
          // Update stored sizes
          if (currentActiveElement === titleBox) {
            titleFontSize = 72;
          } else if (currentActiveElement === textBox) {
            textFontSize = 72;
          }
        }
      });

      // Initialize the input value
      updateFontSizeInput();
      updateFontPickerSelectedFont();

      function attachColorInputHandlers() {
        const fontColorInput = document.getElementById('fontColor');
        const highlightColorInput = document.getElementById('highlightColor');

        if (!fontColorInput || !highlightColorInput) {
          requestAnimationFrame(attachColorInputHandlers);
          return;
        }

        if (!fontColorInput.dataset.bound) {
          fontColorInput.addEventListener('change', (e) => {
            document.execCommand('foreColor', false, e.target.value);
          });
          fontColorInput.dataset.bound = 'true';
        }

        if (!highlightColorInput.dataset.bound) {
          highlightColorInput.addEventListener('change', (e) => {
            document.execCommand('backColor', false, e.target.value);
          });
          highlightColorInput.dataset.bound = 'true';
        }
      }
      attachColorInputHandlers();

      document.addEventListener('apply-text-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#000000';
        document.execCommand('foreColor', false, color);
      });

      document.addEventListener('apply-bg-color', (event) => {
        const color = event.detail && event.detail.color ? event.detail.color : '#ffff00';
        const targetTable = selectedTable && getTableSelectedCells(selectedTable).length
          ? selectedTable
          : null;
        if (targetTable) {
          const cells = getTableSelectedCells(targetTable);
          if (cells.length) {
            const normalized = normalizeColorHex(color);
            cells.forEach((cell) => {
              cell.style.backgroundColor = normalized;
            });
            capture();
            saveEditorState('color_table_cells');
            return;
          }
        }
        document.execCommand('backColor', false, color);
      });

      // Save function per Editor.json and auth_system.json
      function savePresentation() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        if (!currentUser) {
          if (isGuest) {
            alert('Please sign in to save presentations. Guests can only view and edit.');
            return;
          }
          alert('Please log in to save presentations.');
          window.location.href = './templates.html';
          return;
        }

        capture();
        const title = titleBox.textContent.trim() || "Title";
        const content = textBox.textContent.trim() || "";
        
        // Save to user-specific key per auth_system.json
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        saved.push({
          title: title,
          date: new Date().toISOString().split("T")[0],
          content: content
        });
        
        localStorage.setItem(userKey, JSON.stringify(saved));
        
        // Show notification animation
        showNotification('Presentation saved!');
      }

      // FIXED: Save presentation to recents with full slides data
      function saveToRecents() {
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        const isGuest = localStorage.getItem('guest') === 'true';
        
        if (!currentUser) {
          console.warn('Cannot save to recents: no user logged in');
          return;
        }

        // Ensure slides array exists and has content
        if (typeof slides === 'undefined' || !Array.isArray(slides) || slides.length === 0) {
          console.warn('Cannot save to recents: slides array is empty or undefined');
          return;
        }

        // Get the presentation title
        const title = (typeof titleBox !== 'undefined' && titleBox.textContent) 
          ? titleBox.textContent.trim() 
          : 'AI Generated Presentation';
        
        // Create presentation object
        const presentation = {
          id: crypto.randomUUID ? crypto.randomUUID() : `pres-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          title: title || 'Untitled',
          date: new Date().toISOString(),
          slides: JSON.stringify(slides) // Store slides as JSON string
        };
        
        // Save to user-specific key
        const userKey = `presentations_${currentUser.username}`;
        const saved = JSON.parse(localStorage.getItem(userKey) || '[]');
        
        // Add new presentation to the beginning of the array
        saved.unshift(presentation);
        
        // Keep only the 50 most recent presentations
        if (saved.length > 50) {
          saved.splice(50);
        }
        
        localStorage.setItem(userKey, JSON.stringify(saved));
        
        console.log('Presentation saved to recents with', slides.length, 'slides');
      }

      // Topbar button actions per slides.json
      document.getElementById('btnDel').addEventListener('click', () => {
        deleteSlide(active);
      });

      document.getElementById('btnReset').addEventListener('click', () => {
        if (confirm('Reset all slides? This cannot be undone.')) {
          saveEditorState('reset_slides');
          const resetSlide = createEmptySlide();
          resetSlide.transition = DEFAULT_TRANSITION;
          resetSlide.transitionDuration = DEFAULT_TRANSITION_DURATION;
          slides.splice(0, slides.length, resetSlide);
          active = 0;
          load();
          renderSidebar();
          updateSlideCanvasMenuState();
        }
      });

      document.getElementById('btnSave').addEventListener('click', savePresentation);

      document.getElementById('btnHome').addEventListener('click', () => {
        capture();
        window.location.href = './templates.html';
      });

      // Hover button functions per Editor.json slidePreview

      function createNewSlide(index) {
        capture();
        saveEditorState('create_slide');
        const newSlide = createEmptySlide();
        newSlide.transition = DEFAULT_TRANSITION;
        newSlide.transitionDuration = DEFAULT_TRANSITION_DURATION;
        slides.splice(index + 1, 0, newSlide);
        active = index + 1;
        load();
        renderSidebar();
        updateSlideCanvasMenuState();
      }

      function duplicateCurrentSlide(index) {
        capture();
        saveEditorState('duplicate_slide');
        const s = slides[index];
        const duplicatedAnimations = Array.isArray(s.animations)
          ? sortSlideAnimations(s).map((anim, idx) => ({
              id: generateElementId('anim'),
              targetId: anim.targetId,
              effect: normalizeAnimationEffect(anim.effect),
              duration: clampAnimationDuration(anim.duration ?? DEFAULT_ANIMATION_DURATION),
              order: idx + 1
            }))
          : [];
        slides.splice(index + 1, 0, { 
          title: s.title ? `${s.title} copy` : '',
          content: s.content,
          titleBox: s.titleBox ? {...s.titleBox} : { top: 24, left: 24, right: 24, width: null, height: null, rotation: 0, visible: false },
          textBox: s.textBox ? {...s.textBox} : { top: 100, left: 24, right: 24, bottom: 24, width: null, height: null, rotation: 0, visible: false },
          titleFontFamily: s.titleFontFamily || DEFAULT_FONT_STACK,
          textFontFamily: s.textFontFamily || DEFAULT_FONT_STACK,
          shapes: s.shapes ? JSON.parse(JSON.stringify(s.shapes)) : [],
          additionalTextBoxes: s.additionalTextBoxes ? JSON.parse(JSON.stringify(s.additionalTextBoxes)) : [],
        tables: s.tables ? JSON.parse(JSON.stringify(s.tables)) : [],
        images: s.images ? JSON.parse(JSON.stringify(s.images)) : [],
        videos: s.videos ? JSON.parse(JSON.stringify(s.videos)) : [],
        comments: s.comments ? JSON.parse(JSON.stringify(s.comments)) : [],
        animations: duplicatedAnimations,
        transition: normalizeTransitionEffect(s.transition),
        transitionDuration: clampTransitionDuration(s.transitionDuration),
        background: s.background ? { ...s.background } : { image: '', size: '', position: '', repeat: '', color: '#ffffff' }
        });
        active = index + 1;
        load();
        renderSidebar();
        updateSlideCanvasMenuState();
      }

      // Auto-save on input with debounce for undo
      let textEditTimeout;
      function saveTextEditState() {
        clearTimeout(textEditTimeout);
        textEditTimeout = setTimeout(() => {
          saveEditorState('edit_text');
        }, 1000); // Save state 1 second after typing stops
      }
      
      // CRITICAL FIX: Run IMMEDIATELY on focus before any typing
      if (titleBox) {
        titleBox.addEventListener('focus', function() {
          this.style.setProperty('display', 'block', 'important');
          this.style.setProperty('width', '200px', 'important');
          this.style.setProperty('min-width', '200px', 'important');
          this.style.setProperty('word-break', 'normal', 'important');
          this.style.setProperty('overflow-wrap', 'normal', 'important');
          this.style.setProperty('writing-mode', 'horizontal-tb', 'important');
        }, true);
        
        titleBox.addEventListener('keydown', function(e) {
          this.style.setProperty('display', 'block', 'important');
          this.style.setProperty('width', '200px', 'important');
          this.style.setProperty('min-width', '200px', 'important');
        }, true);
      }
      
      titleBox.addEventListener('input', () => {
        // AGGRESSIVE FIX: Ensure styles are correct on every input
        titleBox.style.setProperty('display', 'block', 'important');
        titleBox.style.setProperty('flex-direction', 'row', 'important');
        titleBox.style.setProperty('writing-mode', 'horizontal-tb', 'important');
        
        const computed = window.getComputedStyle(titleBox);
        if (computed.display === 'flex' || computed.display === 'inline-flex') {
          titleBox.style.setProperty('display', 'block', 'important');
        }
        
        // CRITICAL: Check and fix width on every keystroke
        const width = parseFloat(computed.width);
        if (width < 100 || isNaN(width)) {
          titleBox.style.setProperty('width', '200px', 'important');
          titleBox.style.setProperty('min-width', '200px', 'important');
        }
        
        titleBox.style.setProperty('word-break', 'normal', 'important');
        titleBox.style.setProperty('overflow-wrap', 'normal', 'important');
        
        if (titleBox.style.display === 'none') return;
        slides[active].title = titleBox.textContent.trim();
        renderSidebar();
        saveTextEditState();
      });
      
      textBox.addEventListener('input', () => {
        // AGGRESSIVE FIX: Ensure styles are correct on every input
        textBox.style.setProperty('display', 'block', 'important');
        textBox.style.setProperty('flex-direction', 'row', 'important');
        textBox.style.setProperty('writing-mode', 'horizontal-tb', 'important');
        
        const computed = window.getComputedStyle(textBox);
        if (computed.display === 'flex' || computed.display === 'inline-flex') {
          textBox.style.setProperty('display', 'block', 'important');
        }
        
        // CRITICAL: Check and fix width on every keystroke
        const width = parseFloat(computed.width);
        if (width < 100 || isNaN(width)) {
          textBox.style.setProperty('width', '200px', 'important');
          textBox.style.setProperty('min-width', '200px', 'important');
        }
        
        textBox.style.setProperty('word-break', 'normal', 'important');
        textBox.style.setProperty('overflow-wrap', 'normal', 'important');
        
        if (textBox.style.display === 'none') return;
        slides[active].content = textBox.textContent.trim();
        saveTextEditState();
      });
      
      // CRITICAL FIX: Run IMMEDIATELY on focus before any typing for textBox
      if (textBox) {
        textBox.addEventListener('focus', function() {
          this.style.setProperty('display', 'block', 'important');
          this.style.setProperty('width', '200px', 'important');
          this.style.setProperty('min-width', '200px', 'important');
          this.style.setProperty('word-break', 'normal', 'important');
          this.style.setProperty('overflow-wrap', 'normal', 'important');
          this.style.setProperty('writing-mode', 'horizontal-tb', 'important');
        }, true);
        
        textBox.addEventListener('keydown', function(e) {
          this.style.setProperty('display', 'block', 'important');
          this.style.setProperty('width', '200px', 'important');
          this.style.setProperty('min-width', '200px', 'important');
        }, true);
      }
      
      // Add MutationObservers to main text boxes to watch for style changes
      if (titleBox) {
        const titleBoxStyleObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              const display = titleBox.style.display;
              if (display === 'flex' || display === 'inline-flex') {
                titleBox.style.display = 'block';
              }
            }
          });
        });
        titleBoxStyleObserver.observe(titleBox, {
          attributes: true,
          attributeFilter: ['style']
        });
      }
      
      if (textBox) {
        const textBoxStyleObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              const display = textBox.style.display;
              if (display === 'flex' || display === 'inline-flex') {
                textBox.style.display = 'block';
              }
            }
          });
        });
        textBoxStyleObserver.observe(textBox, {
          attributes: true,
          attributeFilter: ['style']
        });
      }
      
      // Also track input on additional text boxes
      document.addEventListener('input', (e) => {
        if (e.target.classList && e.target.classList.contains('additional-text-box')) {
          saveTextEditState();
        }
      });

      // Check if loading a saved presentation from Recent section
      const loadPres = sessionStorage.getItem('loadPresentation');
      if (loadPres) {
        try {
          const pres = JSON.parse(loadPres);
          
          // FIXED: Load full slides array if available
          if (pres.slides && typeof pres.slides === 'string') {
            // Parse the slides array from JSON string
            const loadedSlides = JSON.parse(pres.slides);
            if (Array.isArray(loadedSlides) && loadedSlides.length > 0) {
              // Clear existing slides and load the saved ones
              slides.length = 0;
              slides.push(...loadedSlides);
              active = 0;
              // Re-render the editor with loaded slides
              if (typeof render === 'function') {
                render();
              }
              if (typeof renderSlideList === 'function') {
                renderSlideList();
              }
              console.log('Loaded presentation with', slides.length, 'slides');
            }
          } else {
            // Fallback: Set the title and content from saved presentation (old format)
            slides[0].title = pres.title || slides[0].title || '';
            slides[0].content = pres.content || '';
          }
          
          sessionStorage.removeItem('loadPresentation'); // Clear after loading
        } catch (e) {
          console.error('Error loading presentation:', e);
        }
      }

      // JSON Template Import Functions
      function importJsonTemplate(jsonData) {
        try {
          // Parse the JSON
          const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
          
          // Check if it has the slides array
          if (!data.slides || !Array.isArray(data.slides)) {
            throw new Error('Invalid JSON format: missing slides array');
          }
          
          // Clear existing slides
          slides.length = 0;
          
          // Check if this is a PowerPoint/Canva-style format (has text_blocks)
          const isPowerPointFormat = data.slides.length > 0 && data.slides[0].text_blocks !== undefined;
          
          if (isPowerPointFormat) {
            // Convert PowerPoint/Canva format to our format
            console.log('Detected PowerPoint/Canva format, converting...');
            data.slides.forEach((slideData, index) => {
              const newSlide = createEmptySlide();
              
              // Extract title and content from text_blocks
              let title = '';
              let content = '';
              
              if (slideData.text_blocks && Array.isArray(slideData.text_blocks)) {
                slideData.text_blocks.forEach((block) => {
                  if (block.type === 'Title' || block.type === 'Header') {
                    if (title) {
                      title += '\n' + block.text;
                    } else {
                      title = block.text;
                    }
                  } else if (block.type === 'Text' || block.type === 'Body') {
                    if (content) {
                      content += '\n' + block.text;
                    } else {
                      content = block.text;
                    }
                  } else {
                    // Unknown type, add to content
                    if (content) {
                      content += '\n' + block.text;
                    } else {
                      content = block.text;
                    }
                  }
                });
              }
              
              // If no title found but we have content, use first content as title
              if (!title && content) {
                const lines = content.split('\n');
                title = lines[0] || '';
                content = lines.slice(1).join('\n');
              }
              
              newSlide.title = title || '';
              newSlide.content = content || '';
              
              // Make boxes visible if there's content
              newSlide.titleBox.visible = (newSlide.title && newSlide.title.trim() !== '') ? true : false;
              newSlide.textBox.visible = (newSlide.content && newSlide.content.trim() !== '') ? true : false;
              
              console.log(`Converted slide ${index}: title="${newSlide.title}", content="${newSlide.content}"`);
              
              slides.push(newSlide);
            });
          } else {
            // Standard format - load each slide from JSON
            data.slides.forEach((slideData, index) => {
              const newSlide = createEmptySlide();
              
              // Debug: Log what we're importing for each slide
              console.log(`Importing slide ${index}:`, slideData);
              
              // Preserve the slide ID if it exists
              if (slideData.id) {
                newSlide.id = slideData.id;
              }
              
              // Copy all properties from JSON slide
              // Handle both string and object formats
              newSlide.title = slideData.title || '';
              newSlide.content = slideData.content || '';
              
              // Debug: Check if content exists
              if (!newSlide.title && !newSlide.content) {
                console.warn(`Slide ${index} appears to have no title or content`);
              }
            newSlide.background = slideData.background || newSlide.background;
            newSlide.shapes = Array.isArray(slideData.shapes) ? slideData.shapes : [];
            newSlide.charts = Array.isArray(slideData.charts) ? slideData.charts : [];
            newSlide.images = Array.isArray(slideData.images) ? slideData.images : [];
            newSlide.videos = Array.isArray(slideData.videos) ? slideData.videos : [];
            newSlide.tables = Array.isArray(slideData.tables) ? slideData.tables : [];
            newSlide.additionalTextBoxes = Array.isArray(slideData.additionalTextBoxes) ? slideData.additionalTextBoxes : [];
            newSlide.comments = Array.isArray(slideData.comments) ? slideData.comments : [];
            newSlide.animations = Array.isArray(slideData.animations) ? slideData.animations : [];
            newSlide.transition = slideData.transition || 'none';
            newSlide.transitionDuration = slideData.transitionDuration || 0.5;
            
            // Handle titleBox and textBox - use defaults if not in export, but preserve if they exist
            if (slideData.titleBox) {
              // Merge with defaults, preserving exported values
              newSlide.titleBox.top = slideData.titleBox.top !== undefined ? slideData.titleBox.top : newSlide.titleBox.top;
              newSlide.titleBox.left = slideData.titleBox.left !== undefined ? slideData.titleBox.left : newSlide.titleBox.left;
              newSlide.titleBox.right = slideData.titleBox.right !== undefined ? slideData.titleBox.right : newSlide.titleBox.right;
              newSlide.titleBox.width = slideData.titleBox.width !== undefined ? slideData.titleBox.width : newSlide.titleBox.width;
              newSlide.titleBox.height = slideData.titleBox.height !== undefined ? slideData.titleBox.height : newSlide.titleBox.height;
              newSlide.titleBox.rotation = slideData.titleBox.rotation !== undefined ? slideData.titleBox.rotation : newSlide.titleBox.rotation;
              // If visible is explicitly set, use it; otherwise make visible if title exists
              if (slideData.titleBox.visible !== undefined) {
                newSlide.titleBox.visible = slideData.titleBox.visible;
              } else {
                newSlide.titleBox.visible = (newSlide.title && newSlide.title.trim() !== '') ? true : false;
              }
              if (slideData.titleBox.id) {
                newSlide.titleBox.id = slideData.titleBox.id;
              }
            } else {
              // No titleBox in export - create visible one if title exists
              newSlide.titleBox.visible = (newSlide.title && newSlide.title.trim() !== '') ? true : false;
            }
            
            if (slideData.textBox) {
              // Merge with defaults, preserving exported values
              newSlide.textBox.top = slideData.textBox.top !== undefined ? slideData.textBox.top : newSlide.textBox.top;
              newSlide.textBox.left = slideData.textBox.left !== undefined ? slideData.textBox.left : newSlide.textBox.left;
              newSlide.textBox.right = slideData.textBox.right !== undefined ? slideData.textBox.right : newSlide.textBox.right;
              newSlide.textBox.bottom = slideData.textBox.bottom !== undefined ? slideData.textBox.bottom : newSlide.textBox.bottom;
              newSlide.textBox.width = slideData.textBox.width !== undefined ? slideData.textBox.width : newSlide.textBox.width;
              newSlide.textBox.height = slideData.textBox.height !== undefined ? slideData.textBox.height : newSlide.textBox.height;
              newSlide.textBox.rotation = slideData.textBox.rotation !== undefined ? slideData.textBox.rotation : newSlide.textBox.rotation;
              // If visible is explicitly set, use it; otherwise make visible if content exists
              if (slideData.textBox.visible !== undefined) {
                newSlide.textBox.visible = slideData.textBox.visible;
              } else {
                newSlide.textBox.visible = (newSlide.content && newSlide.content.trim() !== '') ? true : false;
              }
              if (slideData.textBox.id) {
                newSlide.textBox.id = slideData.textBox.id;
              }
            } else {
              // No textBox in export - create visible one if content exists
              newSlide.textBox.visible = (newSlide.content && newSlide.content.trim() !== '') ? true : false;
            }
            
            // Force visibility to true if there's content (safety check)
            if (newSlide.title && newSlide.title.trim() !== '') {
              newSlide.titleBox.visible = true;
            }
            if (newSlide.content && newSlide.content.trim() !== '') {
              newSlide.textBox.visible = true;
            }
            
            // Handle font families if they exist
            if (slideData.titleFontFamily) {
              newSlide.titleFontFamily = slideData.titleFontFamily;
            }
            if (slideData.textFontFamily) {
              newSlide.textFontFamily = slideData.textFontFamily;
            }
            
            slides.push(newSlide);
          });
          }
          
          // Set active slide to first one
          active = 0;
          
          // Debug: Log imported slides
          console.log('Imported slides:', slides);
          if (slides.length > 0) {
            console.log('First slide data:', slides[0]);
            console.log('First slide title:', slides[0].title);
            console.log('First slide content:', slides[0].content);
            console.log('First slide titleBox:', slides[0].titleBox);
            console.log('First slide textBox:', slides[0].textBox);
          }
          
          // Update UI - load the first slide
          load(); // This loads the slide content into the editor
          renderSidebar();
          
          // Force update content after load (in case load() didn't work properly)
          setTimeout(() => {
            const firstSlide = slides[0];
            if (firstSlide) {
              // Manually ensure content is displayed
              if (firstSlide.title && firstSlide.title.trim() !== '') {
                if (titleBox) {
                  titleBox.textContent = firstSlide.title;
                  titleBox.style.display = 'block';
                  if (firstSlide.titleBox) {
                    titleBox.style.top = (firstSlide.titleBox.top || 24) + 'px';
                    titleBox.style.left = (firstSlide.titleBox.left || 24) + 'px';
                  }
                }
              }
              if (firstSlide.content && firstSlide.content.trim() !== '') {
                if (textBox) {
                  textBox.textContent = firstSlide.content;
                  textBox.style.display = 'block';
                  if (firstSlide.textBox) {
                    textBox.style.top = (firstSlide.textBox.top || 100) + 'px';
                    textBox.style.left = (firstSlide.textBox.left || 24) + 'px';
                  }
                }
              }
              
              console.log('After manual update - Title:', firstSlide.title, 'Content:', firstSlide.content);
              console.log('TitleBox visible:', firstSlide.titleBox?.visible, 'TextBox visible:', firstSlide.textBox?.visible);
              console.log('TitleBox display:', titleBox?.style.display, 'TextBox display:', textBox?.style.display);
            }
          }, 200);
          
          // Show success notification
          showNotification(`Imported ${slides.length} slide(s) from template`);
          
          return true;
        } catch (error) {
          console.error('Error importing JSON template:', error);
          console.error('JSON data:', jsonData);
          alert('Error importing template: ' + error.message);
          return false;
        }
      }

      function loadJsonFromFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          importJsonTemplate(e.target.result);
        };
        reader.onerror = () => {
          alert('Error reading file. Please make sure it is a valid JSON file.');
        };
        reader.readAsText(file);
      }

      async function loadPptxFromFile(file) {
        try {
          if (typeof JSZip === 'undefined') {
            alert('JSZip library is required to import PPTX files. Please wait for libraries to load.');
            return;
          }

          const arrayBuffer = await file.arrayBuffer();
          const zip = await JSZip.loadAsync(arrayBuffer);
          
          // Get all slide files (ppt/slides/slide*.xml)
          const slideFiles = [];
          zip.forEach((relativePath, file) => {
            if (relativePath.startsWith('ppt/slides/slide') && relativePath.endsWith('.xml')) {
              slideFiles.push({ path: relativePath, file: file });
            }
          });

          if (slideFiles.length === 0) {
            alert('No slides found in the PPTX file.');
            return;
          }

          // Sort slides by number
          slideFiles.sort((a, b) => {
            const numA = parseInt(a.path.match(/slide(\d+)\.xml/)?.[1] || '0');
            const numB = parseInt(b.path.match(/slide(\d+)\.xml/)?.[1] || '0');
            return numA - numB;
          });

          // Extract images from ppt/media folder
          const mediaFiles = new Map();
          zip.forEach((relativePath, file) => {
            if (relativePath.startsWith('ppt/media/')) {
              const fileName = relativePath.split('/').pop();
              mediaFiles.set(fileName, file);
            }
          });

          // Create new slides from PPTX
          capture();
          const newSlides = [];
          
          for (let i = 0; i < slideFiles.length; i++) {
            const slideData = slideFiles[i];
            const slideXml = await slideData.file.async('string');
            
            // Parse XML to extract text and image references
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(slideXml, 'text/xml');
            
            // Extract text from slide - comprehensive extraction
            let slideText = '';
            let slideTitle = '';
            
            // Helper function to get all text from a node
            const getAllTextNodes = (node) => {
              let text = '';
              if (node.nodeType === 3) { // Text node
                text += node.textContent || '';
              } else {
                for (let child = node.firstChild; child; child = child.nextSibling) {
                  text += getAllTextNodes(child);
                }
              }
              return text;
            };
            
            // Get all shapes (text containers) in the slide
            const allShapes = xmlDoc.getElementsByTagName('p:sp');
            const shapeData = [];
            
            // Extract text from each shape and identify its type
            for (let j = 0; j < allShapes.length; j++) {
              const shape = allShapes[j];
              const shapeText = getAllTextNodes(shape).trim();
              
              if (!shapeText) continue;
              
              let shapeType = 'body'; // Default to body
              const nvSpPr = shape.getElementsByTagName('p:nvSpPr')[0];
              
              if (nvSpPr) {
                const ph = nvSpPr.getElementsByTagName('p:ph')[0];
                if (ph) {
                  const phType = ph.getAttribute('type');
                  if (phType === 'ctrTitle' || phType === 'title' || phType === 'subTitle') {
                    shapeType = 'title';
                  } else if (phType === 'body' || phType === 'obj' || phType === 'body' || phType === 'dt') {
                    shapeType = 'body';
                  } else {
                    shapeType = 'other';
                  }
                }
              }
              
              shapeData.push({ text: shapeText, type: shapeType });
            }
            
            // Also extract text directly from text elements (fallback)
            const textElements = xmlDoc.getElementsByTagName('a:t');
            const directTexts = [];
            for (let j = 0; j < textElements.length; j++) {
              const text = textElements[j].textContent || '';
              if (text.trim()) {
                directTexts.push(text.trim());
              }
            }
            
            // Categorize extracted text
            const titleTexts = shapeData.filter(s => s.type === 'title').map(s => s.text);
            const bodyTexts = shapeData.filter(s => s.type === 'body').map(s => s.text);
            const otherTexts = shapeData.filter(s => s.type === 'other').map(s => s.text);
            
            // Assign title - prefer title placeholders, then first text
            if (titleTexts.length > 0) {
              slideTitle = titleTexts[0];
            } else if (directTexts.length > 0) {
              // Use first direct text as title if no title placeholder found
              slideTitle = directTexts[0];
            }
            
            // Collect ALL body content - this is critical
            const allContent = [];
            const seenTexts = new Set(); // Track what we've already added
            
            // Add all body texts
            if (bodyTexts.length > 0) {
              bodyTexts.forEach(text => {
                if (text && text !== slideTitle && !seenTexts.has(text)) {
                  allContent.push(text);
                  seenTexts.add(text);
                }
              });
            }
            
            // Add other texts (non-title shapes)
            if (otherTexts.length > 0) {
              otherTexts.forEach(text => {
                if (text && text !== slideTitle && !seenTexts.has(text)) {
                  allContent.push(text);
                  seenTexts.add(text);
                }
              });
            }
            
            // Add remaining direct texts that aren't the title
            if (directTexts.length > 1) {
              const remaining = titleTexts.length > 0 ? directTexts : directTexts.slice(1);
              remaining.forEach(text => {
                if (text && text !== slideTitle && !seenTexts.has(text)) {
                  allContent.push(text);
                  seenTexts.add(text);
                }
              });
            } else if (directTexts.length === 1 && titleTexts.length === 0) {
              // If only one text and it was used as title, also use it as content if no other content
              if (bodyTexts.length === 0 && otherTexts.length === 0 && !seenTexts.has(directTexts[0])) {
                allContent.push(directTexts[0]);
                seenTexts.add(directTexts[0]);
              }
            }
            
            // Also check if we have title texts but they might contain content too
            if (titleTexts.length > 1) {
              // If multiple title-like texts, use extras as content
              titleTexts.slice(1).forEach(text => {
                if (text && !seenTexts.has(text)) {
                  allContent.push(text);
                  seenTexts.add(text);
                }
              });
            }
            
            // Combine all content
            if (allContent.length > 0) {
              slideText = allContent.join('\n\n');
            }
            
            // Fallback: if we have title but no content, try to extract more text
            if (slideTitle && !slideText) {
              // Get all text from paragraphs
              const paragraphs = xmlDoc.getElementsByTagName('a:p');
              const paraTexts = [];
              for (let j = 0; j < paragraphs.length; j++) {
                const paraText = getAllTextNodes(paragraphs[j]).trim();
                if (paraText && paraText !== slideTitle && !paraTexts.includes(paraText)) {
                  paraTexts.push(paraText);
                }
              }
              if (paraTexts.length > 0) {
                slideText = paraTexts.join('\n\n');
              }
              
              // If still no content, try getting all text from text runs
              if (!slideText) {
                const textRuns = xmlDoc.getElementsByTagName('a:r');
                const runTexts = [];
                for (let j = 0; j < textRuns.length; j++) {
                  const runText = getAllTextNodes(textRuns[j]).trim();
                  if (runText && runText !== slideTitle && !runTexts.includes(runText)) {
                    runTexts.push(runText);
                  }
                }
                if (runTexts.length > 0) {
                  slideText = runTexts.join(' ');
                }
              }
              
              // Last resort: get all text from text boxes
              if (!slideText) {
                const textBoxes = xmlDoc.getElementsByTagName('a:txBody');
                const boxTexts = [];
                for (let j = 0; j < textBoxes.length; j++) {
                  const boxText = getAllTextNodes(textBoxes[j]).trim();
                  if (boxText && boxText !== slideTitle && !boxTexts.includes(boxText)) {
                    boxTexts.push(boxText);
                  }
                }
                if (boxTexts.length > 0) {
                  slideText = boxTexts.join('\n\n');
                }
              }
            }
            
            // Final fallback: extract all text and split intelligently
            if (!slideText && !slideTitle) {
              const allText = getAllTextNodes(xmlDoc.documentElement).trim();
              if (allText) {
                // Try to split by common patterns
                const lines = allText.split(/\n+/).filter(l => l.trim().length > 0);
                if (lines.length > 0) {
                  slideTitle = lines[0].trim();
                  if (lines.length > 1) {
                    slideText = lines.slice(1).map(l => l.trim()).join('\n\n');
                  } else {
                    // Single line - use as both if reasonable length
                    const words = allText.split(/\s+/);
                    if (words.length > 10) {
                      slideTitle = words.slice(0, 5).join(' ');
                      slideText = words.slice(5).join(' ');
                    } else {
                      slideTitle = allText;
                      slideText = allText;
                    }
                  }
                }
              }
            }
            
            // Ensure we have at least a default title
            if (!slideTitle) {
              slideTitle = `Slide ${i + 1}`;
            }
            
            console.log(`Slide ${i + 1}:`);
            console.log(`  Title: "${slideTitle}"`);
            console.log(`  Content: "${slideText ? (slideText.length > 100 ? slideText.substring(0, 100) + '...' : slideText) : '(empty)'}"`);
            console.log(`  Body texts found: ${bodyTexts.length}, Other texts: ${otherTexts.length}, Direct texts: ${directTexts.length}`);

            // Extract styling information from shapes
            const extractTextStyle = (shape) => {
              const style = {
                fontSize: null,
                fontFamily: null,
                color: null,
                bold: false,
                italic: false,
                underline: false
              };
              
              // Extract font size - search in text runs and paragraphs
              const szElements = shape.getElementsByTagName('a:sz');
              if (szElements.length > 0) {
                const sz = szElements[0];
                const size = sz.getAttribute('val');
                if (size) {
                  // PPTX font size is in 1/100th of a point, convert to pixels
                  style.fontSize = (parseInt(size) / 100 * 0.75) + 'px';
                }
              }
              
              // Extract font family
              const latinElements = shape.getElementsByTagName('a:latin');
              if (latinElements.length > 0) {
                const latin = latinElements[0];
                const typeface = latin.getAttribute('typeface');
                if (typeface) {
                  style.fontFamily = typeface;
                }
              }
              
              // Extract text color - search in text runs
              const solidFillElements = shape.getElementsByTagName('a:solidFill');
              if (solidFillElements.length > 0) {
                const solidFill = solidFillElements[0];
                const srgbClrElements = solidFill.getElementsByTagName('a:srgbClr');
                const schemeClrElements = solidFill.getElementsByTagName('a:schemeClr');
                
                if (srgbClrElements.length > 0) {
                  const srgbClr = srgbClrElements[0];
                  const val = srgbClr.getAttribute('val');
                  if (val) {
                    style.color = '#' + val;
                  }
                } else if (schemeClrElements.length > 0) {
                  const schemeClr = schemeClrElements[0];
                  const val = schemeClr.getAttribute('val');
                  const colorMap = {
                    'tx1': '#000000',
                    'tx2': '#ffffff',
                    'accent1': '#0070C0',
                    'accent2': '#00B050'
                  };
                  style.color = colorMap[val] || '#000000';
                }
              }
              
              // Extract bold/italic/underline from text runs
              const rPrElements = shape.getElementsByTagName('a:rPr');
              if (rPrElements.length > 0) {
                const rPr = rPrElements[0];
                style.bold = rPr.getAttribute('b') === '1' || rPr.hasAttribute('b');
                style.italic = rPr.getAttribute('i') === '1' || rPr.hasAttribute('i');
                style.underline = rPr.getAttribute('u') !== null;
              }
              
              return style;
            };
            
            // Extract background color from slide
            let slideBgColor = '#ffffff';
            const bgElements = xmlDoc.getElementsByTagName('p:bg');
            if (bgElements.length > 0) {
              const bg = bgElements[0];
              const bgPrElements = bg.getElementsByTagName('p:bgPr');
              if (bgPrElements.length > 0) {
                const bgPr = bgPrElements[0];
                const solidFillElements = bgPr.getElementsByTagName('a:solidFill');
                if (solidFillElements.length > 0) {
                  const solidFill = solidFillElements[0];
                  const srgbClrElements = solidFill.getElementsByTagName('a:srgbClr');
                  if (srgbClrElements.length > 0) {
                    const srgbClr = srgbClrElements[0];
                    const val = srgbClr.getAttribute('val');
                    if (val) {
                      slideBgColor = '#' + val;
                    }
                  }
                }
              }
            }
            
            // Extract images with positions and sizes
            const slideNum = slideData.path.match(/slide(\d+)\.xml/)?.[1] || '1';
            const relsPath = `ppt/slides/_rels/slide${slideNum}.xml.rels`;
            const imageData = []; // Array of {url, left, top, width, height, rotation}
            
            // Get all image shapes with their positions
            const imageShapes = xmlDoc.getElementsByTagName('p:pic');
            const imageRidMap = new Map(); // Map rEmbed (relationship ID) to image position data
            
            for (let j = 0; j < imageShapes.length; j++) {
              const pic = imageShapes[j];
              const blipElements = pic.getElementsByTagName('a:blip');
              if (blipElements.length > 0) {
                const blip = blipElements[0];
                const rEmbed = blip.getAttribute('r:embed');
                if (rEmbed) {
                  // Get position and size from the shape's transform
                  const xfrmElements = pic.getElementsByTagName('a:xfrm');
                  let left = 0, top = 0, width = 200, height = 150, rotation = 0;
                  
                  if (xfrmElements.length > 0) {
                    const xfrm = xfrmElements[0];
                    const offElements = xfrm.getElementsByTagName('a:off');
                    const extElements = xfrm.getElementsByTagName('a:ext');
                    const rot = xfrm.getAttribute('rot');
                    
                    if (offElements.length > 0) {
                      const off = offElements[0];
                      // PPTX uses EMU (English Metric Units), 1 inch = 914400 EMU
                      // Convert to pixels (assuming 96 DPI)
                      const x = parseInt(off.getAttribute('x') || '0');
                      const y = parseInt(off.getAttribute('y') || '0');
                      left = x / 914400 * 96;
                      top = y / 914400 * 96;
                    }
                    
                    if (extElements.length > 0) {
                      const ext = extElements[0];
                      const cx = parseInt(ext.getAttribute('cx') || '2000000');
                      const cy = parseInt(ext.getAttribute('cy') || '1500000');
                      width = cx / 914400 * 96;
                      height = cy / 914400 * 96;
                    }
                    
                    if (rot) {
                      rotation = parseInt(rot) / 60000; // Convert from 1/60000th of a degree
                    }
                  }
                  
                  // Store position data keyed by the relationship ID (rEmbed)
                  imageRidMap.set(rEmbed, { left, top, width, height, rotation });
                }
              }
            }
            
            // Get relationships to find actual image files
            if (zip.files[relsPath]) {
              try {
                const relsXml = await zip.files[relsPath].async('string');
                const relsDoc = parser.parseFromString(relsXml, 'text/xml');
                const relationships = relsDoc.getElementsByTagName('Relationship');
                
                for (let j = 0; j < relationships.length; j++) {
                  const rel = relationships[j];
                  const type = rel.getAttribute('Type');
                  const rId = rel.getAttribute('Id');
                  
                  if (type && type.includes('image')) {
                    const target = rel.getAttribute('Target');
                    if (target) {
                      // Handle different path formats
                      let imagePath = target;
                      if (target.startsWith('../media/')) {
                        imagePath = target.replace('../media/', 'ppt/media/');
                      } else if (target.startsWith('media/')) {
                        imagePath = `ppt/${target}`;
                      } else if (target.startsWith('../')) {
                        imagePath = target.replace('../', 'ppt/');
                      } else if (!target.startsWith('ppt/')) {
                        imagePath = `ppt/media/${target}`;
                      }
                      
                      // Try the resolved path
                      if (zip.files[imagePath]) {
                        try {
                          const imageBlob = await zip.files[imagePath].async('blob');
                          const imageUrl = URL.createObjectURL(imageBlob);
                          
                          // Get position data if available - match by rId
                          const posData = imageRidMap.get(rId) || { left: 100, top: 100, width: 200, height: 150, rotation: 0 };
                          
                          imageData.push({
                            url: imageUrl,
                            left: Math.round(posData.left),
                            top: Math.round(posData.top),
                            width: Math.round(posData.width),
                            height: Math.round(posData.height),
                            rotation: Math.round(posData.rotation * 100) / 100
                          });
                        } catch (err) {
                          console.warn('Failed to load image:', imagePath, err);
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                console.warn('Failed to parse relationships:', relsPath, err);
              }
            }
            
            // Extract text styling from title and body shapes
            let titleStyle = null;
            let bodyStyle = null;
            
            for (let j = 0; j < allShapes.length; j++) {
              const shape = allShapes[j];
              const nvSpPr = shape.getElementsByTagName('p:nvSpPr')[0];
              const shapeText = getAllTextNodes(shape).trim();
              
              if (!shapeText) continue;
              
              const style = extractTextStyle(shape);
              
              if (nvSpPr) {
                const ph = nvSpPr.getElementsByTagName('p:ph')[0];
                if (ph) {
                  const phType = ph.getAttribute('type');
                  if ((phType === 'ctrTitle' || phType === 'title') && !titleStyle) {
                    titleStyle = style;
                  } else if ((phType === 'body' || phType === 'obj') && !bodyStyle) {
                    bodyStyle = style;
                  }
                }
              }
            }
            
            // Extract text boxes with background colors (as additional text boxes)
            const extractedTextBoxes = [];
            
            // Extract shapes and objects (non-text, non-image shapes)
            const extractedShapes = [];
            const allShapeElements = xmlDoc.getElementsByTagName('p:sp');
            
            // Map PPTX geometry types to editor shape IDs
            const pptxShapeMap = {
              'rect': 'rectangle',
              'roundRect': 'rectangle',
              'ellipse': 'circle',
              'triangle': 'triangle',
              'star5': 'star',
              'star': 'star',
              'pentagon': 'pentagon',
              'arrow': 'arrow-right',
              'line': 'line',
              'straightConnector1': 'line',
              'bentConnector2': 'line',
              'curvedConnector2': 'line'
            };
            
            for (let j = 0; j < allShapeElements.length; j++) {
              const shape = allShapeElements[j];
              
              // Skip if it's a text placeholder (already processed)
              const nvSpPr = shape.getElementsByTagName('p:nvSpPr')[0];
              let isTextPlaceholder = false;
              if (nvSpPr) {
                const ph = nvSpPr.getElementsByTagName('p:ph')[0];
                if (ph) {
                  const phType = ph.getAttribute('type');
                  // Skip title and body placeholders
                  if (phType === 'title' || phType === 'ctrTitle' || phType === 'body' || phType === 'obj' || 
                      phType === 'subTitle' || phType === 'dt' || phType === 'ftr' || phType === 'sldNum') {
                    isTextPlaceholder = true;
                  }
                }
              }
              
              // Skip text placeholders
              if (isTextPlaceholder) continue;
              
              // Check if this shape is primarily text (has significant text content)
              const shapeText = getAllTextNodes(shape).trim();
              const txBody = shape.getElementsByTagName('p:txBody')[0];
              
              // Get shape geometry to determine type
              const spPr = shape.getElementsByTagName('p:spPr')[0];
              if (!spPr) continue;
              
              // Check if it has geometry (not just text)
              const prstGeom = spPr.getElementsByTagName('a:prstGeom')[0];
              const custGeom = spPr.getElementsByTagName('a:custGeom')[0];
              
              // Skip if no geometry (text-only shape)
              if (!prstGeom && !custGeom) continue;
              
              // Check if this is a text box with background (should be extracted as additional text box)
              if (txBody && shapeText.length > 10) {
                const hasFill = spPr.getElementsByTagName('a:solidFill').length > 0 || 
                               spPr.getElementsByTagName('a:gradFill').length > 0 ||
                               spPr.getElementsByTagName('a:blipFill').length > 0;
                
                // If it's a rectangle/roundRect with text and fill, extract as text box
                if (prstGeom) {
                  const prst = prstGeom.getAttribute('prst');
                  if ((prst === 'rect' || prst === 'roundRect') && hasFill) {
                    // Extract as additional text box with background
                    const xfrm = spPr.getElementsByTagName('a:xfrm')[0];
                    let left = 100, top = 100, width = 200, height = 150, rotation = 0;
                    
                    if (xfrm) {
                      const offElements = xfrm.getElementsByTagName('a:off');
                      const extElements = xfrm.getElementsByTagName('a:ext');
                      const rot = xfrm.getAttribute('rot');
                      
                      if (offElements.length > 0) {
                        const off = offElements[0];
                        const x = parseInt(off.getAttribute('x') || '0');
                        const y = parseInt(off.getAttribute('y') || '0');
                        left = x / 914400 * 96;
                        top = y / 914400 * 96;
                      }
                      
                      if (extElements.length > 0) {
                        const ext = extElements[0];
                        const cx = parseInt(ext.getAttribute('cx') || '2000000');
                        const cy = parseInt(ext.getAttribute('cy') || '1500000');
                        width = cx / 914400 * 96;
                        height = cy / 914400 * 96;
                      }
                      
                      if (rot) {
                        rotation = parseInt(rot) / 60000;
                      }
                    }
                    
                    // Extract background color
                    let bgColor = 'transparent';
                    const solidFillElements = spPr.getElementsByTagName('a:solidFill');
                    if (solidFillElements.length > 0) {
                      const solidFill = solidFillElements[0];
                      const srgbClrElements = solidFill.getElementsByTagName('a:srgbClr');
                      const schemeClrElements = solidFill.getElementsByTagName('a:schemeClr');
                      
                      if (srgbClrElements.length > 0) {
                        const srgbClr = srgbClrElements[0];
                        const val = srgbClr.getAttribute('val');
                        if (val) {
                          bgColor = '#' + val;
                        }
                      } else if (schemeClrElements.length > 0) {
                        const schemeClr = schemeClrElements[0];
                        const val = schemeClr.getAttribute('val');
                        const colorMap = {
                          'tx1': '#000000',
                          'tx2': '#ffffff',
                          'accent1': '#0070C0',
                          'accent2': '#00B050',
                          'accent3': '#FFC000',
                          'accent4': '#C00000',
                          'accent5': '#7030A0',
                          'accent6': '#00B0F0'
                        };
                        bgColor = colorMap[val] || 'transparent';
                      }
                    }
                    
                    // Extract text styling
                    const style = extractTextStyle(shape);
                    
                    extractedTextBoxes.push({
                      id: generateElementId('textbox'),
                      html: shapeText.replace(/\n/g, '<br>'),
                      top: Math.round(top),
                      left: Math.round(left),
                      width: Math.round(width),
                      height: Math.round(height),
                      fontSize: style.fontSize || '16px',
                      fontFamily: style.fontFamily || DEFAULT_FONT_STACK,
                      color: style.color || '#000000',
                      backgroundColor: bgColor,
                      rotation: Math.round(rotation * 100) / 100,
                      minWidth: 80,
                      minHeight: 30,
                      display: ''
                    });
                    
                    continue; // Skip - handled as text box
                  }
                }
                
                // If it has text but no visible styling (no fill, no line), it's likely just a text container
                const hasLine = spPr.getElementsByTagName('a:ln').length > 0;
                if (!hasFill && !hasLine) {
                  continue;
                }
              }
              
              // Additional filter: skip very thin shapes (likely borders/decorative lines, not real shapes)
              const xfrmCheck = spPr.getElementsByTagName('a:xfrm')[0];
              if (xfrmCheck) {
                const extElements = xfrmCheck.getElementsByTagName('a:ext');
                if (extElements.length > 0) {
                  const ext = extElements[0];
                  const cx = parseInt(ext.getAttribute('cx') || '0');
                  const cy = parseInt(ext.getAttribute('cy') || '0');
                  const width = cx / 914400 * 96;
                  const height = cy / 914400 * 96;
                  
                  // Skip very thin shapes (likely decorative lines/borders)
                  // Also skip very narrow or very tall shapes (likely UI elements)
                  if (width < 30 || height < 30 || (width < 50 && height > 1000) || (height < 50 && width > 1000)) {
                    continue;
                  }
                }
              }
              
              let shapeType = 'rectangle'; // Default
              
              if (prstGeom) {
                const prst = prstGeom.getAttribute('prst');
                if (prst) {
                  // Map PPTX preset geometry to editor shape
                  shapeType = pptxShapeMap[prst] || 'rectangle';
                }
              } else if (custGeom) {
                // Custom geometry - try to detect type from path
                const pathElements = custGeom.getElementsByTagName('a:pathLst');
                if (pathElements.length > 0) {
                  // Default to rectangle for custom shapes
                  shapeType = 'rectangle';
                }
              }
              
              // Get position and size
              const xfrm = spPr.getElementsByTagName('a:xfrm')[0];
              let left = 100, top = 100, width = 200, height = 150, rotation = 0;
              
              if (xfrm) {
                const offElements = xfrm.getElementsByTagName('a:off');
                const extElements = xfrm.getElementsByTagName('a:ext');
                const rot = xfrm.getAttribute('rot');
                
                if (offElements.length > 0) {
                  const off = offElements[0];
                  const x = parseInt(off.getAttribute('x') || '0');
                  const y = parseInt(off.getAttribute('y') || '0');
                  left = x / 914400 * 96;
                  top = y / 914400 * 96;
                }
                
                if (extElements.length > 0) {
                  const ext = extElements[0];
                  const cx = parseInt(ext.getAttribute('cx') || '2000000');
                  const cy = parseInt(ext.getAttribute('cy') || '1500000');
                  width = cx / 914400 * 96;
                  height = cy / 914400 * 96;
                }
                
                if (rot) {
                  rotation = parseInt(rot) / 60000;
                }
              }
              
              // Get shape color
              let shapeColor = null;
              const solidFillElements = spPr.getElementsByTagName('a:solidFill');
              if (solidFillElements.length > 0) {
                const solidFill = solidFillElements[0];
                const srgbClrElements = solidFill.getElementsByTagName('a:srgbClr');
                const schemeClrElements = solidFill.getElementsByTagName('a:schemeClr');
                
                if (srgbClrElements.length > 0) {
                  const srgbClr = srgbClrElements[0];
                  const val = srgbClr.getAttribute('val');
                  if (val) {
                    shapeColor = '#' + val;
                  }
                } else if (schemeClrElements.length > 0) {
                  const schemeClr = schemeClrElements[0];
                  const val = schemeClr.getAttribute('val');
                  const colorMap = {
                    'tx1': '#000000',
                    'tx2': '#ffffff',
                    'accent1': '#0070C0',
                    'accent2': '#00B050',
                    'accent3': '#FFC000',
                    'accent4': '#C00000',
                    'accent5': '#7030A0',
                    'accent6': '#00B0F0'
                  };
                  shapeColor = colorMap[val] || '#9ae6b4';
                }
              }
              
              // Get outline/border color if no fill
              if (!shapeColor) {
                const lnElements = spPr.getElementsByTagName('a:ln');
                if (lnElements.length > 0) {
                  const ln = lnElements[0];
                  const lnSolidFill = ln.getElementsByTagName('a:solidFill')[0];
                  if (lnSolidFill) {
                    const lnSrgbClr = lnSolidFill.getElementsByTagName('a:srgbClr')[0];
                    if (lnSrgbClr) {
                      const val = lnSrgbClr.getAttribute('val');
                      if (val) {
                        shapeColor = '#' + val;
                      }
                    }
                  }
                }
              }
              
              // Use default color if none found
              if (!shapeColor) {
                const defaultShape = SHAPE_OPTION_MAP.get(shapeType);
                shapeColor = defaultShape ? defaultShape.defaultColor : '#9ae6b4';
              }
              
              // Get z-index (order in XML)
              const zIndex = j + 2; // Start from 2 to be above background
              
              extractedShapes.push({
                id: generateElementId('shape'),
                shapeId: shapeType,
                left: Math.round(left),
                top: Math.round(top),
                width: Math.round(width),
                height: Math.round(height),
                rotation: Math.round(rotation * 100) / 100,
                color: shapeColor,
                zIndex: zIndex,
                minWidth: 60,
                minHeight: 60
              });
            }
            
            console.log(`  Extracted ${extractedShapes.length} shapes`);

            // Create a new slide
            const newSlide = createEmptySlide();
            newSlide.title = slideTitle || `Slide ${i + 1}`;
            newSlide.content = slideText || '';
            
            // Apply background color
            newSlide.background.color = slideBgColor;
            
            // Make text boxes visible if there's content
            const hasRealTitle = slideTitle && slideTitle.trim() && slideTitle !== `Slide ${i + 1}`;
            const hasContent = slideText && slideText.trim();
            
            if (hasRealTitle) {
              newSlide.titleBox.visible = true;
              // Apply title styling
              if (titleStyle) {
                if (titleStyle.fontSize) {
                  // Store fontSize for titleBox (will be applied in load function)
                  newSlide.titleBox.fontSize = titleStyle.fontSize;
                }
                if (titleStyle.fontFamily) {
                  newSlide.titleFontFamily = titleStyle.fontFamily;
                }
                if (titleStyle.color) {
                  newSlide.titleBox.color = titleStyle.color;
                }
              }
            } else {
              newSlide.titleBox.visible = false;
            }
            
            // Always show content box if there's content
            if (hasContent) {
              newSlide.textBox.visible = true;
              // Apply body styling
              if (bodyStyle) {
                if (bodyStyle.fontSize) {
                  newSlide.textBox.fontSize = bodyStyle.fontSize;
                }
                if (bodyStyle.fontFamily) {
                  newSlide.textFontFamily = bodyStyle.fontFamily;
                }
                if (bodyStyle.color) {
                  newSlide.textBox.color = bodyStyle.color;
                }
              }
            } else {
              newSlide.textBox.visible = false;
            }
            
            // Add images with their positions and styling
            if (imageData.length > 0) {
              // Check if first image should be background (full slide coverage)
              const firstImage = imageData[0];
              const isFullSlide = firstImage.left < 50 && firstImage.top < 50 && 
                                  firstImage.width > 800 && firstImage.height > 500;
              
              if (isFullSlide && imageData.length === 1) {
                // Use as background
                newSlide.background.image = firstImage.url;
                newSlide.background.size = 'cover';
                newSlide.background.position = 'center';
                newSlide.background.repeat = 'no-repeat';
              } else {
                // Add all images as image elements with proper positioning
                imageData.forEach((imgData, idx) => {
                  newSlide.images.push({
                    id: generateElementId('img'),
                    src: imgData.url,
                    left: Math.max(0, imgData.left),
                    top: Math.max(0, imgData.top),
                    width: imgData.width,
                    height: imgData.height,
                    rotation: imgData.rotation
                  });
                });
              }
            }
            
            // Add extracted shapes to slide
            if (extractedShapes.length > 0) {
              newSlide.shapes = extractedShapes;
            }
            
            // Add extracted text boxes with backgrounds
            if (extractedTextBoxes.length > 0) {
              if (!Array.isArray(newSlide.additionalTextBoxes)) {
                newSlide.additionalTextBoxes = [];
              }
              newSlide.additionalTextBoxes.push(...extractedTextBoxes);
            }
            
            console.log(`  Extracted ${extractedTextBoxes.length} text boxes with backgrounds`);
            
            console.log(`  Final slide data:`, {
              title: newSlide.title,
              contentLength: newSlide.content.length,
              titleBoxVisible: newSlide.titleBox.visible,
              textBoxVisible: newSlide.textBox.visible,
              imagesCount: newSlide.images.length,
              shapesCount: newSlide.shapes.length,
              backgroundImage: !!newSlide.background.image,
              backgroundColor: newSlide.background.color,
              titleStyle: titleStyle,
              bodyStyle: bodyStyle
            });

            newSlides.push(newSlide);
          }

          // Replace existing slides with imported ones
          slides.length = 0;
          slides.push(...newSlides);
          active = 0;
          load();
          renderSidebar();
          saveEditorState('import_pptx');
          showNotification(`Imported ${newSlides.length} slide(s) from PPTX`);
          
        } catch (error) {
          console.error('Error importing PPTX:', error);
          alert('Error importing PPTX file: ' + error.message);
        }
      }

      // Add event listeners for import (JSON and PPTX)
      const importBtn = document.getElementById('btnImportTemplate');
      const jsonFileInput = document.getElementById('jsonTemplateInput');
      
      if (importBtn && jsonFileInput) {
        importBtn.addEventListener('click', () => {
          jsonFileInput.click();
        });

        jsonFileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            const fileName = file.name.toLowerCase();
            if (fileName.endsWith('.json')) {
              loadJsonFromFile(file);
            } else if (fileName.endsWith('.pptx')) {
              loadPptxFromFile(file);
            } else {
              alert('Please select a JSON or PPTX file.');
              e.target.value = '';
              return;
            }
          }
          // Reset input so same file can be selected again
          e.target.value = '';
        });
      }

      // Load and apply saved background color from settings
      const savedBg = localStorage.getItem('siteBackgroundColor');
      if (savedBg) {
        applyGlobalThemeColor(savedBg, { persist: false });
      }

      // Listen for background color updates from settings page
      window.addEventListener('message', (e) => {
        if (e.data.type === 'updateBackground') {
          const color = e.data.color;
          applyGlobalThemeColor(color, { persist: true });
        }
      });

      // Init
      renderSidebar();
      load();
      updateSlideCanvasMenuState();
      updateElementContextMenuState();

    </script>
  </body>
  </html>